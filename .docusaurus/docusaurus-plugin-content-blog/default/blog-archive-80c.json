{
  "blogPosts": [
    {
      "id": "/JS模块化演变及其区别",
      "metadata": {
        "permalink": "/blog/JS模块化演变及其区别",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/JS模块化演变及其区别.md",
        "source": "@site/blog\\JS模块化演变及其区别.md",
        "title": "JS模块化演变及其区别",
        "description": "为什么需要模块化？",
        "date": "2022-05-12T00:00:00.000Z",
        "formattedDate": "2022年5月12日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 3.41,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "JS模块化演变及其区别",
          "date": "2022-05-12T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "nextItem": {
          "title": "你知道原型链？那你能实现一个new吗？",
          "permalink": "/blog/你知道原型链？那你能实现一个new吗？"
        }
      },
      "content": "## 为什么需要模块化？\r\n> 假如没有模块化，在前端开发时可能存在下面的问题：\r\n\r\n1. 变量和方法不容易维护，容易污染到全局作用域。\r\n2. 通过script标签进行大量引入资源，代码可读性和可维护性都比较差。\r\n3. 代码一多就比较复杂。\r\n4. 多人合作的场景下，资源的引入会带来比较大的困难。\r\n\r\n## JS模块化的演变史\r\n### 1. CommonJS\r\n> 我们熟知的Node.js在模块化方面就是遵守的CommonJS规范。CommonJS模块化具有下面几个特点：\r\n\r\n1. 模块内的代码运行在模拟作用域中，不会污染到全局作用域中。\r\n2. 模块可以多次引入，但只会在第一次加载的时候执行一次，后面的运行都是从缓存中获取值。\r\n3. 代码出现的顺序就是模块加载的顺序。\r\n\r\n> `模块的导入导出方式：`\r\n\r\n> 通过module.exports或者exports进行导出，通过require进行导入。\r\n\r\n```js\r\nmodule.exports = {age: 1,name: 'hello'}\r\n```\r\n\r\n```js\r\nconst foo = require('./foo.js');\r\n```\r\n\r\n### 2. ES6 Module\r\n> CommonJS不适合浏览器等场景，于是ES6 Module诞生了，它是ES6之后新增的模块化规范。\r\n\r\n> `模块的导入导出方式：`\r\n\r\n> 通过export导出模块，通过import导入模块。在导出的时候有两种方式，一种是默认暴露，一种是分别暴露。\r\n\r\n\r\n## 问题汇总\r\n### RQ1：浏览器为什么不适用CommonJS？\r\n> 因为CommonJS的require语法是同步的，在浏览器端文件一般存放在服务器上，一般通过网络请求来获取数据，如果使用CommonJS会导致时间很长，造成浏览器卡顿现象，NodeJS之所以采用CommonJS是因为NodeJS在服务端读取的是本地硬盘，因此速度比较快。\r\n\r\n### RQ2：CommonJS和ES6 Module之间的区别\r\n1. CommonJS输出的是值的拷贝，而ES6 Module输出的是值的引用。\r\n2. CommonJS模块是运行时加载，ES6 Moduke是编译时输出接口。\r\n3. CommonJS加载是同步的可能阻塞的，ES6 Module是异步加载。\r\n\r\n### RQ3：在Node.js中module.exports和exports有什么区别？\r\n1. 通过module.exports暴露的函数，在引入的时候可以不知道函数名，但是通过exports暴露的内容必须知道名字。\r\n2. exports对象是module对象的一个属性，初始时module.exports和exports指向的是同一块内存区域。\r\n3. 模块导出的是module.exports，exports只是和它指向的是同一片内存，在不改变exports内存的情况下，修改exports的值可以改变module.exports的值。\r\n4. 导出时尽量使用module.exports以避免赋值导致的混乱。"
    },
    {
      "id": "/你知道原型链？那你能实现一个new吗？",
      "metadata": {
        "permalink": "/blog/你知道原型链？那你能实现一个new吗？",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/你知道原型链？那你能实现一个new吗？.md",
        "source": "@site/blog\\你知道原型链？那你能实现一个new吗？.md",
        "title": "你知道原型链？那你能实现一个new吗？",
        "description": "在学习前端知识的时候，我们不仅要会用工具和API，更要知道其实现原理，因为只有知道原理，我们的理解才能更上一层楼，这次让我们来一起解决最常见的new的实现原理吧。",
        "date": "2022-05-11T00:00:00.000Z",
        "formattedDate": "2022年5月11日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 2.38,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "你知道原型链？那你能实现一个new吗？",
          "date": "2022-05-11T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "JS模块化演变及其区别",
          "permalink": "/blog/JS模块化演变及其区别"
        },
        "nextItem": {
          "title": "Koa的洋葱模型到底是什么？",
          "permalink": "/blog/Koa的洋葱模型到底是什么？"
        }
      },
      "content": "> 在学习前端知识的时候，我们不仅要会用工具和API，更要知道其实现原理，因为只有知道原理，我们的理解才能更上一层楼，这次让我们来一起解决最常见的new的实现原理吧。\r\n\r\n## new在原型链中扮演什么样的角色？\r\n> 在this的指向规则中，有一种this指向是new绑定，new绑定会让构造函数的this指向我们新创建的对象，请看下面的例子：\r\n\r\n```js\r\nfunction sayHi(name){\r\n  this.name = name;\r\n\r\n}\r\nvar Hi = new sayHi('zhangsan');\r\nconsole.log('Hello,', Hi.name);  // Hello, zhangsan\r\n```\r\n\r\n> 其实，除了上面我们提到的this指向之外，new还会让实例的隐式原型指向其显式原型，下面让我们来一起看看new的内部是如何实现的吧！\r\n\r\n## 手写new的实现\r\n1. 创建一个空对象。\r\n2. 拿到构造函数。\r\n3. 让空对象的隐式原型指向构造函数的显示原型。\r\n4. 让构造函数的this指向我们创建的对象并执行。\r\n5. 如果执行的结果是引用类型则返回引用类型，否则返会创建的对象。\r\n\r\n```js\r\nfunction myNew() {\r\n    // 1. 创建一个空对象\r\n    const obj = {};\r\n    // 2. 拿到构造函数，也就是第一个参数\r\n    const Constructor = Array.prototype.shift.call(arguments);\r\n    // 3. 让实例的隐式原型指向构造函数的显式原型\r\n    obj.__proto__ = Constructor.prototype;\r\n    // 4. 改变构造函数的this指向并执行\r\n    const res = Constructor.apply(obj, arguments);\r\n    // 5. 判断是否是引用类型，是则返回引用类型，不是则返回obj\r\n    return res instanceof Object ? res : obj;\r\n}\r\n```\r\n\r\n## 总结\r\n> 手写new不仅是一道常考题，其内部涉及到了this指向，原型链，如何通过原生方法获取arguments的第一个参数，apply执行的结果等知识，是一道必须掌握的题目！"
    },
    {
      "id": "/Koa的洋葱模型到底是什么？",
      "metadata": {
        "permalink": "/blog/Koa的洋葱模型到底是什么？",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Koa的洋葱模型到底是什么？.md",
        "source": "@site/blog\\Koa的洋葱模型到底是什么？.md",
        "title": "Koa的洋葱模型到底是什么？",
        "description": "什么是Koa？",
        "date": "2022-05-10T00:00:00.000Z",
        "formattedDate": "2022年5月10日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 4.42,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Koa的洋葱模型到底是什么？",
          "date": "2022-05-10T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "你知道原型链？那你能实现一个new吗？",
          "permalink": "/blog/你知道原型链？那你能实现一个new吗？"
        },
        "nextItem": {
          "title": "OSI七层网络模型，你了解多少？",
          "permalink": "/blog/OSI七层网络模型，你了解多少？"
        }
      },
      "content": "## 什么是Koa？\r\n> Koa是一个精简的node框架，被认为是第二代Node框架，其最大的特点就是独特的中间件流程控制，是一个典型的洋葱模型，它的核心工作包括下面两个方面：\r\n\r\n1. 将node原生的req和res封装成为一个context对象。\r\n2. 基于async/await的中间件洋葱模型机制。\r\n\r\n## Koa1和Koa2在源码上的区别有何不同？\r\n1. Koa1是使用generator、yield的模式。\r\n2. Koa2使用的是async/await + Promise的模式。\r\n\r\n## 什么是洋葱模型？\r\n> Koa的洋葱模型是以next()函数为分割点，先由外到内执行Request的逻辑，然后再由内到外执行Response的逻辑，这里的request的逻辑，我们可以理解为是next之前的内容，response的逻辑是next函数之后的内容，也可以说每一个中间件都有两次处理时机。洋葱模型的核心原理主要是借助compose方法。为了大家更好的理解什么是洋葱模型，这个图很好的给出了解释：\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/6bdcbf3b5c4068f62326debea8f1550a.png)\r\n\r\n> 下面是洋葱模型的示例代码：\r\n\r\n```js\r\nconst Koa = require('koa');\r\n\r\n//Applications\r\nconst app = new Koa();\r\n\r\n// 中间件1\r\napp.use((ctx, next) => {\r\n  console.log(1);\r\n  next();\r\n  console.log(2);\r\n});\r\n\r\n// 中间件 2 \r\napp.use((ctx, next) => {\r\n  console.log(3);\r\n  next();\r\n  console.log(4);\r\n});\r\n\r\napp.listen(7000, '0.0.0.0', () => {\r\n    console.log(`Server is starting`);\r\n});\r\n```\r\n\r\n> 当我们访问指定路径的7000端口时，中间件的打印顺序是1 -> 3 -> 4 -> 2。\r\n\r\n## 源码解析\r\n1. use方法\r\n\r\n> 当我们使用中间件的时候，首先是使用use方法，use方法会将传入的中间件回调函数存储到middleware中间件数组中。\r\n\r\n2. listen方法\r\n\r\n> 当执行app.listen去监听端口的时候，其实其内部调用了http模块的createServer方法，然后传入内置的callback方法，这个callback方法就会将use方法存储的middleware中间件数组传给compose函数。\r\n\r\n3. compose方法\r\n\r\n> compose方法是洋葱模型的核心，compose方法中有一个dispatch方法，第一次调用的时候，执行的是第一个中间件函数，中间件函数执行的时候就是再次调用dispatch函数，也就说形成了一个递归，这就是next函数执行的时候会执行下一个中间件的原因，因此形成了一个洋葱模型。\r\n\r\n```js\r\nfunction compose (middleware) {\r\n  // ...\r\n  return function (context, next) {\r\n    // last called middleware #\r\n    let index = -1\r\n    // 一开始的时候传入为 0，后续会递增\r\n    return dispatch(0)\r\n    function dispatch (i) {\r\n      // 假如没有递增，则说明执行了多次\r\n      if (i <= index) return Promise.reject(new Error('next() called multiple times'))\r\n      index = i\r\n      // 拿到当前的中间件\r\n      let fn = middleware[i]\r\n      if (i === middleware.length) fn = next\r\n      // 当 fn 为空的时候，就会开始执行 next() 后面部分的代码\r\n      if (!fn) return Promise.resolve()\r\n      try {\r\n        // 执行中间件，留意这两个参数，都是中间件的传参，第一个是上下文，第二个是 next 函数\r\n        // 也就是说执行 next 的时候也就是调用 dispatch 函数的时候\r\n        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));\r\n      } catch (err) {\r\n        return Promise.reject(err)\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n\r\n## 为什么需要洋葱模型？\r\n> 因为很多时候，在一个app里面有很多个中间件，有些中间件需要依赖其他中间件的结果，洋葱模型可以保证执行的顺序，如果没有洋葱模型，执行顺序可能出乎我们的预期。\r\n\r\n\r\n## 参考文献\r\n[【Node】深入浅出 Koa 的洋葱模型](https://juejin.cn/post/7012031464237694983)"
    },
    {
      "id": "/OSI七层网络模型，你了解多少？",
      "metadata": {
        "permalink": "/blog/OSI七层网络模型，你了解多少？",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/OSI七层网络模型，你了解多少？.md",
        "source": "@site/blog\\OSI七层网络模型，你了解多少？.md",
        "title": "OSI七层网络模型，你了解多少？",
        "description": "OSI七层模型具体指的是哪七层？",
        "date": "2022-05-09T00:00:00.000Z",
        "formattedDate": "2022年5月9日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 2.685,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "OSI七层网络模型，你了解多少？",
          "date": "2022-05-09T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "Koa的洋葱模型到底是什么？",
          "permalink": "/blog/Koa的洋葱模型到底是什么？"
        },
        "nextItem": {
          "title": "Promise的异常捕获问题",
          "permalink": "/blog/Promise的异常捕获问题"
        }
      },
      "content": "## OSI七层模型具体指的是哪七层？\r\n> 从底到上分别是：\r\n\r\n* 物理层\r\n* 数据链路层\r\n* 网络层\r\n* 传输层\r\n* 会话层\r\n* 表示层\r\n* 应用层\r\n\r\n## 每一层主要负责什么？都有什么协议？\r\n* 物理层\r\n\r\n> 物理层主要规定通信设备的电气特性，用以建立物理链路连接，例如规定了设备的规格尺寸、引脚数量和排列情况等，电气特性规定了物理连接上传输bit流时信号电平的大小、传输速率等，核心作用就是负责传输0和1的电信号。\r\n\r\n* 数据链路层\r\n\r\n> 数据链路层在物理层提供比特流的基础上，通过差错控制提供数据帧在信道上无差错的传输，这一层确定了0和1的分组方式。数据链路层将物理层的比特流转换成帧。\r\n\r\n* 网络层\r\n\r\n> 计算机网络中进行通信的两个计算机之间可能会经过多个数据链路，或通信子网，网络层的任务就是选择合适的路由和交换节点，确保数据及时传送，网络层将数据链路层提供的帧组成数据包。这一层的代表协议是`IP协议、RIP协议。`网络层的核心功能是建立主机到主机的通信。RIP协议是一种动态路由选择协议。\r\n\r\n* 传输层\r\n\r\n> 传输层的核心功能是建立端口到端口的通信，只要确定主机和端口就能实现程序之间的通信。传输层的代表协议有：`TCP、UDP协议。`\r\n\r\n* 会话层\r\n\r\n> 会话层主要用于辅助何时建立连接、何时断开连接、以及保持多久的连接。代表的协议有`DNS`。\r\n\r\n* 表示层\r\n\r\n> 表示层和主要是将设备固有的数据格式和网络标准数据格式之间的转换。\r\n\r\n* 应用层\r\n\r\n> 应用层主要是针对特定应用的协议，例如`电子邮件Email、远程登陆协议SSH、文件传输协议FTP、网络请求协议HTTP。`"
    },
    {
      "id": "/Promise的异常捕获问题",
      "metadata": {
        "permalink": "/blog/Promise的异常捕获问题",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Promise的异常捕获问题.md",
        "source": "@site/blog\\Promise的异常捕获问题.md",
        "title": "Promise的异常捕获问题",
        "description": "Promise根据异常出现的位置不同采取的方案也不同",
        "date": "2022-05-08T00:00:00.000Z",
        "formattedDate": "2022年5月8日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 0.765,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Promise的异常捕获问题",
          "date": "2022-05-08T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "OSI七层网络模型，你了解多少？",
          "permalink": "/blog/OSI七层网络模型，你了解多少？"
        },
        "nextItem": {
          "title": "Vue中的v-if和v-for为什么不能一起用？",
          "permalink": "/blog/Vue中的v-if和v-for为什么不能一起用？"
        }
      },
      "content": "## Promise根据异常出现的位置不同采取的方案也不同\r\n### Promise内部抛出异常\r\n> 通过then的第二个函数来捕捉异常。\r\n\r\n```js\r\n// Promise的异常捕获问题\r\nconst promise = new Promise((resolve,reject) => {\r\n    throw new Error('test')\r\n})\r\n\r\n// 通过then的第二个函数来进行捕捉\r\npromise.then(res => {\r\n    console.log(res);\r\n},err => {\r\n    console.log(err); // [Error test]\r\n})\r\n```\r\n\r\n### Promise.then的第一个函数出现了异常\r\n> 通过catch来捕捉Promise.then的第一个函数。\r\n\r\n```js\r\nconst promise = new Promise((resolve,reject) => {\r\n    resolve(666)\r\n})\r\n\r\n// 通过.catch进行捕捉\r\npromise.then(res => {\r\n    throw new Error('test2')\r\n},err => {\r\n    console.log(err); \r\n}).catch(err => {\r\n    console.log(err);  //[Error test2]\r\n})\r\n```"
    },
    {
      "id": "/Vue中的v-if和v-for为什么不能一起用？",
      "metadata": {
        "permalink": "/blog/Vue中的v-if和v-for为什么不能一起用？",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Vue中的v-if和v-for为什么不能一起用？.md",
        "source": "@site/blog\\Vue中的v-if和v-for为什么不能一起用？.md",
        "title": "Vue中的v-if和v-for为什么不能一起用？",
        "description": "假如v-if和v-for一起使用会出现什么情况？",
        "date": "2022-05-07T00:00:00.000Z",
        "formattedDate": "2022年5月7日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 0.585,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Vue中的v-if和v-for为什么不能一起用？",
          "date": "2022-05-07T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "Promise的异常捕获问题",
          "permalink": "/blog/Promise的异常捕获问题"
        },
        "nextItem": {
          "title": "for...in和for....of的区别是什么？",
          "permalink": "/blog/for...in和for....of的区别是什么？"
        }
      },
      "content": "## 假如v-if和v-for一起使用会出现什么情况？\r\n```js\r\n<ul>\r\n  <li v-for=\"(item,index) in arr \" v-if=\"flag\" :key=\"index\"  >\r\n    {{item}}\r\n  </li>\r\n</ul>\r\n```\r\n\r\n> 一起使用，会出现下面的错误提示：\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/7b7a4485ef10f50740dc8c06fbac449e.png)\r\n\r\n## 为什么不能一起使用？\r\n> 因为v-for的优先级比v-if的优先级高，所以如果嵌套使用的话，每次v-for都会执行一次v-if，造成重复计算的问题，会影响性能，所以vue官方不推荐这样使用。"
    },
    {
      "id": "/for...in和for....of的区别是什么？",
      "metadata": {
        "permalink": "/blog/for...in和for....of的区别是什么？",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/for...in和for....of的区别是什么？.md",
        "source": "@site/blog\\for...in和for....of的区别是什么？.md",
        "title": "for...in和for....of的区别是什么？",
        "description": "核心区别：获取的内容不同",
        "date": "2022-05-06T00:00:00.000Z",
        "formattedDate": "2022年5月6日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 1.22,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "for...in和for....of的区别是什么？",
          "date": "2022-05-06T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "Vue中的v-if和v-for为什么不能一起用？",
          "permalink": "/blog/Vue中的v-if和v-for为什么不能一起用？"
        },
        "nextItem": {
          "title": "这一次，彻底搞懂Vue中的keep-alive",
          "permalink": "/blog/这一次，彻底搞懂Vue中的keep-alive"
        }
      },
      "content": "## 核心区别：获取的内容不同\r\n* for...in主要获取对象的key和数组的下标，同时for...in还能够遍历原型链上的可枚举属性。\r\n* for...of主要获取对象的value值。\r\n\r\n```js\r\nconst obj = {'a' : '111','b':'222'};\r\n\r\nfor (let key in obj) {\r\n    console.log(key);  // a b\r\n}\r\n//  没有部署原生的iterator接口的对象不能直接遍历\r\nfor (let value of Object.keys(obj)) {\r\n    console.log(obj[value]);  // 111  222\r\n}\r\n```\r\n\r\n\r\n## 常见问题汇总\r\n### RQ1：for...in或者for...of能遍历Symbol类型的值吗？\r\n> 无论是for...in还是for...of都不能遍历Symbol类型的值，遍历Symbol类型的值需要使用Object.getOwnPropertySymbols()方法。\r\n\r\n### RQ2：for...in遍历出原型上的属性怎么办？\r\n> 如果只想要遍历实例对象身上的属性，不遍历原型链上的属性可以使用hasOwnProperty方法来过滤。\r\n\r\n### RQ3：for in 和 Object.keys()的区别？\r\n> for...in循环会遍历原型链上的可枚举属性，但是Object.keys()则不会涉及到原型链上的属性。"
    },
    {
      "id": "/这一次，彻底搞懂Vue中的keep-alive",
      "metadata": {
        "permalink": "/blog/这一次，彻底搞懂Vue中的keep-alive",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/这一次，彻底搞懂Vue中的keep-alive.md",
        "source": "@site/blog\\这一次，彻底搞懂Vue中的keep-alive.md",
        "title": "这一次，彻底搞懂Vue中的keep-alive",
        "description": "keep-alive的使用场景及其特点",
        "date": "2022-05-05T00:00:00.000Z",
        "formattedDate": "2022年5月5日",
        "tags": [
          {
            "label": "Vue",
            "permalink": "/blog/tags/vue"
          }
        ],
        "readingTime": 2.015,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "这一次，彻底搞懂Vue中的keep-alive",
          "date": "2022-05-05T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Vue",
          "tags": [
            "Vue"
          ]
        },
        "prevItem": {
          "title": "for...in和for....of的区别是什么？",
          "permalink": "/blog/for...in和for....of的区别是什么？"
        },
        "nextItem": {
          "title": "LeetCode——简化路径（辅助栈）",
          "permalink": "/blog/LeetCode——简化路径（辅助栈）"
        }
      },
      "content": "## keep-alive的使用场景及其特点\r\n\r\n1. 用于Vue性能优化。\r\n2. 缓存组件。\r\n3. 频繁切换，不需要重复渲染。\r\n4. keep-alive有include和exclude属性，这两个属性决定了哪些组件可以进入缓存。\r\n5. keep-alive还有一个max属性，通过它可以设置最大缓存数，当缓存的实例超过max的时候，vue会删除最久没有使用的缓存，属于LRU缓存策略。\r\n6. keep-alive其内部所有嵌套的组件都具有两个生命周期钩子函数，分别是activated和deactivated，它们分别在组件激活和失活的时候触发。\r\n\r\n> 将组件放入keep-alive中即可实现组件的缓存。\r\n\r\n```js\r\n<keep-alive>\r\n    <KeepaliveA v-if=\"state === 'A' \" />\r\n    <KeepaliveB v-if=\"state === 'B' \"/>\r\n    <KeepaliveC v-if=\"state === 'C' \"/>\r\n</keep-alive>\r\n```\r\n\r\n## keep-alive的原理？\r\n> keep-alive在实现上，维护了一个key数组和一个缓存对象，这个key数组记录目前缓存的组件的key值，如果这个组件没有指定key值，会自动生成一个唯一的key值，缓存对象会以key值为键，vnode为值，用于缓存组件对应的虚拟DOM，在keep-alive的渲染函数中，其基本逻辑是判断当前渲染的vnode是否有对应的缓存，如果有则从缓存中读取到对应的组件实例，没有就把它缓存。\r\n\r\n## keep-alive如何根据不同场景来更新数据？\r\n> 可以利用keep-alive提供的include和exclude指定缓存哪些组件不缓存哪些组件，然后配合vuex等状态管理工具实现动态控制。"
    },
    {
      "id": "/LeetCode——简化路径（辅助栈）",
      "metadata": {
        "permalink": "/blog/LeetCode——简化路径（辅助栈）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——简化路径（辅助栈）.md",
        "source": "@site/blog\\LeetCode——简化路径（辅助栈）.md",
        "title": "LeetCode——简化路径（辅助栈）",
        "description": "题目描述",
        "date": "2022-05-04T00:00:00.000Z",
        "formattedDate": "2022年5月4日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.26,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——简化路径（辅助栈）",
          "date": "2022-05-04T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "这一次，彻底搞懂Vue中的keep-alive",
          "permalink": "/blog/这一次，彻底搞懂Vue中的keep-alive"
        },
        "nextItem": {
          "title": "你了解Vue的动态加载组件和异步加载组件吗？",
          "permalink": "/blog/你了解Vue的动态加载组件和异步加载组件吗？"
        }
      },
      "content": "## 题目描述\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/d6998e5f8fe46337381fd42da9b5b704.png)\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/0deb816c63a7f7e4bb2fab67be09e1ef.png)\r\n\r\n## 解题思路\r\n> 核心的解题思路就是借助一个栈来辅助我们，遇到空字符串和一个点的则跳过，遇到两个点的则出栈。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/0bada2ad5f44676be9bdaf4db4c83ca4.png)\r\n\r\n## AC代码\r\n\r\n```js\r\nvar simplifyPath = function(path) {\r\n    // 简化路径的核心就是借助辅助栈\r\n    const stack = [];\r\n    // 分割字符串\r\n    const strArr = path.split('/');\r\n    // 遇到空字符串和一个点的直接跳过\r\n    // 遇到两个点则出栈\r\n    const res = [];\r\n    for (let v of strArr) {\r\n        if (v.length === 0 || v === '.') {\r\n            continue;\r\n        }\r\n        if (v === '..') {\r\n            stack.pop();\r\n            continue;\r\n        }\r\n        stack.push(v);\r\n    }\r\n    for (let i = 0; i < stack.length; i++) {\r\n        res.push('/');\r\n        res.push(stack[i]);\r\n    }\r\n    return res.length > 0 ? res.join('') : '/'\r\n};\r\n```\r\n\r\n## 总结\r\n> 简化路径的本质就是借助栈这个数据结构的特点对不同的情况进行出栈和入栈，最后返回的就是路径的简化结果，遇到空字符串和一个点的都跳过，遇到两个点的则出栈是本题的核心。"
    },
    {
      "id": "/你了解Vue的动态加载组件和异步加载组件吗？",
      "metadata": {
        "permalink": "/blog/你了解Vue的动态加载组件和异步加载组件吗？",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/你了解Vue的动态加载组件和异步加载组件吗？.md",
        "source": "@site/blog\\你了解Vue的动态加载组件和异步加载组件吗？.md",
        "title": "你了解Vue的动态加载组件和异步加载组件吗？",
        "description": "如何动态加载组件？",
        "date": "2022-04-30T00:00:00.000Z",
        "formattedDate": "2022年4月30日",
        "tags": [
          {
            "label": "Vue",
            "permalink": "/blog/tags/vue"
          }
        ],
        "readingTime": 0.53,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "你了解Vue的动态加载组件和异步加载组件吗？",
          "date": "2022-04-30T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Vue",
          "tags": [
            "Vue"
          ]
        },
        "prevItem": {
          "title": "LeetCode——简化路径（辅助栈）",
          "permalink": "/blog/LeetCode——简化路径（辅助栈）"
        },
        "nextItem": {
          "title": "Vue的作用域插槽slot有什么用？",
          "permalink": "/blog/Vue的作用域插槽slot有什么用？"
        }
      },
      "content": "## 如何动态加载组件？\r\n1. 引入可能被使用的组件\r\n\r\n```js\r\nimport slotDemo from './components/slotDemo'\r\nimport HelloWorld from './components/HelloWorld'\r\n```\r\n\r\n2. 通过动态属性is来读取组件名\r\n\r\n```js\r\n<component  :is=\"comName\"/>\r\n```\r\n\r\n## 如何异步加载组件？\r\n\r\n\r\n1. 通过import在注册组件的时候引入组件\r\n\r\n```js\r\ncomponents: {\r\n    FormDemo: () => import(`../xxxComponent`)\r\n}\r\n```\r\n\r\n2. 通过条件渲染来加载组件\r\n\r\n```js\r\n<FormDemo v-if=\"showFormDemo\" />\r\n<button @click=\"showFormDemo = true\" >show form demo</button>\r\n```"
    },
    {
      "id": "/Vue的作用域插槽slot有什么用？",
      "metadata": {
        "permalink": "/blog/Vue的作用域插槽slot有什么用？",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Vue的作用域插槽slot有什么用？.md",
        "source": "@site/blog\\Vue的作用域插槽slot有什么用？.md",
        "title": "Vue的作用域插槽slot有什么用？",
        "description": "一、基本使用",
        "date": "2022-04-27T00:00:00.000Z",
        "formattedDate": "2022年4月27日",
        "tags": [
          {
            "label": "Vue",
            "permalink": "/blog/tags/vue"
          }
        ],
        "readingTime": 1.185,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Vue的作用域插槽slot有什么用？",
          "date": "2022-04-27T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Vue",
          "tags": [
            "Vue"
          ]
        },
        "prevItem": {
          "title": "你了解Vue的动态加载组件和异步加载组件吗？",
          "permalink": "/blog/你了解Vue的动态加载组件和异步加载组件吗？"
        },
        "nextItem": {
          "title": "你真的了解Vue的生命周期吗？",
          "permalink": "/blog/你真的了解Vue的生命周期吗？"
        }
      },
      "content": "## 一、基本使用\r\n> 由父组件向子组件中传递数据，子组件通过slot进行接收，不传递则显示的是默认的内容。\r\n\r\n* 父组件\r\n\r\n```js\r\n<template>\r\n  <div id=\"app\">\r\n    <slotDemo :url=\"website.url\">\r\n        {{website.title}}\r\n    </slotDemo>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport slotDemo from './components/slotDemo'\r\n\r\nexport default {\r\n  name: 'App',\r\n  data() {\r\n    return {\r\n      website: {\r\n        url: 'https://www.baidu.com',\r\n        title: '这是根节点的title'\r\n      }\r\n    }\r\n  },\r\n  components: {\r\n    slotDemo\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n* 子组件\r\n\r\n```js\r\n<template>\r\n    <a :href=\"url\">\r\n        <slot>\r\n            默认内容\r\n        </slot>\r\n    </a>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n    name: 'slotDemo',\r\n    props: ['url'],\r\n}\r\n</script>\r\n```\r\n\r\n## 二、父组件通过slot接收子组件传递过来的值\r\n1. 子组件通过slot进行动态属性传值\r\n\r\n```js\r\n<template>\r\n    <a :href=\"url\">\r\n        <slot :slotData = \"website\">\r\n            默认内容\r\n        </slot>\r\n    </a>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n    name: 'slotDemo',\r\n    props: ['url'],\r\n    data() {\r\n        return {\r\n            website: {\r\n                url: '这是子组件的URL',\r\n                title: '子组件的title'\r\n            }\r\n        };\r\n    }\r\n};\r\n</script>\r\n```\r\n\r\n2. 父组件通过template v-slot进行接收\r\n\r\n```js\r\n<template>\r\n  <div id=\"app\">\r\n    <slotDemo :url=\"website.url\">\r\n        <template v-slot=\"slotProps\">\r\n          {{slotProps.slotData.title}}\r\n        </template>\r\n    </slotDemo>\r\n  </div>\r\n</template>\r\n```\r\n\r\n## 三、具名插槽\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/d7da1e416f57f27a3b7da211f926f7be.png)"
    },
    {
      "id": "/你真的了解Vue的生命周期吗？",
      "metadata": {
        "permalink": "/blog/你真的了解Vue的生命周期吗？",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/你真的了解Vue的生命周期吗？.md",
        "source": "@site/blog\\你真的了解Vue的生命周期吗？.md",
        "title": "你真的了解Vue的生命周期吗？",
        "description": "Vue生命周期的主要阶段",
        "date": "2022-04-26T00:00:00.000Z",
        "formattedDate": "2022年4月26日",
        "tags": [
          {
            "label": "Vue",
            "permalink": "/blog/tags/vue"
          }
        ],
        "readingTime": 2.875,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "你真的了解Vue的生命周期吗？",
          "date": "2022-04-26T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Vue",
          "tags": [
            "Vue"
          ]
        },
        "prevItem": {
          "title": "Vue的作用域插槽slot有什么用？",
          "permalink": "/blog/Vue的作用域插槽slot有什么用？"
        },
        "nextItem": {
          "title": "浅析Vue中$nextTick的原理",
          "permalink": "/blog/浅析Vue中$nextTick的原理"
        }
      },
      "content": "## Vue生命周期的主要阶段\r\n### 创建前后\r\n1. beforeCreate：实例刚在内存中被创建出来，此时还没有初始化好data和methods属性。\r\n2. created：实例已经在内存中创建好，此时data和methods已经创建好，此时还没有开始编译模板。\r\n\r\n### 载入前后\r\n3. beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面上。\r\n4. mounted：此时已经编译好模板，并挂载到了页面指定的容器中。\r\n\r\n### 更新前后\r\n5. beforeUpdate：状态更新之前执行这个函数，此时data中的状态值是最新的，但是界面上显示的数据还是旧的，因为此时还没有开始重新渲染DOM节点。\r\n6. updated：实例更新完毕之后调用此函数，此时data中的状态值和界面上显示的数据都已经完成了更新，界面已经被重新渲染好了。\r\n\r\n### 销毁前后\r\n7. beforeDestroy：实例销毁之前调用，在这一步，实例仍然可用。\r\n8. destroyed阶段：Vue实例销毁后调用，调用后，Vue实例所指向的内容都会解除绑定，所有的事件监听器都会被移除，所有的子实例也会被销毁。\r\n\r\n## Vue父子组件的生命周期\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/2b132cc2ee5d8c5427c5c4c023ec0a7c.png)\r\n\r\n## Vue不同生命周期函数的作用\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/75ec4eaceb3f1215aca84a17ea70e01a.png)\r\n\r\n## 问题汇总\r\n### RQ1：Vue虚拟DOM渲染在哪个生命周期？\r\n> 执行到beforeMount的时候虚拟DOM已经渲染完成，等beforeMount这个钩子函数执行完之后真实DOM已经渲染完成。\r\n\r\n### RQ2：created和mounted的区别，操作dom是在哪个里面操作？\r\n> created在模板渲染成HTML前调用，通常初始化某些属性值，然后再渲染视图。\r\n\r\n> mounted在模板渲染成HTML之后再调用，通常是初始化页面完成后，对DOM的节点进行操作。\r\n\r\n### RQ3：发起http请求在哪个钩子？ 绑定事件在哪个钩子？取消事件在哪个钩子？\r\n> 发起HTTP请求一般在created这个钩子函数中，但是如果设计到需要页面加载完成之后调用，则需要在mounted这个钩子中写。\r\n\r\n> 绑定事件在mounted钩子函数中。\r\n\r\n> 取消事件在beforeDestroy钩子函数中。"
    },
    {
      "id": "/浅析Vue中$nextTick的原理",
      "metadata": {
        "permalink": "/blog/浅析Vue中$nextTick的原理",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/浅析Vue中$nextTick的原理.md",
        "source": "@site/blog\\浅析Vue中$nextTick的原理.md",
        "title": "浅析Vue中$nextTick的原理",
        "description": "一、$nextTick有什么用？",
        "date": "2022-04-26T00:00:00.000Z",
        "formattedDate": "2022年4月26日",
        "tags": [
          {
            "label": "Vue",
            "permalink": "/blog/tags/vue"
          }
        ],
        "readingTime": 1.29,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "浅析Vue中$nextTick的原理",
          "date": "2022-04-26T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Vue",
          "tags": [
            "Vue"
          ]
        },
        "prevItem": {
          "title": "你真的了解Vue的生命周期吗？",
          "permalink": "/blog/你真的了解Vue的生命周期吗？"
        },
        "nextItem": {
          "title": "手写函数柯里化",
          "permalink": "/blog/Vue中的methods、watch、computed、filters到底有什么区别？"
        }
      },
      "content": "## 一、$nextTick有什么用？\r\n1. Vue是异步渲染的框架。\r\n2. data改变之后，DOM不会立刻渲染。\r\n3. $nextTick会在DOM渲染之后被触发，以获取最新的DOM节点。\r\n4. 连续多次的异步渲染，$nextTick只会执行最后一次渲染后的结果。\r\n\r\n## 二、$nextTick的原理\r\n>\\$nextTick主要通过事件循环中的任务队列的方式异步执行传入的回调函数，首先会判断当前的执行环境是否支持Promise，MutationObserver，setImmediate，setTimeout。如果支持则创建对应的异步方法，这里的MutationObserver并不是监听DOM，而是利用其微任务特性。需要注意的是更新DOM的方法也是通过nextTick进行调用的，因此就可以实现传入$.nextTick的回调函数在DOM渲染完成之后执行这些微任务。\r\n\r\n## 三、循环调用的话nextTick里面有容错机制吗？\r\n>多次调用 nextTick 会将方法存入队列 callbacks 中，通过这个异步方法清空当前队列。"
    },
    {
      "id": "/Vue中的methods、watch、computed、filters到底有什么区别？",
      "metadata": {
        "permalink": "/blog/Vue中的methods、watch、computed、filters到底有什么区别？",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Vue中的methods、watch、computed、filters到底有什么区别？.md",
        "source": "@site/blog\\Vue中的methods、watch、computed、filters到底有什么区别？.md",
        "title": "手写函数柯里化",
        "description": "一、methods",
        "date": "2022-04-25T00:00:00.000Z",
        "formattedDate": "2022年4月25日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 2.28,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "手写函数柯里化",
          "date": "2022-04-25T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "浅析Vue中$nextTick的原理",
          "permalink": "/blog/浅析Vue中$nextTick的原理"
        },
        "nextItem": {
          "title": "LeetCode——回文数（反转比较）",
          "permalink": "/blog/LeetCode——回文数（反转比较）"
        }
      },
      "content": "## 一、methods\r\n> methods中存放的是事件的回调函数，具有以下几个特点：\r\n\r\n1. 可以通过Vue实例访问方法，在方法中最好不要使用箭头函数，因为涉及到this指向的问题。\r\n2. 重新渲染的时候，methods总会执行该函数。\r\n3. methods是函数调用，filters和computed、watch是属性调用。\r\n4. methods是不具有缓存性的。\r\n\r\n## 二、filters\r\n> filters一般用于格式化输出的场景，比如日期格式化，filters过滤器可以进行串联调用，所以可以定义一些基础的filters，然后按需在组件内使用。filters不具有缓存性。\r\n\r\n```js\r\n{{msg | fliterA | filterB}}\r\n```\r\n\r\n## 三、computed\r\n> computed是计算属性，会监听一个依赖属性，如果这个属性发生变化，就会更新视图，适用于计算比较消耗性能的计算场景，因为其具有缓存功能，这意味着其监听的数据如果没有发生变化，多次调用计算属性会返回之间的计算结果，不必再次执行函数。\r\n\r\n## 四、watch\r\n> watch可以监听某一个数据的变化，watch要想监听对象中某个属性是否发生了变化，需要将deep属性置为true。但是watch无法拿到对象中属性变化的旧值，只能拿到新的对象。\r\n\r\n```js\r\n  watch: {\r\n    name(newValue, oldValue) {\r\n      console.log(\"name\", newValue, oldValue);\r\n    },\r\n    info: {\r\n      handler: function(newValue,oldValue) {\r\n        console.log('info',newValue,oldValue);\r\n      },\r\n      deep: true\r\n    }\r\n  },\r\n ```\r\n \r\n ## 问题汇总\r\n ### RQ1：watch和computed的区别\r\n 1. watch是监听一个数据是否发生变化，当这个数据发生变化才执行函数。\r\n 2. computed则是只要其函数内部的代码指向的数据发生了变化，其就会执行函数，然后返回。\r\n 3. computed具有缓存特性，watch则没有。"
    },
    {
      "id": "/LeetCode——回文数（反转比较）",
      "metadata": {
        "permalink": "/blog/LeetCode——回文数（反转比较）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——回文数（反转比较）.md",
        "source": "@site/blog\\LeetCode——回文数（反转比较）.md",
        "title": "LeetCode——回文数（反转比较）",
        "description": "题目描述",
        "date": "2022-04-09T00:00:00.000Z",
        "formattedDate": "2022年4月9日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.5,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——回文数（反转比较）",
          "date": "2022-04-09T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "手写函数柯里化",
          "permalink": "/blog/Vue中的methods、watch、computed、filters到底有什么区别？"
        },
        "nextItem": {
          "title": "手写函数柯里化",
          "permalink": "/blog/手写函数柯里化"
        }
      },
      "content": "## 题目描述\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/45d4c45b5ff60936d769996e546e5ff8.png)\r\n\r\n## 解题思路\r\n### 思路一：反转比较法\r\n> 回文数的一个特点是正着读和倒着读是一样的，那么我们可以定义一个临时变量来存储目标元素的反转，然后顺序比较每个元素是否相等，相等则返回true，反之false。\r\n\r\n```js\r\nvar isPalindrome = function(x) {\r\n  // 使用反转对比的方法来判断是否是回文数字\r\n  x = x.toString();\r\n  const temp = x.split('').reverse();\r\n  const xArr = x.split('');\r\n\r\n  for (let i = 0; i < xArr.length; i++) {\r\n    if (temp[i] != xArr[i]) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n\r\n};\r\n```\r\n\r\n### 思路二：使用递归比较首尾元素\r\n> 首先比较首元素和尾元素是否一致，一致则去掉首尾元素，将其余元素记性递归判断。\r\n\r\n```js\r\nvar isPalindrome = function(x) {\r\n  // 使用递归判断\r\n  // 递归的介绍条件是输入的x小于等于1\r\n  if (x.toString().length <= 1) {\r\n    return true;\r\n  }\r\n  x = x.toString().split('');\r\n  let start = 0;\r\n  let end = x.length - 1;\r\n\r\n  if (x[start] === x[end]) {\r\n    return isPalindrome(x.slice(1,end).join(''))\r\n  } else {\r\n    return false;\r\n  }\r\n};\r\n```\r\n\r\n## 总结\r\n> 判断回文数是一道高频考题，思路也比较简单就是根据回文数的特点出发来进行解题。"
    },
    {
      "id": "/手写函数柯里化",
      "metadata": {
        "permalink": "/blog/手写函数柯里化",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/手写函数柯里化.md",
        "source": "@site/blog\\手写函数柯里化.md",
        "title": "手写函数柯里化",
        "description": "什么是函数柯里化？",
        "date": "2022-04-08T00:00:00.000Z",
        "formattedDate": "2022年4月8日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 1.66,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "手写函数柯里化",
          "date": "2022-04-08T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "LeetCode——回文数（反转比较）",
          "permalink": "/blog/LeetCode——回文数（反转比较）"
        },
        "nextItem": {
          "title": "你知道多少种判断数据类型的方法？",
          "permalink": "/blog/你知道多少种判断数据类型的方法？"
        }
      },
      "content": "## 什么是函数柯里化？\r\n> 函数柯里化主要用于给函数分步传递参数，每次传递参数进行处理，并返回一个更具体的函数来接受剩下的参数，这中间可以嵌套多层，直至返回最后的结果。\r\n\r\n## 实现思路\r\n1. 接收一个处理数据的函数。\r\n2. 定义一个数组用于接收所有的参数。\r\n3. 返回一个函数，如果返回的函数接收的参数的长度是0，则返回fn执行的结果，如果不是0，则将参数push进数组中，并返回函数。\r\n\r\n## 代码实现一（需要额外调用）\r\n```js\r\n// 手写函数柯里化\r\nconst curring = function(fn) {\r\n    const args = [];\r\n    return function result(...rest) {\r\n        if (rest.length === 0) {\r\n            return fn(...args)\r\n        } else {\r\n            args.push(...rest);\r\n            return result;\r\n        }\r\n    }\r\n}\r\nconst sum = (...arg) => {\r\n    return arg.reduce((pre,cur) => {\r\n        return pre + cur\r\n    },0)\r\n}\r\n\r\ncurring(sum)(1)(2,5)(3)()\r\n```\r\n\r\n## 代码实现二（不需要额外调用）\r\n\r\n```js\r\n// 手写函数科里化\r\n// foo(1)(2)(3)\r\nconst sum = (arg) => {\r\n    return arg.reduce((pre,cur) => {\r\n        return pre + cur;\r\n    },0)\r\n};\r\n\r\nconst foo = (...args1) => {\r\n    const sum1 = sum(args1);\r\n    const fn = (...args2) => {\r\n        const sum2 = sum(args2);\r\n        return foo(sum1 + sum2); \r\n    }\r\n    fn.toString = () => {\r\n        return sum1;\r\n    }\r\n    return fn;\r\n}\r\n// 这种方式只能使用== 不能使用===\r\nfoo(1)(2)(3) == 6\r\n```\r\n\r\n> 但是这种方式只能使用==，不能使用==="
    },
    {
      "id": "/你知道多少种判断数据类型的方法？",
      "metadata": {
        "permalink": "/blog/你知道多少种判断数据类型的方法？",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/你知道多少种判断数据类型的方法？.md",
        "source": "@site/blog\\你知道多少种判断数据类型的方法？.md",
        "title": "你知道多少种判断数据类型的方法？",
        "description": "方式一：通过constructor",
        "date": "2022-04-02T00:00:00.000Z",
        "formattedDate": "2022年4月2日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 3.53,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "你知道多少种判断数据类型的方法？",
          "date": "2022-04-02T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "手写函数柯里化",
          "permalink": "/blog/手写函数柯里化"
        },
        "nextItem": {
          "title": "这一次，彻底搞懂Vue的组件通信",
          "permalink": "/blog/这一次，彻底搞懂Vue的组件通信"
        }
      },
      "content": "## 方式一：通过constructor\r\n> 通过constructor可以直接找到元素的构造函数类型，这种方法能够区分引用数据类型到底是哪种类型，请看下面的例子。\r\n\r\n```js\r\nconst arr = [1,2,3,5];\r\nconst date = new Date();\r\nconst num = 666;\r\nconst map = new Map();\r\nconst set = new Set();\r\nconst reg = new RegExp();\r\nconst str = '111';\r\nconst sym = Symbol(66);\r\nconst func = function(){}\r\n// 需要注意的是null和undefined没有constructor\r\n\r\nconsole.log(arr.constructor === Array);  // true\r\nconsole.log(date.constructor === Date);  // true\r\nconsole.log(num.constructor === Number); // true\r\nconsole.log(map.constructor === Map);  // true\r\nconsole.log(set.constructor === Set);  // true\r\nconsole.log(reg.constructor === RegExp); // true\r\nconsole.log(str.constructor === String);  // true\r\nconsole.log(sym.constructor === Symbol); // true\r\nconsole.log(func.constructor === Function); // true\r\n```\r\n\r\n`需要特别注意的是null和undefined没有constructor属性。`\r\n\r\n## 方式二：使用instanceof来判断引用类型到底属于哪种类型\r\n\r\n```js\r\nconst arr = [1,2,3,5];\r\nconst date = new Date();\r\nconst map = new Map();\r\nconst set = new Set();\r\nconst reg = new RegExp();\r\nconst func = function(){}\r\n\r\nconsole.log(arr instanceof Array);  // true\r\nconsole.log(date instanceof Date);  // true\r\nconsole.log(map instanceof Map);  // true\r\nconsole.log(set instanceof Set);  // true\r\nconsole.log(reg instanceof RegExp); // true\r\nconsole.log(func instanceof Function); // true\r\n```\r\n\r\n`需要特别注意的是：instanceof 不适用于判断基本类型。`\r\n\r\n## 方式三：使用typeof来判断基本数据类型\r\n> 需要注意的是typeof能够帮助我们判断出基本数据类型和函数，但是引用数据类型一般是object。\r\n\r\n```js\r\nconst arr = [1,2,3,5];\r\nconst date = new Date();\r\nconst num = Number(666);\r\nconst map = new Map();\r\nconst set = new Set();\r\nconst reg = new RegExp();\r\nconst str = '111';\r\nconst sym = Symbol(66);\r\nconst func = function(){}\r\n// 需要注意的是null和undefined没有constructor\r\n\r\nconsole.log(typeof arr);  // object\r\nconsole.log(typeof date);  // object\r\nconsole.log(typeof num);  // number\r\nconsole.log(typeof map);  // object\r\nconsole.log(typeof set); // object\r\nconsole.log(typeof reg); // object\r\nconsole.log(typeof str); // string\r\nconsole.log(typeof sym);  // symbol\r\nconsole.log(typeof func);  //function\r\n```\r\n\r\n## 方式四：通过Object.prototype.toString.call()精准确定类型（强烈推荐）\r\n> 需要注意的是这个方法输出的是一个字符串，这个字符串object是小写的，后面的是大写的。\r\n\r\n```js\r\nconst arr = [1,2,3,5];\r\nconst date = new Date();\r\nconst num = Number(666);\r\nconst map = new Map();\r\nconst set = new Set();\r\nconst reg = new RegExp();\r\nconst str = '111';\r\nconst sym = Symbol(66);\r\nconst func = function(){}\r\n\r\nconsole.log(Object.prototype.toString.call(arr));  // [object Array]\r\nconsole.log(Object.prototype.toString.call(date));  // [object Date]\r\nconsole.log(Object.prototype.toString.call(num));  // [object Number]\r\nconsole.log(Object.prototype.toString.call(map));  // [object Map]\r\nconsole.log(Object.prototype.toString.call(set)); // [object Set]\r\nconsole.log(Object.prototype.toString.call(reg)); // [object RegExp]\r\nconsole.log(Object.prototype.toString.call(str)); // [object String]\r\nconsole.log(Object.prototype.toString.call(sym));  // [object Symbol]\r\nconsole.log(Object.prototype.toString.call(func));  // [object Function]\r\n```\r\n\r\n## 问题汇总\r\n### RQ1：如何判断一个对象是一个空对象？\r\n1. 通过Reflect.ownKeys的长度为零。Reflect.ownKys()可以返回一个由目标对象自身的属性组成的数组。\r\n\r\n```js\r\nconst obj = {};\r\n\r\nconsole.log(Reflect.ownKeys(obj).length === 0);  // true\r\n```\r\n\r\n2. 通过JSON.stringify()\r\n\r\n```js\r\nconst obj = {};\r\n\r\nconsole.log(JSON.stringify(obj) === '{}');  // true\r\n```\r\n\r\n### RQ2：有什么方法可以获取对象的key？\r\n1. 使用Object.keys()\r\n2. 使用Reflect.ownKeys()\r\n\r\n### RQ3：对象的中括号运算符和点运算符有什么区别？\r\n> 中括号中可以用变量，但是点后面不能是一个变量。\r\n\r\n```js\r\nconst obj = {};\r\n\r\nobj.name = '111';\r\nconst myName = 'name'\r\nconsole.log(obj.myName); // undefined\r\nconsole.log(obj[myName]);  // 111\r\n```"
    },
    {
      "id": "/这一次，彻底搞懂Vue的组件通信",
      "metadata": {
        "permalink": "/blog/这一次，彻底搞懂Vue的组件通信",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/这一次，彻底搞懂Vue的组件通信.md",
        "source": "@site/blog\\这一次，彻底搞懂Vue的组件通信.md",
        "title": "这一次，彻底搞懂Vue的组件通信",
        "description": "前言",
        "date": "2022-04-02T00:00:00.000Z",
        "formattedDate": "2022年4月2日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 3.67,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "这一次，彻底搞懂Vue的组件通信",
          "date": "2022-04-02T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "你知道多少种判断数据类型的方法？",
          "permalink": "/blog/你知道多少种判断数据类型的方法？"
        },
        "nextItem": {
          "title": "大白话阐述什么是BFC（一道可能的面试题）",
          "permalink": "/blog/大白话阐述什么是BFC（一道可能的面试题）"
        }
      },
      "content": "## 前言\r\n> vue的组件通信无论是在工作中还是在面试中都是经常考到的知识，这一次让我们一起来系统的梳理下Vue的组件通信都有哪些方式吧~\r\n\r\n## 一、父组件向子组件进行传值\r\n`核心：通过props就行传递。`\r\n\r\n1. 在父组件中引入子组件。\r\n2. 通过在子组件的标签上进行传递。\r\n3. 子组件中通过声明props进行接收。\r\n\r\n## 二、子组件向父组件传值\r\n\r\n`核心：通过this.$emit('父组件中的函数名',传递参数)`\r\n\r\n1. 父组件给子组件绑定函数。\r\n2. 子组件通过this.$emit出发父组件给子组件绑定的函数。\r\n\r\n## 三、子组件通过$parent来获取父组件实例的属性和方法\r\n\r\n`核心：在子组件中通过this.$parent.xxx来获取父组件的属性和方法`\r\n\r\n## 四、通过\\$refs或$children获取子组件的属性或方法\r\n### 通过$refs获取子组件的属性和方法\r\n1. 给子组件绑定ref属性。\r\n2. 通过this.$refs.son.xxx来调用子组件身上的属性和方法。\r\n\r\n### 通过$children获取子组件的属性和方法\r\n> \\$children属性无需绑定，即可直接使用，\\$children获取的是一个数组，有多少个子组件就有多少个元素，\\$children[0]代表的是第0个组件。\r\n\r\n## 五、通过\\$attrs和\\$listeners获取父组件中的属性和方法\r\n`核心：主要包括下面的两点：`\r\n\r\n1. 通过\\$attrs获取父组件通过子组件props形式传递过来的，但是不在子组件props声明接收的属性。\r\n\r\n```js\r\n<Son :obj=\"obj\" :msg=\"msg\" />\r\n```\r\n\r\n> 例如上面这个例子，在子组件中obj被props声明接收了，但是msg并没有声明接收，那么子组件的this.\\$attrs这个对象中就包含了msg。\r\n\r\n2. 通过\\$listeners可以获取到父作用域中的v-on事件监听器。\r\n\r\n> 注意：this.\\$listeners能够获取到的父组件中的事件监听器必须要通过v-on传递给子组件。\r\n\r\n## 六、使用Event Bus实现跨组件通信\r\n1. 在main.js中对外暴露一个Vue实例\r\n\r\n```js\r\nexport const eventBus = new Vue()\r\n```\r\n\r\n2. 在组件1中引入这个eventBus\r\n\r\n```js\r\nimport {eventBus} from '../main'\r\n```\r\n\r\n3. 组件1中的数据发生变化的时候通过eventBus.$emit派发数据。\r\n\r\n```js\r\neventBus.$emit('add-age',1)\r\n```\r\n\r\n4. 组件2在crated生命周期钩子函数中监听事件并修改数据。\r\n\r\n```js\r\ncreated() {\r\n    eventBus.$on('add-age',(num) => {\r\n      this.ageData += num\r\n    })\r\n}\r\n```\r\n\r\n## 七、父组件通过provide和inject向所有子组件传入数据，不管子组件层次有多深\r\n> 特点是：父组件有一个provide来提供数据，子组件有一个inject来使用这个数据。\r\n\r\n1. 根组件\r\n\r\n```js\r\n  provide: {\r\n    text: '叶子节点你好'\r\n  }\r\n```\r\n\r\n2. 叶子组件\r\n\r\n```js\r\ninject: ['text'],\r\n```\r\n\r\n> 对叶子节点来说，此时根组件传过来的值已经在this身上了。"
    },
    {
      "id": "/大白话阐述什么是BFC（一道可能的面试题）",
      "metadata": {
        "permalink": "/blog/大白话阐述什么是BFC（一道可能的面试题）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/大白话阐述什么是BFC（一道可能的面试题）.md",
        "source": "@site/blog\\大白话阐述什么是BFC（一道可能的面试题）.md",
        "title": "大白话阐述什么是BFC（一道可能的面试题）",
        "description": "什么是BFC？",
        "date": "2022-03-31T00:00:00.000Z",
        "formattedDate": "2022年3月31日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 2.75,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "大白话阐述什么是BFC（一道可能的面试题）",
          "date": "2022-3-31",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "这一次，彻底搞懂Vue的组件通信",
          "permalink": "/blog/这一次，彻底搞懂Vue的组件通信"
        },
        "nextItem": {
          "title": "浏览器的渲染原理你了解吗？",
          "permalink": "/blog/浏览器的渲染原理你了解吗？"
        }
      },
      "content": "## 什么是BFC？\r\n>在系统性的阐述什么是BFC之前，我们首先介绍下CSS中常见的布局。1. 普通流。行内元素排成一行，一行不够则换行，块级元素，一个占一行。2. 浮动。元素会脱离普通流。3. 定位。元素会脱离普通流。BFC也属于普通流，设置为BFC的元素，相当于一种隔离了的元素，容器内部的元素不会在布局上影响外面的元素。\r\n\r\n`BFC指的是块级格式化上下文，一个元素如果具备了BFC的条件，那么这个元素会形成一个独立的渲染区域，内部元素的渲染不会影响外界。`\r\n\r\n## 如何触发BFC？\r\n1. 根元素(\\<html/>)\r\n2. 浮动元素(元素的float不是none)\r\n3. 绝对定位元素(元素的position为absolute或fixed)\r\n4. display为下面几种：\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/4ee0df07cab5ad37f793f4e6a9dab1e8.png)\r\n\r\n5. overflow的值不为visible的块元素\r\n6. contain的值为layout、content或paint的元素\r\n\r\n## BFC的应用场景\r\n### 1. 避免外边距重叠\r\n>在同一个BFC内两个相邻的盒子会出现外边距塌陷的问题，我们可以让这两个div分别位于两个不同的BFC中，则可以有效的避免外边距塌陷的问题。\r\n[codeSandBox在线演示](https://codesandbox.io/s/shiyongbfcbimianwaibianjutaxianwenti-c9z34?file=/index.html)\r\n\r\n### 2. 清除浮动\r\n>BFC容器之所以能够清除浮动，是因为BFC容器可以包裹浮动元素。\r\n\r\n[codeSandBox在线演示](https://codesandbox.io/s/shiyongbfcqingchufudong-lim36?file=/index.html)\r\n\r\n### 3. 阻止元素被浮动元素覆盖\r\n>如果一个元素设置了浮动，但是下面的元素没有设置浮动，下面的元素会顶上来，形成一个浮动覆盖的效果，我们可以通过给非浮动元素设置成BFC元素，可以防止被浮动元素覆盖。\r\n\r\n[codeSandBox在线演示](https://codesandbox.io/s/shiyongbfczuzhiyuansubeifudongyuansufugai-2oeqr?file=/index.html)\r\n\r\n### 4. 使用BFC实现左侧盒子定宽，右侧盒子自适应布局\r\n>左侧设置为浮动，右侧浮动，右侧的宽度计算为100% - 左侧\r\n\r\n[codeSandBox在线测试](https://codesandbox.io/s/bfcshixianzuocegudingkuanduyouceziguayingkuandu-2x7mu?file=/index.html)\r\n\r\n\r\n## 手写clearfix来清除浮动\r\n\r\n```css\r\n    <style>\r\n        .clearfix::after {\r\n            content: '';\r\n            clear: both;\r\n            display: block;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"clearfix\">\r\n        <div style=\"width:100px;height:100px;background-color: red;float: left;\"></div>\r\n        <div style=\"width:100px;height:100px;background-color: green;float: left;\"></div>\r\n    </div>\r\n    <div>456</div>\r\n    <p>789</p>\r\n</body>\r\n```"
    },
    {
      "id": "/浏览器的渲染原理你了解吗？",
      "metadata": {
        "permalink": "/blog/浏览器的渲染原理你了解吗？",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/浏览器的渲染原理你了解吗？.md",
        "source": "@site/blog\\浏览器的渲染原理你了解吗？.md",
        "title": "浏览器的渲染原理你了解吗？",
        "description": "从整体上看浏览器的渲染流程",
        "date": "2022-03-31T00:00:00.000Z",
        "formattedDate": "2022年3月31日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 6.27,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "浏览器的渲染原理你了解吗？",
          "date": "2022-03-31T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "大白话阐述什么是BFC（一道可能的面试题）",
          "permalink": "/blog/大白话阐述什么是BFC（一道可能的面试题）"
        },
        "nextItem": {
          "title": "使用reduce实现map",
          "permalink": "/blog/使用reduce实现map"
        }
      },
      "content": "## 从整体上看浏览器的渲染流程\r\n> 浏览器的渲染流程主要包括以下几个流程：\r\n\r\n1. 解析HTML，生成DOM树，解析CSS，生成CSSOM树。\r\n2. 将DOM树和CSSOM树进行结合，生成渲染树(Render Tree)。\r\n3. 根据生成的渲染树，进行回流（Layout），得到节点的几何信息（位置，大小）。\r\n4. 根据渲染树以及回流得到的几何信息，得到节点的绝对像素。\r\n5. 将像素发送给GPU，展示在页面上。\r\n\r\n## 一、生成DOM树\r\n1. 首先，浏览器会从内存或者网络中读取出HTML文件的二进制数据，然后将其转换为字符串，然后转换为Token。\r\n2. Token会标识出当前字符串是开始标签还是结束标签还是文本。\r\n3. 每生成一个Token之后会立刻创建出节点对象，最后生成一颗DOM树。\r\n\r\n## 二、生成CSSOM树\r\n> 浏览器拿到CSS后，首先会识别出Token，然后构建节点并生成CSSOM树,这个过程和构建DOM树很类似。\r\n\r\n## 三、生成渲染树\r\n> 生成DOM树和CSSOM树之后，需要将这两棵树进行组合称为渲染树。需要注意的是，渲染树并不是简单的将二者进行结合，渲染树只会包括需要显示的节点和节点的样式信息，如果某个节点是display:none，那么就不会出现在渲染树中。\r\n\r\n* 渲染过程遇到JS文件怎么办？\r\n\r\n> 因为浏览器有GUI线程和JS引擎线程，这两个线程是互斥的，JS的加载、解析和执行会阻塞DOM的构建，因此要想首屏渲染的快，就尽量减少在首屏加载JS文件，尽量将script标签放在body标签的底部。\r\n\r\n* 如果浏览器尚未完成CSSOM树的构建，此时想要运行JS脚本怎么办？\r\n\r\n> 这种情况下，浏览器会先下载和构建CSSOM，然后再执行JS脚本，最后构建DOM。\r\n\r\n## 四、回流布局\r\n> 根据生成的渲染树，计算元素在设备视口内的确切位置和大小，这个计算的阶段就是回流，为了弄清每个对象在网站上的确切位置和大小，需要从根节点进行遍历。\r\n\r\n## 五、重绘\r\n> 经过回流布局之后，我们已经知道了节点的样式和具体的位置大小，接下来就可以将渲染树的每个节点都转换为屏幕上的实际像素，这就是重绘。\r\n\r\n## 常见问题汇总\r\n### RQ1：CSSOM树和DOM树是同时解析的吗？\r\n> 浏览器会下下载HTML解析页面生成DOM树，遇到CSS标签就开始解析CSS，这个过程不会阻塞，但是如果遇到了JS脚本，此时假如CSSOM还没有构建完，需要等待CSSOM构建完，再去执行JS脚本，然后再执行DOM解析，此时会阻塞。\r\n\r\n### RQ2：浏览器渲染时的分层是什么意思？\r\n> 通常页面的组成是很复杂的，尤其是一些页面中包含一些复杂的动画效果，如果没有分层机制，从布局树直接生成目标图标的话，每次页面发生细微的变化的时候都要进行回流和重绘，会严重影响性能，分层就是类似于PS中的一张图片可以分为很多图层，将素材分解为多个图层的操作就是分层。\r\n\r\n### RQ3：重排和重绘的概念\r\n> 重排：当DOM的变化影响了元素的几何位置，浏览器需要重新计算元素的几何属性，将其放在页面中的正确位置，这个过程叫做重排。\r\n\r\n> 重绘：指的是元素的外观样式发生变化，但是没有改变布局，重新把外观绘制出来的过程叫做重绘。\r\n\r\n### RQ4：发生重绘和回流的时机是什么？\r\n> 发生回流的情况：\r\n\r\n* 页面刚开始渲染的时候\r\n* 浏览器的窗口尺寸发生变化的时候\r\n* 添加或删除可见的DOM元素\r\n* 元素的位置发生变化\r\n* 元素的尺寸发生变化\r\n* 内容发生变化\r\n* 字体大小变化\r\n\r\n> 发生重绘但是不会流的情况\r\n\r\n* 当页面中发生的是元素样式的改变，但是位置并未发生变化的情况。（例如color，background等）\r\n\r\n> `注意：回流一定重绘，重绘不一定回流。`\r\n\r\n### RQ5：回流和重绘谁更影响性能？\r\n> 回流，因为有时候一个元素发生回流，会导致其周围元素也发生回流。\r\n\r\n### RQ6：如何减少回流和重绘？\r\n* 使用visibility替换display: none，前者只会引起重绘，后者可能会引发回流。\r\n* 离线操作DOM，例如可以通过document.fragment，操作完成之后再将元素带回到文档中。\r\n\r\n## 参考文档\r\n* [阿离王-浏览器渲染过程](https://347830076.github.io/myBlog/javascript/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E6%B5%81%E7%A8%8B.html#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B)"
    },
    {
      "id": "/使用reduce实现map",
      "metadata": {
        "permalink": "/blog/使用reduce实现map",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/使用reduce实现map.md",
        "source": "@site/blog\\使用reduce实现map.md",
        "title": "使用reduce实现map",
        "description": "原生map方法的特点",
        "date": "2022-03-23T00:00:00.000Z",
        "formattedDate": "2022年3月23日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 1.635,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "使用reduce实现map",
          "date": "2022-03-23T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "浏览器的渲染原理你了解吗？",
          "permalink": "/blog/浏览器的渲染原理你了解吗？"
        },
        "nextItem": {
          "title": "使用reduce实现数组扁平化",
          "permalink": "/blog/使用reduce实现数组扁平化"
        }
      },
      "content": "## 原生map方法的特点\r\n1. map不会对原数组产生影响。\r\n2. map返回的是一个新数组。\r\n3. 一个数组一旦调用map方法，每一个元素都会执行map中的回调函数。\r\n4. map方法会跳过被delete删除或者未定义的元素。\r\n\r\n## 原生map接收的两个参数都有什么用？\r\n### 第一个参数：callback\r\n> map接收的第一个参数是一个回调函数，这个参数是必须传入的，callback中有三个可选参数，分别代表着元素，索引和调用map方法的数组，也就是(item,index,arr)。\r\n\r\n### 第二个参数：thisArg（定义执行callback的this指向）：可选\r\n> 第二个参数表示的是callback的this指向。\r\n\r\n## 使用reduce实现map\r\n> 实现思路主要有以下步骤：\r\n\r\n1. 首先判断传入的fn是否是一个函数，如果不是则抛出异常。\r\n2. 使用reduce进行拼接调用，最后返回。\r\n3. this指向的是调用map的数组。\r\n\r\n```js\r\n// 使用reduce实现map\r\nArray.prototype.myMap = function(fn,thisArg=[]) {\r\n  // 如果fn传入的不是一个函数则抛出异常\r\n  if (typeof fn != 'function') {\r\n    throw new Error(`${fn} is not a function`);\r\n  }\r\n  return this.reduce((pre,cur,index,arr) => {\r\n    return pre.concat(fn.call(thisArg,cur,index,arr)); \r\n  },[])\r\n}\r\nconst arr = [2,3,1,5];\r\nconst temp = arr.myMap(item => item * 2)\r\ntemp  // [4,6,2,10]\r\n```"
    },
    {
      "id": "/使用reduce实现数组扁平化",
      "metadata": {
        "permalink": "/blog/使用reduce实现数组扁平化",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/使用reduce实现数组扁平化.md",
        "source": "@site/blog\\使用reduce实现数组扁平化.md",
        "title": "使用reduce实现数组扁平化",
        "description": "实现的目标",
        "date": "2022-03-23T00:00:00.000Z",
        "formattedDate": "2022年3月23日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 1.57,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "使用reduce实现数组扁平化",
          "date": "2022-03-23T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "使用reduce实现map",
          "permalink": "/blog/使用reduce实现map"
        },
        "nextItem": {
          "title": "关于数组去重，你知道多少种方案？",
          "permalink": "/blog/关于数组去重，你知道多少种方案？"
        }
      },
      "content": "## 实现的目标\r\n> 使用数组原生的API，reduce来实现flat，又叫数组拍平。\r\n\r\n> 下面是一个数组拍平的例子：\r\n\r\n```shell\r\n[1, [[2], 3, 4], 5] -->  [1,2,3,4,5]\r\n```\r\n\r\n## 原生flat具有的特点\r\n> 原生flat每调用一次，数组的维度减少1，多维数组在这种情况时可能处理起来很麻烦，无法一次性的边多维数组变为一维数组，比如下面这个例子。\r\n\r\n```js\r\nconst arr = [1, [[2], 3, 4], 5];\r\nconsole.log(arr.flat());   // [1,[2],3,4,5]\r\n```\r\n\r\n## 使用reduce函数实现数组扁平化\r\n> 使用reduce函数实现数组的扁平化主要用到下面的几个API。\r\n\r\n1. reduce\r\n2. concat\r\n\r\n> reduce重点是理解其回调函数的两个参数，主要是什么意思，分别是pre，cur。其中pre代表的是之前的累积和，cur代表的是当前的元素。\r\n\r\n> concat重点是理解谁调用concat，就把后面的部分进行结构赋值，然后加入到调用concat的部分，请看下面的例子：\r\n\r\n```js\r\n// 测试concat\r\nconst test = [666];\r\ntest.concat([1,2,3])  // [666,1,2,3]\r\n```\r\n\r\n### 实现代码\r\n```js\r\n// 使用reduce实现\r\nconst myFlat = (arr) => {\r\n  return arr.reduce((pre,cur) => {\r\n    return pre.concat(Array.isArray(cur) ? myFlat(cur) : cur);\r\n  },[])\r\n}\r\nconst arr = [1, [[2], 3, 4], 5];\r\nconsole.log(myFlat(arr));  // [1,2,3,4,5]\r\n```"
    },
    {
      "id": "/关于数组去重，你知道多少种方案？",
      "metadata": {
        "permalink": "/blog/关于数组去重，你知道多少种方案？",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/关于数组去重，你知道多少种方案？.md",
        "source": "@site/blog\\关于数组去重，你知道多少种方案？.md",
        "title": "关于数组去重，你知道多少种方案？",
        "description": "方式一：通过Set",
        "date": "2022-03-23T00:00:00.000Z",
        "formattedDate": "2022年3月23日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 2.15,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "关于数组去重，你知道多少种方案？",
          "date": "2022-03-23T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "使用reduce实现数组扁平化",
          "permalink": "/blog/使用reduce实现数组扁平化"
        },
        "nextItem": {
          "title": "这一次，彻底搞懂进程与线程之间的联系",
          "permalink": "/blog/这一次，彻底搞懂进程与线程之间的联系"
        }
      },
      "content": "## 方式一：通过Set\r\n```js\r\n// 借助Set实现数组去重\r\nconst arr = [2,3,5,6,8,6,8,2,9];\r\n\r\nconst unique = [...new Set(arr)]\r\nconsole.log(unique);  // [2,3,5,6,8,9]\r\n```\r\n\r\n## 方式二：通过对象\r\n> 首先让待去重的数组的每个元素在对象中key和value相等，如果已经存在的情况下，通过splice对数组进行删除，此时需要注意下标的变化。\r\n\r\n```js\r\n// 通过对象实现数组去重\r\nconst arr = [2,3,5,6,8,6,8,2,9];\r\nconst obj = {};\r\n\r\nfor (let i = 0; i < arr.length; i++) {\r\n    const item = arr[i]\r\n    if (obj[item]) {\r\n        arr.splice(i,1);\r\n        i--;\r\n    } else {\r\n        obj[item] = item\r\n    }\r\n}\r\nconsole.log(arr); // [2,3,5,6,8,9]\r\n```\r\n\r\n## 方式三：利用indexOf和-1的关系进行遍历\r\n```js\r\n// 利用indexOf和-1的关系实现数组去重\r\nconst arr = [2,3,5,6,8,6,8,2,9];\r\n\r\nconst res = [];\r\narr.forEach(item => {\r\n    if (res.indexOf(item) === -1) {\r\n        res.push(item);\r\n    }\r\n})\r\nconsole.log(res);  // [2,3,5,6,8,9]\r\n```\r\n\r\n## 方式四：利用filter和indexOf的关系\r\n```js\r\n// 利用filter和indexOf结合\r\nconst arr = [2,3,5,6,8,6,8,2,9];\r\nconst unique = arr.filter((item,index) => {\r\n    return arr.indexOf(item) === index\r\n})\r\nconsole.log(unique);  // [2,3,5,6,8,9]\r\n```\r\n\r\n## 方式五：利用sort + splice\r\n```js\r\n// 利用sort + splice\r\nconst arr = [2,3,5,6,8,6,8,2,9];\r\n\r\narr.sort((next,pre) => next - pre);\r\n\r\nfor (let i = 0;i < arr.length; i++) {\r\n    if (arr[i] === arr[i + 1]) {\r\n        arr.splice(i,1);\r\n        i--;\r\n    }\r\n}\r\nconsole.log(arr);  // [2,3,5,6,8,9]\r\n```\r\n\r\n## 方式六：借助Map\r\n```js\r\n// 借助Map\r\nconst arr = [2,3,5,6,8,6,8,2,9];\r\nconst map = new Map();\r\nconst unique = [];\r\n\r\nfor (let v of arr) {\r\n    if (!map.has(v)) {\r\n        map.set(v,true);\r\n        unique.push(v)\r\n    }\r\n}\r\nconsole.log(unique);  //[2,3,5,6,8,9]\r\n```\r\n\r\n## 方式七：借助reduce + includes\r\n```js\r\n// 借助reduce + includes\r\nconst arr = [2,3,5,6,8,6,8,2,9];\r\n\r\nconst unique = arr.reduce((pre,cur) => {\r\n    return pre.includes(cur) ? pre : [...pre,cur]\r\n},[])\r\n\r\nconsole.log(unique);  // [2,3,5,6,8,9]\r\n```\r\n\r\n## 复杂数据类型的数组去重借助JSON.stringify\r\n```js\r\n// 复杂数据类型借助 JSON.stringify\r\nconst arr = [2,3,5,6,8,6,8,[7],[7],2,9];\r\nconst unique = [];\r\narr.forEach(item => {\r\n    let flag = false;\r\n    unique.forEach(item1 => {\r\n        if (JSON.stringify(item1) === JSON.stringify(item)) {\r\n            flag = true;\r\n        }\r\n    })\r\n    if (!flag) {\r\n        unique.push(item);\r\n    }\r\n})\r\nconsole.log(unique);  // [2,3,5,6,8,[7],9]\r\n```"
    },
    {
      "id": "/这一次，彻底搞懂进程与线程之间的联系",
      "metadata": {
        "permalink": "/blog/这一次，彻底搞懂进程与线程之间的联系",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/这一次，彻底搞懂进程与线程之间的联系.md",
        "source": "@site/blog\\这一次，彻底搞懂进程与线程之间的联系.md",
        "title": "这一次，彻底搞懂进程与线程之间的联系",
        "description": "什么是进程？",
        "date": "2022-03-20T00:00:00.000Z",
        "formattedDate": "2022年3月20日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 8.04,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "这一次，彻底搞懂进程与线程之间的联系",
          "date": "2022-03-20T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "关于数组去重，你知道多少种方案？",
          "permalink": "/blog/关于数组去重，你知道多少种方案？"
        },
        "nextItem": {
          "title": "这一次，一起来了解下position的盲区",
          "permalink": "/blog/这一次，一起来了解下position的盲区"
        }
      },
      "content": "## 什么是进程？\r\n> 进程是系统进行资源调度和分配的基本单位，每个进程都有自己独立的一块内存空间，在Windows系统中，一个运行的exe程序就是一个进程。\r\n\r\n## 什么是线程？\r\n> 线程是进程的子任务，是CPU调度和分配的基本单位，用于保证程序的实时性，实现进程内部的并发，线程是操作系统可以识别的最小执行和调度单位，线程之间共享同一块地址空间。\r\n\r\n## 进程和线程的区别\r\n* `根本区别`：进程是操作系统进行资源调度和分配的基本单位，而线程是CPU进行资源调度和分配的基本单位。\r\n* `从资源开销上讲：`每个进程都有自己的内存空间，进程之间切换性能开销比较大，线程与线程之间是共享代码和内存空间的，每个线程都有自己独立的运行栈和程序计数器，线程之间的开销小。\r\n* `从包含关系上讲：`一个进程可以有多个线程，线程是进程的一部分。\r\n* `从内存分配上讲：`同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的。\r\n* `从影响关系上讲：`一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都会挂掉，所以多进程程序相对多线程要更加健壮。\r\n* `从执行过程上讲：`进程可以独立执行，但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行。\r\n\r\n## 并发和并行的区别\r\n* `并发：`一个处理器同时处理多个任务。类似于两队等一个咖啡机。\r\n* `并行：`多个处理器或者多核处理器同时处理多个不同的任务，类似于两队等待两个咖啡机。\r\n\r\n## 进程之间如何进行通信？\r\n1. 消息队列\r\n\r\n> 比如A进程想要给B进程发送消息，A进程把数据放在对应的消息队列之后就可以返回了，B进程需要的时候去消息队列中读取数据即可，同理，B进程要给A进程发送消息也是如此。消息队列是保存在内核中的消息链表。\r\n\r\n2. 共享内存\r\n\r\n> 共享内存的机制就是拿出一块虚拟地址空间来，映射到相同的物理内存中，这样一个进程写入的文件，另一个进程马上就可以看到，减少了拷贝的次数，提高了进程之间通信的速度。\r\n\r\n3. Socket通信\r\n\r\n> Socket不仅可以实现跨网络和不同主机之间的进程通信，还可以在同主机上进行进程通信。\r\n\r\n## 线程之间如何进行通信？\r\n> 线程间通信的目的主要是用于线程同步，主要有以下几种机制：\r\n\r\n* 锁机制：互斥锁、读写锁等。\r\n* 信号量机制\r\n* 阻塞唤醒机制\r\n\r\n## 进程调度策略\r\n1. 先来先服务\r\n2. 最短作业优先调度\r\n3. 时间片轮转调度（给每个进程分配一个时间片，CPU轮流切换进程执行。）\r\n4. 最高优先级调度（在时间片轮转的基础上，加上了优先级，调度程既希望给每个进程轮转调度，又希望每次轮转尽可能选择高优先级的进程）\r\n\r\n## 常见问题汇总\r\n### RQ1：什么是僵尸进程？\r\n> 僵尸进程指的是子进程比父进程先结束，而父进程没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程。僵尸进程会占用系统资源，如果很多，则会严重影响服务器的性能。\r\n\r\n### RQ2：Chrome浏览器为什么采用多进程架构？\r\n> 浏览器刚被设计出来的时候，网页资源占有率比较小，因此一个进程处理多个网页是可行的，但是随着流媒体资源的丰富，网页也变得越来越复杂，把所有网页都放在一个进程在健壮性、响应速度、安全性方面都面临很多挑战，如果是多线程架构，一个网页崩溃会导致其他网页受到影响。多线程架构之间的内存共享也会带来安全问题。\r\n\r\n### RQ3：浏览器的不同tab间是线程还是进程？\r\n> 对Chrome浏览器来说不同的tab是不同的进程。\r\n\r\n### RQ4：浏览器都有哪些进程事件？\r\n1. Browser进程：浏览器的主线程，负责浏览器界面的显示与交互，各个页面的管理，创建和销毁其他进程，网络资源的管理和下载等。\r\n2. Renderer进程：也称为浏览器渲染进程或浏览器内核，其内部是多线程的，主要负责页面渲染，脚本执行，事件处理等。\r\n3. 第三方插件进程。\r\n4. GPU进程：用于3D绘制等。\r\n\r\n### RQ5：浏览器内核都有哪些线程？\r\n* GUI渲染线程\r\n* JS引擎线程\r\n* 定时触发器线程\r\n* 事件触发线程\r\n* 异步http请求线程\r\n\r\n### RQ5：浏览器处理AJAX请求和渲染页面是同一个进程吗，为什么？\r\n> 浏览器处理Ajax请求是发生在浏览器内核进程中的异步http请求线程中，GUI渲染也是在内核中，所以他们在同一个进程中，但是不是同一个线程。\r\n\r\n### RQ6：浏览器的Worker线程和主线程是如何进行通信的？\r\n1. 主线程采用new命令，调用Worker()新建一个Worker线程。Worker()构造函数的参数是一个脚本文件，该文件就是Worker线程所要执行的任务。\r\n2. 主线程调用woker.postmessage方法想worker发送消息。\r\n3. worker线程通过监听函数onmessage收到消息，处理数据然后通过postmessage进行返回。\r\n4. 主线程通过decodeWorker.onmessage监听函数，接收子线程发回来的消息。\r\n5. 等Worker完成任务后，主线程就可以把它关掉了。"
    },
    {
      "id": "/这一次，一起来了解下position的盲区",
      "metadata": {
        "permalink": "/blog/这一次，一起来了解下position的盲区",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/这一次，一起来了解下position的盲区.md",
        "source": "@site/blog\\这一次，一起来了解下position的盲区.md",
        "title": "这一次，一起来了解下position的盲区",
        "description": "为什么要了解position？",
        "date": "2022-03-19T00:00:00.000Z",
        "formattedDate": "2022年3月19日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 2.56,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "这一次，一起来了解下position的盲区",
          "date": "2022-03-19T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "这一次，彻底搞懂进程与线程之间的联系",
          "permalink": "/blog/这一次，彻底搞懂进程与线程之间的联系"
        },
        "nextItem": {
          "title": "「引用」博客的本质是电线杆子",
          "permalink": "/blog/「引用」博客的本质是电线杆子"
        }
      },
      "content": "## 为什么要了解position？\r\n> 学习这个知识之前，我们首先要知道为什么要学习这个知识点，position不仅是面试中的常考点，很多CSS布局中也是不可获取的一种方案，因此我们必须熟练掌握这个知识。\r\n\r\n## Position有哪些属性？\r\n### 1. 静态定位static\r\n> 静态定位指的是目标元素使用正常的布局，也就是按照元素在文档流中的默认位置进行排列布局，此时设置top、right、bottom、left和z-index属性是无效的。\r\n\r\n### 2. 相对定位relative\r\n> 相对定位是相对元素未添加定位时的位置进行移动，因此会在未添加定位的时候所在的位置留下空白。\r\n\r\n### 3. 绝对定位absolute\r\n> 绝对定位首先会脱离标准文档流，并且不会为元素预留空间，绝对定位相对的是最近的非静态定位的祖先元素来进行偏移。\r\n\r\n### 4. 固定定位fixed\r\n> 固定定位会脱离标准文档流，并且不会未元素预留空间，固定定位相对的是屏幕视口来进行偏移的，元素的位置在屏幕滚动的时候不会发生变化。\r\n\r\n### 5. 粘性定位sticky\r\n> 粘性定位是相对定位和固定定位的混合，元素在跨越特定阈值之前为相对定位，之后为固定定位，这个阈值是根据视口滚动来进行判断的。粘性定位并不脱离标准文档流。\r\n\r\n## Postiton都有哪些应用场景？\r\n1. 标准文档流就是静态定位的例子。\r\n2. 绝对定位和相对定位最经典的例子就是子绝父相布局。\r\n3. 例如掘进论坛文章的点赞按钮，固定在窗口的某个位置，不随滚动而滚动。\r\n4. 粘性定位的经典例子是头部固定。\r\n\r\n## 哪些定位会脱离标准文档流？\r\n1. 绝对定位\r\n2. 固定定位"
    },
    {
      "id": "/「引用」博客的本质是电线杆子",
      "metadata": {
        "permalink": "/blog/「引用」博客的本质是电线杆子",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/「引用」博客的本质是电线杆子.md",
        "source": "@site/blog\\「引用」博客的本质是电线杆子.md",
        "title": "「引用」博客的本质是电线杆子",
        "description": "记录博客日常的访问数据",
        "date": "2022-03-18T00:00:00.000Z",
        "formattedDate": "2022年3月18日",
        "tags": [
          {
            "label": "博客",
            "permalink": "/blog/tags/博客"
          }
        ],
        "readingTime": 2.725,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Faith&Passion",
            "title": "有些鱼是关不住的，因为他们属于天空。",
            "url": "https://jpy.wiki/",
            "imageURL": "https://www.7wate.com/logo.png",
            "key": "Justin"
          }
        ],
        "frontMatter": {
          "title": "「引用」博客的本质是电线杆子",
          "description": "记录博客日常的访问数据",
          "keywords": [
            "博客访问统计"
          ],
          "tags": [
            "博客"
          ],
          "authors": [
            "Justin"
          ],
          "date": "2022-03-18T00:00:00.000Z"
        },
        "prevItem": {
          "title": "这一次，一起来了解下position的盲区",
          "permalink": "/blog/这一次，一起来了解下position的盲区"
        },
        "nextItem": {
          "title": "单页面应用的前端路由原理是什么？",
          "permalink": "/blog/单页面应用的前端路由原理是什么？"
        }
      },
      "content": "也是看到友博的文章《正经人谁写博客》，然后翻阅了一下近两个月来的博客流量访问数据。今年年初也是被纳入了几个订阅合集，分享讨论一下关于个人博客流量。\r\n\r\n目前主要维护的网站有三个，分别是站点首页、个人博客、知识维基。其中两个网站做了流量统计，实际看来还是较惨的……\r\n\r\n经常来逛的老朋友可能没有关注过站点首页，顶级域名是做了一个站点导航，博客则是二级域名。\r\n\r\n## 首页\r\n\r\n![趋势分析](https://static.7wate.com/img/2022/03/18/3483539320860.png)\r\n\r\n![来源分类](https://static.7wate.com/img/2022/03/18/af4f401b9462a.png)\r\n\r\n![地区](https://static.7wate.com/img/2022/03/18/67c3bda2b26f1.png)\r\n\r\n站点首页的数据及其惨淡，可以说无人问津……\r\n\r\n大多可能是自己或者老朋友，大学同学来逛的比较多。\r\n\r\n说来也是有趣，很多友博可能想不明白为什么我的顶级域名是 7wate.com，说来话长。因为大学同学说我脑子瓦特掉了，然后 wate.com 这个域名又被注册了，然后选一个幸运数 7，主域名就这样来了 ~\r\n\r\n## 博客\r\n\r\n![趋势分析](https://static.7wate.com/img/2022/03/18/995ca4435a8ff.png)\r\n\r\n![来访域名](https://static.7wate.com/img/2022/03/18/778177571481f.png)\r\n\r\n![地区](https://static.7wate.com/img/2022/03/18/a52f0f76e0b35.png)\r\n\r\n![终端](https://static.7wate.com/img/2022/03/18/3f571029be7fc.png)\r\n\r\n![移动端](https://static.7wate.com/img/2022/03/18/4ae02e5ac5469.png)\r\n\r\n![搜索引擎](https://static.7wate.com/img/2022/03/18/a1cb22948c59b.png)\r\n\r\n总的趋势来说，主要流量来源于今年加入了一些订阅合集，剩下的就归功于友博了哈哈，蹭着你的每日金句也是掌握了流量密码哈哈 ~\r\n\r\n从来访地区来看，北上广深杭这些一线城市最多。\r\n\r\n桌面端的话，MS 还是老大，零零散散还有些许 Linux。话说我也想尝试换成 Linux 工作，MS 真得是槽点满满！\r\n\r\n移动端还是 iphone 居多，紧接着是华为和小米，跟手机销量排行基本相同。\r\n\r\n百度现在基本可以正确检索了，完全 ok，所以目前是不再打算做访客信息统计了。\r\n\r\n最后引用友博的标题《[博客的本质是电线杆子，所以难免会遇到乱尿的](https://onojyun.com/2022/03/18/2908/)》，欢迎大家来”尿“\r\n\r\n哈哈哈哈哈哈哈哈哈哈哈哈"
    },
    {
      "id": "/单页面应用的前端路由原理是什么？",
      "metadata": {
        "permalink": "/blog/单页面应用的前端路由原理是什么？",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/单页面应用的前端路由原理是什么？.md",
        "source": "@site/blog\\单页面应用的前端路由原理是什么？.md",
        "title": "单页面应用的前端路由原理是什么？",
        "description": "前置知识",
        "date": "2022-03-13T00:00:00.000Z",
        "formattedDate": "2022年3月13日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 5.09,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "单页面应用的前端路由原理是什么？",
          "date": "2022-03-13T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "「引用」博客的本质是电线杆子",
          "permalink": "/blog/「引用」博客的本质是电线杆子"
        },
        "nextItem": {
          "title": "Vue和React的区别到底是什么？",
          "permalink": "/blog/Vue和React的区别到底是什么？"
        }
      },
      "content": "## 前置知识\r\n> 在了解单页面应用的前端路由原理之前，我们先了解下什么事单页面应用，什么是多页面应用，他们之间的区别又是什么？\r\n\r\n### 什么是单页面应用？\r\n> 单页面应用指的是第一次进入页面的时候会请求一个html文件，切换到其他组件的时候，虽然路径会发生相应的变化，但是没有新的html文件请求，原理是JS会感知到url的变化，然后js会动态的将当前页面的内容清除掉，然后将下一个页面的内容挂载到当前的页面上，这个时候的路由不是由后端做的而是由前端来做的，来判断页面到底显示哪个组件，这个过程就是单页面的应用。\r\n\r\n### 单页面应用的优缺点\r\n> 优点：页面切换快：因为页面每次切换的时候，并不需要做html文件的请求，这样就减少了很多http发送的时延。\r\n\r\n> 缺点：单页面应用的首屏加载时间比较慢，首屏加载需要一次HTML请求和一次JS请求，时间相对较慢，而且SEO效果差，因为搜索引擎只认识HTML中的内容，但是单页应用中的内容很多需要靠JS渲染出来，搜索引擎不识别这部分内容，就会导致SEO效果不好。\r\n\r\n### 什么是多页面应用？\r\n> 多页面应用指的是每一次页面跳转的时候，服务器都会返回一个新的HTML文档，这种类型的应用叫做多页应用。\r\n\r\n### 多页面应用的优缺点\r\n> 优点：首屏加载快，SEO效果好。因为客户端向服务端发送请求的时候，服务端只返回了一个HTML页面，所以加载比较快。\r\n\r\n> 缺点：页面切花比较慢。\r\n\r\n### 单页面应用和多页面应用的区别\r\n1. 应用构成不同\r\n\r\n> 多页面应用是由多个不同的页面构成，单页面应用是一个外壳页面和多个页面片段构成。\r\n\r\n2. 页面跳转方式不同\r\n\r\n> 多页面应用的页面跳转是从一个页面跳转到另一个页面，而单页面则是把一个页面片段删除或隐藏，加载另一个页面片段。\r\n\r\n3. 跳转后公共资源是否重新加载\r\n\r\n> 跳转后多页面应用是需要进行重新加载的，但是单页面不需要重新加载。\r\n\r\n4. 用户体验不同\r\n\r\n> 多页面应用首屏加载快但是且缓慢，单页面应用首屏加载慢但是切换快。\r\n\r\n5. 页面传递数据方式不同\r\n\r\n> 多页面应用依靠URL、Cookie、LocalStorage来传递数据，单页面应用则是靠组件进行通信，相对更加简单。\r\n\r\n## 前端路由的原理\r\n> `前端路由的原理本质上就是在不刷新浏览器的请求下修改URL、检测URL的变化，截获URL的地址，通过解析、匹配路由规则从而实现UI的更新。`路由的实现通常有两种形式一种是Hash模式，一种是History模式。\r\n\r\n### Hash路由的原理\r\n> 在Hash模式下，url中#后面的部分表示的是一个客户端状态，当这部分发生变化的时候，浏览器本身就不会刷新，这样就满足了第一个条件，即在不刷新浏览器的情况下修改浏览器链接，同时通过监听hashChange事件来监听URL中hash值的变化，触发相关函数，改变相关组件。\r\n\r\n### History路由的原理\r\n> History模式利用了HTML5中history的API,history.pushState和history.replaceState这两个方法可以在不刷新页面的情况下，操作浏览器的历史记录，这样也就满足了第一个条件，然后通过监听popState事件来剪影URL的变化，从而触发相关函数，改变相关组件。"
    },
    {
      "id": "/Vue和React的区别到底是什么？",
      "metadata": {
        "permalink": "/blog/Vue和React的区别到底是什么？",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Vue和React的区别到底是什么？.md",
        "source": "@site/blog\\Vue和React的区别到底是什么？.md",
        "title": "Vue和React的区别到底是什么？",
        "description": "一提到前端框架，相信大家都对Vue和React不陌生，这两个前端框架都是比较主流的，用户也都比较多，但是我们在使用这些框架的时候，是否对这两个框架之间的区别有所了解呢？接下来，让我们来一起的系统梳理这两个框架的区别是什么吧~",
        "date": "2022-03-10T00:00:00.000Z",
        "formattedDate": "2022年3月10日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 10.005,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Vue和React的区别到底是什么？",
          "date": "2022-03-10T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "单页面应用的前端路由原理是什么？",
          "permalink": "/blog/单页面应用的前端路由原理是什么？"
        },
        "nextItem": {
          "title": "请这样回答双向数据绑定原理",
          "permalink": "/blog/请这样回答双向数据绑定原理"
        }
      },
      "content": "> 一提到前端框架，相信大家都对Vue和React不陌生，这两个前端框架都是比较主流的，用户也都比较多，但是我们在使用这些框架的时候，是否对这两个框架之间的区别有所了解呢？接下来，让我们来一起的系统梳理这两个框架的区别是什么吧~\r\n\r\n## 预备知识介绍\r\n> 在了解Vue和React的区别之前，我们首先来了解一下MVC和MVVM架构，这个知识点有助于我们对后续知识的了解。\r\n\r\n### MVC架构\r\n> 首先MVC指的是Model-View-Controller，分别代表着模型层、视图层、控制器。\r\n\r\n> Model（模型层），主要管理的是业务模型的数据和处理数据的逻辑。\r\n\r\n> View（视图层）主要是接收用户的交互请求并展示数据信息给用户。\r\n\r\n> Controller（控制器层）主要担任的是Model和View之间的桥梁，用于控制程序的流程。Controller负责确保View可以访问到需要显示的Model对象的数据，View接收到用户的交互请求之后，会将请求转发给控制器，控制器解析请求之后，会交给对应的Model处理。\r\n\r\n### MVVM架构\r\n> MVVM架构指的是Model-View-ViewModel，我们可以看到MVVM架构和MVC架构的区别在于有一个ViewModel部分，首先我们要知道在已经有了MVC架构的时候，为什么还要衍生出MVVM架构，这是因为View中很多控件的数据类型和Model中的属性不相同，例如Model中的时间数据可能是一串数字，View想要展示成日期的格式，这就需要一种转化，这个转换如果放在View不合适，因为View中不应该出现逻辑代码，放在Model中也不合适，这回导致Model臃肿庞大，因为这种问题的存在诞生了ViewModel，这一层可以帮助View转化为相应的数据给Model或者从Model中转化成View可以显示的内容。\r\n\r\n## Vue和React的区别是什么？\r\n### 一、核心思想不同\r\n> Vue的核心思想是尽可能的降低前端开发的门槛，是一个灵活易用的渐进式双向绑定的MVVM框架。\r\n\r\n> React的核心思想是声明式渲染和组件化、单向数据流，React既不属于MVC也不属于MVVM架构。\r\n\r\n* RQ1：声明式是什么意思？\r\n\r\n> 声明式与之相对应的是命令式，命令式指的是通过DOM操作一步步把网页变成想要的样子，而声明式则是只需要通过状态去形容最后的网页长什么样子即可。\r\n\r\n* RQ2：组件化是什么意思？\r\n\r\n> 组件化指的是尽可能的将页面拆分成一个个较小的、可以复用的组件，这样让我们的代码更加方便组织和管理，并且拓展性页更强。\r\n\r\n* RQ3：如何理解React的单向数据流？\r\n\r\n> React的单向数据流指的是数据主要从父节点通过props传递到子节点，如果顶层某个props改变了，React会重新渲染所有的子节点，但是单向数据流并非单向绑定，React想要从一个组件去更新另一个组件的状态，需要进行状态提升，即将状态提升到他们最近的祖先组件中，触发父组件的状态变更，从而影响另一个组件的显示。单向数据流的好处是能够保证状态改变的可追溯性，假如，父组件维护了一个状态，子组件如果能够随意更改父组件的状态，那么各组件的状态改变就会变得难以追溯。\r\n\r\n## 二、组件写法上不同\r\n> Vue的组件写法是通过template的单文件组件格式。\r\n\r\n> React的组件写法是JSX+inline style，也就是吧HTML和CSS全部写进JavaScript中。\r\n\r\n## 三、Diff算法不同\r\n### Diff算法前置知识：虚拟DOM\r\n> 在了解Diff算法之前，我们首先要知道什么是虚拟DOM，`虚拟DOM是一个用来描述真实DOM的对象，本质是对象。`\r\n\r\n### 什么是Diff算法?\r\n> Diff算法是一种对比算法，主要是对比旧的虚拟DOM和新的虚拟DOM，找出发生更改的节点，并只更新这些接地那，而不更新未发生变化的节点，从而准确的更新DOM，减少操作真实DOM的次数，提高性能。\r\n\r\n### Diff算法是深度优先还是广度优先？时间复杂度是多少？\r\n> Diff算法是深度优先算法，时间复杂度是O(n)。\r\n\r\n### Vue的Diff算法\r\n> 下面是Vue的diff算法的主要流程：\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/7c612bffc0ee060183b44547e0ddae2d.png)\r\n\r\n1. 当数据发生变化的时候，会触发setter，然后通过Dep类的notify方法去通知所有的订阅者Watcher，订阅者会调用patch方法。\r\n2. patch方法会通过sameVnode方法来判断当前同层的虚拟节点是否是同一种类型的节点，如果是则调用patchVnode方法，不是则直接替换成新的节点。\r\n3. 如果是同一类型的节点，patchVnode会首先找到节点对应的真实DOM，然后判断新旧节点是否是指向的同一个对象，如果是则直接return。如果不是则判断文本节点是否相等，不相等则将真实DOM的文本节点改为新节点的文本内容，然后看旧节点和新节点的子节点的关系，如果旧的有新的没有，则删除真实DOM的子节点，如果信有旧没有，则将虚拟节点真实化之后，添加上去，如果二者都有子节点则执行updateChildren函数比较子节点。\r\n4. updateChildren方法的核心对比思路就是通过首尾指针的方法进行对比。\r\n\r\n* RQ：为什么不建议使用index作为节点的key？\r\n\r\n> 假如我们在一组节点的首部添加了一个新节点，使用index作为key，diff算法通过key判断是相同类型的节点之后，会进行进一步的比较，把其内容进行更改，这样就会造成这一组的节点都被更新了，最后一个节点还被当做新节点创建了，这样会造成很大的性能浪费，因此不建议使用index作为key。\r\n\r\n### React的diff和Vue的diff算法的不同之处\r\n> vue和react的diff算法都是进行同层次的比较，主要有以下两点不同：\r\n\r\n1. vue对比节点，如果节点元素类型相同，但是className不同，认为是不同类型的元素，会进行删除重建，但是react则会认为是同类型的节点，只会修改节点属性。\r\n2. vue的列表比对采用的是首尾指针法，而react采用的是从左到右依次比对的方式，当一个集合只是把最后一个节点移动到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移动到最后一个，从这点上来说vue的对比方式更加高效。\r\n\r\n## 四、响应式原理不同\r\n### React的响应式原理\r\n> React主要是通过setState()方法来更新状态，状态更新之后，组件也会重新渲染。\r\n\r\n### Vue的响应式原理\r\n> vue会遍历data数据对象，使用Object.definedProperty()将每个属性都转换为getter和setter，每个Vue组件实例都有一个对应的watcher实例，在组件初次渲染的时候会记录组件用到了那些数据，当数据发生改变的时候，会触发setter方法，并通知所有依赖这个数据的watcher实例调用update方法去触发组件的compile渲染方法，进行渲染数据。"
    },
    {
      "id": "/请这样回答双向数据绑定原理",
      "metadata": {
        "permalink": "/blog/请这样回答双向数据绑定原理",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/请这样回答双向数据绑定原理.md",
        "source": "@site/blog\\请这样回答双向数据绑定原理.md",
        "title": "请这样回答双向数据绑定原理",
        "description": "前言",
        "date": "2022-03-07T00:00:00.000Z",
        "formattedDate": "2022年3月7日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 3.47,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "请这样回答双向数据绑定原理",
          "date": "2022-03-07T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "Vue和React的区别到底是什么？",
          "permalink": "/blog/Vue和React的区别到底是什么？"
        },
        "nextItem": {
          "title": "实现Sleep函数的四种方法",
          "permalink": "/blog/实现Sleep函数的四种方法"
        }
      },
      "content": "## 前言\r\n> 双向数据绑定是Vue的重要原理，也是面试过程中几乎必问的一道题目，搞懂这个原理无论是对我们的技术提高还是对面试都是有百利而无一害的，下面就让我们一起来解决这个问题吧~\r\n\r\n## 双向数据绑定每一个模块都负责什么?\r\n\r\n### new Vue\r\n> new Vue这个操作主要是调用了数据劫持Observe方法和模板编译的函数Compile。\r\n\r\n### Observe函数\r\n> Observer函数将递归遍历传入对象的所有property，并使用Object.defineProperty把这些property全部转化为getter/setter。一旦监听的属性发生变化的时候变通知Dep类。\r\n\r\n### Dep类\r\n> Dep类负责收集每个watcher，并当Observe监听到属性变化时通知收集到的每一个watcher。\r\n\r\n### Watcher类\r\n> Watcher是Observe和Compile之间的桥梁，watcher会在自身实例化的时候向dep类上添加自身，并提供一个update方法，一旦属性发生变化时，dep类会通过这个方法来触发Compile中的回调函数进行渲染数据。\r\n\r\n### Compile函数\r\n> Compile函数的主要工作是将模板中的变量替换成数据，然后渲染页面视图，并给每个节点绑定更新函数，创建订阅者，一旦数据有变化，收到通知就更新视图，因为遍历的时候会多次操作DOM，为了提高效率会将根节点转换成文档碎片fragment进行离线DOM操作，解析完成之后再将fragment添加到真实的DOM中。\r\n\r\n## 双向数据绑定原理流程图\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/cb469a015904fa75a751daa1767d3467.png)\r\n\r\n## Vue2和Vue3响应式原理的不同之处\r\n1. Vue2使用的是Object.defineProperty()实现响应式原理，而Vue3使用的是Proxy()实现。\r\n2. 在面对对象嵌套的时候，Vue2和Vue3都需要进行递归，但是Vue2是对所有属性进行递归，而Vue3则是按需递归，如果没有使用到内部对象的属性，就不要递归，性能更好。\r\n3. Vue2中对象不存在的属性是不能被拦截的，但是Vue3可以。\r\n\r\n## Vue3为什么弃用了ObjectdefineProperty选择了Proxy\r\n1. Object.defineProperty无法监控到数组下标的变化，导致通过数组数组下标添加元素不能实时响应。\r\n2. Proxy不仅可以代理对象，还可以代理数组，还可以代理动态增加的属性。\r\n3. Object.defineProperty不能对ES6新产生的Map、Set这样的数据结构进行监听。\r\n\r\n## 总结\r\n> 在回答关于双向数据绑定的问题的时候，可以结合上面的流程图，对每一个节点主要的工作进行介绍，并把流程讲清楚即可。"
    },
    {
      "id": "/实现Sleep函数的四种方法",
      "metadata": {
        "permalink": "/blog/实现Sleep函数的四种方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/实现Sleep函数的四种方法.md",
        "source": "@site/blog\\实现Sleep函数的四种方法.md",
        "title": "实现Sleep函数的四种方法",
        "description": "实现sleep函数，是一道考察候选人JS基本功的考题，让我们来一起探索这道题目吧~",
        "date": "2022-03-05T00:00:00.000Z",
        "formattedDate": "2022年3月5日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 1.755,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "实现Sleep函数的四种方法",
          "date": "2022-03-05T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "请这样回答双向数据绑定原理",
          "permalink": "/blog/请这样回答双向数据绑定原理"
        },
        "nextItem": {
          "title": "LeetCode——岛屿数量（DFS）",
          "permalink": "/blog/LeetCode——岛屿数量（DFS）"
        }
      },
      "content": "> 实现sleep函数，是一道考察候选人JS基本功的考题，让我们来一起探索这道题目吧~\r\n\r\n## 方式一：使用Promise + then\r\n> 在Promise中通过setTimout来设置定时器，通过then来执行回调。\r\n\r\n```js\r\n// 使用Promise实现sleep\r\n\r\nconst sleep = time => {\r\n  return new Promise(resolve => {\r\n    setTimeout(resolve,time)\r\n  })\r\n}\r\n\r\nvar start = new Date().getTime();\r\nsleep(2000).then(() => {\r\n  console.log(1);\r\n  var end = new Date().getTime();       \r\n  console.log(end-start+'ms');  // 2004ms\r\n})\r\n```\r\n\r\n## 方式二：使用生成器函数 + then\r\n> 通过生成器函数的yield关键字返回一个Promise，然后通过next().value.then进行调用。\r\n\r\n```js\r\nfunction* sleep(time) {\r\n  yield new Promise(resolve => {\r\n    setTimeout(resolve, time)\r\n  })\r\n}\r\n\r\nvar start = new Date().getTime();\r\nsleep(2000).next().value.then(() => {\r\n  console.log(1);\r\n  var end = new Date().getTime();\r\n  console.log(end - start + 'ms');  // 2003ms\r\n})\r\n```\r\n\r\n## 方式三：使用async + await\r\n> async + await的方式可以实现异步阻塞任务。\r\n\r\n```js\r\nfunction sleep(time) {\r\n  return new Promise(resolve => {\r\n    setTimeout(resolve, time)\r\n  })\r\n}\r\n\r\nvar start = new Date().getTime();\r\nasync function output() {\r\n  await sleep(2000);\r\n  var end = new Date().getTime();\r\n  console.log(end - start + 'ms');  // 2002ms\r\n}\r\noutput()\r\n```\r\n\r\n## 方式四：直接通过setTimeout实现\r\n```js\r\nfunction sleep(callback,time) {\r\n  setTimeout(callback,time);\r\n}\r\nconst start = new Date().getTime();\r\n\r\nfunction output() {\r\n  console.log(111);\r\n  const end = new Date().getTime();\r\n  console.log(`${end - start} ms`); // 2006 ms\r\n}\r\n\r\nsleep(output,2000)\r\n```\r\n\r\n## RQ：为什么定时器执行后存在时间误差？\r\n> 因为setTimeout属于宏任务，在执行宏任务之前如何当前执行栈中在执行的任务超过了定时器设定的时间，是可能存在误差的。"
    },
    {
      "id": "/LeetCode——岛屿数量（DFS）",
      "metadata": {
        "permalink": "/blog/LeetCode——岛屿数量（DFS）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——岛屿数量（DFS）.md",
        "source": "@site/blog\\LeetCode——岛屿数量（DFS）.md",
        "title": "LeetCode——岛屿数量（DFS）",
        "description": "题目描述",
        "date": "2022-03-04T00:00:00.000Z",
        "formattedDate": "2022年3月4日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 2.375,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——岛屿数量（DFS）",
          "date": "2022-03-04T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "实现Sleep函数的四种方法",
          "permalink": "/blog/实现Sleep函数的四种方法"
        },
        "nextItem": {
          "title": "LeetCode——买卖股票的最佳时机 II（动态规划）",
          "permalink": "/blog/LeetCode——买卖股票的时机 II（动态规划）"
        }
      },
      "content": "## 题目描述\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/a726ee4df10e19159569f0634527849c.png)\r\n\r\n## 解题思路\r\n> 岛屿数量是一道经典的DFS问题，要想解决这个问题，首先要搞明白下面的几个问题：\r\n\r\n### RQ1：怎么判断是一个岛屿？\r\n> 并不是有1的地方就是一个岛屿，一个孤立的岛屿其上下左右都是没有1的，这样的岛屿才能算作一个岛屿，这也就是为什么第一个例子中那么多个1才是一个岛屿的原因，请看下面的例子，这个图中有三个岛屿：\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/39256399ebe0f02290621118e2cb6a91.png)\r\n\r\n### RQ2：DFS如何解决岛屿的数量问题？\r\n> 第二个问题也就是我们解题的核心，核心思路就一句话`假如当前遍历的元素的值是1，就将岛屿数量加1,同时将其上下左右的1都变为0，然后继续循环。`\r\n\r\n## 解题代码\r\n```js\r\nvar numIslands = function (grid) {\r\n    // 岛屿的数量是一道经典的DFS问题\r\n    let row = grid.length;\r\n    let column = grid[0].length;\r\n    let count = 0;\r\n    for (let i = 0; i < row; i++) {\r\n        for (let j = 0; j < column; j++) {\r\n            if (grid[i][j] === '1') {\r\n                count++;\r\n                dfs(i,j,grid);\r\n            }\r\n        }\r\n    }\r\n    return count;\r\n    function dfs(i,j,grid) {\r\n        if (i < 0 || i >= row || j < 0 || j >= column || grid[i][j] === '0') {\r\n            return;\r\n        }\r\n        grid[i][j] = '0';\r\n        dfs(i+1,j,grid);\r\n        dfs(i,j+1,grid);\r\n        dfs(i-1,j,grid);\r\n        dfs(i,j-1,grid);\r\n    }\r\n\r\n};\r\n```\r\n\r\n## 同类对比\r\n> 岛屿的数量和[岛屿的最大面积](https://juejin.cn/post/7032058260186202125)可谓是双胞胎的题目，两者都可以通过DFS进行解决，而且整个代码的结构都高度类似，区别在于岛屿的数量进入DFS函数后是将上下左右的值变为0，而岛屿的最大面积的核心是将上下左右的1加一起然后返回计算最大值。因此，在无论是在工作的时候，还是在刷题的时候，我们都要将同一类的题目进行归纳总结。"
    },
    {
      "id": "/LeetCode——买卖股票的时机 II（动态规划）",
      "metadata": {
        "permalink": "/blog/LeetCode——买卖股票的时机 II（动态规划）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——买卖股票的时机 II（动态规划）.md",
        "source": "@site/blog\\LeetCode——买卖股票的时机 II（动态规划）.md",
        "title": "LeetCode——买卖股票的最佳时机 II（动态规划）",
        "description": "介绍",
        "date": "2022-03-01T00:00:00.000Z",
        "formattedDate": "2022年3月1日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 3.04,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——买卖股票的最佳时机 II（动态规划）",
          "date": "2022-03-01T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "LeetCode——岛屿数量（DFS）",
          "permalink": "/blog/LeetCode——岛屿数量（DFS）"
        },
        "nextItem": {
          "title": "这一次，彻底搞懂HTML5新特性",
          "permalink": "/blog/这一次，彻底搞懂HTML5新特性"
        }
      },
      "content": "## 介绍\r\n> 买卖股票的最佳时机是一道高频考题，这个题目已经衍生出多个版本，其中尤其是买卖股票的最佳时机I和II是面试中的高频考题，让我们来一起看看该如何解决这类问题吧~\r\n\r\n## 题目描述\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/44c4d22c58b00e1a479cd27142aa2c2e.png)\r\n\r\n## 解题思路\r\n> 无论是买卖股票的最佳时机I还是II，动态规划都是解决的好方法，动态规划最重要的就是理解动态方程的含义是什么，下面对动态规划的核心进行介绍：\r\n\r\n* dp[i][0]：表示的是第i天，手上没有股票获取的最大收益，也就是说赚的钱数。\r\n* dp[i][1]：表示的是第i天，手上有股票获取的最大收益。\r\n* dp[i][0]的可能性：\r\n    * 第i-1天手里也没有股票：dp[i-1][0]\r\n    * 第i-1天手里有股票，但是今天卖了：dp[i-1][1] + prices[i]\r\n    \r\n* dp[i][1]的可能性：\r\n    * 前一天也有股票，并保持到今天：dp[i-1][1]\r\n    * 前一天没有股票，今天买入了：dp[i-1][0] - prices[i]\r\n    \r\n> 动态规划到最后一天，是持有股票还是手上没有股票的收益大？\r\n\r\n> `手上没有股票的收益大，因为最后一天持有股票说明还没有变现。`\r\n\r\n## AC代码实现\r\n\r\n```js\r\nvar maxProfit = function(prices) {\r\n  // 动态规划是解决买卖股票的最佳时机的核心技巧\r\n  // 首先构造一个二维数组dp\r\n  const dp = new Array(prices.length).fill([0,0]);\r\n\r\n  // 初始化\r\n  dp[0][0] = 0;\r\n  dp[0][1] = -prices[0];\r\n\r\n  // 处理一般情况\r\n  for (let i = 1; i < dp.length; i++) {\r\n    dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1] + prices[i]);\r\n    dp[i][1] = Math.max(dp[i-1][0] - prices[i],dp[i-1][1]);\r\n  }\r\n\r\n  return dp[prices.length-1][0];\r\n};\r\n```\r\n\r\n> 构造二维数组的时候，fill中传入的是一个[0,0]。\r\n\r\n## 买卖股票的最佳时机I和买卖股票的最佳时机II的区别在哪里？\r\n> 核心的区别就在于下面这行代码上：\r\n\r\n> 买卖股票的最佳时机I\r\n\r\n```js\r\ndp[i][1] = Math.max(- prices[i], dp[i - 1][1]);\r\n```\r\n\r\n> 买卖股票的最佳时机II\r\n```js\r\ndp[i][1] = Math.max(dp[i-1][0] - prices[i],dp[i-1][1]);\r\n```\r\n\r\n> 这说明什么呢？买卖股票的最佳时机如果今天买入，意味着前面不能有买卖操作，也就是说只能买卖一次，但是买卖股票的最佳时机II则可以多次买入，卖出。\r\n\r\n## 总结\r\n> 在遇到同一类题目时，一定要对比题目之间的异同点，进行对比记忆。"
    },
    {
      "id": "/这一次，彻底搞懂HTML5新特性",
      "metadata": {
        "permalink": "/blog/这一次，彻底搞懂HTML5新特性",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/这一次，彻底搞懂HTML5新特性.md",
        "source": "@site/blog\\这一次，彻底搞懂HTML5新特性.md",
        "title": "这一次，彻底搞懂HTML5新特性",
        "description": "前言",
        "date": "2022-02-28T00:00:00.000Z",
        "formattedDate": "2022年2月28日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 3.865,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "这一次，彻底搞懂HTML5新特性",
          "date": "2022-02-28T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "LeetCode——买卖股票的最佳时机 II（动态规划）",
          "permalink": "/blog/LeetCode——买卖股票的时机 II（动态规划）"
        },
        "nextItem": {
          "title": "这一次，彻底搞懂原型与原型链",
          "permalink": "/blog/这一次，彻底搞懂原型与原型链"
        }
      },
      "content": "## 前言\r\n> HTML5已经被提出多年，关于HTML5到底带来了哪些新特性？和之前的HTML版本有什么区别？这经常是面试官考到的题目，下面让我们来深刻的总结这个问题吧~\r\n\r\n## HTML新特性\r\n### 1：语义化标签\r\n> 通过语义化标签，可以让页面有更加完善的结构，让页面的元素有含义，同时利于被搜索引擎解析，有利于SEO，主要标签包括下面的标签：\r\n\r\n| 标签 | 描述 |\r\n| --- | --- |\r\n| header | 表示文档的头部区域 |\r\n| footer | 表示文档的尾部区域 |\r\n| nav | 表示文档导航部分 |\r\n| section | 表示文档的某一节 |\r\n| article | 表示文章 |\r\n| main | 表示文档主要的内容区域 |\r\n\r\n### 2：增强型表单\r\n> 例如可以通过input的type属性指定类型是number还是date或者url，同时还添加了placeholder和required等表单属性。\r\n\r\n### 3. 媒体元素\r\n> 新增了audio和video两个媒体相关的标签，可以让开发人员不必以来任何插件就能在网页中嵌入浏览器的音频和视频内容。\r\n\r\n### 4. canvas绘图\r\n> canvas绘图指的是在页面中设定一个区域，然后通过JS动态的在这个区域绘制图形。\r\n\r\n### 5. svg绘图\r\n> 这一部分不详细展开，想要了解的小伙伴可以参考其他文章~\r\n\r\n### 6. 地理定位\r\n> 使用getCurrentPosition()方法来获取用户的位置，从而实现队地理位置的定位。\r\n\r\n### 7. 拖放API\r\n> 通过给标签元素设置属性draggable值为true，能够实现对目标元素的拖动。\r\n\r\n### 8. Web Worker\r\n> Web Worker通过加载一个脚本文件，进而创建一个独立工作的线程，在主线程之外运行，worker线程运行结束之后会把结果返回给主线程，worker线程可以处理一些计算密集型的任务，这样主线程就会变得相对轻松，这并不是说JS具备了多线程的能力，而实浏览器作为宿主环境提供了一个JS多线程运行的环境。\r\n\r\n### 9. Web Storage\r\n> 关于Web Storage部分，大家需要重点掌握的是cookie、Localstorage和SessionStorage三者之间的区别：\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/5ff77340963295f7eda03878b42f1aec.png)\r\n\r\n### 10. Websocket\r\n> 关于websocket协议，大家主要需要记住的就是websocket和HTTP的区别。\r\n\r\n* 相同点\r\n\r\n> HTTP和Websocket都是基于TCP的应用层协议。\r\n\r\n* 不同点\r\n\r\n> websocket是双向通信协议，模拟socket协议，可以双向发送和接受消息，HTTP是单向的，意思是说通信只能由客户端发起。\r\n> websocket是需要浏览器和服务器通过握手建立连接，但是HTTP是浏览器向服务器发送连接，服务器预先不知道这个连接。\r\n\r\n* 联系\r\n\r\n> websocket建立握手时需要基于HTTP进行传输，建立连接之后呢便不再需要HTTP协议了。\r\n\r\n## 总结\r\n> 关于HTML5的新特性，希望大家能从以上十个点来进行系统性的回答。"
    },
    {
      "id": "/这一次，彻底搞懂原型与原型链",
      "metadata": {
        "permalink": "/blog/这一次，彻底搞懂原型与原型链",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/这一次，彻底搞懂原型与原型链.md",
        "source": "@site/blog\\这一次，彻底搞懂原型与原型链.md",
        "title": "这一次，彻底搞懂原型与原型链",
        "description": "为什么要学习原型与原型链？",
        "date": "2022-02-28T00:00:00.000Z",
        "formattedDate": "2022年2月28日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 3.42,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "这一次，彻底搞懂原型与原型链",
          "date": "2022-02-28T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "这一次，彻底搞懂HTML5新特性",
          "permalink": "/blog/这一次，彻底搞懂HTML5新特性"
        },
        "nextItem": {
          "title": "这一次，彻底搞懂this指向问题",
          "permalink": "/blog/这一次，彻底搞懂this指向问题"
        }
      },
      "content": "## 为什么要学习原型与原型链？\r\n> 原型与原型链是面试中的重点考察方向，也是JS基础的重中之重，因此这是我们前进路上必须要攻克的堡垒，接下来让我们来一起系统的梳理原型与原型链吧~\r\n\r\n## 原型与原型链的三个关键概念\r\n> 原型与原型链的三个关键概念分别是：\\_\\_proto\\_\\_、prototype、constructor。\r\n\r\n## 1. \\_\\_proto\\_\\_（隐式原型）\r\n> 首先我们要明确的是proto指向的是谁？指向的是父类构造函数的原型对象，proto通常称为隐式原型，prorotype则是显式原型，我们可以说`一个对象的隐式原型指向了该对象的构造函数的显式原型。`,在显式原型上定义的属性和方法，通过隐式原型传递给了构造函数的实例，这样一来实例就能很容易的访问到构造函数原型上的方法和属性了。\r\n\r\n> 关于proto的知识中有一个特别需要注意的问题：\r\n\r\n#### RQ1：原型对象prototype本质是什么？其本质是一个object，那么其隐式原型指的就是其构造函数的原型对象也就是Object.prototype。\r\n\r\n#### RQ2：构造函数的隐式原型是什么？\r\n> 构造函数的本质是一个函数，因此其构造函数的显示原型是Function.prototype。\r\n\r\n> 要想更好的解决上面的两个问题，最终要的是看懂下面的这个图，这个图包含了很多易错的点：\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cffc5fbf30a4f2d897e11e8edb0983e~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 2. prototype(显式原型)\r\n> prototype指的是显式原型，它是从一个函数指向一个对象，prototype设计的目的就是为了实现继承，让特定函数创建的所有势力共享属性和方法，也可以说是让某一个构造函数实例化的所有对象可以找到公共的方法和属性。\r\n\r\n## 3. constructor\r\n> constructor指向的函数就是该对象的构造函数，实例的原型对象的constructor属性都是指向其对应的构造函数，而一个函数的构造函数指向的是Function根构造函数，并且Function函数的构造函数指向的是它本身。\r\n\r\n> 重点记住下面这个图：\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33f53f8c09cd4aaf83c716665487d24b~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 高频经典问题\r\n### RQ：原型链的终点是什么？\r\n> 原型链的终点其实是null，我们可以从隐式原型那一节可以看出来。\r\n\r\n### RQ：如何理解原型与原型链？\r\n> 关于原型和原型链重点从上面的三个属性进行系统的介绍，把每个属性讲清楚了，原型与原型链之间的关系也就讲清楚了。"
    },
    {
      "id": "/这一次，彻底搞懂this指向问题",
      "metadata": {
        "permalink": "/blog/这一次，彻底搞懂this指向问题",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/这一次，彻底搞懂this指向问题.md",
        "source": "@site/blog\\这一次，彻底搞懂this指向问题.md",
        "title": "这一次，彻底搞懂this指向问题",
        "description": "this到底是什么？",
        "date": "2022-02-25T00:00:00.000Z",
        "formattedDate": "2022年2月25日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 5.27,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "这一次，彻底搞懂this指向问题",
          "date": "2022-02-25T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "这一次，彻底搞懂原型与原型链",
          "permalink": "/blog/这一次，彻底搞懂原型与原型链"
        },
        "nextItem": {
          "title": "这一次，彻底搞懂前端性能优化",
          "permalink": "/blog/这一次，彻底搞懂前端性能优化"
        }
      },
      "content": "## this到底是什么？\r\n> this的本质是指针，this并不是总是指向自身，关于this到底指向哪里，一直是面试中的常考问题，最重要的是要搞懂this的绑定规则，那么接下来就让我们一起来学习this的绑定规则吧~\r\n\r\n## this的绑定规则\r\n### 规则1：默认绑定\r\n> 默认绑定指的是function中的this指向，在严格模式下指向undefined，非严格模式下指向window（浏览器环境中），如果是node环境下不是挂载在全局对象上。\r\n\r\n```js\r\n  var name = 666;\r\n  function test() {\r\n    var name = 777;\r\n    function test2() {\r\n      console.log(\"看全局：\",this.name);  // 看全局：666\r\n      console.log(name);   // 777\r\n    }\r\n    test2();\r\n  }\r\n  test()\r\n```\r\n\r\n### 规则2：隐式绑定\r\n> 隐式绑定的特点是XXX.func()，能够影响到this的是最后一层的调用位置。\r\n\r\n```js\r\nfunction sayHi(){\r\n    console.log('Hello,', this.name);  // Hello, 张三\r\n}\r\nvar person2 = {\r\n    name: '张三',\r\n    sayHi: sayHi\r\n}\r\nvar person1 = {\r\n    name: '李四',\r\n    friend: person2\r\n}\r\nperson1.friend.sayHi();  \r\n```\r\n\r\n### 规则3：显示绑定（硬绑定）\r\n> 显示绑定指的是通过call、apply、bind的方式来指定this指向，其中call、apply、bind的第一个参数就是要指向的对象，区别在于call和apply都会执行对应的函数，但是bind不会。\r\n\r\n```js\r\nfunction sayHi(){\r\n  console.log('Hello,', this.name);  // Hello, 张三\r\n}\r\nvar person = {\r\n  name: '张三',\r\n  sayHi: sayHi\r\n}\r\nvar name = '李四';\r\nvar Hi = person.sayHi;\r\nHi.call(person); \r\n```\r\n\r\n> 需要注意的是如果给call、apply、bind的第一个参数传入的是null,此时的this指向的是window或者undefiend。\r\n\r\n```js\r\nfunction sayHi(){\r\n    console.log('Hello,', this.name);  // Hello, Wiliam\r\n}\r\nvar person = {\r\n    name: 'YvetteLau',\r\n    sayHi: sayHi\r\n}\r\nvar name = 'Wiliam';\r\nvar Hi = function(fn) {\r\n    fn.call(this);\r\n}\r\nHi.call(null,person.sayHi);\r\n```\r\n\r\n> 丢失绑定的情况，主要是调用的时候是如何调用的。下面的这个例子就是因为fn()是直接调用的，相当于是默认绑定。\r\n\r\n```js\r\nfunction sayHi(){\r\n    console.log('Hello,', this.name); // Hello, Wiliam\r\n}\r\nvar person = {\r\n    name: 'YvetteLau',\r\n    sayHi: sayHi\r\n}\r\nvar name = 'Wiliam';\r\nvar Hi = function(fn) {\r\n    fn();\r\n}\r\nHi.call(person, person.sayHi); \r\n```\r\n\r\n### 规则4：new绑定\r\n> new绑定指的是通过new操作符会将this指向新创建的对象。\r\n\r\n```js\r\nfunction sayHi(name){\r\n  this.name = name;\r\n\r\n}\r\nvar Hi = new sayHi('zhangsan');\r\nconsole.log('Hello,', Hi.name);  // Hello, zhangsan\r\n```\r\n\r\n## 绑定规则之间的优先级关系\r\n> 优先级顺序按照下面的序号进行排列：\r\n\r\n1. call(null)\r\n2. new绑定\r\n3. 显示绑定\r\n4. 隐式绑定\r\n5. 默认绑定\r\n\r\n## 箭头函数中this的指向\r\n> 箭头函数中的this指向主要看两种情况，箭头函数定义的上下文有没有function，有则和这个function的this指向相同，没有则是window。\r\n\r\n```js\r\nvar obj = {\r\n    hi: function(){\r\n        console.log(this);\r\n        return ()=>{\r\n            console.log(this);\r\n        }\r\n    },\r\n    sayHi: function(){\r\n        return function() {\r\n            console.log(this);\r\n            return ()=>{\r\n                console.log(this);\r\n            }\r\n        }\r\n    },\r\n    say: ()=>{\r\n        console.log(this);\r\n    }\r\n}\r\nlet hi = obj.hi();  //输出obj对象\r\nhi();               //输出obj对象\r\nlet sayHi = obj.sayHi();\r\nlet fun1 = sayHi(); //输出window\r\nfun1();             //输出window\r\nobj.say();          //输出window\r\n```\r\n\r\n> 下面给出详细的解释：\r\n\r\n```\r\nlet hi = obj.hi();  //输出obj对象\r\n```\r\n\r\n> 这个语句首先执行了obj中的hi方法，此时函数中的this指的是obj，并返回了一个箭头函数给hi，所以输出的是obj对象。\r\n\r\n```js\r\nhi();               //输出obj对象\r\n```\r\n\r\n> 上面我们说过了hi是一个箭头函数，箭头函数的this看的是定义的位置，定义的位置被一个function包裹，因此和这个function的this相同，因此也是obj对象。\r\n\r\n```js\r\nlet sayHi = obj.sayHi();\r\nlet fun1 = sayHi(); //输出window\r\n```\r\n\r\n> obj.sayHi()直接返回了一个函数给sayHi,由于sayhi没有按照隐式绑定的XXX.func的形式进行调用，所以此时变成了默认绑定，那么默认绑定的this指的是window对象，执行完之后返回给fun1一个箭头函数。\r\n\r\n```js\r\nfun1();             //输出window\r\n```\r\n\r\n> 由于fun1是一个箭头函数，其定义的位置被一个function包裹着，因此和这个function的this指向相同，因此是window。\r\n\r\n```js\r\nobj.say();          //输出window\r\n```\r\n\r\n> obj.say()返回的是一个箭头函数，由于这个箭头函数没有被function包裹，此时指向的是window。\r\n\r\n## RQ：箭头函数的this能够改变吗？\r\n> 箭头函数的this不能被改变，即使是显式绑定也不行。"
    },
    {
      "id": "/这一次，彻底搞懂前端性能优化",
      "metadata": {
        "permalink": "/blog/这一次，彻底搞懂前端性能优化",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/这一次，彻底搞懂前端性能优化.md",
        "source": "@site/blog\\这一次，彻底搞懂前端性能优化.md",
        "title": "这一次，彻底搞懂前端性能优化",
        "description": "前言",
        "date": "2022-02-24T00:00:00.000Z",
        "formattedDate": "2022年2月24日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 5.675,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "这一次，彻底搞懂前端性能优化",
          "date": "2022-02-24T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "这一次，彻底搞懂this指向问题",
          "permalink": "/blog/这一次，彻底搞懂this指向问题"
        },
        "nextItem": {
          "title": "这一次，彻底搞懂let、var、const",
          "permalink": "/blog/这一次，彻底搞懂let、var、const"
        }
      },
      "content": "## 前言\r\n> 性能优化问题是区分一个前端工程师能力的重要指标，一个不会性能优化的工程师注定不会做出一个优秀的产品，因为任何一款优秀的产品必然是经过精细打磨的产品，而性能优化就是这打磨的过程，无论是在实际工作中还是面试中性能优化问题都是面试必考的问题，下面让我们来一起解决这个问题吧~\r\n\r\n## 优化思路\r\n> 当我们在浏览器地址栏上输入URL到页面显示出结果的时候，我们都知道时间主要消耗在了网络传输和页面渲染上，因此我们主要从这两个方面出发进行性能优化。\r\n\r\n## 网络传输性能优化\r\n### 1. 使用HTTP2\r\n> HTTP2相对于HTTP1进行了下面的优化：\r\n\r\n* 二进制分帧层\r\n* 多路复用\r\n* 首部压缩\r\n* 请求优先级\r\n* 服务器推送\r\n* 流量控制\r\n\r\n### 2. 资源打包压缩\r\n> 资源打包压缩主要是通过webpack压缩以下内容：\r\n\r\n* 压缩JS代码：通过webpack的production模式压缩JS代码。\r\n* 压缩HTML代码：使用html-webpack-plugin的minify进行压缩。\r\n* 压缩CSS代码：使用cssnano压缩css，在postcss.config.js中进行配置。\r\n\r\n### 3. 图片资源优化\r\n> 在网络传输中真正占用大量网络资源的不是文件而是图片，如果对图片进行了优化，可以看到立竿见影的效果。主要优化措施如下：\r\n\r\n* 在html中尽量不要放图片。\r\n* 使用雪碧图：雪碧图可以减少请求的次数。\r\n* 使用字体图标：字体图片能够像图片一样工作，但是资源占用和图片请求比起来小很多。\r\n* 使用webp：webp格式的图片相对根据国家节省网络带宽。\r\n\r\n### 4. 使用CDN\r\n> CDN指的是在网络不同地点部署节点服务器，将源站内容分发至所有CDN节点，使得用户可以就近获得所需内容。CDN提高了网站的响应速度、降低了延迟。\r\n\r\n### 5. 使用预加载\r\n> 当一个页面加载时，可能会加载很多第三方资源，但是这些资源的优先级是不同的，一些重要资源需要提前进行获取，因此我们可以使用link标签来进行DNS预解析、预加载、预渲染来管理页面资源的加载。\r\n\r\n### 6. 减少DNS查找\r\n> 尽量将资源放在同一域名下面，因为域名越少，DNS查询就会越少。\r\n\r\n### 7. 发送请求时使用防抖和节流策略\r\n> 防抖节流可以避免短时间内发送过多的重复请求。\r\n\r\n## 页面渲染性能优化\r\n### 1. 减少重排和重绘的发生\r\n* 重排：指的是元素布局发生修改，导致页面重新排列。\r\n* 重绘：所有对元素的视觉表现属性的修改，都会引发重绘。\r\n\r\n> 重排和重绘都会影响性能，要想提高网页性能尽可能降低重排和重绘的频率。重排是由CPU处理的，而重绘是由GPU处理的，GPU的处理效率要相对更高，重排一定发生重绘，但是重绘不一定引起重排，所以要尽可能的降低重排和重绘的发生。\r\n\r\n### 2. DOM元素离线更新\r\n> 当对DOM元素进行操作的时候，尽量使用documentFragment对象进行离线操作，待元素组装完成之后再一次插入页面。\r\n\r\n### 3. 避免CSS、JS阻塞\r\n> CSS资源优于JS资源的引入，JS应当尽量少影响DOM的构建。\r\n\r\n## 经典问题\r\n### RQ1：首屏加载如何优化？\r\n> 主要方法包括以下步骤：\r\n\r\n1. 动态加载路由\r\n\r\n> 配置路由的时候，以函数的形式加载路由，只有在解析给定的路由时，才会加载路由。\r\n\r\n2. 合理使用缓存\r\n\r\n> 设置强缓存、协商缓存、localstorage等。\r\n\r\n3. UI框架按需加载\r\n\r\n> 不要引入整个UI库，尽量进行按需加载。\r\n\r\n4. 避免重复加载组件\r\n\r\n> 可以使用webpack将多次使用的包抽离出来，放入公共依赖文件，避免重复加载组件。\r\n\r\n5. 压缩图片资源\r\n\r\n> 雪碧图、字体图标、webp等。\r\n\r\n6. 开启Gzip压缩\r\n\r\n7. 使用SSR服务端渲染\r\n\r\n> 组件或页面通过服务器生成html字符串，再发送到浏览器。"
    },
    {
      "id": "/这一次，彻底搞懂let、var、const",
      "metadata": {
        "permalink": "/blog/这一次，彻底搞懂let、var、const",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/这一次，彻底搞懂let、var、const.md",
        "source": "@site/blog\\这一次，彻底搞懂let、var、const.md",
        "title": "这一次，彻底搞懂let、var、const",
        "description": "前言",
        "date": "2022-02-23T00:00:00.000Z",
        "formattedDate": "2022年2月23日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 2.575,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "这一次，彻底搞懂let、var、const",
          "date": "2022-02-23T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "这一次，彻底搞懂前端性能优化",
          "permalink": "/blog/这一次，彻底搞懂前端性能优化"
        },
        "nextItem": {
          "title": "LeetCode——第一个只出现一次的字符（Map）",
          "permalink": "/blog/LeetCode——第一个只出现一次的字符（Map）"
        }
      },
      "content": "## 前言\r\n> 关于js定义变量时使用的三个常用的定义方法let、var、const是在js编程领域的基石，无论是在面试中还是实际工作中，这些都是我们必须要掌握的知识点。\r\n\r\n## let、var、const的区别\r\n### 1：是否可以重复定义\r\n> var可以重复定义，但是let和const不能重复定义。\r\n\r\n### 2：值是否可以修改\r\n> var和let定义的变量可以修改值，但是const如果定义的是常量值不能被改变，如果定义的是引用类型，其地址不能被改变。\r\n\r\n### 3：是否有变量声明提升\r\n> var存在声明提升，let和const不存在声明提升，存在暂时性死区。\r\n\r\n### 4：是否能够形成块级作用域\r\n> var不能形成块级作用域，但是function可以，let和const会形成块级作用域。\r\n\r\n### 5：是否支持循环\r\n> var和let是支持循环的，但是const不支持循环。\r\n\r\n## RQ1：var为什么可以重复定义变量？\r\n> JS运行时编译器负责词法分析和语法分析、代码生辰等工作，编译器在作用域判断这是重名声明时，会忽略var直接赋值。\r\n\r\n## RQ2：let、const与栈、堆之间的关系，栈、堆哪个访问速度更快，为什么？\r\n> var会预先在站内存里跟配空间，等实际语句执行的时候再存储对应的值，如果传入的是引用类型，会在堆内存中开辟一个内存空间存储实际内容，栈内存中存储的是一个指向堆内存的指针，let和const都不会预先分配内存空间在栈中，并且在分配变量的时候会检查是否有重名的情况，有则报错。\r\n\r\n## RQ3：const 声明生成对象的时候，如何使其不可更改？\r\n> 通过Object.freeze()或者Object.defineProperty()使其不可更改，其中Object.freeze只是浅层的冻结，所以我们可以使用Object.defineProperty然后利用递归的方式使其深度不可更改。"
    },
    {
      "id": "/LeetCode——第一个只出现一次的字符（Map）",
      "metadata": {
        "permalink": "/blog/LeetCode——第一个只出现一次的字符（Map）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——第一个只出现一次的字符（Map）.md",
        "source": "@site/blog\\LeetCode——第一个只出现一次的字符（Map）.md",
        "title": "LeetCode——第一个只出现一次的字符（Map）",
        "description": "题目描述",
        "date": "2022-02-22T00:00:00.000Z",
        "formattedDate": "2022年2月22日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 2.545,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——第一个只出现一次的字符（Map）",
          "date": "2022-02-22T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "这一次，彻底搞懂let、var、const",
          "permalink": "/blog/这一次，彻底搞懂let、var、const"
        },
        "nextItem": {
          "title": "满分回答之从输入URL到页面显示经历了什么？",
          "permalink": "/blog/满分回答之从输入URL到页面显示经历了什么？"
        }
      },
      "content": "## 题目描述\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/008c747c714ff09d912104c9bebd0bc4.png)\r\n\r\n> 题目主要是让我们找到第一个只出现一次的字符，如果没有并不是返回为空字符串，而是单空格，这个地方容易出错，大家一定要注意。\r\n\r\n## 解题思路\r\n> 博主原本想使用set来实现的，出现第二次就将其从set中去除，但是这种方法无法应对出现三次或者五次等奇数的情况。，因此后来采用了最简单的方法map遍历，然后将其次数存储到map的value中，key则是每一个单字符。\r\n\r\n1. 如果传入的参数是一个空字符串，则染回单空格。\r\n2. 初始化一个map，遍历每一个字符，并更新字符出现的次数。\r\n3. 遍历map的每一个item，如果item[1]等于1，则直接返回item[0]。\r\n4. 如果第三步没有找到符合条件的则返回单空格。\r\n\r\n## AC代码\r\n\r\n```js\r\nvar firstUniqChar = function (s) {\r\n  if (s.length === 0) return \" \"\r\n  const map = new Map();\r\n\r\n  for (let v of s) {\r\n    if (map.has(v)) {\r\n      map.set(v,map.get(v) + 1);\r\n    } else {\r\n      map.set(v,1);\r\n    }\r\n  }\r\n\r\n  for (let item of map) {\r\n    if (item[1] === 1) {\r\n      return item[0];\r\n    }\r\n  }\r\n  return \" \"\r\n\r\n};\r\n```\r\n\r\n## 总结\r\n> 第一次只出现一次的字符，使用map是最直接的能够想到的方法了，通过遍历每一个字符出现的次数便可以知道第一次只出现一次的字符。所以通过这个题目，我们能够巩固对map的基本API的操作。在这里我想要强调一下map和传统的object的区别是什么？map类似于对象，也是键值对的组合，但是传统object的键的范围只能是字符串，而map的键可以使各种类型的值，包括对象都可以当做键，也就是说普通的对象提供了字符串到值的对应关系，而map数据结构则提供了值到值的对应，是一种更加完善的hash结构实现。"
    },
    {
      "id": "/满分回答之从输入URL到页面显示经历了什么？",
      "metadata": {
        "permalink": "/blog/满分回答之从输入URL到页面显示经历了什么？",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/满分回答之从输入URL到页面显示经历了什么？.md",
        "source": "@site/blog\\满分回答之从输入URL到页面显示经历了什么？.md",
        "title": "满分回答之从输入URL到页面显示经历了什么？",
        "description": "前言",
        "date": "2022-02-20T00:00:00.000Z",
        "formattedDate": "2022年2月20日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 7.355,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "满分回答之从输入URL到页面显示经历了什么？",
          "date": "2022-02-20T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "LeetCode——第一个只出现一次的字符（Map）",
          "permalink": "/blog/LeetCode——第一个只出现一次的字符（Map）"
        },
        "nextItem": {
          "title": "这一次，彻底搞懂双向数据绑定04",
          "permalink": "/blog/这一次，彻底搞懂双向数据绑定04"
        }
      },
      "content": "## 前言\r\n> 从输入URL到页面显示不仅仅是一道经典的面试题，这个知识点中涉及到了非常广泛的知识点，因此面试官可以通过这个问题有点到面的向候选人发起提问，因此这个面试题被频繁的问到，所以下面让我们来好好看看这个题目该如何回答。\r\n\r\n## 阶段一：用户输入阶段\r\n> 用户在地址栏输入内容之后，浏览器会首先判断用户输入的是合法的URL还是搜索内容，如果是搜索内容就合成URL，如果是合法的URL就开始进行加载。\r\n\r\n## 阶段二：发起URL请求阶段\r\n> 发起URL请求阶段主要包括以下步骤：\r\n\r\n1. 构建请求行：浏览器进程首先会构建请求行信息，然后通过进程间通信IPC将URL请求发送给网络进程。\r\n2. 查找缓存：网络进程获取到URL之后，会先去本地缓存中查找是否有缓存资源，如果有则直接将缓存资源返回给浏览器进程，否则进入网络请求阶段。\r\n3. DNS解析：网络进程请求首先会从DNS数据缓存服务器中查找是否缓存过当前域名的信息，有则直接返回，否则，会进行DNS解析域名对应的IP和端口号。\r\n4. 等待TCP队列：chrome有个机制，同一个域名同时最多只能建立6个TCP连接，如果超过这个数量的连接必须要进入排队等待状态。\r\n5. 建立TCP连接：通过TCP三次握手与服务器建立连接，然后进行数据传输。\r\n6. 发起HTTP请求：浏览器首先会向服务器发送请求行，请求行中包含了请求方法、请求URI和HTTP版本，还会发送请求头，告诉服务器一些浏览器的相关信息，比如浏览器内核、请求域名、Cookie等信息。\r\n7. 服务器处理请求：服务器首先返回相应行，包括协议版本和状态码，然后会返回响应头包含返回的数据类型，服务器要在客户端保存的Cookie等。\r\n8. 断开TCP连接：数据传输完成后，通过四次挥手来断开连接。\r\n\r\n## 阶段三：准备渲染进程阶段\r\n1. 网络进程将获取的数据进行解析，根据响应头中的Content-type来判断响应数据的类型，如果是字节流类型，就将该请求交给下载管理器去下载，如果是text/html类型，就通知浏览器进程获取到的是HTML，准备渲染进程。\r\n2. 一般情况下浏览器的一个tab页面对应一个渲染进程，如果从当前页面打开的新页面并且属于同一站点，这种情况会复用渲染进程，其他情况则需要创建新的渲染进程。\r\n\r\n## 阶段四：提交文档阶段\r\n1. 渲染进程准备好之后，浏览器会发出提交文档的消息给渲染进程，渲染进程收到消息后，会和网络进程建立数据传输的管道，文档数据传输完成后，渲染进程会返回确认提交的消息给浏览器进程。\r\n2. 浏览器收到确认提交的消息后，会更新浏览器的页面状态，包括了安全状态，地址栏的URL，前进后退的历史状态，并更新web页面为空白。\r\n\r\n## 阶段五：页面渲染阶段\r\n1. 文档提交之后，渲染进程将开始页面解析并加载子资源。\r\n2. 构建DOM树：HTML经过解析后输出的是一个以document为顶层节点的树状结构的DOM。\r\n3. 样式计算：将从link标签引入的外部样式，style标签里的样式和元素身上的样式转换成浏览器能够理解的样式表，然后将样式表中的属性值进行标准化，例如color:red转换为color的rgb形式，然后根据CSS的继承和层叠规则计算出DOM树种每个节点的具体样式。\r\n4. 布局阶段：会生成一棵只包含可见元素的布局树，然后根据布局树的每个节点计算出其具体位置和大小。\r\n5. 分层：对页面种的复杂效果例如3D转换，页面滚动或者z轴排序等生成图层树。\r\n6. 绘制：为每个图层生成绘制列表，并将其提交到合成线程中。\r\n7. 光栅化：优先选择可视窗口内的图块来生成位图数据。\r\n8. 合成：所有图块都被光栅话之后开始显示页面。\r\n\r\n## 问题汇总\r\n### RQ1：浏览器解析HTML过程\r\n> 针对这个问题，我们可以从阶段五：页面渲染阶段来回答。\r\n\r\n### RQ2：强缓存和协商缓存发生在那个阶段？\r\n>强缓存和协商缓存发生在发起URL请求阶段，在这个阶段构建请求行之后会查找缓存。\r\n\r\n### RQ3：DNS解析中端口需要DNS解析吗？\r\n> 不需要，因为HTTP默认的是80端口，HTTPS默认的是443端口，如果要指定端口可以直接在URL里面添加。\r\n\r\n### RQ4：哪些阶段可以优化？\r\n1. 优化DNS查询：DNS预解析\r\n2. 优化TCP连接：可以通过请求头keep-alive来优化。\r\n3. 优化HTTP响应报文：通过CDN和Gzip压缩。\r\n\r\n> 更多的优化细节将通过专门的文章进行讲解，大家敬请期待。\r\n\r\n\r\n## 参考文档\r\n> 感谢下面文章的作者，收获到很多知识！\r\n\r\n* [「面试常问」从输入 URL 到显示发生了什么（ 99 分答案）](https://cloud.tencent.com/developer/article/1830653)"
    },
    {
      "id": "/这一次，彻底搞懂双向数据绑定04",
      "metadata": {
        "permalink": "/blog/这一次，彻底搞懂双向数据绑定04",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/这一次，彻底搞懂双向数据绑定04.md",
        "source": "@site/blog\\这一次，彻底搞懂双向数据绑定04.md",
        "title": "这一次，彻底搞懂双向数据绑定04",
        "description": "一、实现数据从data到view的单向数据绑定",
        "date": "2022-02-19T00:00:00.000Z",
        "formattedDate": "2022年2月19日",
        "tags": [
          {
            "label": "Vue",
            "permalink": "/blog/tags/vue"
          }
        ],
        "readingTime": 2.86,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "这一次，彻底搞懂双向数据绑定04",
          "date": "2022-02-19T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Vue",
          "tags": [
            "Vue"
          ]
        },
        "prevItem": {
          "title": "满分回答之从输入URL到页面显示经历了什么？",
          "permalink": "/blog/满分回答之从输入URL到页面显示经历了什么？"
        },
        "nextItem": {
          "title": "这一次，彻底搞懂双向数据绑定03",
          "permalink": "/blog/这一次，彻底搞懂双向数据绑定03"
        }
      },
      "content": "## 一、实现数据从data到view的单向数据绑定\r\n1. 当data发生变化的时候首先触发数据劫持的setter函数\r\n\r\n```js\r\n  set(newVal) {\r\n    value = newVal\r\n    Observe(value)\r\n    // 通知每个订阅者更新自己的文本\r\n    dep.notify()\r\n  }\r\n```\r\n\r\n> setter函数先改变新的值，然后通知每一个订阅者。\r\n\r\n2. Dep类的notify函数通知每一个订阅者watcher\r\n\r\n```js\r\n  notify() {\r\n    this.subs.forEach(watcher => watcher.update())\r\n  }\r\n```\r\n\r\n3. Watcher类的update函数获取最新的值并调用渲染函数。\r\n\r\n```js\r\n  update() {\r\n    const value = this.key.split('.').reduce((newObj,k) => newObj[k],this.vm)\r\n    this.cb(value);\r\n  }\r\n```\r\n\r\n4. 渲染函数执行渲染\r\n\r\n```js\r\nnew Watcher(vm,execResult[1],(newValue) => {\r\n  node.textContent = text.replace(regMustache,newValue);\r\n})\r\n```\r\n\r\n## 二、实现文本框的单向数据绑定\r\n> 在渲染函数中首先判断当前节点是否为input并且含有属性v-model，有则获取值并创建watcher实例。\r\n\r\n```js\r\n// 判断当前的节点是否为input框\r\nif (node.nodeType === 1 && node.tagName.toUpperCase() === 'INPUT') {\r\n  // 得到当前元素的所有属性节点\r\n  const attrs = Array.from(node.attributes);\r\n  const findResult = attrs.find(x => x.name === 'v-model')\r\n  if (findResult) {\r\n    // 获取当前v-model属性的值 v-model=\"name\" v-model=\"info.a\"\r\n    const expStr = findResult.value;\r\n    const value = expStr.split('.').reduce((newObj,k) => newObj[k],vm);\r\n    node.value = value;\r\n    // 创建Watcher的实例\r\n    new Watcher(vm,expStr,(newValue) => {\r\n      node.value = newValue;\r\n    })\r\n  }\r\n}\r\n```\r\n\r\n## 三、实现文本框的双向数据绑定\r\n> 实现文本框的双向数据绑定重点是在单向数据绑定的基础上，监听文本框的输入事件，拿到文本框的最新值，并将最新值更新到vm上即可。\r\n\r\n```js\r\n// 判断当前的节点是否为input框\r\nif (node.nodeType === 1 && node.tagName.toUpperCase() === 'INPUT') {\r\n  // 得到当前元素的所有属性节点\r\n  const attrs = Array.from(node.attributes);\r\n  const findResult = attrs.find(x => x.name === 'v-model')\r\n  if (findResult) {\r\n    // 获取当前v-model属性的值 v-model=\"name\" v-model=\"info.a\"\r\n    const expStr = findResult.value;\r\n    const value = expStr.split('.').reduce((newObj,k) => newObj[k],vm);\r\n    node.value = value;\r\n    // 创建Watcher的实例\r\n    new Watcher(vm,expStr,(newValue) => {\r\n      node.value = newValue;\r\n    })\r\n\r\n    // 监听文本框的input输入事件，拿到文本框的最新值，并把最新值更新到vm上即可\r\n    node.addEventListener('input',e => {\r\n      const keyArr = expStr.split('.');\r\n      const obj = keyArr.slice(0,keyArr.length-1).reduce((newObj,k) => newObj[k],vm);\r\n      obj[keyArr[keyArr.length - 1]] = e.target.value;\r\n    })\r\n  }\r\n}\r\n```\r\n\r\n## 总结\r\n> Vue的双向数据绑定是数据劫持、模板编译、发布订阅模式等综合知识点的体现，是我们必须要学会并掌握的知识点。"
    },
    {
      "id": "/这一次，彻底搞懂双向数据绑定03",
      "metadata": {
        "permalink": "/blog/这一次，彻底搞懂双向数据绑定03",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/这一次，彻底搞懂双向数据绑定03.md",
        "source": "@site/blog\\这一次，彻底搞懂双向数据绑定03.md",
        "title": "这一次，彻底搞懂双向数据绑定03",
        "description": "一、将this.$data上的属性代理到vm实例上",
        "date": "2022-02-18T00:00:00.000Z",
        "formattedDate": "2022年2月18日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 3.665,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "这一次，彻底搞懂双向数据绑定03",
          "date": "2022-02-18T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "这一次，彻底搞懂双向数据绑定04",
          "permalink": "/blog/这一次，彻底搞懂双向数据绑定04"
        },
        "nextItem": {
          "title": "使用Python递归遍历目标路径下的所有文件",
          "permalink": "/blog/使用Python递归遍历目标路径下的所有文件"
        }
      },
      "content": "## 一、将this.$data上的属性代理到vm实例上\r\n> 所谓的将this.\\$data挂载到vm实例上，实际上就是说不需要通过vm.\\$data.属性来获取值，而是直接通过vm.属性获取值。\r\n\r\n> `方法：通过Object.defineProperty将this.$data身上的属性代理到this身上。`\r\n\r\n```js\r\nclass Vue {\r\n  constructor(options) {\r\n    this.$data = options.data;\r\n\r\n    // 调用数据劫持的方法\r\n    Observe(this.$data);\r\n\r\n    // 将属性绑定到this身上\r\n    Object.keys(this.$data).forEach(key => {\r\n      Object.defineProperty(this,key,{\r\n        enumerable: true,\r\n        configurable: true,\r\n        get() {\r\n          return this.$data[key];\r\n        },\r\n        set(newValue) {\r\n          this.$data[key] = newValue; \r\n        }\r\n      })\r\n    })\r\n  }\r\n}\r\n```\r\n\r\n## 二、文档碎片的作用\r\n### 文档碎片是什么？\r\n> 文档碎片的本质是一片内存空间，文档碎片的存在就是为了防止频繁的对DOM进行操作，造成重绘和重排影响性能，通过将页面中的DOM存储在文档碎片中，对文档碎片进行操作，可以有效的防止频繁的对DOM进行操作。\r\n\r\n### 递归文本节点并使用正则进行替换\r\n\r\n```js\r\n  function replace(node) {\r\n    // 匹配插值表达式的正则\r\n    const regMustache = /\\{\\{\\s*(\\S+)\\s*\\}\\}/\r\n    // 证明当前的node节点是一个文本子节点\r\n    if (node.nodeType === 3) {\r\n      const text = node.textContent;\r\n      // 进行正则提取\r\n      const execResult = regMustache.exec(text);\r\n\r\n      if (execResult) {\r\n        const value = execResult[1].split('.').reduce((newObj,k) => newObj[k],vm)\r\n        node.textContent = text.replace(regMustache,value)\r\n      }\r\n      return\r\n    }\r\n    // 不是文本节点，则投入递归\r\n    node.childNodes.forEach(child => replace(child))\r\n  }\r\n```\r\n\r\n## 三、创建Dep类进行依赖收集\r\n> 下面的Dep类主要实现三个功能：\r\n\r\n1. 在实例身上定义一个存放订阅者的数组。\r\n2. 定义一个向数组中增加订阅者的函数。\r\n3. 定义一个通知每一个订阅者watcher的方法。\r\n\r\n```js\r\n// 收集watcher订阅者的类\r\nclass Dep {\r\n  constructor() {\r\n    this.subs = [];\r\n  }\r\n\r\n  addSub(watcher) {\r\n    this.subs.push(watcher);\r\n  }\r\n  // 负责通知每个watcher的方法\r\n  notify() {\r\n    this.subs.forEach(watcher => watcher.update())\r\n  }\r\n}\r\n```\r\n\r\n## 四、创建Watcher类的实例\r\n> 在replace函数第一次渲染的时候，创建Watcher实例：\r\n\r\n```js\r\n  function replace(node) {\r\n    // 匹配插值表达式的正则\r\n    const regMustache = /\\{\\{\\s*(\\S+)\\s*\\}\\}/\r\n    // 证明当前的node节点是一个文本子节点\r\n    if (node.nodeType === 3) {\r\n      const text = node.textContent;\r\n      // 进行正则提取\r\n      const execResult = regMustache.exec(text);\r\n\r\n      if (execResult) {\r\n        const value = execResult[1].split('.').reduce((newObj,k) => newObj[k],vm)\r\n        node.textContent = text.replace(regMustache,value)\r\n        // 在这里创建watcher\r\n        new Watcher(vm,execResult[1],(newValue) => {\r\n          node.textContent = text.replace(regMustache,newValue);\r\n        })\r\n      }\r\n      return\r\n    }\r\n    // 不是文本节点，则投入递归\r\n    node.childNodes.forEach(child => replace(child))\r\n  }\r\n```\r\n\r\n## 五、将watcher实例存储到dep.subs数组中\r\n> 将watcher实例存储到dep.subs数组中主要是需要下面三个方面的配合：\r\n\r\n1. 编译函数在编译DOM节点的时候需要实例化watcher。\r\n2. watcher的构造函数中要有下面三行代码。这三行代码需要和Observer中的get进行配合使用\r\n\r\n```js\r\nDep.target = this;\r\nkey.split('.').reduce((newObj,k) => newObj[k],vm);\r\nDep.target = null;\r\n```\r\n\r\n> 发挥关键作用的在与第二行代码，看似是在调用，其实是在出发Observe中的getter。\r\n\r\n3. Observe中的getter\r\n\r\n```js\r\n  get() {\r\n    Dep.target && dep.addSub(Dep.target)\r\n    return value;\r\n  }\r\n```"
    },
    {
      "id": "/使用Python递归遍历目标路径下的所有文件",
      "metadata": {
        "permalink": "/blog/使用Python递归遍历目标路径下的所有文件",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/使用Python递归遍历目标路径下的所有文件.md",
        "source": "@site/blog\\使用Python递归遍历目标路径下的所有文件.md",
        "title": "使用Python递归遍历目标路径下的所有文件",
        "description": "需求介绍",
        "date": "2022-02-17T00:00:00.000Z",
        "formattedDate": "2022年2月17日",
        "tags": [
          {
            "label": "python",
            "permalink": "/blog/tags/python"
          }
        ],
        "readingTime": 2.6,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "使用Python递归遍历目标路径下的所有文件",
          "date": "2022-02-17T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "python",
          "tags": [
            "python"
          ]
        },
        "prevItem": {
          "title": "这一次，彻底搞懂双向数据绑定03",
          "permalink": "/blog/这一次，彻底搞懂双向数据绑定03"
        },
        "nextItem": {
          "title": "这一次，彻底搞懂双向数据绑定02",
          "permalink": "/blog/这一次，彻底搞懂双向数据绑定02"
        }
      },
      "content": "## 需求介绍\r\n> 从网上获取目标网站的数据一般通过网络爬虫的方式，但是这种方式往往可能效率比较低，而且有些网站可能会限制爬虫，比如著名的Github，当通过API爬虫的方式获取数据的时候，Github官方对爬虫速率进行了限制，超过了这个速率的爬虫会被限制，同时Github官方还要求提供Github用户验证等等，这些限制无形中都加大了我们爬虫的难度，但是其实我们还可以通过直接下载Github仓库的方式来获取数据，这种方式比爬虫要更加方便快捷，但是下下来的文件中很多是文件夹或者不符合条件的文件，我们该如何快速的通过python脚本将这些文件提取出来呢？下面就是我们要介绍的使用python递归遍历目标路径下的所有文件。\r\n\r\n## 实现思路\r\n1. 导入操作json和文件的模块,并定义最终存储的变量。\r\n\r\n```py\r\nimport os\r\nimport json\r\ntarget_json = []\r\n```\r\n\r\n2. 定义递归函数，接收路径作为参数，遍历路径中的每一个item，并判断其为文件夹还是文件,文件夹则投入继续递归，文件则读取文件中的json数据并存储到指定变量中。\r\n\r\n```py\r\ndef getTarget(dir):\r\n  temp = os.listdir(dir)\r\n  for t in temp:\r\n    if (os.path.isfile(dir + '/' + t)):\r\n      print('找到了',t)\r\n\r\n      for line in open(dir + '/' + t): \r\n        # print(line)\r\n        line=line.strip('\\n')\r\n        line = json.loads(line)\r\n        target_json.append(line)\r\n      # with open(dir + '/' + t) as f:\r\n      #   line = f.readline()\r\n      #   while line:\r\n      #     target_json.append(line)\r\n        # print(line)\r\n    else:\r\n      getTarget(dir + '/' + t)\r\n      \r\ngetTarget('./crates.io-index-master')\r\n```\r\n\r\n3. 将指定变量中的数据存储为json文件，方便后续使用。\r\n\r\n```py\r\njson_str = json.dumps(target_json)\r\nwith open('target_json.json', 'w') as json_file:\r\n    json_file.write(json_str)\r\n```\r\n\r\n## 总结\r\n> 获取有代码仓库的网站的数据，不一定要使用爬虫，有时候直接从代码仓库中下载数据并使用脚本进行处理，无论是从获取的速度还是精度都要更高。"
    },
    {
      "id": "/这一次，彻底搞懂双向数据绑定02",
      "metadata": {
        "permalink": "/blog/这一次，彻底搞懂双向数据绑定02",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/这一次，彻底搞懂双向数据绑定02.md",
        "source": "@site/blog\\这一次，彻底搞懂双向数据绑定02.md",
        "title": "这一次，彻底搞懂双向数据绑定02",
        "description": "实现Vue中的Getter",
        "date": "2022-02-16T00:00:00.000Z",
        "formattedDate": "2022年2月16日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 2.83,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "这一次，彻底搞懂双向数据绑定02",
          "date": "2022-02-16T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "使用Python递归遍历目标路径下的所有文件",
          "permalink": "/blog/使用Python递归遍历目标路径下的所有文件"
        },
        "nextItem": {
          "title": "这一次，彻底搞懂双向数据绑定01",
          "permalink": "/blog/这一次，彻底搞懂双向数据绑定01"
        }
      },
      "content": "## 实现Vue中的Getter\r\n1. 在HTML文件中引入自己创建的vue.js.\r\n2. 在vue.js中定义Vue类和构造函数.\r\n3. vue.js中定义一个数据劫持的方法\r\n4. 使用Object.keys(obj).forEach获取对象所有的键。\r\n\r\n> 下面是html结构\r\n\r\n```html\r\n<body>\r\n  <div id=\"app\">\r\n    <h2>姓名：{{name}}</h2>\r\n    <h2>年龄：{{age}}</h2>\r\n  </div>\r\n\r\n  <script src=\"./vue.js\"></script>\r\n\r\n  <script>\r\n    const vm = new Vue({\r\n      el: '#app',\r\n      data: {\r\n        name: '张三',\r\n        age: 20,\r\n        info: {\r\n          a: 'a1',\r\n          c: 'c1'\r\n        }\r\n      }\r\n    });\r\n    console.log(vm);\r\n  </script>\r\n</body>\r\n```\r\n\r\n> 下面是我们自建的vue.js文件：\r\n\r\n```js\r\nclass Vue {\r\n  constructor(options) {\r\n    this.$data = options.data;\r\n\r\n    // 调用数据劫持的方法\r\n    Observe(this.$data);\r\n  }\r\n}\r\n\r\n// 定义一个数据劫持的方法\r\nfunction Observe(obj) {\r\n  Object.keys(obj).forEach((key) => {\r\n    let value = obj[key];\r\n    Object.defineProperty(obj,key,{\r\n      enumerable: true,\r\n      configurable: true,\r\n      get() {\r\n        console.log(`有人获取${key}的值`);\r\n        return value;\r\n      },\r\n      set(newVal) {\r\n        value = newVal\r\n      }\r\n    })\r\n  })\r\n}\r\n```\r\n\r\n> 上面的Observer函数存在一个问题，就是只将对象的第一层属性添加了getter和setter，却没有对深层次的属性添加，因此下面使用递归解决这个问题。\r\n\r\n## 使用递归为对象上的所有属性添加getter和setter\r\n\r\n```js\r\n// 定义一个数据劫持的方法\r\nfunction Observe(obj) {\r\n  \r\n  // 递归结束条件\r\n  if (!obj || typeof obj !== 'object') {\r\n    return;\r\n  }\r\n  Object.keys(obj).forEach((key) => {\r\n    let value = obj[key];\r\n    Observe(value);\r\n    Object.defineProperty(obj,key,{\r\n      enumerable: true,\r\n      configurable: true,\r\n      get() {\r\n        console.log(`有人获取${key}的值`);\r\n        return value;\r\n      },\r\n      set(newVal) {\r\n        value = newVal\r\n      }\r\n    })\r\n  })\r\n}\r\n```\r\n\r\n> 主要就是看从哪里开始递归，以及递归的终止条件是什么。\r\n\r\n> 上面的Observe函数还存在着一个问题，那就是加入为对象的属性赋值会覆盖掉原本的setter和getter。\r\n\r\n## 为新赋值的对象也添加getter和setter\r\n> 为了解决上面提到的问题，我们在调用属性的setter方法时，也需要再次将对象投入Observe递归中。\r\n\r\n```js\r\n// 定义一个数据劫持的方法\r\nfunction Observe(obj) {\r\n  \r\n  // 递归结束条件\r\n  if (!obj || typeof obj !== 'object') {\r\n    return;\r\n  }\r\n  Object.keys(obj).forEach((key) => {\r\n    let value = obj[key];\r\n    Observe(value);\r\n    Object.defineProperty(obj,key,{\r\n      enumerable: true,\r\n      configurable: true,\r\n      get() {\r\n        console.log(`有人获取${key}的值`);\r\n        return value;\r\n      },\r\n      set(newVal) {\r\n        value = newVal\r\n        Observe(value)\r\n      }\r\n    })\r\n  })\r\n}\r\n```\r\n\r\n## 总结\r\n> 要想给vue实例上的data进行数据劫持，需要考虑数据类型，递归，getter和setter时什么时候调用递归等等问题。"
    },
    {
      "id": "/这一次，彻底搞懂双向数据绑定01",
      "metadata": {
        "permalink": "/blog/这一次，彻底搞懂双向数据绑定01",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/这一次，彻底搞懂双向数据绑定01.md",
        "source": "@site/blog\\这一次，彻底搞懂双向数据绑定01.md",
        "title": "这一次，彻底搞懂双向数据绑定01",
        "description": "双向数据绑定所需前置知识",
        "date": "2022-02-14T00:00:00.000Z",
        "formattedDate": "2022年2月14日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 2.895,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "这一次，彻底搞懂双向数据绑定01",
          "date": "2022-02-14T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "这一次，彻底搞懂双向数据绑定02",
          "permalink": "/blog/这一次，彻底搞懂双向数据绑定02"
        },
        "nextItem": {
          "title": "这一次，彻底搞懂深拷贝",
          "permalink": "/blog/这一次，彻底搞懂深拷贝"
        }
      },
      "content": "## 双向数据绑定所需前置知识\r\n\r\n### 1. 数组的reduce方法\r\n>数组的reduce方法的使用场景一般是本次操作的初始值需要依赖上次操作的返回值，例如数值的累加，链式获取对象属性的值。\r\n\r\n> reduce函数接收两个参数：\r\n\r\n* 函数(之前的累积值，当前遍历到的元素的值)\r\n* 初始值\r\n\r\n> 函数体中要返回之前的累积值和当前遍历的值的和\r\n\r\n```js\r\nconst arr = [1,2,3,4];\r\n\r\nlet res = arr.reduce((pre,cur) => {\r\n  return pre + cur;\r\n},0)\r\n\r\nconsole.log(res); // 10\r\n```\r\n\r\n\r\n> 通过reduce链式获取对象属性的值\r\n\r\n```js\r\nconst obj = {\r\n  name: '张三',\r\n  info: {\r\n    address: {\r\n      location: '北京怀柔'\r\n    }\r\n  }\r\n}\r\n\r\nconst arr = ['info','address','location'];\r\nconst location = arr.reduce((pre,cur) => pre[cur],obj);\r\nconsole.log(location);  // 北京怀柔\r\n```\r\n\r\n\r\n### 2. 发布订阅模式\r\n> 发布订阅模式中主要包含下面两个类：\r\n\r\n1. Dep类\r\n    * 负责进行依赖收集\r\n    * 有一个数组，用来存放所有的订阅信息\r\n    * 有一个向数组中添加订阅的方法\r\n    * 提供一个循环，循环出发数组中的每个订阅信息\r\n2. Watcher类\r\n    * 负责订阅事件\r\n    \r\n> 下面是最基本的Dep类和Watcher类：\r\n\r\n```js\r\n// Dep类主要是收集订阅\r\nclass Dep {\r\n  constructor() {\r\n    // subs数组，用于存放所有订阅者的信息\r\n    this.subs = []\r\n  }\r\n  // 向subs数组中，添加订阅者的信息\r\n  addSub(watcher) {\r\n    this.subs.push(watcher);\r\n  }\r\n  // 发布通知的方法\r\n  notify(){\r\n    this.subs.forEach(watcher => {\r\n      watcher.update();\r\n    })\r\n  }\r\n}\r\n\r\n// 订阅者的类\r\nclass Watcher {\r\n  constructor(cb) {\r\n    this.cb = cb;\r\n  }\r\n  // 触发回调的方法\r\n  update() {\r\n    this.cb();\r\n  }\r\n}\r\n\r\nconst w1 = new Watcher(() => {\r\n  console.log('这是第一个订阅者');\r\n})\r\n\r\nconst w2 = new Watcher(() => {\r\n  console.log('这是第二个订阅者');\r\n})\r\nconst dep = new Dep();\r\ndep.addSub(w1);\r\ndep.addSub(w2);\r\ndep.notify()\r\n```\r\n\r\n> 订阅者我们可以理解为DOM元素，当数据发生变化的时候，Vue会通知到每一个订阅者，然后订阅者根据最新的数据更新DOM。\r\n\r\n### 3. 使用Object.defineProperty()进行数据劫持\r\n1. 通过get()劫持取值操作。\r\n2. 通过set()劫持赋值操作。\r\n\r\n```js\r\n    const obj = {\r\n  name: '张三',\r\n  age: 20,\r\n  info: {\r\n    a: 1,\r\n    b: 2\r\n  }\r\n}\r\n\r\nObject.defineProperty(obj,'name',{\r\n  enumerable: true,\r\n  configurable: true,\r\n  get() {\r\n    console.log('有人获取了obj.name的值');\r\n    return \"获取的是这里的张三\"\r\n  },\r\n  set(newVal) {\r\n    console.log('打印出新的值');\r\n  }\r\n})\r\n\r\nconsole.log(obj.name);\r\nobj.name = '555';\r\n\r\nconsole.log(obj);\r\n```\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/2c55c472a951b070b4fee0f621797ac9.png)"
    },
    {
      "id": "/这一次，彻底搞懂深拷贝",
      "metadata": {
        "permalink": "/blog/这一次，彻底搞懂深拷贝",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/这一次，彻底搞懂深拷贝.md",
        "source": "@site/blog\\这一次，彻底搞懂深拷贝.md",
        "title": "这一次，彻底搞懂深拷贝",
        "description": "为什么要学习深拷贝？",
        "date": "2022-02-13T00:00:00.000Z",
        "formattedDate": "2022年2月13日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 4.925,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "这一次，彻底搞懂深拷贝",
          "date": "2022-02-13T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "这一次，彻底搞懂双向数据绑定01",
          "permalink": "/blog/这一次，彻底搞懂双向数据绑定01"
        },
        "nextItem": {
          "title": "这一次，彻底搞懂Promise",
          "permalink": "/blog/这一次，彻底搞懂Promise"
        }
      },
      "content": "## 为什么要学习深拷贝？\r\n> 在介绍深拷贝之前，我们首先要知道为什么要学习深拷贝，不仅仅是因为这是一道面试常考的问题，还因为在实际的开发中，我们经常会遇到需要进行深拷贝的场景，因此深拷贝这个问题是我们必须要掌握的，深拷贝其中涉及到的知识点还是很多的，通过这个知识点的学习可以帮助我们迅速拓展巩固其他相关的知识点。\r\n\r\n## 基本数据类型和引用数据类型\r\n> 在介绍深拷贝之前，我们首先要明白基本数据类型和引用数据类型的概念和区别。\r\n\r\n>基本数据类型没有子类型，不能再进行拆分了，但是复杂数据类型还有子类型。数据类型的不同，造成数据在内存中的存储方式的不同，简单数据类型都是存储在栈中，存储的是一个值，如果是复杂数据类型，存储在堆中，存储的是一个地址，正是因为存储方式的不同，导致了我们在拷贝对象的时候，有时候需要浅拷贝，有时候需要深拷贝。\r\n\r\n### 基本数据类型\r\n\r\n> 典型的基本数据类型有以下几种：\r\n\r\n* undefined\r\n* number\r\n* boolean\r\n* bigint\r\n* symbol \r\n* null\r\n* string\r\n\r\n### 引用数据类型\r\n> 典型的引用数据类型主要有以下几种：\r\n\r\n* Object\r\n* Array\r\n* Map\r\n* Set\r\n* Date\r\n* Regexp\r\n* Function\r\n\r\n## 深拷贝和浅拷贝的区别\r\n> 对浅拷贝来说：如果属性是基本类型，拷贝的就是对应的值，如果属性是引用类型，拷贝就是对应的内存地址，所以此时如果修改新拷贝对象中的引用类型的属性会影响到原对象中的属性。\r\n\r\n> 对深拷贝来说：如果属性是基本类型，拷贝的是对应的值，如果是引用类型，会从堆内存中开辟一个新的空间存在新对象，修改新对象不会对原来的对象产生影响。\r\n\r\n## 如何实现深拷贝\r\n### 方式一：通过JSON.parse(JSON.stringify(obj))\r\n> 下面介绍一个通过JSON.parse(JSON.stringify(obj))实现深拷贝的例子\r\n\r\n```js\r\nlet obj = {\r\n  id:666,\r\n  info:{\r\n    name:\"张三\",\r\n    age:24\r\n  }\r\n}\r\nlet obj2 = JSON.parse(JSON.stringify(obj))// 复杂数据类型也可以使用JSON.parse(JSON.stringify(obj))\r\nobj2.info.age = 100;\r\nobj.info.age  //24\r\nobj2.info.age  // 100\r\n```\r\n\r\n> 需要注意的是JSON.parse这种方法并不是万能的，因为支持的数据类型是有限的，比如只支持object、array、string、number、boolean、null等,不支持undefined、function、正则、Date、环形obj、map、set等拷贝。\r\n\r\n### 方式二：递归拷贝\r\n> 所谓的递归拷贝就是我们通过递归的方式将无法直接拷贝的引用数据类型进行分贝拷贝。主要是考虑Array、Function、RegExp、Date、Map、Set等数据类型，同时需要考虑到循环引用并过滤掉原型身上的属性。\r\n\r\n```js\r\nfunction deepClone(target, cache = new Map()) {\r\n  if (cache.get(target)) {\r\n    return cache.get(target)\r\n  }\r\n  if (target instanceof Object) {\r\n    let dist;\r\n    if (target instanceof Array) {\r\n      // 拷贝数组\r\n      dist = [];\r\n    } else if (target instanceof Function) {\r\n      // 拷贝函数\r\n      dist = function () {\r\n        return target.call(this, ...arguments);\r\n      };\r\n    } else if (target instanceof RegExp) {\r\n      // 拷贝正则表达式\r\n      dist = new RegExp(target.source, target.flags);\r\n    } else if (target instanceof Date) {\r\n      // 拷贝日期函数\r\n      dist = new Date(target);\r\n    } else if (target instanceof Map) {\r\n      // 拷贝Map\r\n      dist = new Map(target);\r\n    } else if (target instanceof Set) {\r\n      // 拷贝Set\r\n      dist = new Set(target);\r\n    } else {\r\n      // 拷贝普通对象\r\n      dist = {};\r\n    }\r\n    // 将属性和拷贝后的值作为一个map\r\n    cache.set(target, dist);\r\n    for (let key in target) {\r\n      // 过滤掉原型身上的属性\r\n      if (target.hasOwnProperty(key)) {\r\n        dist[key] = deepClone(target[key], cache);\r\n      }\r\n    }\r\n    return dist;\r\n  } else {\r\n    return target;\r\n  }\r\n}\r\n```\r\n\r\n## 总结\r\n> 深拷贝的实现本质就是需要考虑不同数据类型该如何实现深拷贝，根据不同类型的特点来分别解决问题。"
    },
    {
      "id": "/这一次，彻底搞懂Promise",
      "metadata": {
        "permalink": "/blog/这一次，彻底搞懂Promise",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/这一次，彻底搞懂Promise.md",
        "source": "@site/blog\\这一次，彻底搞懂Promise.md",
        "title": "这一次，彻底搞懂Promise",
        "description": "一、为什么要引入Promise?",
        "date": "2022-02-12T00:00:00.000Z",
        "formattedDate": "2022年2月12日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 10.8,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "这一次，彻底搞懂Promise",
          "date": "2022-02-12T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "这一次，彻底搞懂深拷贝",
          "permalink": "/blog/这一次，彻底搞懂深拷贝"
        },
        "nextItem": {
          "title": "LeetCode——最长公共子序列（动态规划）",
          "permalink": "/blog/LeetCode——最长公共子序列（动态规划）"
        }
      },
      "content": "## 一、为什么要引入Promise?\r\n>在介绍本章之前，首先先抛出几个问题：\r\n\r\n* Promise解决了什么问题？\r\n* Promise有哪些具体的使用场景？\r\n\r\n### Promise解决了什么问题？\r\n1. 回调地狱问题\r\n\r\n> 在没有Promise之前，前端获取数据往往需要通过回调函数层层嵌套的方式来解决异步问题，例如下面这段代码实例：\r\n\r\n```js\r\n// 回调地狱实例\r\n\r\n// 奶茶函数\r\nfunction getTea(fn) {\r\n  setTimeout(() => {\r\n    fn('获取到一杯奶茶')\r\n  },2000)\r\n}\r\n\r\n// 面包函数\r\nfunction getBread(fn) {\r\n  setTimeout(() => {\r\n    fn('获取到一个面包')\r\n  },100)\r\n}\r\n\r\n// 如果必须按照顺序获取，而不是根据时间，要求是先获取到奶茶后获取到面包。\r\ngetTea(function(data) {\r\n  console.log(data);\r\n  getBread(function(data) {\r\n    console.log(data);\r\n  }) \r\n})\r\n```\r\n\r\n2. 可读性问题\r\n\r\n> 通过Promise我们可以将上面的代码重写为下面的方式，明显这样可读性更高。\r\n\r\n```js\r\n// 下面解释下，如何通过Promise来解决回调地狱的问题\r\nfunction getTea() {\r\n  return new Promise((resolve) => {\r\n    setTimeout(() => {\r\n      resolve('获取到一杯奶茶')\r\n    }, 2000)\r\n  })\r\n}\r\n\r\nfunction getBread() {\r\n  return new Promise((resolve) => {\r\n    setTimeout(() => {\r\n      resolve('获取到一个面包')\r\n    }, 500)\r\n  })\r\n}\r\n\r\ngetTea()\r\n  .then(res => {\r\n    console.log(res);\r\n    return getBread();\r\n  })\r\n  .then(res => {\r\n    console.log(res);\r\n  })\r\n```\r\n\r\n3. 信任问题(也叫回调多次执行问题)\r\n\r\n> 传统的回调函数无法保证只被执行一次，回调函数还要可能被执行其他操作，而Promise调用且仅调用一次resolve，不会产生回调多次执行的问题，所以Promise很好的解决了第三方库多次调用回调的问题。\r\n\r\n### Promise有哪些具体的使用场景？\r\n* 场景1：将图片的加载写成一个Promise，图片一旦加载完成，Promise的状态就会发生变化。\r\n* 场景2：当下一个异步请求需要依赖上一个请求结果的时候，可以通过链式操作解决问题。\r\n* 场景3：通过all()实现多个请求合并在一起，汇总所有的请求结果，只需设置一个loading即可。\r\n* 场景4：通过race()可以设置图片请求超时。\r\n\r\n## 二、手写Prromise身上的方法\r\n### 手写Promise.all\r\n> Promise.all的特点是接收的是一个可迭代对象，当这个可迭代对象中的所有元素都执行成功会返回一个数组，一个出错则立即返回错误。\r\n\r\n```js\r\nfunction myPromiseAll(iterable) {\r\n  // 首先明确要返回的对象是一个Promise\r\n  return new Promise((resolve,reject) => {\r\n    // 首先将可迭代对象转换为数组\r\n    const promises = Array.from(iterable);\r\n    let flag = 0;\r\n    const result = [];\r\n    // 开始遍历执行\r\n    for (let i = 0; i < promises.length; i++) {\r\n      Promise.resolve(promises[i]).then(res => {\r\n        result[i] = res;\r\n        flag++;\r\n        if (flag === promises.length) {\r\n          resolve(result)\r\n        }\r\n      }).catch(err => {\r\n        reject(err)\r\n      })\r\n    }\r\n  })  \r\n}\r\n```\r\n\r\n### 手写Promise.race\r\n> Promise.race函数接收的是一个可迭代对象，相当于让这个可迭代对象中的所有promise对象进行赛跑，只要有一个promise对象发生了状态变化，那么直接返回这个promise对象返回的结果。\r\n\r\n```js\r\n// 手写promise.race\r\nfunction myPromiseRace(iterator) {\r\n  // 首先返回的是一个promise对象\r\n  return new Promise((resolve,reject) => {\r\n    for (let item of iterator) {\r\n      Promise.resolve(item).then(res => {\r\n        resolve(item);\r\n      }).catch(err => {\r\n        reject(err);\r\n      })\r\n    }\r\n  })\r\n}\r\n\r\nlet p1 = new Promise(resolve => {\r\n  setTimeout(resolve, 105, 'p1 done')\r\n})\r\nlet p2 = new Promise(resolve => {\r\n  setTimeout(resolve, 100, 'p2 done')\r\n})\r\nmyPromiseRace([p1, p2]).then(data => {\r\n  console.log(data); // p2 done\r\n})\r\n```\r\n\r\n### 手写Promise.finally\r\n> Promise.finally的特点\r\n\r\n* 无论成功还是失败，都会执行这个方法\r\n* 返回的是一个Promise\r\n\r\n> Promise.finally执行的例子\r\n\r\n```js\r\nlet p = new Promise((resolve,reject) => {\r\n  setTimeout(() => {\r\n    resolve(111);\r\n  },2000)\r\n})\r\n\r\np.then(res => {\r\n  console.log(res);  // 111\r\n}).finally(() => {\r\n  console.log('无论如何这里都会被执行');  // 无论如何这里都会被执行\r\n})\r\n```\r\n\r\n> 手写Promise.finally（Promise.finally返回的本质上是一个then方法，需要在then方法中执行我们传入的参数，然后返回形参）\r\n\r\n```js\r\nPromise.prototype.finally = function(f) {\r\n  return this.then((value) => {\r\n    return Promise.resolve(f()).then(() => value)\r\n  },(err) => {\r\n    return Promise.resolve(f()).then(() => {\r\n      throw err;\r\n    })\r\n  })\r\n}\r\n```\r\n\r\n### Promise.all和Promise.race的区别\r\n> Promise.all()成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候返回的是最先被reject的值。当Promise.all()的结果是成功的时候，返回结果的数组里边的数据顺序和Promise.all()接收到的promise顺序是一致的。\r\n\r\n> promise.race表示多个Promise赛跑的意思，里面哪个结果执行的快就返回哪个结果，不管结果本身是成功还是失败，其他Promise代码还会执行，只是不会返回。\r\n\r\n### Promise.all和Promise.race的应用场景\r\n#### promise.all()的应用场景\r\n* 多个异步任务都得到结果时，进行显示的场景\r\n\r\n> 比如，当用户点击按钮时，会弹出一个对话框，这个对话框中的数据来自两个不同的后端接口获取的数据，当用户刚点击的时候，显示的时数据加载中的状态，当这两部分数据都从接口获取到数据的时候，才让数据加载中的状态消失，此时就可以使用Promise.all方法。\r\n\r\n#### Promise.race()的应用场景\r\n* 提示用户请求超时\r\n\r\n> 比如，当用户点击按钮发送请求的时候，当后端的接口超过我们设定的时间还没有获取到数据的时候，我们就可以提示用户请求超时。\r\n\r\n## 三、Promise是如何解决串行和并行的？\r\n### 什么是并行？什么是串行？\r\n> 并行：指的是多个异步请求同时进行。\r\n\r\n> 串行：一个异步请求完成之后再进行下一个请求。\r\n\r\n### Promise实现并行请求\r\n> Promise实现并行请求主要是依靠Promise.all方法和Promise.race方法，我们可以通过手写Promise.all方法或Promise.race方法来实现这一目标。\r\n\r\n### Promise实现串行请求\r\n> Promise实现串行请求主要是借助reduce函数。可以参考我的这篇文章[如何控制Promise的串行执行？](https://juejin.cn/post/7011289190461603870)\r\n\r\n```js\r\n// 借助reduce函数来实现Promise的串行执行\r\nconst funcArr = [\r\n  () => {\r\n    return new Promise((resolve) => {\r\n      setTimeout(() => {resolve(1)},2000)\r\n    })\r\n  },\r\n  () => {\r\n    return new Promise((resolve) => {\r\n      setTimeout(() => {resolve(2)},1000)\r\n    })\r\n  },\r\n  () => {\r\n    return new Promise((resolve) => {\r\n      setTimeout(() => {resolve(3)},3000)\r\n    })\r\n  },\r\n];\r\n\r\nfunction inOrder(arr) {\r\n  const res = [];\r\n  return new Promise((resolve) => {\r\n    arr.reduce((pre,cur) => {\r\n      return pre.then(cur).then(data => res.push(data))\r\n    },Promise.resolve()).then(data => resolve(res))\r\n  })\r\n}\r\n\r\ninOrder(funcArr).then(data => console.log(data))   // [1,2,3]\r\n```\r\n\r\n## 四、什么是Promise穿透？\r\n> 所谓的Promise的值穿透指的是.then或者.catch的参数希望是函数，如果传入的不是函数，则可能会发生值穿透。Promise方法通过return传值，没有return就只是相互独立的任务而已。看看下面这个例子的输出可能会更好的帮助我们理解什么是值穿透？\r\n\r\n```js\r\nPromise.resolve(1)\r\n  .then(function(){return 2})\r\n  .then(Promise.resolve(3))\r\n  .then(console.log)   // 2\r\n```\r\n\r\n> 之所以发生了值穿透就是因为第二个then中传入的不是一个函数的形式。\r\n\r\n## 五、使用Promise封装Ajax请求\r\n> 使用Promise封装Ajax请求的关键步骤，全部在下面的代码中的注释里，详情请看下面的代码。\r\n\r\n```js\r\n// 使用Promise封装Ajax请求\r\nconst res = new Promise((resolve,reject) => {\r\n  // 1. 创建一个XMLHttpRequest对象\r\n  const xhr = new XMLHttpRequest();\r\n  // 2. 初始化请求方法和URL\r\n  xhr.open('GET','https://api.apiopen.top/getJoke');\r\n  // 3. 发送请求\r\n  xhr.send();\r\n  // 4. 绑定事件，处理响应结果\r\n  xhr.onreadystatechange = function() {\r\n    if (xhr.readyState === 4) {\r\n      // 这里4代表的就是说服务端返回了全部的结果\r\n      // 如果服务端返回的状态码是2开头的，我们就resolve这个返回的结果，反之则reject对应的状态码\r\n      if (xhr.status >= 200 && xhr.status < 300) {\r\n        resolve(xhr.response)\r\n      } else {\r\n        reject(xhr.status)\r\n      }\r\n    }\r\n  }\r\n})\r\nres.then(function(value) {\r\n  console.log(value);\r\n},function(err) {\r\n  console.log(err);\r\n})\r\n```\r\n\r\n## 六、Promise有哪些状态？\r\n> Promise主要有以下三种状态：\r\n\r\n* pending状态（初始状态）\r\n* fulfilled状态(已经成功的状态)\r\n* rejected状态(已经失败的状态)\r\n\r\n### Promise状态的变化过程\r\n1. 从pending到fulfilled状态的切换\r\n\r\n> resolve前是pending状态，resolve之后是fulfilled状态\r\n\r\n```js\r\nconst p = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log('resolve前的状态：', p);\r\n    resolve();\r\n    console.log('resolve之后的状态', p);\r\n  })\r\n})\r\n```\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/478d6501e00f746426b25d16d8f1c2f9.png)\r\n\r\n2. 从pending状态到rejected状态\r\n\r\n> reject前是pending状态，reject之后是rejected状态。\r\n\r\n```js\r\nconst p = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    console.log('reject前的状态：', p);\r\n    reject();\r\n    console.log('reject之后的状态', p);\r\n  })\r\n})\r\n```\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/15873ec647ca0e3a481c9e6ae21d52e9.png)\r\n\r\n## 七、将callback改写成Promise\r\n\r\n1. 传统callback的形式\r\n\r\n```js\r\nconst fs = require('fs');\r\n\r\nfs.readFile('./temp.md',(err,data) => {\r\n  console.log(data.toString());\r\n})\r\n```\r\n\r\n2. 将callback改为promise的形式\r\n\r\n> 核心就是通过resolve来获取callback的数据。\r\n\r\n```js\r\nconst fs = require('fs');\r\n\r\nasync function myReadFile() {\r\n  let result = await new Promise((resolve,reject) => {\r\n    fs.readFile('./temp.md',(err,data) => {\r\n      resolve(data.toString());\r\n    })\r\n  })\r\n  console.log(result);   // xxxxx\r\n  return result;\r\n}\r\n\r\nmyReadFile()\r\n```"
    },
    {
      "id": "/LeetCode——最长公共子序列（动态规划）",
      "metadata": {
        "permalink": "/blog/LeetCode——最长公共子序列（动态规划）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——最长公共子序列（动态规划）.md",
        "source": "@site/blog\\LeetCode——最长公共子序列（动态规划）.md",
        "title": "LeetCode——最长公共子序列（动态规划）",
        "description": "题目描述",
        "date": "2022-02-11T00:00:00.000Z",
        "formattedDate": "2022年2月11日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 2.375,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——最长公共子序列（动态规划）",
          "date": "2022-02-11T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "这一次，彻底搞懂Promise",
          "permalink": "/blog/这一次，彻底搞懂Promise"
        },
        "nextItem": {
          "title": "JS是单线程的，那么JS是如何实现并发请求的？",
          "permalink": "/blog/JS是单线程的，那么JS是如何实现并发请求的？"
        }
      },
      "content": "## 题目描述\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/ec084e6afde668314410788e79b8cf4a.png)\r\n\r\n## 解题思路\r\n> 动态规划是解决这个题目的方法之一，动态规划之所以能够解决这个问题，关键在于构建dp[i][j]，这里的dp[i][j]表示的是第一个字符串从0到i和第二个字符串从0到j之间的最长公共子序列的长度，明白这个含义之后，就方便后续的理解了。\r\n\r\n> 假如，我们在比较第一个字符串的第i个元素和第二个字符串的第j个元素的时候，有两种情况：\r\n\r\n* 要比较的字符相等\r\n    * dp[i][j] = dp[i-1][j-1] + 1\r\n* 要比较的字符不相等\r\n    * dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1])\r\n\r\n## AC代码\r\n```js\r\nvar longestCommonSubsequence = function(text1, text2) {\r\n  // 使用表格法解决最长公共子序列\r\n  let row,column;\r\n  if (text1.length > text2.length) {\r\n    row = text2.length + 1;\r\n    column = text1.length + 1;\r\n  } else {\r\n    row = text1.length + 1;\r\n    column = text2.length + 1;\r\n    let temp = text1;\r\n    text1 = text2;\r\n    text2 = temp;\r\n  }\r\n\r\n  // 首先进行填零操作\r\n  const dp = [];\r\n  for (let i = 0; i < row; i++) {\r\n    dp[i] = new Array(column).fill(0)\r\n  }\r\n\r\n  // 从第一行的第一列开始进行遍历\r\n  for (let i = 1; i < row; i++) {\r\n    for (let j = 1; j < column; j++) {\r\n      if (text1[j-1] === text2[i-1]) {\r\n        dp[i][j] = dp[i-1][j-1] + 1;\r\n      } else {\r\n        dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);\r\n      }\r\n    }\r\n  }\r\n\r\n  return dp[row-1][column-1];\r\n\r\n};\r\n```\r\n\r\n> 上述的代码有以下几个易错点\r\n\r\n1. 哪个字符串的长度长，哪个字符串的长度+1做列。\r\n2. 如果是text2比较长，text1和text2需要进行交换。\r\n3. 构造二维数组的时候fill中填入的一定要是一个常量，否则可能会出错。\r\n\r\n## 启示\r\n> 做了很多道动态规划的题目，我们可以发现一个动态规划的核心就是搞懂dp[i][j]，只要能够搞懂这个关键变量代表的是什么含义，那么题目往往能够迎刃而解。"
    },
    {
      "id": "/JS是单线程的，那么JS是如何实现并发请求的？",
      "metadata": {
        "permalink": "/blog/JS是单线程的，那么JS是如何实现并发请求的？",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/JS是单线程的，那么JS是如何实现并发请求的？.md",
        "source": "@site/blog\\JS是单线程的，那么JS是如何实现并发请求的？.md",
        "title": "JS是单线程的，那么JS是如何实现并发请求的？",
        "description": "JS为什么能够执行并发请求？",
        "date": "2022-02-10T00:00:00.000Z",
        "formattedDate": "2022年2月10日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 3.025,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "JS是单线程的，那么JS是如何实现并发请求的？",
          "date": "2022-02-10T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "LeetCode——最长公共子序列（动态规划）",
          "permalink": "/blog/LeetCode——最长公共子序列（动态规划）"
        },
        "nextItem": {
          "title": "LeetCode——下一个排列（降序重排法）",
          "permalink": "/blog/LeetCode——下一个排列（降序重排法）"
        }
      },
      "content": "## JS为什么能够执行并发请求？\r\n> 一般情况下，在单线程中，所有的任务需要排队，前一个任务执行完毕之后，才会去执行下一个任务，如果前一个任务耗时很长，后一个任务就不得不一直等着，那么JS是如何实现并发请求的呢？或者说JS是如何实现异步请求的呢？答案就是因为有消息队列和事件循环的存在。\r\n\r\n## 什么是消息队列？\r\n> 消息队列指的是一个先进先出的队列，在这个队列中可以存在各种消息。\r\n\r\n## 什么是事件循环？\r\n> 事件循环指的是主线程重复从消息队列中获取消息、执行的过程。\r\n\r\n## 事件循环的基本流程\r\n> JS的主线程一般只会做一件事情，就是从消息队列里取出消息，然后执行消息，再取出消息然后再执行，当消息队列为空时，就会等待直到消息队列中有消息的存在，而且主线程只有再将当前的消息执行完成之后，才会去执行下一个消息，这种机制就是事件循环机制。\r\n\r\n## 事件循环的例子\r\n> 请看下面的一段代码，我们来详细介绍下事件循环中代码的执行流程是什么？\r\n\r\n```js\r\nconsole.log('main1');\r\n\r\nprocess.nextTick(function() {\r\n    console.log('process.nextTick1');\r\n});\r\n\r\nsetTimeout(function() {\r\n    console.log('setTimeout');\r\n    process.nextTick(function() {\r\n        console.log('process.nextTick2');\r\n    });\r\n}, 0);\r\n\r\nnew Promise(function(resolve, reject) {\r\n    console.log('promise');\r\n    resolve();\r\n}).then(function() {\r\n    console.log('promise then');\r\n});\r\n\r\nconsole.log('main2');\r\n```\r\n\r\n> 正确的执行顺序请看下方的结果：\r\n\r\n* main1\r\n* promise\r\n* main2\r\n* process.nextTick1\r\n* promise then\r\n* setTimeout\r\n* process.nextTick2\r\n\r\n> 详细分析：\r\n> 事件循环在执行上流程上，首先将全局代码当作一个宏任务，会先执行这个宏任务，执行这个宏任务的时候，会首先执行同步代码，遇到微任务就添加到微任务队列，遇到宏任务就会添加到宏任务队列，当同步代码执行完毕的时候，会开始执行微任务队列中的任务，执行完毕之后会执行宏任务队列中的任务，所以，本题最重要的就是要区分好宏任务是什么，微任务是什么，setTimeout中的回调函数时宏任务，process.nextTick是微任务，所以执行顺序是上面的结果。"
    },
    {
      "id": "/LeetCode——下一个排列（降序重排法）",
      "metadata": {
        "permalink": "/blog/LeetCode——下一个排列（降序重排法）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——下一个排列（降序重排法）.md",
        "source": "@site/blog\\LeetCode——下一个排列（降序重排法）.md",
        "title": "LeetCode——下一个排列（降序重排法）",
        "description": "题目描述",
        "date": "2022-02-09T00:00:00.000Z",
        "formattedDate": "2022年2月9日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 2.48,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——下一个排列（降序重排法）",
          "date": "2022-02-09T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "JS是单线程的，那么JS是如何实现并发请求的？",
          "permalink": "/blog/JS是单线程的，那么JS是如何实现并发请求的？"
        },
        "nextItem": {
          "title": "JavaScript中string是个基本类型，但是它的string.length是怎么实现的？",
          "permalink": "/blog/JavaScript中string是个基本类型，但是它的string.length是怎么实现的？"
        }
      },
      "content": "## 题目描述\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/a7984eef838c356a53661cce50ace4e2.png)\r\n\r\n## 解题思路\r\n### 第一步：从右往左倒着找看是否有降序元素的存在\r\n> 如果有降序元素的存在则进行标记，可以设置一个变量来帮助我们标记。加入nums[right] > nums[right-1]，我们此时要记录这个right-1的位置后续有用，如果没有降序元素的存在，则直接进行升序排列即可，不用再看下面的步骤了，直接返回。\r\n\r\n### 第二步：从降序位置往后的所有元素进行一次升序排列\r\n\r\n### 第三步：对升序排列的数组进行遍历找到第一个比right元素大的元素，进行交换\r\n\r\n### 第四步：交换后进行二次升序排列。\r\n\r\n## AC代码\r\n\r\n```js\r\nvar nextPermutation = function(nums) {\r\n  // 下一个排列要求的是原地排序\r\n  let flag = false;\r\n  let right = nums.length - 1;\r\n  // 第一步：从右往左进行遍历，查找是否有降序元素的存在\r\n  while (right) {\r\n    if (nums[right] > nums[right-1]) {\r\n      flag = true;\r\n      right--;\r\n      break;\r\n    } else {\r\n      right--;\r\n    }\r\n  }\r\n\r\n  if (flag) {\r\n    const sorted = nums.splice(right + 1).sort((next,pre) => next - pre);\r\n    // 找到排序好的数组的第一个比nums[right]的元素，然后进行交换\r\n    let temp;\r\n    for (let i = 0; i < sorted.length; i++) {\r\n      if (sorted[i] > nums[right]) {\r\n        temp = i;\r\n        break;\r\n      }\r\n    }\r\n    let t = nums[right];\r\n    nums[right] = sorted[temp];\r\n    sorted[temp] = t;\r\n    // 对sorted进行二次排序\r\n    sorted.sort((next,pre) => next - pre);\r\n    // 进行拼接\r\n    nums.push(...sorted);\r\n  } else {\r\n    nums.sort((next,pre) => next - pre)\r\n  }\r\n\r\n};\r\n```\r\n\r\n## 总结\r\n> 下一个排列这个题目是一道高频考题，核心思路就是理解整个题目的意思，难点不在写代码上，难点在理解这个思路上，只要我们能够安装上文介绍的解题思路进行解题，很快就能解决这个问题，本题的可能不好想，因为倒序本身就不符合常规思维，但是多加练习就能理解的。\r\n\r\n## 参考文献\r\n* [HOT100——下一个排列（JS实现）](https://juejin.cn/post/6982746312764555271)"
    },
    {
      "id": "/JavaScript中string是个基本类型，但是它的string.length是怎么实现的？",
      "metadata": {
        "permalink": "/blog/JavaScript中string是个基本类型，但是它的string.length是怎么实现的？",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/JavaScript中string是个基本类型，但是它的string.length是怎么实现的？.md",
        "source": "@site/blog\\JavaScript中string是个基本类型，但是它的string.length是怎么实现的？.md",
        "title": "JavaScript中string是个基本类型，但是它的string.length是怎么实现的？",
        "description": "JS的基本类型和引用类型",
        "date": "2022-02-08T00:00:00.000Z",
        "formattedDate": "2022年2月8日",
        "tags": [
          {
            "label": "JavaScript基础",
            "permalink": "/blog/tags/java-script基础"
          }
        ],
        "readingTime": 2.385,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "JavaScript中string是个基本类型，但是它的string.length是怎么实现的？",
          "date": "2022-02-08T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "JavaScript基础",
          "tags": [
            "JavaScript基础"
          ]
        },
        "prevItem": {
          "title": "LeetCode——下一个排列（降序重排法）",
          "permalink": "/blog/LeetCode——下一个排列（降序重排法）"
        },
        "nextItem": {
          "title": "使用Python通过API对Github进行爬虫的思路",
          "permalink": "/blog/使用Python通过API对Github进行爬虫的思路"
        }
      },
      "content": "## JS的基本类型和引用类型\r\n### 基本类型\r\n> JS的基本类型有undefined、null、boolean、string、number、bigint、symbol。基本类型的值保存在栈中，访问的时候直接访问的是值本身。\r\n\r\n### 引用类型\r\n> JS的引用类型有Object、Array、Date、RegExp、Function、Map、Set。引用类型的值是保存在堆内存中的地址，访问的时候访问的是这个地址。我们知道引用类型一般有属性和方法，但是上文我们提到了string是一个基本类型，那么它为什么会有.length这个方法呢？请看下文的详细介绍。\r\n\r\n## 基本包装类型\r\n> 在JS的基本类型中其中有三个是基本包装类型，其中包括有：Boolean、String、Number,这三个基本包装类型和其他引用类型一样，拥有内置的方法可以对数据进行操作。\r\n\r\n> `注意：并不是基本类型string执行了自身的方法，而是JS为它创建了一个对应的基本包装类型String,它根据基本类型的值实例化出了一个实例，让这个实例去调用指定的方法，最后销毁自己。由于这个自销毁特性的存在，我们不能为基本类型的值添加自定义属性和方法。`\r\n\r\n## 自定义使用基本包装类型\r\n* 通过new String来自定义使用基本包装类型\r\n\r\n```js\r\n// 自定义创建基本包装类型\r\nconst str = new String('haha');\r\nconsole.log(str.toUpperCase());  //HAHA\r\n```\r\n\r\n* 直接字面量的string和通过new String创建的有什么区别？\r\n\r\n> 通过字面量进行直接赋值的形式本质是一个基本数据类型string，但是通过new String创建的本质是一个object对象。\r\n\r\n```js\r\nconst strs = new String('1111');\r\nconst str2 = '2222';\r\n\r\nconsole.log(typeof strs); //object\r\nconsole.log(typeof str2); //string\r\n```\r\n\r\n\r\n## 参考文献\r\n* [【JS】基本包装类型](https://segmentfault.com/a/1190000021961278)\r\n\r\n* [JavaScript中为什么string可以拥有方法？](https://www.cnblogs.com/SheilaSun/p/4765394.html)"
    },
    {
      "id": "/使用Python通过API对Github进行爬虫的思路",
      "metadata": {
        "permalink": "/blog/使用Python通过API对Github进行爬虫的思路",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/使用Python通过API对Github进行爬虫的思路.md",
        "source": "@site/blog\\使用Python通过API对Github进行爬虫的思路.md",
        "title": "使用Python通过API对Github进行爬虫的思路",
        "description": "一、从GitHub Advisory上获取Rust漏洞数据的方法",
        "date": "2022-02-06T00:00:00.000Z",
        "formattedDate": "2022年2月6日",
        "tags": [
          {
            "label": "Python",
            "permalink": "/blog/tags/python"
          }
        ],
        "readingTime": 2.42,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "使用Python通过API对Github进行爬虫的思路",
          "date": "2022-02-06T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Python",
          "tags": [
            "Python"
          ]
        },
        "prevItem": {
          "title": "JavaScript中string是个基本类型，但是它的string.length是怎么实现的？",
          "permalink": "/blog/JavaScript中string是个基本类型，但是它的string.length是怎么实现的？"
        },
        "nextItem": {
          "title": "通过API接口实现提交订单云打印小票、格式化日期",
          "permalink": "/blog/通过API接口实现提交订单云打印小票、格式化日期"
        }
      },
      "content": "## 一、从GitHub Advisory上获取Rust漏洞数据的方法\r\n> 执行下面的语句即可：\r\n```shell\r\npython github_advisory_rust_vulnerability_first.py\r\n```\r\n\r\n### 增量更新方法\r\n> 执行下面的语句即可：\r\n\r\n```shell\r\npython github_advisory_rust_update.py\r\n```\r\n\r\n\r\n\r\n## 二、获取Cargo的第三方依赖数据的方法\r\n\r\n> 执行下面的程序\r\n\r\n```shell\r\npython3 Get_Cargo_First.py\r\npython3 clean_dataset.py\r\n```\r\n\r\n> 将cargo数据集：cargo_dependency_datasets.json\r\n\r\n### 增量更新的方法\r\n\r\n> 首先执行下面的语句：\r\n\r\n```shell\r\npython3 Get_Cargo_First.py\r\n```\r\n\r\n> 接着执行下面的语句：\r\n\r\n```shell\r\npython3 cargo_update.py\r\n```\r\n\r\n> 最后将产生这样的数据集：cargo_dependency_datasets.json 和 cargo_hashtable.json\r\n\r\n## 三、从Rust官方维护的漏洞数据库中获取数据的思路\r\n> 下面是Rust官方维护的漏洞数据库对应的网址：\r\n\r\nhttps://rustsec.org/\r\n\r\n> 下面是Rust官方维护的漏洞数据库对应的Github仓库的地址：\r\n\r\nhttps://github.com/RustSec/advisory-db\r\n\r\n> 下面是仓库API对应的地址：\r\n\r\nhttps://api.github.com/repos/rustsec/advisory-db/contents\r\n\r\n> 下面是API使用的参考文档：\r\n\r\nhttps://docs.github.com/en/rest/reference/repos#get-repository-content\r\n\r\n一、找到所有的漏洞地址\r\n\r\n1. 要考虑到仓库中的两个入口点：\r\n\r\n    * crates\r\n    * rust\r\n    \r\n> crates对应的url是：\r\n\r\nhttps://api.github.com/repos/rustsec/advisory-db/contents/crates?ref=main\r\n\r\n> rust对应的url是：\r\n\r\nhttps://api.github.com/repos/rustsec/advisory-db/contents/rust?ref=main\r\n\r\n2. 找到两个入口点的所有的元素对应的md文档\r\n\r\n> 以rust为出发点，找到的每一个元素的URL项的URL，是每一个漏洞对应的URL。\r\n\r\n> 以crates为出发点，找到每一个元素对应的URL项的URL，也是每一个漏洞对应的URL。\r\n\r\n3. 将所有的url构造一个URLS为最终的url集合。\r\n\r\n4. 向URLS中的每一个URL发起请求，将其中的content值进行base64解码，然后通过正则解析的方式获取关键信息，其中id作为key，然后整个元素作为value。\r\n\r\n\r\n## 四、RustSec数据获取与更新\r\n\r\n1. 爬取RustSec数据的方法，只需运行下面的语句。\r\n\r\n```py\r\npython3 rustsec_crawler.py\r\n```\r\n\r\n>将输出 RustSec_Dataset.json 与 RustSec_HashTable.json\r\n\r\n2. 增量更新的方法\r\n\r\n```py\r\npython3 rustsec_update.py\r\n```\r\n\r\n>将更新 RustSec_Dataset.json 与 RustSec_HashTable.json"
    },
    {
      "id": "/通过API接口实现提交订单云打印小票、格式化日期",
      "metadata": {
        "permalink": "/blog/通过API接口实现提交订单云打印小票、格式化日期",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/通过API接口实现提交订单云打印小票、格式化日期.md",
        "source": "@site/blog\\通过API接口实现提交订单云打印小票、格式化日期.md",
        "title": "通过API接口实现提交订单云打印小票、格式化日期",
        "description": "一、硬件介绍",
        "date": "2022-02-05T00:00:00.000Z",
        "formattedDate": "2022年2月5日",
        "tags": [
          {
            "label": "Egg.js",
            "permalink": "/blog/tags/egg-js"
          }
        ],
        "readingTime": 2.455,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "通过API接口实现提交订单云打印小票、格式化日期",
          "date": "2022-02-05T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Egg.js",
          "tags": [
            "Egg.js"
          ]
        },
        "prevItem": {
          "title": "使用Python通过API对Github进行爬虫的思路",
          "permalink": "/blog/使用Python通过API对Github进行爬虫的思路"
        },
        "nextItem": {
          "title": "从零开始使用Neo4j构建知识图谱（二）",
          "permalink": "/blog/从零开始使用Neo4j构建知识图谱（二）"
        }
      },
      "content": "## 一、硬件介绍\r\n* 一台能够实现wifi自动接单的云打印机\r\n* 可以参考飞蛾云打印机（https://www.feieyun.com/）\r\n\r\n## 二、云打印机的使用方法\r\n> 还是以上文提到的飞蛾云打印机为例，进行介绍：\r\n\r\n1. 给打印机连接电源。\r\n2. 给打印机装上打印纸。\r\n3. 配置打印机WiFi密码。\r\n4. 通过打印机的二维码来配置设备，并进行测试打印。\r\n\r\n## 三、开发者接入云打印的方法\r\n1. 通过飞蛾云打印的开放平台。\r\n2. 通过文档注册账户。\r\n3. 下载对应的SDK。\r\n4. 配置SDK，并进行测试打印。\r\n\r\n> 云打印机的SDK本质就是一个实现打印的Demo，针对不同的开发语言。\r\n\r\n## 四、格式化日期\r\n> 在Vue2中，我们可以使用过滤器对日期进行格式化，但是Vue3中去除了这个过滤器，官方建议使用计算属性或者自定义方法来对日期进行格式化。\r\n\r\n> 下面主要介绍如何通过第三方模块moment，进行日期格式化。\r\n\r\n1. 在项目中安装模块\r\n\r\n```shell\r\n npm i moment --save\r\n```\r\n\r\n2. 在vue的指定页面中引入moment\r\n\r\n```js\r\nimport moment from 'moment'\r\n```\r\n\r\n3. 定义一个方法\r\n\r\n> 首先定义一个模式串，然后通过moment将毫秒变为秒，然后利用我们的模式串进行转换。\r\n\r\n```js\r\ngetTime(time: any) {\r\n  const pattern = \"YYYY-MM-DD hh:mm:ss\";\r\n  return moment(time * 1000).format(pattern)\r\n}\r\n```\r\n\r\n4. 在模板中调用我们上文定义好的方法\r\n\r\n```js\r\n<div class=\"order_time\">下单时间：{{getTime(list.addTime)}}</div>\r\n```\r\n\r\n5. 此时毫秒的数据将变为年月日的时间格式。\r\n\r\n## 格式化日期模式串的参数含义\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/e00b56a06cdc2848b2d345ee28e5b8d1.png)\r\n\r\n[参考文献](https://blog.csdn.net/ZYS10000/article/details/104737438)\r\n\r\n## 总结\r\n> 我们常见的扫码点餐实现云打印小票的实现原理就是服务器通过SDK下达打印的指令，然后通过WIFI传递给打印机，从而实现云打印。"
    },
    {
      "id": "/从零开始使用Neo4j构建知识图谱（二）",
      "metadata": {
        "permalink": "/blog/从零开始使用Neo4j构建知识图谱（二）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/从零开始使用Neo4j构建知识图谱（二）.md",
        "source": "@site/blog\\从零开始使用Neo4j构建知识图谱（二）.md",
        "title": "从零开始使用Neo4j构建知识图谱（二）",
        "description": "一、Neo4j导入导出数据库",
        "date": "2022-02-03T00:00:00.000Z",
        "formattedDate": "2022年2月3日",
        "tags": [
          {
            "label": "Neo4j",
            "permalink": "/blog/tags/neo-4-j"
          }
        ],
        "readingTime": 2.215,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "从零开始使用Neo4j构建知识图谱（二）",
          "date": "2022-02-03T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Neo4j",
          "tags": [
            "Neo4j"
          ]
        },
        "prevItem": {
          "title": "通过API接口实现提交订单云打印小票、格式化日期",
          "permalink": "/blog/通过API接口实现提交订单云打印小票、格式化日期"
        },
        "nextItem": {
          "title": "使用腾讯云ServerLess部署Egg.js（项目问题排查记录）",
          "permalink": "/blog/使用腾讯云ServerLess部署Egg.js（项目问题排查记录）"
        }
      },
      "content": "## 一、Neo4j导入导出数据库\r\n\r\n### 导入数据库\r\n> 有时候，我们想要直接导入一个数据库，Neo4j的数据库文件的后缀有一种时dump形式。\r\n\r\n1. 点击增加文件到项目中\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/e77cb204843f4995da22ef0bb7605283.png)\r\n\r\n2. 选择从dump文件创建新的数据库\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/2a56cd420fa4113f2a012b1cd7b7de73.png)\r\n\r\n3. 为新数据库设定数据库名和密码\r\n\r\n4. 启动项目\r\n\r\n### 导出数据库\r\n> 导出数据库主要包括以下几个步骤。\r\n\r\n1. 通过Neo4j Browser暂停数据库服务\r\n\r\n2. 通过相关命令行输入下面的代码\r\n\r\n```shell\r\nbin/neo4j-admin dump --database=neo4j --to=/dumps/neo4j/neo4j-<timestamp>.dump\r\n```\r\n\r\n> 注意事项：首先我们必须在对应的项目的bin目录中输入上面的命令，下面介绍下如何定位到bin目录\r\n\r\n* 首先进入相关项目的命令行\r\n* 输入ls查看当前所在的位置\r\n* 从这个位置出发找到bin目录\r\n\r\n> --to后面跟的其实是对应盘的根目录。\r\n\r\n## 二、通过py2neo执行Cypher语句\r\n> 主要是通过run方法来执行相关语句，返回的是一个迭代器，这个迭代器只有通过遍历才能够获取数据。\r\n\r\n```py\r\nfind_test = graph.run(\"match (n:Person{name: 'test_node'}) return n\")\r\nfor i in find_test:\r\n    print(i)\r\n```\r\n\r\n## 三、删除节点之间的关系\r\n> 注意：下面的删除方法可能会把相应的节点也删掉。\r\n\r\n```shell\r\nMATCH (p1:Dependency)-[r:依赖于]-(p2:Dependency) DELETE r\r\n```\r\n\r\n## 四、基本查询方法\r\n\r\n1. 显示数据库的状态\r\n\r\n```shell\r\nSHOW DATABASE neo4j;\r\n```\r\n\r\n2. 显示所有数据库的状态\r\n\r\n```shell\r\nSHOW DATABASES;\r\n```\r\n\r\n3. 创建数据库\r\n\r\n```shell\r\nCREATE DATABASE sales;\r\n```\r\n\r\n4. 切换数据库\r\n\r\n```shell\r\n:use sales\r\n```\r\n\r\n5. 停止数据库\r\n\r\n```shell\r\nSTOP DATABASE sales;\r\n```\r\n\r\n6. 启动数据库\r\n\r\n```shell\r\n:use system\r\nSTART DATABASE sales;\r\n```\r\n\r\n## 官方参考文档\r\n* [Neo4j官方文档](https://neo4j.com/docs/operations-manual/current/backup-restore/offline-backup/)"
    },
    {
      "id": "/使用腾讯云ServerLess部署Egg.js（项目问题排查记录）",
      "metadata": {
        "permalink": "/blog/使用腾讯云ServerLess部署Egg.js（项目问题排查记录）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/使用腾讯云ServerLess部署Egg.js（项目问题排查记录）.md",
        "source": "@site/blog\\使用腾讯云ServerLess部署Egg.js（项目问题排查记录）.md",
        "title": "使用腾讯云ServerLess部署Egg.js（项目问题排查记录）",
        "description": "问题描述",
        "date": "2022-02-02T00:00:00.000Z",
        "formattedDate": "2022年2月2日",
        "tags": [
          {
            "label": "ServerLess",
            "permalink": "/blog/tags/server-less"
          }
        ],
        "readingTime": 2.79,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "使用腾讯云ServerLess部署Egg.js（项目问题排查记录）",
          "date": "2022-02-02T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "ServerLess",
          "tags": [
            "ServerLess"
          ]
        },
        "prevItem": {
          "title": "从零开始使用Neo4j构建知识图谱（二）",
          "permalink": "/blog/从零开始使用Neo4j构建知识图谱（二）"
        },
        "nextItem": {
          "title": "从零开始使用Neo4j构建知识图谱（一）",
          "permalink": "/blog/从零开始使用Neo4j构建知识图谱（一）"
        }
      },
      "content": "## 问题描述\r\n> 博主在使用serverless部署egg.js项目时，由于该项目已经多次部署过，所以直接使用了serverless deploy命令，在然后通过云函数的控制台中自动进行了安装依赖，发现出现了405错误，这在平时从未发生过，然后我开始了耗时一下午的Bug排查，下面介绍下Bug排查的过程。\r\n\r\n## 1. 检查代码是否写错\r\n> 博主首先对更新的代码进行了检查，由于更新代码只是一个后端返回的API内容上的修改，所以几乎不可能是更新代码的问题，因此这个原因被排除了。\r\n\r\n## 2. 查看最新文档\r\n> 下面是官方给出的最新文档：\r\n\r\n* [快速部署 Egg 框架](https://cloud.tencent.com/document/product/1154/40492)\r\n\r\n> 通过查询官方文档，我们能够发现官方文档发生了下面的变化。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/118dc519cac4904651131feb74e50de9.png)\r\n\r\n> 也就是说，需要给项目添加一个`scf_bootstrap`启动文件到项目的根目录，通过查看这个文件的代码，我们可以发现其实我们不需要修改什么，只需要复制就行。于是我在项目中添加了这个文件，重新部署后发现还是报405的错误，这又是为什么呢？\r\n\r\n## 3. 给文件添加权限\r\n> 通过仔细查看文档和咨询相关的售后人员，他们说需要给启动文件添加权限。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/c0f050035c7c52d686eb825670b024b8.png)\r\n\r\n> 我们可以发现chmod其实是一个linux命令，那么我们该如何在windows下执行呢?答案是通过git命令行工具去执行即可。\r\n\r\n## 4. 确保部署文件和对应的serverless应用一致\r\n> 在serverless项目中有一个非常重要的文件就是serverless.yml配置文件，这个配置文件需要和我们的应用中的相关信息保持一致。\r\n\r\n## 5. 通过云函数的命令行安装依赖\r\n> 云函数的自动安装依赖有时候会无效，因此通过命令行安装依赖很重要。\r\n\r\n```shell\r\ncd src\r\nnpm i\r\n```\r\n\r\n## 总结\r\n> 要想确保云函数的部署成功， 最关键的是要保证serverless.yml文件和启动文件授权。"
    },
    {
      "id": "/从零开始使用Neo4j构建知识图谱（一）",
      "metadata": {
        "permalink": "/blog/从零开始使用Neo4j构建知识图谱（一）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/从零开始使用Neo4j构建知识图谱（一）.md",
        "source": "@site/blog\\从零开始使用Neo4j构建知识图谱（一）.md",
        "title": "从零开始使用Neo4j构建知识图谱（一）",
        "description": "一、安装Neo4j",
        "date": "2022-02-01T00:00:00.000Z",
        "formattedDate": "2022年2月1日",
        "tags": [
          {
            "label": "Neo4j",
            "permalink": "/blog/tags/neo-4-j"
          }
        ],
        "readingTime": 2.09,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "从零开始使用Neo4j构建知识图谱（一）",
          "date": "2022-02-01T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Neo4j",
          "tags": [
            "Neo4j"
          ]
        },
        "prevItem": {
          "title": "使用腾讯云ServerLess部署Egg.js（项目问题排查记录）",
          "permalink": "/blog/使用腾讯云ServerLess部署Egg.js（项目问题排查记录）"
        },
        "nextItem": {
          "title": "LeetCode——删除链表的倒数第N个节点（快慢指针）",
          "permalink": "/blog/LeetCode——删除链表的倒数第N个节点（快慢指针）"
        }
      },
      "content": "## 一、安装Neo4j\r\n>下面是官方文档：https://neo4j.com/download/ 通过上述网址下载后，记住弹出的key，后续软件的激活需要使用到这个key。\r\n\r\n## 二、基础使用方法\r\n1. 新建项目\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/c400736cd64fe60b234662497057b195.png)\r\n\r\n2.更改项目名\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/b4f361720e1a8616d921452d547712b3.png)\r\n\r\n3. 建立本地数据库或者远程数据库\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/da4db96bf0e744a79022cb98eb66f47d.png)\r\n\r\n4. 启动本地数据库\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/88d4c6a2f71e68708a7a071fb9e92f39.png)\r\n\r\n5. 通过Neo4j Broswer进行操作\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/bbfe110fc5ef595c373496e14be392e0.png)\r\n\r\n## 节点操作\r\n1. 创建节点\r\n\r\n```shell\r\ncreate(:大学{name:\"西安电子科技大学\"})\r\n```\r\n\r\n2. 查看构建好的节点图\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/dc37f8e846e913af3fee861edca6ad96.png)\r\n\r\n3. 调整节点显示字体的大小\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/9c8dc157ba5d3bd76d781fa5ce3a2260.png)\r\n\r\n4. 获取所有节点\r\n\r\n```shell\r\nmatch(n) return (n)\r\n```\r\n\r\n> 下面重点介绍下如何通过py2neo来对Neo4j进行操作。\r\n\r\n5. 查询节点\r\n\r\n```py\r\ncreated_node = matcher[node_id]\r\nprint(created_node)\r\n```\r\n\r\n6. 附带条件的查询\r\n\r\n```py\r\nmatcher.match('判决文书').where(name = 'XXX刑事判决书').first()\r\n```\r\n\r\n7. 返回符合条件的一个节点\r\n\r\n```py\r\ntemp = selector.match('Person').first()\r\n```\r\n\r\n8. 增加和修改节点的属性值\r\n\r\n```py\r\ntemp['name'] = '001'\r\n```\r\n\r\n9. 增加标签\r\n\r\n```py\r\ntemp.add_label('案件')\r\ngraph.push(temp)\r\n```\r\n\r\n10. 删除节点\r\n\r\n```py\r\ngraph.delete(node)\r\n```\r\n\r\n11. 创建节点\r\n\r\n```py\r\nnode = Node('人', name = '张三')\r\ngraph.create(node)\r\n```\r\n\r\n## 使用py2neo连接数据库\r\n\r\n```py\r\nfrom py2neo import Graph,Node,Relationship,Subgraph\r\nfrom py2neo.matching import *\r\n\r\n\r\ngraph = Graph(\"bolt://localhost:7687\", auth=(\"neo4j\", \"1234\"))\r\nsuccess = graph.run(\"UNWIND range(1, 3) AS n RETURN n, n * n as n_sq\")\r\nif (success):\r\n  print(\"连接成功\")\r\n```\r\n\r\n\r\n## 总结\r\n> py2neo是一个操作Neo4j的python第三方库，我们可以边查询边使用，非常方便，重点参考官方文档和下文的一些重点参考文档。\r\n\r\n## 参考文档\r\n* [用py2neo对Neo4j进行数据的增删改查：节点](https://www.cnblogs.com/starmon/p/15412184.html)\r\n\r\n* [neo4j︱与python结合的py2neo使用教程](https://blog.csdn.net/sinat_26917383/article/details/79901207)\r\n\r\n* [py2neo的简单使用（1）](https://blog.csdn.net/qq_38486203/article/details/79826028)"
    },
    {
      "id": "/LeetCode——删除链表的倒数第N个节点（快慢指针）",
      "metadata": {
        "permalink": "/blog/LeetCode——删除链表的倒数第N个节点（快慢指针）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——删除链表的倒数第N个节点（快慢指针）.md",
        "source": "@site/blog\\LeetCode——删除链表的倒数第N个节点（快慢指针）.md",
        "title": "LeetCode——删除链表的倒数第N个节点（快慢指针）",
        "description": "题目描述",
        "date": "2022-01-30T00:00:00.000Z",
        "formattedDate": "2022年1月30日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 2.515,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——删除链表的倒数第N个节点（快慢指针）",
          "date": "2022-01-30T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "从零开始使用Neo4j构建知识图谱（一）",
          "permalink": "/blog/从零开始使用Neo4j构建知识图谱（一）"
        },
        "nextItem": {
          "title": "轻量级服务器通过nginx部署express项目",
          "permalink": "/blog/轻量级服务器通过nginx部署express项目"
        }
      },
      "content": "## 题目描述\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/897a6d3ff3223bcd873c903ef8be95b8.png)\r\n\r\n## 解题思路\r\n> 删除链表的倒数第N个结点，有很多种解法，本次我们重点介绍的是快慢指针法，快慢指针在解决链表问题的时候，通常能够快速解决问题，这主要取决于快慢指针的特点。\r\n\r\n### 快慢指针为什么能够找到链表的倒数第N个节点\r\n> 假设一个链表有五个节点，我们想要删除倒数第2个节点，我们首先让快指针、从第一个节点的位置触发，走2+1个节点，我们能够发现此时快指针有两种情况，一是走到了null，二是走到了倒数倒数第2个节点，此时我们分情况讨论：\r\n\r\n* 快指针走到了null，此时如果还没有走完n + 1个节点\r\n    * 让满秩阵继续走完剩余的节点数量，然后返回慢指针即可。\r\n* 快指针走到了倒数第N个节点\r\n    * 此时快慢指针同时继续走，一旦快指针走到了null，删除慢指针的下一个节点，然后返回头指针即可。\r\n    \r\n## 解题代码\r\n```js\r\nvar removeNthFromEnd = function(head, n) {\r\n  // 删除链表的倒数第N个节点是一个典型的双指针问题\r\n  let slow = head;\r\n  let fast = head;\r\n  let temp = head;\r\n  // 第一步：让快指针先走n步\r\n  let count = n+1;\r\n  while (count && fast) {\r\n    fast = fast.next;\r\n    count--;\r\n  }\r\n  if (!fast && count) {\r\n    while (count) {\r\n      slow = slow.next;\r\n      count--;\r\n    }\r\n    return slow;\r\n  }\r\n  while (fast) {\r\n    fast = fast.next;\r\n    slow = slow.next;\r\n  }\r\n  let stemp = slow.next.next;\r\n  slow.next = stemp;\r\n  return temp;\r\n};\r\n```\r\n\r\n## 题目反思\r\n> 删除链表的倒数第N个节点，快慢指针是一种经典的方法，快慢指针不仅能够解决这道题目，在面试中还经常考查到判断链表是否由环，这个也是快慢指针的经典应用，因此，在解决问题的时候，我们一定要学会举一反三，寻找规律。"
    },
    {
      "id": "/轻量级服务器通过nginx部署express项目",
      "metadata": {
        "permalink": "/blog/轻量级服务器通过nginx部署express项目",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/轻量级服务器通过nginx部署express项目.md",
        "source": "@site/blog\\轻量级服务器通过nginx部署express项目.md",
        "title": "轻量级服务器通过nginx部署express项目",
        "description": "功能描述",
        "date": "2022-01-29T00:00:00.000Z",
        "formattedDate": "2022年1月29日",
        "tags": [
          {
            "label": "nginx",
            "permalink": "/blog/tags/nginx"
          }
        ],
        "readingTime": 3.135,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "轻量级服务器通过nginx部署express项目",
          "date": "2022-01-29T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "nginx",
          "tags": [
            "nginx"
          ]
        },
        "prevItem": {
          "title": "LeetCode——删除链表的倒数第N个节点（快慢指针）",
          "permalink": "/blog/LeetCode——删除链表的倒数第N个节点（快慢指针）"
        },
        "nextItem": {
          "title": "VSCode插件remote-ssh无法连接服务器的解决办法",
          "permalink": "/blog/VSCode插件remote-ssh无法连接服务器的解决办法"
        }
      },
      "content": "## 功能描述\r\n> 博主在使用serverless搭建egg.js项目时发现，serverless目前还不支持socket.io，但是博主还是希望使用这个功能的，所以选择了购买轻量级服务器自己搭建，下面介绍下搭建的方法，自己搭建的好处是过程更加透明可控，缺点是比较繁琐，把这个过程写出来，让更多的开发者减少部署的难度，下面让我们来一起开始学习吧~\r\n\r\n## 部署前的准备\r\n1. 一台linux服务器。\r\n2. 能够直接本地运行的前端项目。\r\n\r\n## 服务器端设置\r\n### 1. 安装node环境\r\n\r\n```shell\r\nwget https://nodejs.org/dist/v12.18.1/node-v12.18.1-linux-x64.tar.xz   \r\ntar xf node-v12.18.1-linux-x64.tar.xz                                \r\ncd node-v12.18.1-linux-x64   \r\n```\r\n\r\n### 2. 配置node\r\n\r\n```shell\r\ncp /etc/profile /etc/profile.bak\r\nexport PATH=$PATH:/root/node-v12.18.1-linux-x64/bin\r\nsource /etc/profile\r\n```\r\n\r\n### 3. 测试node是否安装完成\r\n\r\n```shell\r\nnode -v\r\n```\r\n\r\n### 4. 安装forever\r\n\r\n```js\r\nnpm install forever -g\r\n```\r\n\r\n### 5. 将node、npm、forever等工具加入到全局变量中\r\n\r\n```shell\r\nln -s /usr/local/src/nodejs/bin/node /usr/local/bin/node\r\nln -s /usr/local/src/nodejs/bin/npm /usr/local/bin/npm\r\n```\r\n\r\n> 加入的过程中要注意上面路径中的node.js中的文件名，要根据自己的实际路径来。\r\n\r\n### 6. 启动前端项目\r\n```shell\r\nforever start app.js\r\n```\r\n\r\n### 7. 安装nginx\r\n```shell\r\nyum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel\r\n```\r\n\r\n### 8. 下载并解压安装包\r\n```shell\r\ncd /usr/local\r\nmkdir nginx\r\ncd nginx\r\n//下载tar包\r\nwget http://nginx.org/download/nginx-1.13.7.tar.gz\r\ntar -xvf nginx-1.13.7.tar.gz\r\n```\r\n\r\n### 9. 执行nginx相关命令\r\n```shell\r\n//进入nginx目录\r\ncd /usr/local/nginx\r\n//进入目录\r\ncd nginx-1.13.7\r\n//执行命令\r\n./configure\r\n//执行make命令\r\nmake\r\n//执行make install命令\r\nmake install\r\n```\r\n\r\n### 10. 配置nginx.conf\r\n```shell\r\nvi /usr/local/nginx/conf/nginx.conf\r\n```\r\n\r\n### 11. 启动nginx\r\n```shell\r\n/usr/local/nginx/sbin/nginx -s reload\r\n```\r\n\r\n## nginx.conf的写法\r\n> 将前端项目部署到服务器上，最关键的就是nginx.conf的写法，只要这个文件写的正确，几乎就快部署成功了。\r\n\r\n> 快速查找nginx.conf文件的方法：\r\n\r\n```shell\r\nlocate nginx.conf\r\n```\r\n\r\n> nginx.conf的写法：\r\n\r\n* [CodeSandBox在线地址](https://codesandbox.io/s/async-https-9mj0v?file=/nginx.conf)\r\n\r\n> 配置文件说明：\r\n\r\n```shell\r\nserver {\r\n    listen 80;\r\n    server_name 124.223.104.214;\r\n}\r\n```\r\n\r\n* server_name 后边跟的是你的服务器的地址\r\n* listen 80 表示的是你的服务器开放的端口，这个端口一定要在服务器的设置上开启防火墙这个端口。\r\n\r\n```shell\r\nlocation / {\r\n    #设置主机头和客户端真实地址，以便服务器获取客户端真实IP\r\n    proxy_pass http://127.0.0.1:8000;\r\n    proxy_set_header Host $host;\r\n\r\n    proxy_set_header X-Real-IP $remote_addr;\r\n\r\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n\r\n\r\n    #禁用缓存\r\n    proxy_buffering off;\r\n\r\n}\r\n```\r\n\r\n* location 后面跟的是转发地址\r\n* proxy_pass 后面跟的是你要转发给的部署在服务器上的后端地址和端口。"
    },
    {
      "id": "/VSCode插件remote-ssh无法连接服务器的解决办法",
      "metadata": {
        "permalink": "/blog/VSCode插件remote-ssh无法连接服务器的解决办法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/VSCode插件remote-ssh无法连接服务器的解决办法.md",
        "source": "@site/blog\\VSCode插件remote-ssh无法连接服务器的解决办法.md",
        "title": "VSCode插件remote-ssh无法连接服务器的解决办法",
        "description": "问题描述",
        "date": "2022-01-28T00:00:00.000Z",
        "formattedDate": "2022年1月28日",
        "tags": [
          {
            "label": "VSCode",
            "permalink": "/blog/tags/vs-code"
          }
        ],
        "readingTime": 0.91,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "VSCode插件remote-ssh无法连接服务器的解决办法",
          "date": "2022-01-28T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "VSCode",
          "tags": [
            "VSCode"
          ]
        },
        "prevItem": {
          "title": "轻量级服务器通过nginx部署express项目",
          "permalink": "/blog/轻量级服务器通过nginx部署express项目"
        },
        "nextItem": {
          "title": "Socket.io中的命名空间",
          "permalink": "/blog/Socket.io中的命名空间"
        }
      },
      "content": "## 问题描述\r\n> 最近在使用VSCode的插件来远程连接服务器的时候，发现怎么都无法连接服务器，最后看了很多文章，总算把这个问题解决了，下面介绍下问题原因。\r\n\r\n## 问题原因\r\n> 问题可能出在ssh配置文件上，第一次一旦输入错误后，导致.ssh文件下known_hosts出现错误的记录，我们只要将这个文件的最后一行删去即可。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/33acfb3734a2fe3d9f89436017ec9fc9.png)\r\n\r\n## 解决方法\r\n1. 删除ssh种config文件的涉及到目标服务器的所有记录。\r\n2. 刷新插件。\r\n3. 删除known_hosts文件中涉及到目标服务器的记录。\r\n\r\n## 重新登录\r\n```shell\r\nssh root@xxx.xxx.xxx.xxx 22\r\n```"
    },
    {
      "id": "/Socket.io中的命名空间",
      "metadata": {
        "permalink": "/blog/Socket.io中的命名空间",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Socket.io中的命名空间.md",
        "source": "@site/blog\\Socket.io中的命名空间.md",
        "title": "Socket.io中的命名空间",
        "description": "什么是Socket.io中的命名空间？",
        "date": "2022-01-27T00:00:00.000Z",
        "formattedDate": "2022年1月27日",
        "tags": [
          {
            "label": "Socket.io",
            "permalink": "/blog/tags/socket-io"
          }
        ],
        "readingTime": 2.715,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Socket.io中的命名空间",
          "date": "2022-01-27T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Socket.io",
          "tags": [
            "Socket.io"
          ]
        },
        "prevItem": {
          "title": "VSCode插件remote-ssh无法连接服务器的解决办法",
          "permalink": "/blog/VSCode插件remote-ssh无法连接服务器的解决办法"
        },
        "nextItem": {
          "title": "大白话带你理解Socket.io是如何同步数据的",
          "permalink": "/blog/大白话带你理解Socket.io是如何同步数据的"
        }
      },
      "content": "## 什么是Socket.io中的命名空间？\r\n> 所谓的命名空间，在一个域中发消息，只有当前的域的socket能够收到消息，其他域的消息则不能。\r\n\r\n1. 服务端：通过io.of创建命名空间。\r\n\r\n2. 服务端进行广播的时候，也需要使用命名空间。\r\n\r\n3. 客户端向服务端发起连接的时候也需要指定命名空间。\r\n\r\n## egg.js中如何集成socket.io?\r\n> 参考文档：https://eggjs.org/zh-cn/tutorials/socketio.html\r\n\r\n\r\n1. 安装egg-socket.io\r\n\r\n```shell\r\nnpm i egg-socket.io --save\r\n```\r\n\r\n2. 在plugin.js中进行插件配置\r\n\r\n```js\r\n  io: {\r\n    enable: true,\r\n    package: 'egg-socket.io',\r\n  }\r\n```\r\n\r\n3. 在conig.default.js中进行如下配置\r\n\r\n```js\r\n  config.io = {\r\n    init: {}, // passed to engine.io\r\n    namespace: {\r\n      '/': {\r\n        connectionMiddleware: [],\r\n        packetMiddleware: [],\r\n      },\r\n    },\r\n  };\r\n```\r\n\r\n4. 指定io触发的时候连接的中间件\r\n\r\n```js\r\n  config.io = {\r\n    init: {}, // passed to engine.io\r\n    namespace: {\r\n      '/': {\r\n        connectionMiddleware: [\"connection\"],  // 建立连接的时候，触发的中间件\r\n        packetMiddleware: [],\r\n      },\r\n    },\r\n  };\r\n```\r\n\r\n5. 中间件connection.js\r\n\r\n```js\r\nmodule.exports = app => {\r\n  return async (ctx, next) => {\r\n    console.log(\"连接成功。。。\");\r\n    ctx.socket.emit('serverMsg', '连接成功');\r\n    await next();\r\n  };\r\n};\r\n```\r\n\r\n6. 客户端引入socket.io的cdn时尽量引入版本2的，因为版本2的可以直接跨域。\r\n\r\n```js\r\n<script src=\"https://cdn.bootcdn.net/ajax/libs/socket.io/2.2.0/socket.io.js\"></script>\r\n```\r\n\r\n7. 分清是一对一广播还是一对多广播\r\n\r\n* 一对一广播\r\n\r\n```js\r\nctx.socket.emit('serverMsg', `Hi! I've got your message: ${message}`);\r\n```\r\n\r\n* 一对多广播\r\n\r\n```js\r\nawait ctx.app.io.emit('serverMsg', `Hi! I've got your message: ${message}`);\r\n```\r\n\r\n8. 学会使用分组广播\r\n\r\n```js\r\napp.io.to(roomId).emit(\"serverMsg\",\"this is addCart msg\");\r\n```\r\n\r\n> 下面是分组广播但是不通知自己的情况：\r\n\r\n```js\r\nctx.socket.broadcast.to(roomId).emit('serverMsg',\"this is addCart msg\");\r\n```\r\n\r\n## 客户端发送请求的实例\r\n\r\n```js\r\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\r\n<html>\r\n\r\n<head>\r\n    <title>Socket.io客户端1</title>    \r\n    <script src=\"https://cdn.bootcdn.net/ajax/libs/socket.io/2.2.0/socket.io.js\"></script>\r\n    <!-- <script src=\"https://cdn.jsdelivr.net/npm/socket.io-client@4.4.1/dist/socket.io.min.js\"></script> -->\r\n</head>\r\n<body>\r\n    <h2>客户端111</h2>\r\n    <br>\r\n    <button onclick=\"send()\">发送消息</button>\r\n</body>\r\n\r\n<script>\r\n  //1、连接socket.io服务器\r\n  var socket = io.connect(\"http://192.168.1.7:7001?roomId=20\");\r\n\r\n  socket.on(\"serverMsg\",function(serverData){\r\n    console.log(serverData);\r\n  })\r\n \r\n  function send(){\r\n    socket.emit(\"clientMsg\",\"client AddCart\");\r\n  }\r\n</script>\r\n</html>\r\n```\r\n\r\n## 总结\r\n> 客户端发送socket请求的时候，如果服务端使用的是egg.js，则建议尽量使用V2版本，因为这个版本的socket不需要配置跨域，V4版本则需要配置跨域。在客户端与服务端通信时，尽量统一监听字段，这样可以有效防止出错。"
    },
    {
      "id": "/大白话带你理解Socket.io是如何同步数据的",
      "metadata": {
        "permalink": "/blog/大白话带你理解Socket.io是如何同步数据的",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/大白话带你理解Socket.io是如何同步数据的.md",
        "source": "@site/blog\\大白话带你理解Socket.io是如何同步数据的.md",
        "title": "大白话带你理解Socket.io是如何同步数据的",
        "description": "需求分析",
        "date": "2022-01-26T00:00:00.000Z",
        "formattedDate": "2022年1月26日",
        "tags": [
          {
            "label": "Socket.io",
            "permalink": "/blog/tags/socket-io"
          }
        ],
        "readingTime": 3.18,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "大白话带你理解Socket.io是如何同步数据的",
          "date": "2022-01-26T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Socket.io",
          "tags": [
            "Socket.io"
          ]
        },
        "prevItem": {
          "title": "Socket.io中的命名空间",
          "permalink": "/blog/Socket.io中的命名空间"
        },
        "nextItem": {
          "title": "nextTick的实际使用场景分析",
          "permalink": "/blog/nextTick的实际使用场景分析"
        }
      },
      "content": "## 需求分析\r\n> 有时候，我们想要在不同的客户端中对数据进行同步，以扫码点餐为例，一个餐桌上的二维码被多个用户扫描之后，我们希望所有客户端打开的页面中的数据是同步的，这个需求socket.io可以帮助我们实现。\r\n\r\n## 有哪些实现方法？\r\n\r\n### 方法1：不断轮询\r\n> 所谓的不断轮询，指的是在很短的时间内，不同的客户端都去向服务器请求数据，这样能够在很短的时间内刷新数据，但是这种方法会带来很严重的性能浪费，在网络环境不好的情况下，还会带来很大的延迟，因此，这种方法并不推荐。\r\n\r\n### 方法2：长连接\r\n> 浏览器和服务器首先进行握手，建立一个有效的连接，建立连接之后，双方可以在任意时刻，互相推送消息，这种方法比较推荐，能够带来比较好的用户体验。\r\n\r\n## 长连接实现\r\n### 通过Socket.io实现长连接\r\n> socket.io将websocket、ajax等通信方式进行了有效的封装，在使用socket.io的过程中，我们不用担心兼容问题，socket.io会帮助我们选择最佳的通信方式，所以说socket.io包含了websocket，因此会带来较好的兼容性。\r\n\r\n### 使用socket.io实现聊天室功能\r\n> 下面是参考文档\r\n\r\nhttps://socket.io/get-started/chat\r\n\r\n1. 服务端：安装socket.io\r\n\r\n```shell\r\nnpm install socket.io\r\n```\r\n\r\n2. 服务端：创建socket.io服务器\r\n\r\n> 下面的代码主要使用了socket.io和express。\r\n\r\n```js\r\nconst express = require('express');\r\nconst app = express();\r\nconst http = require('http');\r\nconst server = http.createServer(app);\r\nconst { Server } = require(\"socket.io\");\r\nconst io = new Server(server);\r\n\r\napp.set('view engine','ejs');\r\napp.use(express.static('public'));\r\n\r\napp.get('/',(req,res) => {\r\n  res.render('index');\r\n})\r\n\r\nserver.listen(8002)\r\n\r\n// 创建socket.io服务\r\nio.on('connection',(socket) => {\r\n  console.log('一个用户连接到服务器');\r\n  // 下面是给客户端的广播\r\n  socket.emit(\"serverMsg\",\"已经建立了连接\")\r\n})\r\n```\r\n\r\n3. 客户端：连接socket.io服务器并监听广播\r\n\r\n```js\r\n  // 1. 连接socket.io服务器\r\n  const socket = io();\r\n  // 2. 监听广播\r\n  socket.on(\"serverMsg\",function(serverData){\r\n    console.log(serverData);\r\n  })\r\n```\r\n\r\n4. 客户端：向服务端发送数据\r\n\r\n> 下面的代码使用的是Jquery，但是核心就是socket.emit这一句话。\r\n\r\n```js\r\n  $('#send').click(function() {\r\n    const msg = $('#msg').val();\r\n    // alert(msg);\r\n    socket.emit(\"clientMsg\",msg);\r\n  });\r\n```\r\n\r\n5. 服务端监听消息并发送广播\r\n\r\n```js\r\n  socket.on(\"clientMsg\",(clientData) => {\r\n    console.log(clientData);\r\n    io.emit(\"serverMsg\",clientData);\r\n  })\r\n```\r\n\r\n## 总结\r\n> socket.io是一个非常强大的通信库，通过上面的例子，我们可以看到socket.on主要是用来监听特定广播的，但是io.emit则是向所有用户进行广播使用的。"
    },
    {
      "id": "/nextTick的实际使用场景分析",
      "metadata": {
        "permalink": "/blog/nextTick的实际使用场景分析",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/nextTick的实际使用场景分析.md",
        "source": "@site/blog\\nextTick的实际使用场景分析.md",
        "title": "nextTick的实际使用场景分析",
        "description": "需求分析",
        "date": "2022-01-25T00:00:00.000Z",
        "formattedDate": "2022年1月25日",
        "tags": [
          {
            "label": "vue",
            "permalink": "/blog/tags/vue"
          }
        ],
        "readingTime": 2.405,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "nextTick的实际使用场景分析",
          "date": "2022-01-25T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "vue",
          "tags": [
            "vue"
          ]
        },
        "prevItem": {
          "title": "大白话带你理解Socket.io是如何同步数据的",
          "permalink": "/blog/大白话带你理解Socket.io是如何同步数据的"
        },
        "nextItem": {
          "title": "Vue+TS中全局绑定axios、storage、接口地址的方法",
          "permalink": "/blog/Vue+TS中全局绑定axios、storage、接口地址的方法"
        }
      },
      "content": "## 需求分析\r\n> 有时候，我们需要页面的所有数据都渲染完成后在获取数据，通过传统的方法无法获取到渲染后的数据，举个例子，页面中通过v-for渲染的li有12个，但是，我们却在异步获取数据的函数中无法通过document.querySelector拿到所有的数据，此时就需要使用nextTick.\r\n\r\n## 案例分析\r\n> 例如下面这个页面，我们想要实现的是先渲染页面，然后获取li的数量。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/833f35245975a6c39ce0dd7a95078bf8.png)\r\n\r\n## 代码分析\r\n> 请注意，下面的代码要写在获取口味的异步函数完成之后。(这一点很重要，直接放在mounted函数之中是没有作用的。)\r\n\r\n```js\r\n  this.$axios.get(this.$config.apiUrl + \"/flavorList\").then((res) => {\r\n    console.log(res);\r\n    this.flavorList = res.data.result;\r\n    this.$nextTick(() => {\r\n      // 渲染整个页面之后，再执行下面的代码\r\n      this.initEvent();\r\n    });\r\n  });\r\n```\r\n\r\n## 原理分析\r\n> 我们不仅要知道nextTick是如何使用的，还要知道nextTick的原理，这是一道面试常考的题目。\r\n\r\n> 有时候，我们也许无法避免的需要直接对DOM进行操作，但是我们想要操作的是页面渲染完成后的结果，此时nextTick就可以帮助我们实现。\r\n\r\n### vue如何判断DOM是否更新完毕？\r\n#### 利用MutationObserver？而是事件循环。\r\n> MutationObserver是HTML5新增的一个API，这个API可以帮助我们监听DOM。但是通过vue实际上并不是通过MutationObserver，而是通过事件循环，让nextTick在UI render之后再执行，这样就能访问到更新后的DOM了。在时间循环中宏任务总是要等到微任务执行完毕之后再执行，当调用nextTick的时候，会在更新DOM的微任务队列后追加我们自己的回调函数，从而能够保证我们的回调函数是在DOM渲染完成之后被执行的。"
    },
    {
      "id": "/Vue+TS中全局绑定axios、storage、接口地址的方法",
      "metadata": {
        "permalink": "/blog/Vue+TS中全局绑定axios、storage、接口地址的方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Vue+TS中全局绑定axios、storage、接口地址的方法.md",
        "source": "@site/blog\\Vue+TS中全局绑定axios、storage、接口地址的方法.md",
        "title": "Vue+TS中全局绑定axios、storage、接口地址的方法",
        "description": "全局绑定axios(在TypeScript中)",
        "date": "2022-01-24T00:00:00.000Z",
        "formattedDate": "2022年1月24日",
        "tags": [
          {
            "label": "vue",
            "permalink": "/blog/tags/vue"
          }
        ],
        "readingTime": 2.575,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Vue+TS中全局绑定axios、storage、接口地址的方法",
          "date": "2022-01-24T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "vue",
          "tags": [
            "vue"
          ]
        },
        "prevItem": {
          "title": "nextTick的实际使用场景分析",
          "permalink": "/blog/nextTick的实际使用场景分析"
        },
        "nextItem": {
          "title": "Error on importing VueAnalytics to main.ts in Vue CLI (Vue3)",
          "permalink": "/blog/Error on importing VueAnalytics to main in Vue CLI (Vue3)"
        }
      },
      "content": "## 全局绑定axios(在TypeScript中)\r\n1. 通过cnpm安装到项目中。\r\n\r\n```shell\r\ncnpm i axios --save\r\n```\r\n\r\n2. 在main.ts中引入下面的接口和组件\r\n\r\n```js\r\nimport Axios,{AxiosInstance} from  'axios'\r\n```\r\n\r\n3. 在main.ts中进行如下声明\r\n\r\n```js\r\ndeclare module '@vue/runtime-core' {\r\n  interface ComponentCustomProperties {\r\n    $axios: AxiosInstance\r\n  }\r\n}\r\n```\r\n\r\n4. 在方法中可以直接通过this.$axios进行调用。\r\n\r\n```js\r\nrequestData() {\r\n  this.$axios.get('https://s.itying.com/api/v1/login').then(res => {\r\n    console.log(res);\r\n  })\r\n}\r\n```\r\n\r\n## 封装并全局绑定storage\r\n### 封装storage\r\n1. 首先创建一个storage.ts文件\r\n\r\n2. 下面是storage.ts文件中的内容\r\n\r\n```js\r\nexport interface StorageInstance {\r\n  set(key: string,value: any): void;\r\n  get(key: string): any;\r\n  remove(key: string): void;\r\n}\r\n\r\nclass StorageClass implements StorageInstance {\r\n  set(key: string, value: any): void {\r\n    localStorage.setItem(key,JSON.stringify(value));\r\n  }\r\n  get(key: string): any {\r\n    let temp = localStorage.getItem(key);\r\n    if (temp) {\r\n      return JSON.parse(temp);\r\n    }\r\n    return null;\r\n  }\r\n  remove(key: string): void {\r\n    localStorage.removeItem(key);\r\n  }\r\n}\r\nlet Storge = new StorageClass();\r\n\r\nexport default Storage;\r\n```\r\n\r\n### 全局绑定storage\r\n>需要注意的是，我们全局绑定的是我们上一步暴露的storage。\r\n\r\n1. 引入已经封装好的storage。\r\n\r\n```js\r\nimport Storage,{StorageInstance} from './model/storage'\r\n```\r\n\r\n2. 声明module\r\n\r\n```js\r\ndeclare module '@vue/runtime-core' {\r\n  interface ComponentCustomProperties {\r\n    $axios: AxiosInstance,\r\n    $storage: StorageInstance\r\n  }\r\n}\r\n```\r\n\r\n3. 挂载到全局\r\n\r\n```js\r\napp.config.globalProperties.$storage = Storage\r\n```\r\n\r\n4. 通过this.$storage即可访问\r\n\r\n```js\r\nthis.$storage.set(\"token\",res.data.token)\r\n```\r\n\r\n## 封装接口地址\r\n\r\n1. 创建config.ts\r\n\r\n2. 在文件中暴露相关接口地址\r\n\r\n```js\r\nexport interface ConfigInstance {\r\n  apiUrl: string;\r\n  imgUrl: string;\r\n}\r\n\r\nclass ConfigClass implements ConfigInstance {\r\n  apiUrl: string;\r\n  imgUrl: string;\r\n  constructor() {\r\n    this.apiUrl = 'https://s.itying.com/api/v1';\r\n    this.imgUrl = 'https://s.itying.com'\r\n  }\r\n}\r\n\r\nconst Config = new ConfigClass();\r\n\r\nexport default Config;\r\n```\r\n\r\n3. 在main.ts中进行声明与挂载\r\n\r\n```js\r\nimport Config,{ConfigInstance} from './model/config'\r\ndeclare module '@vue/runtime-core' {\r\n  interface ComponentCustomProperties {\r\n    $axios: AxiosInstance,\r\n    $storage: StorageInstance,\r\n    $config: ConfigInstance\r\n  }\r\n}\r\napp.config.globalProperties.$config = Config\r\n```\r\n\r\n4. 组件中获取只需通过this.$config.apiUrl即可。\r\n\r\n\r\n## 总结\r\n> 在vue中进行全局绑定是一个非常重要和常用的操作，以api请求地址为例，假如一个大型的vue项目每一个接口地址都是写死的，那么一旦api地址发生更改，这将给修改带来极大的困难，但是如果我们绑定到全局，修改起来就是十分简单的一件事情了，所以将一些常用属性和方法绑定到全局中是非常重要的。"
    },
    {
      "id": "/Error on importing VueAnalytics to main in Vue CLI (Vue3)",
      "metadata": {
        "permalink": "/blog/Error on importing VueAnalytics to main in Vue CLI (Vue3)",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Error on importing VueAnalytics to main in Vue CLI (Vue3).md",
        "source": "@site/blog/Error on importing VueAnalytics to main in Vue CLI (Vue3).md",
        "title": "Error on importing VueAnalytics to main.ts in Vue CLI (Vue3)",
        "description": "问题描述",
        "date": "2022-01-23T00:00:00.000Z",
        "formattedDate": "2022年1月23日",
        "tags": [
          {
            "label": "debug",
            "permalink": "/blog/tags/debug"
          }
        ],
        "readingTime": 0.605,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Error on importing VueAnalytics to main.ts in Vue CLI (Vue3)",
          "date": "2022-01-23T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "debug",
          "tags": [
            "debug"
          ]
        },
        "prevItem": {
          "title": "Vue+TS中全局绑定axios、storage、接口地址的方法",
          "permalink": "/blog/Vue+TS中全局绑定axios、storage、接口地址的方法"
        },
        "nextItem": {
          "title": "Vue3中集成并使用TypeScript",
          "permalink": "/blog/Vue3中集成并使用TypeScript"
        }
      },
      "content": "## 问题描述\r\n> 最近，在安装完vue-router之后，在写ts的时候，出现下面的错误,起初我以为是版本不兼容，在重装了多次版本后还是没有解决，最后通过直觉告诉我是删除node_modules然后使用cnpm进行安装，后来通过这个方法解决了。\r\n\r\n```\r\nError on importing VueAnalytics to main.ts in Vue CLI (Vue3)\r\n```\r\n\r\n## 解决办法\r\n\r\n1. 删除node_modules文件夹。\r\n\r\n2. 使用cnpm进行安装。\r\n\r\n```shell\r\ncnpm i\r\n```"
    },
    {
      "id": "/Vue3中集成并使用TypeScript",
      "metadata": {
        "permalink": "/blog/Vue3中集成并使用TypeScript",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Vue3中集成并使用TypeScript.md",
        "source": "@site/blog\\Vue3中集成并使用TypeScript.md",
        "title": "Vue3中集成并使用TypeScript",
        "description": "一、安装",
        "date": "2022-01-19T00:00:00.000Z",
        "formattedDate": "2022年1月19日",
        "tags": [
          {
            "label": "Vue",
            "permalink": "/blog/tags/vue"
          }
        ],
        "readingTime": 1.92,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Vue3中集成并使用TypeScript",
          "date": "2022-01-19T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Vue",
          "tags": [
            "Vue"
          ]
        },
        "prevItem": {
          "title": "Error on importing VueAnalytics to main.ts in Vue CLI (Vue3)",
          "permalink": "/blog/Error on importing VueAnalytics to main in Vue CLI (Vue3)"
        },
        "nextItem": {
          "title": "LeetCode——螺旋矩阵（上下左右四指针辅助法）",
          "permalink": "/blog/LeetCode——螺旋矩阵（上下左右四指针辅助法）"
        }
      },
      "content": "## 一、安装\r\n\r\n1. 创建vue项目\r\n```shell\r\nvue create vue-test-demo\r\n```\r\n\r\n2. 进入项目\r\n\r\n```shell\r\ncd vue-ts-demo\r\n```\r\n\r\n3. 新增typescript\r\n\r\n```js\r\nvue add typescript\r\n```\r\n\r\n4. 跳过class语法\r\n\r\n\r\n## 二、如何让组件能够使用TS语法？\r\n1. script标签的lang属性设置为ts。\r\n\r\n```js\r\n<script lang=\"ts\">\r\n```\r\n\r\n2. 从vue中导入defineComponent\r\n\r\n```js\r\nimport { defineComponent } from 'vue';\r\n```\r\n\r\n3. 组件对外暴露时需要通过defineComponent进行包裹。\r\n\r\n```js\r\nexport default defineComponent({\r\n  name: 'App',\r\n  components: {\r\n    Home\r\n  }\r\n});\r\n```\r\n\r\n## 三、Vue中使用TS语法实例\r\n>定义接口并实现接口。\r\n\r\n```js\r\n<script lang=\"ts\">\r\nimport {defineComponent} from 'vue'\r\ninterface News{\r\n  title: string,\r\n  description: string,\r\n  count: number,\r\n  content?: string\r\n}\r\nlet newsData: News= {\r\n  title: \"这是一个新闻\",\r\n  description: \"这是新闻的描述\",\r\n  count: 12\r\n}\r\nexport default defineComponent({\r\n  data() {\r\n    return newsData\r\n  },\r\n  methods: {\r\n    setTitle(): void{\r\n      this.title = '123';\r\n    }\r\n  }\r\n});\r\n</script>\r\n```\r\n\r\n## 四、组合式API中使用TS\r\n>下文首先介绍reactive的使用注意事项。\r\n\r\n### 第一种实现方式（参数）\r\n\r\n```js\r\ninterface User {\r\n  username: string;\r\n  age: number;\r\n}\r\n  setup() {\r\n    let user: User = reactive({\r\n      username: \"张三\",\r\n      age: 20,\r\n    });\r\n    function setUsername(username: string) {\r\n      user.username = username;\r\n    }\r\n    return {\r\n      ...toRefs(user),\r\n      setUsername\r\n    };\r\n  }\r\n```\r\n\r\n### 第二种实现方式（泛型）\r\n```js\r\n  setup() {\r\n    let user = reactive<User>({\r\n      username: \"张三\",\r\n      age: 20,\r\n    });\r\n    function setUsername(username: string) {\r\n      user.username = username;\r\n    }\r\n    return {\r\n      ...toRefs(user),\r\n      setUsername\r\n    };\r\n  }\r\n```\r\n\r\n### 第三种实现方式（通过as）\r\n\r\n```js\r\nlet user = reactive({\r\n  username: \"张三\",\r\n  age: 20,\r\n}) as User;\r\n```\r\n\r\n>下面介绍下ref的注意事项。\r\n\r\n1. ref不支持直接指定类型。\r\n\r\n> 下面的是错误的形式。\r\n\r\n```js\r\nlet num: string = ref('666');\r\n```\r\n\r\n2. ref支持泛型。\r\n\r\n```js\r\nlet num = ref<number | string>('666');\r\n```"
    },
    {
      "id": "/LeetCode——螺旋矩阵（上下左右四指针辅助法）",
      "metadata": {
        "permalink": "/blog/LeetCode——螺旋矩阵（上下左右四指针辅助法）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——螺旋矩阵（上下左右四指针辅助法）.md",
        "source": "@site/blog\\LeetCode——螺旋矩阵（上下左右四指针辅助法）.md",
        "title": "LeetCode——螺旋矩阵（上下左右四指针辅助法）",
        "description": "题目描述",
        "date": "2022-01-15T00:00:00.000Z",
        "formattedDate": "2022年1月15日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 2.1,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——螺旋矩阵（上下左右四指针辅助法）",
          "date": "2022-01-15T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "Vue3中集成并使用TypeScript",
          "permalink": "/blog/Vue3中集成并使用TypeScript"
        },
        "nextItem": {
          "title": "字节青训营笔试之数字金额格式化",
          "permalink": "/blog/字节青训营笔试之数字金额格式化"
        }
      },
      "content": "## 题目描述\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/f46645b5c48abc5efe0db37ebf116873.png)\r\n\r\n## 解题思路\r\n1. 首先定义四个指针，指向如下图所示：\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/95b25fd9d4f6f092d6c77935e63552b7.png)\r\n\r\n2. 按照顺时针进行遍历，分别是从左到右、从上到下、从右到左、从下到上的思路。\r\n\r\n3. 一轮循环后让左指针+1，继续下一轮循环，需要注意的是每次移动指针的时候，都需要注意指针是否越界。\r\n\r\n```js\r\nvar spiralOrder = function(matrix) {\r\n  // 螺旋矩阵的核心是使用四个指针来辅助遍历\r\n  // 首先是初始条件的判断，如果矩阵的长度为0，则返回空数组\r\n  if (matrix.length === 0) return [];\r\n\r\n  // 定义四个指针\r\n  let left = 0;\r\n  let top = 0;\r\n  let right = matrix[0].length - 1;\r\n  let bottom = matrix.length - 1;\r\n\r\n  // 定义最终返回的结果\r\n  const res = [];\r\n\r\n  // 开始遍历\r\n  while (1) {\r\n    // 主要是按照顺时针进行遍历\r\n    // 第一步：从左到右\r\n    for (let i = left; i <= right; i++) {\r\n      res.push(matrix[top][i])\r\n    }\r\n    // 第二步：从上到下\r\n    top++;\r\n    if (top > bottom) break;\r\n    for (let i = top; i <= bottom; i++) {\r\n      res.push(matrix[i][right]);\r\n    }\r\n    // 第三步：从右到左\r\n    right--;\r\n    if (right < left) break;\r\n    for (let i = right; i >= left; i--) {\r\n      res.push(matrix[bottom][i])\r\n    };\r\n    // 第四步：从下到上\r\n    bottom--;\r\n    if (bottom < top) break;\r\n    for (let i = bottom; i >= top; i--) {\r\n      res.push(matrix[i][left])\r\n    }\r\n    // 第五步：也是最容易被遗忘的一步\r\n    left++;\r\n    if (left > right) break;\r\n  }\r\n\r\n  return res;\r\n\r\n};\r\n```\r\n\r\n## 题目反思\r\n> 螺旋矩阵和顺时针打印矩阵是同一道题目，这个题目既出现在了剑指Offer中，也出现在了很多面试场合中，因此这个题目我们一定要搞懂，本质就是指针辅助加条件判断。"
    },
    {
      "id": "/字节青训营笔试之数字金额格式化",
      "metadata": {
        "permalink": "/blog/字节青训营笔试之数字金额格式化",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/字节青训营笔试之数字金额格式化.md",
        "source": "@site/blog\\字节青训营笔试之数字金额格式化.md",
        "title": "字节青训营笔试之数字金额格式化",
        "description": "题目描述",
        "date": "2022-01-13T00:00:00.000Z",
        "formattedDate": "2022年1月13日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 1.45,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "字节青训营笔试之数字金额格式化",
          "date": "2022-01-13T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "LeetCode——螺旋矩阵（上下左右四指针辅助法）",
          "permalink": "/blog/LeetCode——螺旋矩阵（上下左右四指针辅助法）"
        },
        "nextItem": {
          "title": "LeetCode——删除字符串中的所有相邻重复项（用栈实现打牌思路）",
          "permalink": "/blog/LeetCode——删除字符串中的所有相邻重复项（用栈实现打牌思路）"
        }
      },
      "content": "## 题目描述\r\n> 数字金额格式化是一道考频非常高的题目，无论是实习还是校招都有可能考到这个题目，所以笔者希望大家都能搞懂这道题目，下面让我们来一起探索这道题目吧。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/a57db6cb653322a4f695865580bd5aeb.png)\r\n\r\n## 解题思路\r\n1. 首先将传入函数的数字通过toString方法转换为字符串，然后使用split进行分割。\r\n2. 定义一个计数器，用于辅助判断什么时候添加逗号。\r\n3. 倒序遍历添加数字和逗号。\r\n\r\n```js\r\nfunction toThousands(num) {\r\n  // 首先将传入的数字进行分割\r\n  num = num.toString().split('');\r\n  // 定义最终要返回的结果\r\n  const res = [];\r\n  let count = 0;\r\n  // 遍历每一个字符\r\n  for (let i = num.length - 1; i >= 0; i--) {\r\n    res.unshift(num[i]);\r\n    count++\r\n    if (count % 3 === 0 && i !== 0) {\r\n      res.unshift(',')\r\n    }\r\n  }\r\n  return res.join('');\r\n}\r\n\r\nlet test = 236471283572983412;\r\nconsole.log(\"二者是否相等：\",test.toLocaleString() === toThousands(test));\r\nconsole.log(test.toLocaleString()); \r\nconsole.log(toThousands(test)); \r\n```\r\n\r\n## 题目反思\r\n> 这个题目必须要倒着遍历，然后通过计数器辅助来进行添加逗号，是一个很不错的思路，指的我们反复学习揣摩。"
    },
    {
      "id": "/LeetCode——删除字符串中的所有相邻重复项（用栈实现打牌思路）",
      "metadata": {
        "permalink": "/blog/LeetCode——删除字符串中的所有相邻重复项（用栈实现打牌思路）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——删除字符串中的所有相邻重复项（用栈实现打牌思路）.md",
        "source": "@site/blog\\LeetCode——删除字符串中的所有相邻重复项（用栈实现打牌思路）.md",
        "title": "LeetCode——删除字符串中的所有相邻重复项（用栈实现打牌思路）",
        "description": "题目描述",
        "date": "2022-01-09T00:00:00.000Z",
        "formattedDate": "2022年1月9日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.765,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——删除字符串中的所有相邻重复项（用栈实现打牌思路）",
          "date": "2022-01-09T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "字节青训营笔试之数字金额格式化",
          "permalink": "/blog/字节青训营笔试之数字金额格式化"
        },
        "nextItem": {
          "title": "这一次，彻底搞懂困扰已久的Redux",
          "permalink": "/blog/这一次，彻底搞懂困扰已久的Redux"
        }
      },
      "content": "## 题目描述\r\n> 这道题从题目的名字上看是删除字符串中的所有相邻重复项，其实通俗的讲就是消消乐的思想，有两个相邻一致的则消除，消除一对后如果还有则继续消除。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/1c93b04a44fb6e3fa5c8610bf2cc2c7a.png)\r\n\r\n## 解题思路\r\n> 本题的实现可以使用打牌思路，类似题目有最长回文串，这道题目是使用集合来实现打牌思路，但是本题是通过栈来实现打牌思路，首先遍历每一个字符，如果栈中有元素，且栈的最后一个元素和这个元素的值相等，则栈进行pop，反之push进栈，最后返回栈对应的字符串。\r\n\r\n```js\r\nvar removeDuplicates = function(s) {\r\n  // 这道题目的思想类似于打牌的思路，区别在于本题是通过栈来实现打牌思路\r\n  // 有机会可以将这道题目和最长回文串这道题目进行归纳总结\r\n  const stack = [];\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (stack.length && stack[stack.length - 1] === s[i]) {\r\n      stack.pop();\r\n    } else {\r\n      stack.push(s[i]);\r\n    }\r\n  }\r\n  return stack.join('');\r\n\r\n};\r\n```\r\n\r\n## 题目反思\r\n> 使用打牌思路来解决问题已经不是一次出现了，也是面试官常考的题目，但是却不容易被想到，因此我们可以通过归纳总结的方式来对这类题目进行记忆。"
    },
    {
      "id": "/这一次，彻底搞懂困扰已久的Redux",
      "metadata": {
        "permalink": "/blog/这一次，彻底搞懂困扰已久的Redux",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/这一次，彻底搞懂困扰已久的Redux.md",
        "source": "@site/blog\\这一次，彻底搞懂困扰已久的Redux.md",
        "title": "这一次，彻底搞懂困扰已久的Redux",
        "description": "Redux是什么？",
        "date": "2022-01-08T00:00:00.000Z",
        "formattedDate": "2022年1月8日",
        "tags": [
          {
            "label": "Redux",
            "permalink": "/blog/tags/redux"
          }
        ],
        "readingTime": 3.715,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "这一次，彻底搞懂困扰已久的Redux",
          "date": "2022-01-08T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Redux",
          "tags": [
            "Redux"
          ]
        },
        "prevItem": {
          "title": "LeetCode——删除字符串中的所有相邻重复项（用栈实现打牌思路）",
          "permalink": "/blog/LeetCode——删除字符串中的所有相邻重复项（用栈实现打牌思路）"
        },
        "nextItem": {
          "title": "安装sass并将sass文件转换为css文件",
          "permalink": "/blog/安装sass并将sass文件转换为css文件"
        }
      },
      "content": "## Redux是什么？\r\n>Redux是一个JavaScript状态容器，用于进行全局的状态管理。\r\n\r\n## Redxu的流程图（核心中的核心）\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/01c6c07e0d0d9c28a94b1357a0181f77.png)\r\n\r\n## Redux的三大核心\r\n### 核心1：单一数据源\r\n>所谓的单一数据源，指的是整个应用的state被存储在一棵object tree中，并且这个ibject tree只存在于唯一一个store中。\r\n\r\n### 核心2：state是只读的\r\n>唯一改变state的方法就是触发action,action是一个用于描述已发生事件的普通对象，这样确保了视图和网络请求都不能直接修改state，相反他们只能表达想要修改的意图，因为所有的修改都被集中化处理，并且严格按照一个接一个的顺序执行。\r\n\r\n### 核心3：使用纯函数来执行修改\r\n>为了描述action是如何改变state的，我们需要编写reducer,这个reducers是一些纯函数，它接收先前的state和action，并且返回新的state。可以复用、可以控制顺序、传入附加参数。\r\n\r\n## Redux的组成\r\n### state状态\r\n>state就是我们传递的数据，我们在使用React开发项目的时候，大致可以把state分为三类。\r\n* DominDate：来自服务器端传过来的数据，比如获取到的用户的信息等。\r\n* UI State：决定当前UI展示状态的数据，比如弹框的显示和隐藏等。\r\n* App State：App级别的状态，比如：当前是否请求loading。\r\n\r\n### Action事件\r\n>Action是把数据从应用传到store的载体，**它是store的唯一数据来源，一般来说，我们可以通过store.dispatch()将action传递给store**\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/d5a0aa7be76fe98a945e9e907633a8b8.png)\r\n\r\n* Action的本质就是一个JS对象。\r\n* Action对象的内部必须要有一个type属性来表示要执行的动作。\r\n* 多数情况下，上述的type都是一个字符串常量。\r\n* 除了type字段之外，action的结构随意进行定义。\r\n* 一般更倾向于用action创建函数（详情请看下面的实例）。\r\n* action只是描述了状态要改变，但是没有描述状态如何改变。\r\n\r\n**action实例**\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/7976a3d9ced02dd8deb0ba00be39a8f2.png)\r\n\r\n**action函数实例**\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/5f31e0a534aa1cd4782e18a84c26450d.png)\r\n\r\n### Reducer\r\n>Reducer的本质就是一个纯函数，它用来响应发送过来的actions，然后经过处理把state发送给Store。在Reducer函数中需要return返回值，这样store才能接受到数据，reducer会接收到两个参数，一个是初始化的state，第二个则是发送过来的action.\r\n\r\n**reducer函数实例**\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/4c3069239d1c3ed257f906f7056ade8e.png)\r\n\r\n### Store\r\n>store就是把action和reducer联系到一起的对象。\r\n\r\n**主要职责**\r\n1. store和reducer建立连接是通过createStore(reducer)来建立连接的。\r\n2. store和action建立连接是通过store.dispatch(action对象)来建立连接的。\r\n3. store和组件建立联系是通过入口文件传入store这个props。\r\n4. 组件获取状态是通过this.props.store.getState()。\r\n5. 状态要想渲染到页面是通过store.subscribe()。"
    },
    {
      "id": "/安装sass并将sass文件转换为css文件",
      "metadata": {
        "permalink": "/blog/安装sass并将sass文件转换为css文件",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/安装sass并将sass文件转换为css文件.md",
        "source": "@site/blog\\安装sass并将sass文件转换为css文件.md",
        "title": "安装sass并将sass文件转换为css文件",
        "description": "安装sass",
        "date": "2022-01-07T00:00:00.000Z",
        "formattedDate": "2022年1月7日",
        "tags": [
          {
            "label": "Sass",
            "permalink": "/blog/tags/sass"
          }
        ],
        "readingTime": 0.885,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "安装sass并将sass文件转换为css文件",
          "date": "2022-01-07T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Sass",
          "tags": [
            "Sass"
          ]
        },
        "prevItem": {
          "title": "这一次，彻底搞懂困扰已久的Redux",
          "permalink": "/blog/这一次，彻底搞懂困扰已久的Redux"
        },
        "nextItem": {
          "title": "LeetCode——最小栈（辅助栈）",
          "permalink": "/blog/LeetCode——最小栈（辅助栈）"
        }
      },
      "content": "## 安装sass\r\n* 全局安装sass\r\n\r\n```shell\r\nnpm install -g sass\r\n```\r\n\r\n> 注意：sass的后缀名是scss。\r\n\r\n## 将sass文件转换为css文件\r\n\r\n* 将sass文件转换为css文件\r\n\r\n```shell\r\nsass --watch test.scss output.css\r\n```\r\n\r\n> 执行上面的语句会监听scss文件的变化，一旦文件发生变化并保存后将立即输出到css文件上。\r\n\r\n* 监听目录的变化\r\n\r\n```shell\r\nsass --watch app/sass:public/stylesheets\r\n```\r\n\r\n> sass将会监听app/sass目录下所有文件的变动，并编译css到public/stylesheets目录。其中以冒号进行分割，前面是sass目录，后面是css目录。\r\n\r\n## 在sass中定义并使用变量\r\n* 定义变量\r\n\r\n```js\r\n$myFontSize: 18px;\r\n```\r\n\r\n* 使用变量\r\n\r\n```js\r\nfont-size: $myFontSize;\r\n```"
    },
    {
      "id": "/LeetCode——最小栈（辅助栈）",
      "metadata": {
        "permalink": "/blog/LeetCode——最小栈（辅助栈）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——最小栈（辅助栈）.md",
        "source": "@site/blog\\LeetCode——最小栈（辅助栈）.md",
        "title": "LeetCode——最小栈（辅助栈）",
        "description": "题目描述",
        "date": "2022-01-06T00:00:00.000Z",
        "formattedDate": "2022年1月6日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 2.085,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——最小栈（辅助栈）",
          "date": "2022-01-06T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "安装sass并将sass文件转换为css文件",
          "permalink": "/blog/安装sass并将sass文件转换为css文件"
        },
        "nextItem": {
          "title": "（二刷）LeetCode——最大连续1的个数 III（滑动窗口）",
          "permalink": "/blog/（二刷）LeetCode——最大连续1的个数 III（滑动窗口）"
        }
      },
      "content": "## 题目描述\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/a4270b5c1b1db58d55ef02b4cdbf1069.png)\r\n\r\n## 解题思路\r\n### 初始化\r\n> 初始化的时候构造一个普通栈和最小栈，这个最小栈的特点在于，只要发现比最后一个元素小的元素。就把这个元素放到最小栈的最后。\r\n\r\n### push\r\n\r\n> push元素的时候，普通栈直接入栈，如果入栈的元素比最小栈的最后一个元素小，则这个元素也入最小栈，或者最小栈为空，这个元素也入最小栈。\r\n\r\n### pop\r\n\r\n> 首先普通栈pop，如果要pop的元素和最小栈的最后一个元素的值相等，最小栈也要pop。\r\n\r\n### top\r\n\r\n> 直接返回普通栈的最后一个元素。\r\n\r\n### getMin\r\n\r\n> 直接返回最小栈的最后一个元素。\r\n\r\n## AC代码\r\n\r\n```js\r\nvar MinStack = function() {\r\n  // 最下栈的核心就是构造两个栈，一个普通栈，一个最小栈\r\n  this.stack = [];\r\n  this.min_stack = [];\r\n};\r\n\r\n/** \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nMinStack.prototype.push = function(val) {\r\n  // 首先普通栈要入栈\r\n  this.stack.push(val);\r\n  // 如果最小栈为空或者val的值比最小栈的最后一个元素的值小\r\n  if (val <= this.getMin() || this.min_stack.length === 0) {\r\n    this.min_stack.push(val);\r\n  }\r\n};\r\n\r\n/**\r\n * @return {void}\r\n */\r\nMinStack.prototype.pop = function() {\r\n  // 首先，普通栈出栈\r\n  let value = this.stack.pop();\r\n  if (value === this.getMin()) {\r\n    this.min_stack.pop();\r\n  }\r\n  return value;\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMinStack.prototype.top = function() {\r\n  // 直接返回普通栈的最后一个元素\r\n  return this.stack[this.stack.length - 1];\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMinStack.prototype.getMin = function() {\r\n  return this.min_stack[this.min_stack.length - 1]\r\n};\r\n```\r\n\r\n## 题目反思\r\n> 最小栈和用栈模拟队列等都是一类题目，核心就是借助辅助栈来帮助实现想要的功能。"
    },
    {
      "id": "/（二刷）LeetCode——最大连续1的个数 III（滑动窗口）",
      "metadata": {
        "permalink": "/blog/（二刷）LeetCode——最大连续1的个数 III（滑动窗口）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/（二刷）LeetCode——最大连续1的个数 III（滑动窗口）.md",
        "source": "@site/blog\\（二刷）LeetCode——最大连续1的个数 III（滑动窗口）.md",
        "title": "（二刷）LeetCode——最大连续1的个数 III（滑动窗口）",
        "description": "题目描述",
        "date": "2022-01-05T00:00:00.000Z",
        "formattedDate": "2022年1月5日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 2.5,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "（二刷）LeetCode——最大连续1的个数 III（滑动窗口）",
          "date": "2022-01-05T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "LeetCode——最小栈（辅助栈）",
          "permalink": "/blog/LeetCode——最小栈（辅助栈）"
        },
        "nextItem": {
          "title": "Vue与antd结合使用",
          "permalink": "/blog/Vue与antd结合使用"
        }
      },
      "content": "## 题目描述\r\n> 这道题目和[替换后的最长重复字符](https://juejin.cn/post/6996160679795228680)有异曲同工之妙，建议大家结合着来刷题。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/f58dc7e951f09807c4b31bf8d987855f.png)\r\n\r\n## 解题思路\r\n\r\n1. 滑动窗口是这道题目的核心解题思想，既然有滑动窗口少不了的是左右指针和最大值。\r\n\r\n2. 定义一个数组用来存储0和1出现的次数。\r\n\r\n3. 右指针是核心循环条件，当右指针走到数组的长度的位置的时候，此时结束循环。\r\n\r\n* 进入循环后，首先更新右指针指向元素出现的次数，只有指向元素是1的时候，才会更新最大值。这个最大值表示的是1出现的最大次数。\r\n\r\n* 当滑动窗口的长度比max + k大的时候，开始移动左指针，同时左右指针对应出现的次数还要相应减少。\r\n\r\n4. 返回数组的长度 - 左指针 就是连续1的最大个数。\r\n\r\n```js\r\nvar longestOnes = function(nums, k) {\r\n\r\n  // 尝试使用滑动窗口来解决这个问题\r\n  let left = 0;\r\n  let right = 0;\r\n  // 请注意：下标0对应的值代表的是元素0出现的次数，下标1对应的是1出现的次数\r\n  let array = [0,0]\r\n  // 滑动窗口内1出现的最大次数\r\n  let max = 0;\r\n  while (right < nums.length) {\r\n    // 首先更新右指针指向元素出现的次数\r\n    if (nums[right] === 0) {\r\n      array[0]++;\r\n    } else {\r\n      array[1]++;\r\n      // 这个max是核心啊，这里的max表示的是1出现的最大次数\r\n      max = Math.max(max,array[nums[right]]);\r\n    }\r\n    // 更新最大值\r\n\r\n    // 移动左指针的情况\r\n    if (right - left + 1 > max + k) {\r\n      array[nums[left]]--;\r\n      left++;\r\n      array[nums[right]]--;\r\n    } else {\r\n      right++;\r\n    }\r\n\r\n  }\r\n  return nums.length - left;\r\n};\r\n```\r\n\r\n## 题目反思\r\n> 我们在解决一个问题的时候，不仅仅要会这一个题目，还要举一反三，很多题目都有类似的思路，可能只需要进行细微的改动即可。"
    },
    {
      "id": "/Vue与antd结合使用",
      "metadata": {
        "permalink": "/blog/Vue与antd结合使用",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Vue与antd结合使用.md",
        "source": "@site/blog\\Vue与antd结合使用.md",
        "title": "Vue与antd结合使用",
        "description": "什么是antd？",
        "date": "2022-01-04T00:00:00.000Z",
        "formattedDate": "2022年1月4日",
        "tags": [
          {
            "label": "Vue",
            "permalink": "/blog/tags/vue"
          }
        ],
        "readingTime": 4.25,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Vue与antd结合使用",
          "date": "2022-01-04T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Vue",
          "tags": [
            "Vue"
          ]
        },
        "prevItem": {
          "title": "（二刷）LeetCode——最大连续1的个数 III（滑动窗口）",
          "permalink": "/blog/（二刷）LeetCode——最大连续1的个数 III（滑动窗口）"
        },
        "nextItem": {
          "title": "在Egg.js中格式化日期",
          "permalink": "/blog/在Egg.js中格式化日期"
        }
      },
      "content": "## 什么是antd？\r\n> antd是蚂蚁集团旗下开发的一款优秀的前端UI框架，目前这个框架支持Vue和React。这个框架主要用于开发企业级的后台产品，如果想开发移动端应用的话可以选择Ionic。\r\n\r\n## 选择合适的官方文档\r\n>在antd vue官网上选择2.x的antd，因为这个版本对应的是vue3的。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/79213f1bb286c20e8e90b493f211f765.png)\r\n\r\n## 使用步骤\r\n1. 在已有的antd项目中安装antd。\r\n\r\n```js\r\nnpm i --save ant-design-vue@next\r\n```\r\n\r\n2. 在入口文件中引入antd以及antd.css，并挂载到vue身上。\r\n\r\n```js\r\nimport Antd from 'ant-design-vue';\r\nimport 'ant-design-vue/dist/antd.css';\r\napp.use(Antd);\r\n```\r\n\r\n3. 只需在组件的模板中直接使用即可。\r\n\r\n### 添加图标\r\n1. 在script标签中引入图标\r\n\r\n```js\r\nimport {\r\n  HomeOutlined,\r\n} from '@ant-design/icons-vue';\r\n```\r\n\r\n2. 注册组件\r\n\r\n```js\r\n  components: {\r\n    HomeOutlined\r\n  }\r\n```\r\n\r\n3. 使用组件\r\n\r\n```js\r\n<HomeOutlined />\r\n```\r\n\r\n4. 可以通过行内样式的形式来改变组件的样式\r\n\r\n```js\r\n<HomeOutlined style=\"color: blue\" />\r\n```\r\n\r\n5. 在按钮里加入图标（通过template）\r\n\r\n```js\r\n<a-button type=\"primary\" :size=\"size\">\r\n  <template #icon>\r\n    <DownloadOutlined />\r\n  </template>\r\n  Download\r\n</a-button>\r\n```\r\n\r\n> 注意：上面的这种写法依然要引入并注册。\r\n\r\n## 表单组件\r\n> 下面是vue结合antd的基础表单组件的实现效果和代码。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/c65443818a2dac978eee77e473ac6697.png)\r\n\r\n```js\r\n<template>\r\n  <div>\r\n    <ul class=\"input_list\">\r\n      <li>姓名：<a-input v-model:value=\"userinfo.username\"></a-input></li>\r\n      <li>年龄：<a-input v-model:value=\"userinfo.age\"></a-input></li>\r\n      <li>\r\n        性别：\r\n        <a-radio-group v-model:value=\"userinfo.sex\">\r\n          <a-radio value=\"男\">男</a-radio>\r\n          <a-radio value=\"女\">女</a-radio>\r\n        </a-radio-group>\r\n      </li>\r\n      <li>\r\n        爱好：\r\n        <span v-for=\"(item, index) in userinfo.hobbies\" :key=\"index\">\r\n          <a-checkbox v-model:checked=\"item.checked\">{{\r\n            item.label\r\n          }}</a-checkbox>\r\n        </span>\r\n      </li>\r\n      <li>\r\n        城市：\r\n        <a-select\r\n          v-model:value=\"userinfo.selectedCity\"\r\n          mode=\"tags\"\r\n          style=\"width: 300px\"\r\n          placeholder=\"选择城市\"\r\n          :options=\"userinfo.options\"\r\n        >\r\n        </a-select>\r\n      </li>\r\n      <li>\r\n        生日：\r\n        <a-date-picker v-model:value=\"userinfo.birthday\" @change=\"pickerChange\" />\r\n      </li>\r\n    </ul>\r\n\r\n    {{ userinfo }}\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport { defineComponent } from \"vue\";\r\nimport moment from 'moment';\r\nconst dateFormat = \"YYYY-MM-DD\";\r\nexport default defineComponent({\r\n  data() {\r\n    return {\r\n      userinfo: {\r\n        username: \"\",\r\n        age: \"\",\r\n        sex: \"男\",\r\n        hobbies: [\r\n          { label: \"吃饭\", checked: true },\r\n          { label: \"睡觉\", checked: true },\r\n          { label: \"写代码\", checked: false },\r\n        ],\r\n        options: [\r\n          { value: \"北京\" },\r\n          { value: \"上海\" },\r\n          { value: \"广州\" },\r\n          { value: \"深圳\" },\r\n        ],\r\n        selectedCity: [\"北京\"],\r\n        birthday: moment('2021-01-03', dateFormat),\r\n      },\r\n    };\r\n  },\r\n  methods: {\r\n    pickerChange(e) {\r\n      // console.log(e._d)\r\n      if (!e) return;\r\n      var oDate = new Date(e._d);\r\n      console.log(oDate.getTime());\r\n    },\r\n  },\r\n});\r\n</script>\r\n\r\n<style lang=\"scss\">\r\nul {\r\n  list-style: none;\r\n}\r\n\r\n.input_list {\r\n  padding: 10px;\r\n  li {\r\n    margin-bottom: 15px;\r\n    & > input {\r\n      width: 400px !important;\r\n    }\r\n  }\r\n}\r\n</style>\r\n```\r\n\r\n## 在Node.js中实现图片上传或文件\r\n1. 安装第三方依赖\r\n\r\n```shell\r\nnpm i --save multer\r\n```\r\n\r\n2. 引入multer模块\r\n\r\n```js\r\nconst multer = require('multer');\r\n```\r\n\r\n3. 配置storage\r\n\r\n```js\r\nvar storage = multer.diskStorage({\r\n//配置上传的目录\r\ndestination: async (req, file, cb)=>{\r\n    //1、获取当前日期 20200703\r\n    let day=sd.format(new Date(), 'YYYYMMDD');\r\n    // static/upload/20200703\r\n    let dir=path.join(\"static/upload\",day)\r\n    //2、按照日期生成图片存储目录  mkdirp是一个异步方法\r\n    await mkdirp(dir)   \r\n\r\n    cb(null, dir) //上传之前目录必须存在\r\n},\r\n//修改上传后的文件名\r\nfilename: (req, file, cb)=> {\r\n    //1、获取后缀名\r\n    let extname= path.extname(file.originalname);\r\n    //2、根据时间戳生成文件名\r\n    cb(null, Date.now()+extname)\r\n}\r\n```\r\n\r\n4. 使用multer\r\n\r\n* tools.js\r\n\r\n```js\r\nconst multer = require('multer');\r\nconst path = require('path');\r\nconst sd = require('silly-datetime');\r\nconst mkdirp = require('mkdirp')\r\nlet tools={\r\n    multer(){\r\n\r\n        var storage = multer.diskStorage({\r\n            //配置上传的目录\r\n            destination: async (req, file, cb)=>{\r\n                //1、获取当前日期 20200703\r\n                let day=sd.format(new Date(), 'YYYYMMDD');\r\n                // static/upload/20200703\r\n                let dir=path.join(\"static/upload\",day)\r\n                //2、按照日期生成图片存储目录  mkdirp是一个异步方法\r\n                await mkdirp(dir)   \r\n                \r\n                cb(null, dir) //上传之前目录必须存在\r\n            },\r\n            //修改上传后的文件名\r\n            filename: (req, file, cb)=> {\r\n                //1、获取后缀名\r\n                let extname= path.extname(file.originalname);\r\n                //2、根据时间戳生成文件名\r\n                cb(null, Date.now()+extname)\r\n            }\r\n        })\r\n        \r\n        var upload = multer({ storage: storage })\r\n\r\n        return upload;\r\n        \r\n    },\r\n    md5(){\r\n\r\n    }\r\n}\r\n\r\nmodule.exports=tools\r\n```\r\n\r\n* routers.js\r\n\r\n```js\r\nrouter.post(\"/doAdd\",tools.multer().single(\"pic\"), (req, res) => {\r\n    //获取表单传过来的数据    \r\n    res.send({\r\n        body: req.body,\r\n        file: req.file\r\n    });\r\n})\r\n```"
    },
    {
      "id": "/在Egg.js中格式化日期",
      "metadata": {
        "permalink": "/blog/在Egg.js中格式化日期",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/在Egg.js中格式化日期.md",
        "source": "@site/blog\\在Egg.js中格式化日期.md",
        "title": "在Egg.js中格式化日期",
        "description": "将时间戳格式化为时分秒",
        "date": "2022-01-03T00:00:00.000Z",
        "formattedDate": "2022年1月3日",
        "tags": [
          {
            "label": "Egg.js",
            "permalink": "/blog/tags/egg-js"
          }
        ],
        "readingTime": 0.345,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "在Egg.js中格式化日期",
          "date": "2022-01-03T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Egg.js",
          "tags": [
            "Egg.js"
          ]
        },
        "prevItem": {
          "title": "Vue与antd结合使用",
          "permalink": "/blog/Vue与antd结合使用"
        },
        "nextItem": {
          "title": "图解前端调试工具Chrome Dev Tools的使用",
          "permalink": "/blog/图解前端调试工具Chrome Dev Tools的使用"
        }
      },
      "content": "## 将时间戳格式化为时分秒\r\n1. 在app文件夹下创建文件夹extend,然后在extend文件夹下创建helper.js\r\n\r\n```js\r\nconst sd = require('silly-datetime');\r\n\r\nmodule.exports = {\r\n  formatTime(unix) {\r\n    return sd.format(new Date(unix * 1000),'YYYY-MM-DD HH:mm');\r\n  }\r\n}\r\n```\r\n\r\n2. 将时间戳修改为时分秒\r\n\r\n```js\r\nhelper.formatTime(list[i].addTime)\r\n```"
    },
    {
      "id": "/图解前端调试工具Chrome Dev Tools的使用",
      "metadata": {
        "permalink": "/blog/图解前端调试工具Chrome Dev Tools的使用",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/图解前端调试工具Chrome Dev Tools的使用.md",
        "source": "@site/blog\\图解前端调试工具Chrome Dev Tools的使用.md",
        "title": "图解前端调试工具Chrome Dev Tools的使用",
        "description": "快捷指令速查表",
        "date": "2022-01-02T00:00:00.000Z",
        "formattedDate": "2022年1月2日",
        "tags": [
          {
            "label": "debug",
            "permalink": "/blog/tags/debug"
          }
        ],
        "readingTime": 2.32,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "图解前端调试工具Chrome Dev Tools的使用",
          "date": "2022-01-02T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "debug",
          "tags": [
            "debug"
          ]
        },
        "prevItem": {
          "title": "在Egg.js中格式化日期",
          "permalink": "/blog/在Egg.js中格式化日期"
        },
        "nextItem": {
          "title": "LeetCode——环形链表（快慢指针）",
          "permalink": "/blog/LeetCode——环形链表（快慢指针）"
        }
      },
      "content": "## 快捷指令速查表\r\n\r\n| 标题 |  |\r\n| --- | --- |\r\n| 快速打开Dev Tools | `Ctrl + Shift + i` |\r\n| 打开命令菜单 | `Ctrl + Shift + P` |\r\n| 快速打开Dev Tools | `Ctrl + Shift + i` |\r\n| 快速打开Dev Tools | `Ctrl + Shift + i` |\r\n| 快速打开Dev Tools | `Ctrl + Shift + i` |\r\n| 快速打开Dev Tools | `Ctrl + Shift + i` |\r\n| 快速打开Dev Tools | `Ctrl + Shift + i` |\r\n| 快速打开Dev Tools | `Ctrl + Shift + i` |\r\n| 快速打开Dev Tools | `Ctrl + Shift + i` |\r\n\r\n## 修改Dev Tools的主题\r\n* 修改为dark主题\r\n\r\n`dark theme`\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/7c84164c2678b5e2eaf50acad1c801bb.png)\r\n\r\n* 修改为白色主题\r\n`light theme`\r\n\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/322037a1343e3bc9cd9e2d4772dcc761.png)\r\n\r\n## 截屏\r\n`screenshot`\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/913cbf806ff51aac6e25bdd0b90e0962.png)\r\n\r\n## 改变调试窗口的位置\r\n1. `dock to right`\r\n2. `dock to left`\r\n3. `dock to bottom`\r\n\r\n## 常用Tab介绍\r\n### 1. Element\r\n* 查看页面在移动端布局的样子，可以点击下面的按钮\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/675e3165db00d83de494be2d7b5abea1.png)\r\n\r\n* 给目标元素添加样式\r\n>首先选中元素，然后在下面添加样式\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/fe48b8354aae29cd4c039813782c1acc.png)\r\n\r\n* 让hover永驻\r\n\r\n>选中目标元素然后点击下面的内容\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/3d0fc9f11adf3350d244de19ce0551b8.png)\r\n\r\n* 只修改列表项中的某一个\r\n\r\n>选中目标元素点击cls\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/5179276c8a8c1bf152280be8eee820db.png)\r\n\r\n* 复制样式并粘贴样式\r\n\r\n>选中目标样式，然后点击copy styles\r\n\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/f3d8489d3876f8dca2884bee746143da.png)\r\n\r\n>选中需要粘贴样式的位置，然后粘贴到下面的位置\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/f01b1ed2b172ea6d541f84a75db9ef6a.png)\r\n\r\n#### Computed\r\n>这个tab栏主要记载了当前页面都应用了哪些样式，通过点击可以跳转到这些样式。\r\n\r\n* Show all与Group\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/7c277f267d9f1c4f6ebb022a0d0a7f73.png)\r\n\r\n#### Layout\r\n>在Layout标签下可以调试Grid布局和Flex布局。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/c9c81721cd3008f047ed95d2a83c2d26.png)\r\n\r\n>勾选flex元素可以给flex元素加上横线边框。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/649286a8ee65c3f7fc07e9882d31bf95.png)\r\n\r\n>可以通过styles面板中的点击图标来测试flex的其他属性。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/c7bf269184aa06a8a87894fe80e1b1f1.png)\r\n\r\n#### Event Listeners \r\n>该面板可以查看当前页面所有的监听事件。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/930cb008cb3c362be9d7548390979c26.png)"
    },
    {
      "id": "/LeetCode——环形链表（快慢指针）",
      "metadata": {
        "permalink": "/blog/LeetCode——环形链表（快慢指针）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——环形链表（快慢指针）.md",
        "source": "@site/blog\\LeetCode——环形链表（快慢指针）.md",
        "title": "LeetCode——环形链表（快慢指针）",
        "description": "题目描述",
        "date": "2022-01-01T00:00:00.000Z",
        "formattedDate": "2022年1月1日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.12,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——环形链表（快慢指针）",
          "date": "2022-01-01T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "图解前端调试工具Chrome Dev Tools的使用",
          "permalink": "/blog/图解前端调试工具Chrome Dev Tools的使用"
        },
        "nextItem": {
          "title": "这一次，彻底搞懂ES6新特性",
          "permalink": "/blog/这一次，彻底搞懂ES6新特性"
        }
      },
      "content": "## 题目描述\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/c0edd8eae273ffde940785b9413d94bc.png)\r\n\r\n## 解题思路\r\n\r\n> 环形链表这个题目最容易出现错误的地方就是死循环的问题，所以我们要注意防止出现死循环，关键的思想就在于如果一个链表是环形链表，一个指针走得快，另一个指针走得慢，那么这两个指针一定会相遇，这就是这道题的核心思想，也是判断链表是否有环的关键思想。\r\n\r\n```js\r\nvar hasCycle = function(head) {\r\n  // 快慢指针是解决环形链表的不二法门\r\n  let fast = head;\r\n  let slow = head;\r\n\r\n  while (fast) {\r\n    if (fast.next === null) {\r\n      return false;\r\n    }\r\n    fast = fast.next.next;\r\n    slow = slow.next;\r\n    if (fast === slow) return true;\r\n  }\r\n\r\n  return false;\r\n};\r\n```\r\n\r\n## 题目反思\r\n> 判断一个链表是否有环，通过快慢指针是否相遇来进行判断是一个很值得学习到的思路。"
    },
    {
      "id": "/这一次，彻底搞懂ES6新特性",
      "metadata": {
        "permalink": "/blog/这一次，彻底搞懂ES6新特性",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/这一次，彻底搞懂ES6新特性.md",
        "source": "@site/blog\\这一次，彻底搞懂ES6新特性.md",
        "title": "这一次，彻底搞懂ES6新特性",
        "description": "ES6新特性都有哪些？",
        "date": "2021-12-31T00:00:00.000Z",
        "formattedDate": "2021年12月31日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 19.005,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "这一次，彻底搞懂ES6新特性",
          "date": "2021-12-31T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "LeetCode——环形链表（快慢指针）",
          "permalink": "/blog/LeetCode——环形链表（快慢指针）"
        },
        "nextItem": {
          "title": "Webpack中externals与dll",
          "permalink": "/blog/Webpack中externals与dll"
        }
      },
      "content": "## ES6新特性都有哪些？\r\n\r\n### 1. 类class\r\n>ES6中的class不是新的对象继承模型，它只是原型链的语法糖表现形式。\r\n\r\n>ES6类的几点注意事项\r\n\r\n* 类名最好大写\r\n* constructor关键字在类定义的内部创建类的构造函数，这个关键字会告诉解释器在使用new操作符创建类的新实例时，应该调用这个函数，构造函数的定义不是必须的，不定义构造函数相当于将构造函数定义为空函数。\r\n* 类的语法可以非常方便的定义属性应该存在于实例上，还是原型上，还是类本身上。（在constructor构造函数中写的存在于实例上，直接写在类中的普通函数是存在于原型上的，通过static关键字标识的函数是存在于类身上的）\r\n\r\n```js\r\nclass Person { \r\n     constructor() { \r\n         // 存在于实例上\r\n         this.locate = () => console.log('instance', this); \r\n     } \r\n     // 存在于原型对象上\r\n     locate() { \r\n        console.log('prototype', this); \r\n     } \r\n \t// 存在于类身上\r\n     static locate() { \r\n        console.log('class', this); \r\n     } \r\n} \r\nlet p = new Person(); \r\np.locate(); // instance, Person {} \r\nPerson.prototype.locate(); // prototype, {constructor: ... } \r\nPerson.locate(); // class, class Person {}\r\n```\r\n\r\n* ES6中的类使用extends关键字来继承拥有构造函数的原型的对象，这意味着不仅可以继承一个类，也可以继承普通的构造函数。\r\n\r\n### 2. 模块化（Module）\r\n> 在ES6模块化之前有AMD、CMD、require.js以及后面的sea.js，这些都是第三方的插件，ES6的module的不同之处在于，它的运行环境是编译时的，也就是说在编译时就会把所有的依赖导入导出。\r\n\r\n> ES6模块化的核心就是通过export进行暴露，通过import进行引入，其中export和import可以有多个在一个文件或者模块中，但是export default只有一个，在导入的时候，如果时export暴露的，需要通过解构赋值的形式取出来，但是如果时export default则不需要。\r\n\r\n\r\n### 3. 箭头函数\r\n>关于箭头函数的内容，本文不再进行过多的赘述，详情请看我的这篇文章[这一次，彻底搞懂箭头函数](https://juejin.cn/post/7041055543984652319)\r\n\r\n> 箭头函数的核心就是下面的七个特点：\r\n\r\n1. 相比普通函数，箭头函数有更加简洁的语法。\r\n2. 箭头函数不会绑定this，会捕获其所在上下文的this，作为自己的this。\r\n3. 箭头函数是匿名函数，不能作为构造函数，不可以使用new命令，否则会报错。\r\n4. 箭头函数不绑定arguments，取而代之用rest参数解决，同时没有super和new.target。\r\n5. 使用call、apply、bind并不会改变箭头函数中的this指向。\r\n6. 箭头函数没有原型对象prototype属性。\r\n7. 不能使用yield关键字，不能作为generator函数。\r\n\r\n### 4. 函数参数默认值\r\n>ES6中为函数的参数提供了默认值，如果没有传递相关参数，相关参数则使用默认值，默认参数通过直接给参数进行赋值实现。\r\n\r\n```js\r\nfunction greet(name = 'Student', greeting = 'Welcome') {\r\n  return `${greeting} ${name}!`;\r\n}\r\n\r\ngreet(); // Welcome Student!\r\ngreet('James'); // Welcome James!\r\ngreet('Richard', 'Howdy'); // Howdy Richard!\r\n```\r\n\r\n### 5. 模板字符串\r\n> ES6新增了使用模板字面量来定义字符串的能力。模板字面量使用反引号，模板字面量会保持反引号内部的空格，在模板字符串中通过${}的形式可以使用JavaScript表达式。\r\n\r\n\r\n### 6. 解构赋值\r\n>解构赋值包括对象的解构赋值和数组的结构赋值。\r\n\r\n#### 对象的解构赋值\r\n> 对象的解构赋值通过{key}的形式来实现，对象的解构赋值中，如果在相同作用域中存在同名的变量，就会产生冲突，如果想要避免冲突，可以在解构赋值的时候进行重命名。\r\n\r\n```js\r\nconst obj = {\r\n  name: '666',\r\n  age: 3\r\n}\r\nconst {name} = obj;\r\nconsole.log(name)  // 666\r\n```\r\n\r\n> 重命名\r\n\r\n```js\r\nconst obj = {\r\n  name: '大前端',\r\n  age: 3\r\n}\r\n\r\nconst name = '大前端2'\r\nconst {\r\n  name: testName\r\n} = obj\r\nconsole.log(testName)  //大前端\r\n```\r\n\r\n#### 数组的解构赋值\r\n> 数组的解构赋值会根据变量的位置进行分配数组中对应位置的成员，也可以通过拓展运算符来进行解构数组最后的所有成员，也可以通过逗号进行代替解构赋值。\r\n\r\n1. 通过位置进行解构\r\n\r\n```js\r\nconst arr = [100,200,300];\r\n\r\nconst [foo,bar,baz] = arr;\r\n\r\nconsole.log(foo); // 100\r\nconsole.log(bar); // 200\r\nconsole.log(baz); // 300\r\n```\r\n\r\n2. 使用逗号进行代替解构\r\n\r\n```js\r\nconst arr = [100,200,300];\r\nconst [,,baz] = arr;\r\nconsole.log(baz); //300\r\n```\r\n\r\n3. 通过拓展运算符来解构数组的最后成员\r\n\r\n```js\r\nconst arr = [100,200,300,400];\r\nconst [,,...baz] = arr;\r\nconsole.log(baz); // [300,400]\r\n```\r\n\r\n### 7. 拓展运算符与rest参数\r\n> rest参数的形式为: `...变量名`,拓展运算符是三个点`...`。\r\n\r\n#### rest参数\r\n> rest参数用于获取函数的多余参数，与rest参数搭配的变量会变成一个数组，会将多余的参数放入数组中，需要注意的是使用rest参数的后面不能再有其他参数。\r\n\r\n```js\r\nfunction add(...values) {\r\n  let sum = 0;\r\n  console.log(values);  // [1,2,3]\r\n  for (var val of values) {\r\n    sum += val;\r\n  }\r\n  return sum;\r\n}\r\n\r\nadd(1, 2, 3) // 6\r\n```\r\n\r\n#### 拓展运算符\r\n> 拓展运算符可以看作是rest参数的逆运算，将一个数组转为用逗号分割的参数序列。\r\n\r\n```js\r\nconsole.log(...[1,2,3]);  // 1 2 3\r\n\r\nconsole.log(1,...[2,3,4],5); // 1 2 3 4 5\r\n```\r\n\r\n#### rest参数和arguments对象的区别\r\n1. rest参数只包含那些没有对应形参的实参，而arguments对象包含了传给函数的所有实参。\r\n2. arguments对象不是一个真实的数组，而rest参数是真实地Array实例，能在这个实例上直接使用数组的所有方法。\r\n3. arguments对象还有一些附加的属性，比如callee属性。\r\n\r\n### 8. 对象属性简写\r\n> 在ES6中定义对象的时候，如果对象的属性名和外部的变量名同名的时候，可以省略值，直接写属性名。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/f7860b59c403305e564a8ac8af85fe49.png)\r\n\r\n> 对象中定义函数的时候，可以省略function。\r\n\r\n```js\r\nlet obj = {\r\n  getName() {\r\n    return 111;\r\n  }\r\n}\r\n```\r\n\r\n### 9. Promise\r\n#### 为什么要引入Promise?\r\n> 在没有Promise之前，要想处理异步操作，常见的做法是使用回调函数，但回调函数虽然能够解决我么能实现异步操作队列化的需求，但当出现一个方法中嵌套着多个回调函数的时候，此时代码结构就会变得十分臃肿，也就是出现了回调地狱的问题，而Promise对象的差生就是为了解决回调地狱的问题，同时Promise的另一个特性就是支持多个并发的请求，获取并发请求中的数据。\r\n\r\n#### 什么是Promise?\r\n> Promise是异步编程的一种解决方案，从语法上讲,Promise是一个对象，使用它可以获取异步操作的消息，从意义上将，它是承诺，承诺过一段时间会给你一个结果，Promise有三个状态：pending,fulfiled，rejected。状态一旦改变就不会在变，创造promise实例后，它会立即执行。\r\n\r\n#### Promise的构造函数\r\n> Promise是一个构造函数，自己身上由all,race,resolve,reject等方法，原型上由then，catch,finally等方法。Promise的构造函数接收一个参数，这个参数是一个函数，函数需要传入两个参数，resolve和reject，resolve代表的是异步操作成功的回调函数，reject是异步操作失败的回调函数。\r\n\r\n\r\n### 10. 块级作用域let与const\r\n> 关于块级作用域let与const，请看即将发布的[let,var,const的区别]。\r\n\r\n### 11. 基本数据类型Symbol\r\n> Symbol类型是为了解决属性名冲突的问题，同时还具备模拟私有属性的功能。\r\n\r\n#### Symbol变量的特点\r\n1. 创建Symbol变量可以使用Symbol()函数。\r\n2. symbol可以作为对象属性名。（只有字符串和symbol类型才能用作对象属性名。）\r\n3. 没有两个symbol的值是相等的。\r\n\r\n```js\r\nconst symbol1 = Symbol();\r\nconst symbol2 = Symbol();\r\n// 下面这个情况：说明两个symbol是不相等的。\r\nconsole.log(symbol1 === symbol2);  // false\r\n\r\n// 下面的这个情况说明，symbol类型可以作为对象属性名\r\nconst obj = {};\r\nobj[symbol1] = '666';\r\nobj[symbol2] = '777';\r\n\r\nconsole.log(obj[symbol1]); // 666\r\nconsole.log(obj[symbol2]); // 777\r\n```\r\n\r\n#### Symbol的应用场景\r\n1. 描述信息\r\n\r\n> symbol函数只有一个参数，字符串description,这个参数的作用是辅助调试，也就是它的toString值，需要注意的是，两个具有相同descrption的Symbol也是不相等的。\r\n\r\n```js\r\nconst symbol1 = Symbol('my test');\r\nconst symbol2 = Symbol('my test');\r\n\r\n// 下面这个情况说明，通过Symbol函数产生的symbol即使描述一致，也是不相等的\r\nconsole.log(symbol1 === symbol2); // false\r\nconsole.log(symbol1); // 'Symbol(my test)'\r\n```\r\n\r\n> 通过Symbol.for()创建的Symbol会添加到全局的symbol注册中心，并用这个description作为key，也就是说通过Symbol.for()创建的具有相同description的两个symbol是相等的。\r\n\r\n```js\r\nconst symbol1 = Symbol.for('my test');\r\nconst symbol2 = Symbol.for('my test');\r\n\r\n// 下面这个情况说明，通过symbol.for创建的symbol，如果description相同，它们就是相等的\r\nconsole.log(symbol1 === symbol2); // true\r\nconsole.log(symbol1); // 'Symbol(my test)'\r\n```\r\n\r\n> 一般不是用Symbol.for创建symbol，因为这会带来命名冲突的问题。\r\n\r\n2. 解决命名冲突\r\n\r\n> JavaScript内置了一个symbol，那就是ES6中的Symbol.iterator，拥有Symbol.iterator函数的对象被称为可迭代对象，可以在该对象上使用for/of循环。\r\n\r\n```js\r\nconst fibonacci = {\r\n  [Symbol.iterator]: function*() {\r\n    let a = 1;\r\n    let b = 1;\r\n    let temp;\r\n\r\n    yield b;\r\n\r\n    while (true) {\r\n      temp = a;\r\n      a = a + b;\r\n      b = temp;\r\n      yield b;\r\n    }\r\n  }\r\n};\r\n\r\n// Prints every Fibonacci number less than 100\r\nfor (const x of fibonacci) {\r\n  if (x >= 100) {\r\n    break;\r\n  }\r\n  console.log(x);\r\n}\r\n```\r\n\r\n3. 模拟私有属性\r\n\r\n> 由于任何两个symbol都不相等，所以可以使用symbol来模拟私有属性，通过Object.keys或者JSON.stringify()无法获取到symbol，除非通过Object.getOwnPropertySymbols()函数获取。\r\n\r\n```js\r\nfunction getObj() {\r\n  const symbol = Symbol('test');\r\n  const obj = {};\r\n  obj[symbol] = 'test';\r\n  return obj;\r\n}\r\n\r\nconst obj = getObj();\r\n\r\nObject.keys(obj); // []\r\n\r\n// 除非有这个 symbol 的引用，否则无法访问该属性\r\nobj[Symbol('test')]; // undefined\r\n\r\n// 用 getOwnPropertySymbols() 依然可以拿到 symbol 的引用\r\nconst [symbol] = Object.getOwnPropertySymbols(obj);\r\n\r\nobj[symbol]; // 'test'\r\n```\r\n\r\n### 12. Set和Map数据结构\r\n> Set，类似于数组，但是成员的值都是唯一的，没有重复的值，Set本身是一个构造函数，用来生成Set数据结构。\r\n\r\n> Map，类似于对象，也是键值对的结合，但是键的范围不限于字符串，各种类型的值包括对象都可以当作键，也就是说普通的对象提供了字符串到值的对应，而Map数据结构提供了值到值的对应，是一种更加完善的Hash结构实现。\r\n\r\n> 更多详细的内容，请参见这篇文章[深入理解：ES6中的Set和Map数据结构，Map与其它数据结构的互相转换](https://segmentfault.com/a/1190000016411261)，后续我将出一篇文章，更加详细的阐述其中的区别，但这不是本文的重点。\r\n\r\n\r\n### 13. 提供了Proxy构造函数\r\n#### 什么是proxy？\r\n> proxy在目标对象之前假设一层代理，外界对该对象的访问，都必须先经过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。\r\n\r\n#### proxy的语法\r\n> 参数解释：target表示的是要代理的目标对象，handler表示的是定义拦截行为的配置对象。\r\n\r\n```js\r\nlet proxy = new Proxy(target, handler);\r\n```\r\n\r\n#### get(target, key, receiver)\r\n\r\n```js\r\nconst proxy1 = new Proxy(\r\n  {\r\n    a: 1\r\n  },\r\n  {\r\n    get(target, key) {\r\n      if (Reflect.has(target, key)) {\r\n        return Reflect.get(target, key);\r\n      } else {\r\n        return false;\r\n      }\r\n\r\n    }\r\n  }\r\n)\r\nproxy1.a //1\r\nproxy1.b //false\r\n```\r\n\r\n> 上面这个例子很好的说明了，proxy的基础用法，更多关于peoxy的内容，博主将在后续的文章中更新，敬请关注。\r\n\r\n### 14. 提供了迭代器和生成器\r\n\r\n#### 为什么需要迭代器？\r\n> 在ES6之前，一般通过数组的下标来进行遍历，但是随着循环的嵌套就需要追踪多个变量，这给遍历带来了很多麻烦，因此迭代器的出现就是为了消除这种复杂性并减少循环中的错误。\r\n\r\n#### 什么是迭代器？\r\n> 迭代器iterator，在JavaScript中，迭代器是一个独享，它提供了一个next()方法，用来返回迭代序列中的下一项，next方法是一个函数，执行完后返回一个对象包括两个属性:{done: [boolean],value: [any]}。任何数据结构只要不输Iterator接口，就可以进行遍历。\r\n\r\n#### 迭代器的工作原理\r\n1. 创建一个指针对象，指向数据结构的起始位置。\r\n2. 第一次调用next方法，指针自动指向数据结构的第一个成员。\r\n3. 接下来不断调用next方法，指针会一直往后移动，知道指向最后一个元素。\r\n4. 每次调用next方法返回的是一个包含value和done的对象,{value: 当前成员的值，done: 布尔值},value表示当前成员的值，done对应的布尔值表示当前的数据的结构是否遍历结束。\r\n\r\n#### 手写迭代器\r\n\r\n```js\r\nfunction makeIterator(array) {\r\n  var nextIndex = 0\r\n  return {\r\n    next() {\r\n      return nextIndex < array.length ? \r\n        { value: array[nextIndex++], done: false } : \r\n        { done: true }\r\n    }\r\n  }\r\n}\r\n\r\n// iterator 是一个迭代器对象\r\nvar iterator = makeIterator([10, 20, 30])\r\niterator.next() // {value: 10, done: false}\r\niterator.next() // {value: 20, done: false}\r\niterator.next() // {value: 30, done: false}\r\niterator.next() // {done: true}\r\n```\r\n\r\n#### 什么是生成器？\r\n> 生成器是ES6提供的一种异步编程解决方案，在语法上，可以把它理解为一个状态机，内部封装了多种状态。执行generator，会生成返回一个迭代器对象，返回的迭代器对象可以遍历生成器函数的每一个状态，同时ES6规定这个迭代器是生成器的函数实例，也继承了生成器函数的原型对象上的方法。\r\n\r\n#### 生成器的特征\r\n1. function关键字和函数名之间有一个星号。\r\n2. 函数内部使用yield关键字定义不同的内部状态。\r\n\r\n#### 基本用法\r\n> 当我们实例化一个生成器函数之后，这个实例就是一个迭代器，可以同感next方法去启动生成器以及控制生成器是否往下执行。通过yield语句可以在生成器函数内部暂停代码的执行使其挂起，此时生成器函数仍然是运行并且是活跃的，其内部资源都会保留下来，只不过是处在暂停状态。在迭代器上调用next()方法，可以使代码从暂停的位置开始继续往下执行。\r\n\r\n```js\r\nfunction* helloWorldGenerator() {\r\n  yield 'hello';\r\n  yield 'world';\r\n  return 'ending';\r\n}\r\n\r\nvar hw = helloWorldGenerator();\r\n\r\nhw.next()\r\n// { value: 'hello', done: false }\r\n\r\nhw.next()\r\n// { value: 'world', done: false }\r\n\r\nhw.next()\r\n// { value: 'ending', done: true }\r\n\r\nhw.next()\r\n// { value: undefined, done: true }\r\n```\r\n\r\n\r\n## 参考文章\r\n> 特别感谢以下博主的辛勤付出！\r\n\r\n* [ES 6新特性（06）](https://juejin.cn/post/6990516970772758541#heading-15)\r\n\r\n* [JavaScript中的Generator(生成器)](https://cloud.tencent.com/developer/article/1601616)"
    },
    {
      "id": "/Webpack中externals与dll",
      "metadata": {
        "permalink": "/blog/Webpack中externals与dll",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Webpack中externals与dll.md",
        "source": "@site/blog\\Webpack中externals与dll.md",
        "title": "Webpack中externals与dll",
        "description": "externals",
        "date": "2021-12-30T00:00:00.000Z",
        "formattedDate": "2021年12月30日",
        "tags": [
          {
            "label": "webpack",
            "permalink": "/blog/tags/webpack"
          }
        ],
        "readingTime": 2.36,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Webpack中externals与dll",
          "date": "2021-12-30T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "webpack",
          "tags": [
            "webpack"
          ]
        },
        "prevItem": {
          "title": "这一次，彻底搞懂ES6新特性",
          "permalink": "/blog/这一次，彻底搞懂ES6新特性"
        },
        "nextItem": {
          "title": "带你从零学会---基于JWT的接口权限验证",
          "permalink": "/blog/带你从零学会---基于JWT的接口权限验证"
        }
      },
      "content": "## externals\r\n\r\n### 为什么需要externals?\r\n>有时候我们不希望将某些包进行打包，而是通过CDN链接进行引入，此时我们就可以用到externals。\r\n\r\n### 使用externals的步骤\r\n1. 再webpack.config.js中添加配置项指定要忽略打包的内容\r\n\r\n```js\r\n  externals: {\r\n    jquery: 'jQuery'\r\n  }\r\n```\r\n\r\n2. 在静态文件中通过CDN引入\r\n\r\n```js\r\n<script src=\"https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js\"></script>\r\n```\r\n\r\n## dll\r\n### 什么是dll？为什么需要dll?\r\n>dll可以帮助我们对某些库（第三方库：jquery、react、vue...）等库进行单独打包。通过插件引入后，可以有效避免对这些包的重复打包。当运行webpack时，默认查找webpack.config.js配置文件，需要运行下面的指令。\r\n\r\n```shell\r\nwebpack --config webpack.dll.js\r\n```\r\n\r\n### 如何实现dll打包\r\n1. 在webpack.config.js的同名文件创建一个webpack.dll.js文件，并在其中对jquery进行单独打包。\r\n\r\n```js\r\nconst { resolve } = require('path');\r\nconst webpack = require('webpack');\r\n\r\nmodule.exports = {\r\n  entry: {\r\n    jquery: ['jquery']\r\n  },\r\n  output: {\r\n    filename: '[name].js',\r\n    path: resolve(__dirname,'dll'),\r\n    library: '[name]_[hash]'\r\n  },\r\n  plugins: [\r\n    // 打包生成一个manifest.json提供和jquery的映射\r\n    new webpack.DllPlugin({\r\n      name: '[name]_[hash]',\r\n      path: resolve(__dirname,'dll/manifest.json') // 输出文件路径\r\n    })\r\n  ],\r\n  mode: 'production'\r\n}\r\n```\r\n\r\n2. 生成dll文件夹和指定文件\r\n\r\n```shell\r\nwebpack --config webpack.dll.js\r\n```\r\n\r\n3. 在webpack.config.js中增加配置项\r\n\r\n>告诉webpack哪些库不参与打包，并使用插件将dll已经打包好的jquery文件进行引入，这样以后jquery都不需要参与打包了，因为已经打包好了，我们只需要引入即可。\r\n\r\n```js\r\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\r\nconst {resolve} = require('path');\r\nconst webpack = require('webpack');\r\nconst AddAssetHtmlWebpackPlugin = require('add-asset-html-webpack-plugin')\r\n\r\nmodule.exports = {\r\n  entry: './src/index.js',\r\n  output: {\r\n    filename: 'built.js',\r\n    path: resolve(__dirname,'build')\r\n  },\r\n  module: {\r\n    rules: [\r\n\r\n    ]\r\n  },\r\n  plugins: [\r\n    new HtmlWebpackPlugin({\r\n      template: './src/index.html'\r\n    }),\r\n    // 告诉webpack哪些库不参与打包，同时使用的名称根据manifest.json中的来\r\n    new webpack.DllReferencePlugin({\r\n      manifest: resolve(__dirname,'dll/manifest.json')\r\n    }),\r\n    // 将某个文件打包输出去，并在html中自动引入该资源\r\n    new AddAssetHtmlWebpackPlugin({\r\n      filepath: resolve(__dirname,'dll/jquery.js')\r\n    })\r\n  ],\r\n  mode: 'development'\r\n}\r\n```"
    },
    {
      "id": "/带你从零学会---基于JWT的接口权限验证",
      "metadata": {
        "permalink": "/blog/带你从零学会---基于JWT的接口权限验证",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/带你从零学会---基于JWT的接口权限验证.md",
        "source": "@site/blog\\带你从零学会---基于JWT的接口权限验证.md",
        "title": "带你从零学会---基于JWT的接口权限验证",
        "description": "服务端配置JWT的方法",
        "date": "2021-12-29T00:00:00.000Z",
        "formattedDate": "2021年12月29日",
        "tags": [
          {
            "label": "Egg.js",
            "permalink": "/blog/tags/egg-js"
          }
        ],
        "readingTime": 4.325,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "带你从零学会---基于JWT的接口权限验证",
          "date": "2021-12-29T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Egg.js",
          "tags": [
            "Egg.js"
          ]
        },
        "prevItem": {
          "title": "Webpack中externals与dll",
          "permalink": "/blog/Webpack中externals与dll"
        },
        "nextItem": {
          "title": "Egg.js中合成图片二维码的方法",
          "permalink": "/blog/Egg.js中合成图片二维码的方法"
        }
      },
      "content": "## 服务端配置JWT的方法\r\n1. 安装jsonwebtoken第三方工具包\r\n\r\n```shell\r\nnpm i jsonwebtoken\r\n```\r\n\r\n2. 引入jwt\r\n\r\n```js\r\nvar jwt = require('jsonwebtoken');\r\n```\r\n\r\n3. 在控制器中生成token，并进行返回\r\n\r\n```js\r\nrouter.get('/login', function (req, res, next) {\r\n  var token = jwt.sign({ uid: '1', username: \"zhangsan\" }, 'this is sign', {\r\n    expiresIn: 60*60*24\r\n  });\r\n  res.send({\r\n    \"token\":token\r\n  });\r\n});\r\n```\r\n\r\n>注意：sign函数接收的第一个参数表示的是要传递的信息，第二个参数相当于是签名，第三个参数接收的是一个配置对象，对象中可以设置token的过期时间。\r\n\r\n4. 安装basic-auth\r\n\r\n```js\r\nnpm install basic-auth\r\n```\r\n\r\n5. 引入basic-auth\r\n\r\n```js\r\nvar auth = require('basic-auth')\r\n```\r\n\r\n6. 获取到用户传来的token\r\n\r\n```js\r\nconst token = auth(req);\r\n```\r\n\r\n>注意：通过postman传递token，可以通过下面的这种方式来进行传递。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/b1df7596cede81ebe6a0d7186caf923e.png)\r\n\r\n7. 验证token是否合法\r\n\r\n>下面的验证是在控制器中实现的，如果想要实现复用可以在中间件中实现。\r\n\r\n```js\r\nrouter.get('/address', function (req, res, next) {\r\n\r\n  const token = auth(req);\r\n  if (token) {\r\n    try {\r\n      const decoded = jwt.verify(token.name, 'this is sign');\r\n      if (decoded) {\r\n        res.send({\r\n          success: true,\r\n          msg: \"验证成功\"\r\n        })\r\n      } else {\r\n        res.send({\r\n          success: false,\r\n          msg: \"token错误\"\r\n        })\r\n      }\r\n    } catch (error) {\r\n      res.send({\r\n        success: false,\r\n        msg: error\r\n      })\r\n    }\r\n  } else {\r\n    res.send({\r\n      success: false,\r\n      msg: \"token错误\"\r\n    })\r\n  }\r\n})\r\n```\r\n\r\n8. 通过中间件复用验证token的逻辑\r\n\r\n```js\r\n//权限判断的中间件\r\nvar authMiddleWare = function (req, res, next) {\r\n\r\n  var result = auth(req);\r\n  if (!result) {\r\n    res.send({\r\n      success: false,\r\n      msg: \"token错误\"\r\n    });\r\n    return;\r\n  }\r\n  try {\r\n    var decoded = jwt.verify(result.name, 'this is sign');\r\n    console.log(decoded);\r\n    next();\r\n  } catch (error) {\r\n    res.send({\r\n      success: false,\r\n      msg: error\r\n    })\r\n  }\r\n}\r\n```\r\n\r\n9. 在路由匹配时，通过第二个参数来加入中间件判断\r\n\r\n```js\r\nrouter.get('/address',authMiddleWare, function (req, res, next) {\r\n  res.send({\r\n    success: true,\r\n    result:[\r\n      {\"name\":\"张三\",\"address\":\"北京市\"},\r\n      {\"name\":\"李四\",\"address\":\"北京市\"},\r\n      {\"name\":\"王五\",\"address\":\"北京市\"}\r\n    ]      \r\n  });\r\n});\r\n```\r\n\r\n## 前端携带token进行请求的方法\r\n1. 首先将axios挂载到Vue的原型对象上。\r\n\r\n```js\r\nVue.prototype.$http = axios;\r\n```\r\n\r\n2. 前端获取token的方法\r\n\r\n>下面的这个方法不仅获取到了token，而且将token保存到了localstorage上。\r\n\r\n```js\r\n  this.$http\r\n    .get(\"http://localhost:3000/api/login\")\r\n    .then(function(response) {         \r\n      console.log(response.data.token);\r\n\r\n      //保存用户信息 和 token\r\n      localStorage.setItem('token',response.data.token);\r\n    })\r\n    .catch(function(error) {        \r\n      console.log(error);\r\n    });\r\n```\r\n\r\n3. 前端携带token发送请求\r\n\r\n```js\r\ngetAddress() {\r\n  var token=localStorage.getItem('token');\r\n  this.$http\r\n    .get(\"http://localhost:3000/api/address?uid=1&address_id=345\", {\r\n      auth: {\r\n        username: token,\r\n        password: 'sign'\r\n      }\r\n    })\r\n    .then(function(response) {\r\n      console.log(response);\r\n    })\r\n    .catch(function(error) {\r\n      console.log(error);\r\n    });\r\n}\r\n```\r\n\r\n## Egg.js中使用egg-jwt实现接口权限验证\r\n1. 安装egg-jwt\r\n\r\n```js\r\ncnpm i egg-jwt --save\r\n```\r\n\r\n2. 在config下的plugin.js中进行配置\r\n\r\n```js\r\njwt: {\r\n    enable: true,\r\n    package: 'egg-jwt'\r\n  }\r\n```\r\n\r\n3. 在config.default.js下配置密钥\r\n\r\n```js\r\n  // 配置JWT的密钥\r\n  config.jwt = {\r\n    secret: \"123456xxx\"\r\n  }\r\n```\r\n\r\n4. 通过控制器请求指定路由返回token\r\n\r\n```js\r\n  async login() {\r\n    const token = this.app.jwt.sign({foo: 'bar'},this.app.config.jwt.secret,{\r\n      expiresIn: 60*60*2\r\n    });\r\n    this.ctx.body = {\r\n      \"success\": true,\r\n      \"token\": token\r\n    }\r\n  }\r\n```\r\n\r\n5. 配置指定路由需要进行token验证\r\n\r\n>只需在路由的第二个参数上进行配置即可。\r\n\r\n```js\r\nrouter.get(`/api/v1`,app.jwt, controller.api.v1.index);\r\n```\r\n\r\n>注意在egg.js中使用的不是basic auth，而是bearer token，如果想要通过测试工具进行测试可以使用VSCode中的插件Postcode。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/5f79de81afeee2fae73e1288bfc0b44f.png)\r\n\r\n6. 由于egg.js中使用的不是basic auth，因此前端携带token的方式也要进行改变。\r\n\r\n```js\r\ngetIndex() {\r\n  var api = \"http://localhost:7001/api/v1\";\r\n  this.Axios.get(api, {\r\n    headers: {\r\n      Authorization: \"Bearer \" + this.token,\r\n    },\r\n  })\r\n    .then((response) => {\r\n      console.log(response.data);\r\n    })\r\n    .catch((err) => {\r\n      console.log(err);\r\n    });\r\n}\r\n```\r\n\r\n>上文演示的都是get请求携带token的方法，下面我们演示下post请求如何携带token。\r\n\r\n```js\r\naddPeopleInfo() {\r\n  var api = \"http://localhost:7001/api/v1/addPeopleInfo\";\r\n  this.Axios.post(api, {\r\n    tableId: 12,\r\n    pNum: 4,\r\n    pMark: \"不要辣椒\",\r\n  },{\r\n    headers: {\r\n      Authorization: \"Bearer \" + this.token,\r\n    },\r\n  })\r\n    .then((response) => {\r\n      console.log(response.data);\r\n    })\r\n    .catch((err) => {\r\n      console.log(err);\r\n    });\r\n}\r\n```"
    },
    {
      "id": "/Egg.js中合成图片二维码的方法",
      "metadata": {
        "permalink": "/blog/Egg.js中合成图片二维码的方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Egg.js中合成图片二维码的方法.md",
        "source": "@site/blog\\Egg.js中合成图片二维码的方法.md",
        "title": "Egg.js中合成图片二维码的方法",
        "description": "借助qr-image实现生成二维码",
        "date": "2021-12-28T00:00:00.000Z",
        "formattedDate": "2021年12月28日",
        "tags": [
          {
            "label": "Egg.js",
            "permalink": "/blog/tags/egg-js"
          }
        ],
        "readingTime": 3.03,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Egg.js中合成图片二维码的方法",
          "date": "2021-12-28T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Egg.js",
          "tags": [
            "Egg.js"
          ]
        },
        "prevItem": {
          "title": "带你从零学会---基于JWT的接口权限验证",
          "permalink": "/blog/带你从零学会---基于JWT的接口权限验证"
        },
        "nextItem": {
          "title": "剑指Offer——对称的二叉树（JS实现）",
          "permalink": "/blog/剑指Offer——对称的二叉树（JS实现）"
        }
      },
      "content": "## 借助qr-image实现生成二维码\r\n1. 引入qr-image包\r\n\r\n```js\r\nconst qr = require('qr-image');\r\n```\r\n\r\n2. 在service中定义获取二维码的函数\r\n\r\n```js\r\n  async getQrImage(qrText) {\r\n    return new Promise((resolve,reject) => {\r\n      try {\r\n        const qrImage = qr.image(qrText,{type: 'png'});\r\n        resolve(qrImage);\r\n      } catch (error) {\r\n        reject(false);\r\n      }\r\n    })\r\n  }\r\n```\r\n\r\n>在控制器中调用第二步的函数即可获取到一个二维码对象。\r\n\r\n## 借助canvas将二维码图片和背景图片合成在一起\r\n\r\n1. 引入canvas\r\n\r\n```js\r\nconst { createCanvas,Image } = require('canvas');\r\n```\r\n\r\n2. 在service中定义异步函数将两张图片合成在一起\r\n\r\n```js\r\nasync getCanvasImage(text, bgDir, codeDir) {\r\n    return new Promise((reslove, reject) => {\r\n      try {\r\n        const canvas = createCanvas(502, 448)\r\n        const ctx = canvas.getContext('2d');\r\n        //绘制背景图片\r\n        const img1 = new Image();\r\n        img1.onload = () => {\r\n          ctx.drawImage(img1, 0, 0);\r\n          //填充文字  注意字体\r\n          ctx.font = '30px \"Microsoft YaHei\"'\r\n          ctx.fillStyle = \"#ffffff\";\r\n          ctx.fillText(text, 195, 185);\r\n\r\n          const img2 = new Image();\r\n          img2.onload = () => {\r\n            ctx.drawImage(img2, 170, 210);\r\n            reslove(canvas.createPNGStream());\r\n          }\r\n          img2.onerror = err => {\r\n            reject(err);\r\n          }\r\n          //需要注意顺序\r\n          img2.src = codeDir;\r\n        }\r\n        img1.onerror = err => { reject(err); }\r\n        //需要注意顺序\r\n        img1.src = bgDir;\r\n      } catch (error) {\r\n        reject(false);\r\n      }\r\n    })\r\n  }\r\n```\r\n\r\n3. 在控制器中传入相关参数进行合并\r\n\r\n```js\r\nasync showCode() {\r\n    let id = this.ctx.request.query.id;\r\n    let table = await this.ctx.model.Table.findByPk(id);\r\n    let qrImage = await this.ctx.service.tools.getQrImage(\"http://xxx\");\r\n    let qrImageObj = await this.ctx.service.tools.uploadCos(\"code_1.jpg\",qrImage);\r\n\r\n    let canvasStream = await this.ctx.service.tools.getCanvasImage(\r\n      table.title,\r\n      'app/public/admin/images/bg.png',\r\n      \"http://\" + qrImageObj.Location\r\n    );\r\n    let canvasImageObj = await this.ctx.service.tools.uploadCos(\"code_image_1.png\",canvasStream);\r\n    // this.ctx.body = canvasImageObj;\r\n    await this.ctx.render(\"admin/table/code\",{\r\n      imgUrl: \"http://\" + canvasImageObj.Location\r\n    })\r\n  }\r\n```\r\n\r\n## 使用Html5 Canvas加水印合成图片二维码\r\n>在已经有node canvas的情况下，还介绍html5 canvas是因为node canvas需要系统安装指定的程序，这对系统环境要求较高，而HTML5 canvas则不需要安装。\r\n\r\n1. 静态静态页面中定义好canvas函数\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n  <title>Document</title>\r\n  <style>\r\n    #canvas {\r\n      margin: 0 auto;\r\n      display: block;\r\n      width: 502px;\r\n      height: 448px;\r\n    }\r\n  </style>\r\n\r\n</head>\r\n<body>\r\n  <canvas id=\"canvas\" width=\"505\" height=\"448\"></canvas>\r\n</body>\r\n<script>\r\n  // 1.获取canvas这个DOM节点\r\n  var canvas = document.querySelector('#canvas');\r\n  //2.定义2d画布\r\n  var ctx = canvas.getContext('2d');\r\n  const img1 = new Image();\r\n  img1.onload = () => {\r\n    ctx.drawImage(img1, 0, 0);\r\n    //填充文字  注意字体\r\n    ctx.font = '30px \"Microsoft YaHei\"'\r\n    ctx.fillStyle = \"#ffffff\";\r\n    ctx.fillText(\"<%=text%>\", 195, 180);\r\n\r\n    const img2 = new Image();\r\n    img2.onload = () => {\r\n      ctx.drawImage(img2, 170, 205);\r\n    }\r\n    img2.onerror = err => {\r\n      //  throw err \r\n      console.log(err);\r\n    }\r\n    //需要注意顺序\r\n    img2.src = \"<%=codeSrc%>\";\r\n  }\r\n  img1.onerror = err => { console.log(err); }\r\n  //需要注意顺序\r\n  img1.src = \"<%=bgSrc%>\";\r\n</script>\r\n</html>\r\n```\r\n\r\n2. 在控制器中渲染数据即可\r\n\r\n```js\r\n  async showCode() {\r\n    let id = this.ctx.request.query.id;\r\n    let table = await this.ctx.model.Table.findByPk(id);\r\n    let qrImage = await this.ctx.service.tools.getQrImage(\"http://jpy.wiki\");\r\n    let qrImageObj = await this.ctx.service.tools.uploadCos(\"code_1.jpg\",qrImage);\r\n\r\n    await this.ctx.render(\"admin/table/code\",{\r\n      text: table.title,\r\n      bgSrc: '/public/admin/images/bg.png',\r\n      codeSrc: \"http://\" + qrImageObj.Location\r\n    })\r\n  }\r\n```"
    },
    {
      "id": "/剑指Offer——对称的二叉树（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——对称的二叉树（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——对称的二叉树（JS实现）.md",
        "source": "@site/blog\\剑指Offer——对称的二叉树（JS实现）.md",
        "title": "剑指Offer——对称的二叉树（JS实现）",
        "description": "题目描述",
        "date": "2021-12-28T00:00:00.000Z",
        "formattedDate": "2021年12月28日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 2.435,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——对称的二叉树（JS实现）",
          "date": "2021-12-28T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "Egg.js中合成图片二维码的方法",
          "permalink": "/blog/Egg.js中合成图片二维码的方法"
        },
        "nextItem": {
          "title": "Vue3中使用mixin实现组件功能的复用",
          "permalink": "/blog/Vue3中使用mixin实现组件功能的复用"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/0d855ca46f338038328f02f8966b30af.png)\r\n## 解题思路\r\n* 这道题属于二叉树的问题\r\n* 本题的核心在于通过层次遍历，来将一层的元素的值和这一层元素进行反转之后，相同下标的元素是否相同，只要相同，则说明是对称二叉树，反之则不是对称二叉树。\r\n\r\n## 解题代码\r\n```js\r\nvar isSymmetric = function(root) {\r\n    if (!root) return true;\r\n    let flag = true;\r\n    let queue = [root];\r\n    \r\n    while (queue.length !== 0) {\r\n        const temp = [];\r\n        for (let v of queue) {\r\n            temp.push(v);\r\n        }\r\n        let copy = [];\r\n        for (let v of temp) {\r\n            if (v === null) {\r\n                copy.push(null);\r\n                continue;\r\n            }\r\n            copy.push(v.val);\r\n        }\r\n        copy = copy.reverse();\r\n        for (let i = 0; i < temp.length;i++) {\r\n            if (temp[i] === null) {\r\n                if (temp[i] !== copy[i]) {\r\n                    flag = false;\r\n                    return flag;\r\n                } else {\r\n                    continue;\r\n                }\r\n            }\r\n            if (temp[i].val !== copy[i]) {\r\n                flag = false;\r\n                return flag;\r\n            }\r\n        }\r\n        queue = [];\r\n        for (let v of temp) {\r\n            if (v === null) {\r\n                queue.push(null);\r\n                queue.push(null);\r\n                continue;\r\n            }\r\n            queue.push(v.left);\r\n            queue.push(v.right);\r\n        }\r\n        const test = queue.every((value) => {\r\n            return value === null\r\n        }) \r\n        if (test === true) break;\r\n    }\r\n\r\n    return flag;\r\n};\r\n```\r\n\r\n## 使用BFS的思想解题（推荐）\r\n\r\n```js\r\nvar isSymmetric = function (root) {\r\n  // 对称二叉树这道题目可以使用BFS的核心思想来求解\r\n  if (!root) return false;\r\n  const queue = [];\r\n  // 初始化时入队两个节点\r\n  queue.push(root.left, root.right);\r\n\r\n  while (queue.length) {\r\n    let len = queue.length;\r\n    for (let i = 0; i < len; i += 2) {\r\n      // 一次出队两个元素\r\n      let left = queue.shift();\r\n      let right = queue.shift();\r\n      // 只要有一个存在，另一个存在的情况\r\n      if ((!left && right) || (left && !right)) {\r\n        return false;\r\n      }\r\n      // 两个都存在\r\n      if (left && right) {\r\n        // 如果值不同则返回false\r\n        if (left.val != right.val) {\r\n          return false;\r\n        }\r\n        // 推入一对节点：左孩子的左孩子，右孩子的右孩子\r\n        queue.push(left.left, right.right);\r\n        queue.push(left.right, right.left);\r\n      }\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n```\r\n\r\n## 总结（本题给我们的启示思路）\r\n* 思路一：如何进行层次遍历。\r\n* 思路二：同一层的元素通过逆转后，判断相同下标的元素的值是否相同，来判断是否是对称二叉树。"
    },
    {
      "id": "/Vue3中使用mixin实现组件功能的复用",
      "metadata": {
        "permalink": "/blog/Vue3中使用mixin实现组件功能的复用",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Vue3中使用mixin实现组件功能的复用.md",
        "source": "@site/blog\\Vue3中使用mixin实现组件功能的复用.md",
        "title": "Vue3中使用mixin实现组件功能的复用",
        "description": "一、如何使用mixins?",
        "date": "2021-12-27T00:00:00.000Z",
        "formattedDate": "2021年12月27日",
        "tags": [
          {
            "label": "Vue",
            "permalink": "/blog/tags/vue"
          }
        ],
        "readingTime": 1.71,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Vue3中使用mixin实现组件功能的复用",
          "date": "2021-12-27T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Vue",
          "tags": [
            "Vue"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——对称的二叉树（JS实现）",
          "permalink": "/blog/剑指Offer——对称的二叉树（JS实现）"
        },
        "nextItem": {
          "title": "系统梳理Webpack配置",
          "permalink": "/blog/系统梳理Webpack配置"
        }
      },
      "content": "## 一、如何使用mixins?\r\n>mixins主要是进行逻辑的复用，下面我们详细介绍下mixins的主要使用步骤。\r\n\r\n1. 在script标签中定义好要用的mixins。\r\n\r\n```js\r\nconst baseMixin = {\r\n  data() {\r\n    return {\r\n      apiUrl: \"http://xxxxxx\"\r\n    }\r\n  },\r\n  methods: {\r\n    success() {\r\n      console.log(\"成功\");\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n2. 引入mixins。\r\n\r\n```js\r\nexport default {\r\n  mixins: [baseMixin],\r\n  data() {\r\n    return {\r\n      msg: \"首页\"\r\n    }\r\n  },\r\n  components: {\r\n\r\n  }\r\n}\r\n```\r\n\r\n3. 在template中通过语法进行引用即可。\r\n\r\n```js\r\n{{apiUrl}}\r\n```\r\n\r\n## 二、mixins和组件都有的变量以谁为主？\r\n>是以组件的变量或函数为主，请看下面的代码，最终页面上显示的内容是“来自组件的msg”。\r\n\r\n```js\r\n<template>\r\n  <div class=\"container\">\r\n    首页模板----{{msg}}\r\n    <br>\r\n    <button @click=\"success()\">点击触发成功</button>\r\n  </div>\r\n</template>\r\n<script>\r\nconst baseMixin = {\r\n  data() {\r\n    return {\r\n      apiUrl: \"http://jpy.wiki\",\r\n      msg: \"这是来自mixins的 msg\"\r\n    }\r\n  },\r\n  methods: {\r\n    success() {\r\n      console.log(\"成功\");\r\n    }\r\n  }\r\n}\r\nexport default {\r\n  mixins: [baseMixin],\r\n  data() {\r\n    return {\r\n      msg: \"这是来自组件的msg\"\r\n    }\r\n  },\r\n  components: {\r\n\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n## 三、全局配置mixins\r\n1. 对外暴露mixin函数。\r\n\r\n```js\r\nconst baseMixin = {\r\n  data() {\r\n    return {\r\n      apiUrl: \"http://jpy.wiki\",\r\n      msg: \"这是来自mixins的 msg\"\r\n    }\r\n  },\r\n  methods: {\r\n    success() {\r\n      console.log(\"成功\");\r\n    }\r\n  }\r\n}\r\nexport default baseMixin;\r\n```\r\n\r\n2. 在main.js中引入mixin并对外暴露。\r\n\r\n```js\r\nimport baseMixin from './mixin/baseMixin';\r\nconst app = createApp(App);\r\napp.mixin(baseMixin);\r\napp.mount('#app');\r\n```\r\n\r\n3. 在组件中可以直接使用。\r\n\r\n```js\r\n<template>\r\n  <div class=\"container\">\r\n    首页模板----{{msg}}\r\n    <br>\r\n    <button @click=\"success()\">点击触发成功</button>\r\n  </div>\r\n</template>\r\n```"
    },
    {
      "id": "/系统梳理Webpack配置",
      "metadata": {
        "permalink": "/blog/系统梳理Webpack配置",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/系统梳理Webpack配置.md",
        "source": "@site/blog\\系统梳理Webpack配置.md",
        "title": "系统梳理Webpack配置",
        "description": "一、entry",
        "date": "2021-12-26T00:00:00.000Z",
        "formattedDate": "2021年12月26日",
        "tags": [
          {
            "label": "Webpack",
            "permalink": "/blog/tags/webpack"
          }
        ],
        "readingTime": 5.76,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "系统梳理Webpack配置",
          "date": "2021-12-26T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Webpack",
          "tags": [
            "Webpack"
          ]
        },
        "prevItem": {
          "title": "Vue3中使用mixin实现组件功能的复用",
          "permalink": "/blog/Vue3中使用mixin实现组件功能的复用"
        },
        "nextItem": {
          "title": "Vue3中的Teleport有什么用？",
          "permalink": "/blog/Vue3中的Teleport有什么用？"
        }
      },
      "content": "## 一、entry\r\n### 入口个数和输出个数的关系\r\n1. 字符串形式\r\n\r\n>当只有一个入口的时候，打包形成一个chunk，输出一个bundle。\r\n\r\n```js\r\nentry: './src/index.js',\r\n```\r\n\r\n2. 数组形式\r\n\r\n>当以数组的形式引入文件的时候，也只是形成一个chunk,输出一个bundle。(这种方式可以在HMR功能中，让html的热更新生效)\r\n\r\n```js\r\nentry: ['./src/index.js','./src/add.js'],\r\n```\r\n\r\n3. 对象形式\r\n\r\n> 多入口，有几个入口文件就行形成几个chuank，输出几个bundle文件。此时chunk的名称就是key。\r\n\r\n```js\r\nentry: {\r\n    index: './src/index.js',\r\n    add: './src/add.js'\r\n  }\r\n```\r\n\r\n4. 特殊用法\r\n\r\n>下面的这种写法会将index.js和count.js合并打包到index中，会将add单独进行打包。\r\n\r\n```js\r\nentry: {\r\n    index: ['./src/index.js','./src/count.js'],\r\n    add: './src/add.js'\r\n}\r\n```\r\n\r\n## 二、output\r\n1. publicPath的作用\r\n\r\n>这个属性主要是配置所有资源引入公共路径的前缀。\r\n\r\n```js\r\noutput: {\r\n    filename: 'js/[name].js',\r\n    path: resolve(__dirname, 'build'),\r\n    publicPath: '/'\r\n}\r\n```\r\n\r\n>加上上面的属性后，引入资源的路径就会变为下面的样子。\r\n\r\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-DklLkh55-1640396718734)(https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e0a869d0c514eef8332ba8333d95acc~tplv-k3u1fbpfcp-watermark.image?)]\r\n\r\n2. filename\r\n\r\n>指定打包后文件的目录和名称。\r\n\r\n```js\r\nfilename: 'js/[name].js'\r\n```\r\n\r\n3. path\r\n\r\n> 指定输出文件的路径。\r\n\r\n```js\r\npath: resolve(__dirname, 'build')\r\n```\r\n\r\n4. chunkFilename\r\n\r\n>非入口chunk的名称，例如通过import导入的chunk。\r\n\r\n```js\r\nchunkFilename: 'js/[name]_chunk.js'\r\n```\r\n\r\n5. library\r\n\r\n>这个属性主要定义了打包后的库向外暴露的变量名，同时通过livraryTarget还可以指定变量名添加到哪里。\r\n\r\n```js\r\nlibrary: '[name]'\r\n```\r\n\r\n>加上上面这个配置项，打包的文件变为下面的样子。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/29c239f1a99b993c0a3a9d366eab91d0.png)\r\n\r\n>同时可以通过下面的配置，设置变量名添加到哪个环境中。\r\n\r\n```js\r\nlibraryTarget: 'window',\r\nlibraryTarget: 'global',\r\nlibraryTarget: 'commonjs'\r\n```\r\n\r\n## 三、module\r\n1. use\r\n\r\n>多个loader使用use，单个loader用loader。\r\n\r\n```js\r\nuse: ['style-loader','css-loader']\r\n```\r\n\r\n2. exclude\r\n\r\n>让loader排除指定的文件。\r\n\r\n```js\r\nexclude: /node_modules/\r\n```\r\n\r\n3. test\r\n\r\n>让loader匹配什么类型的文件。\r\n\r\n```js\r\ntest: /\\.js$/\r\n```\r\n\r\n4. include\r\n\r\n>指定检查什么类型的文件。\r\n\r\n```js\r\ninclude: resolve(__dirname,'src')\r\n```\r\n\r\n5. enforce\r\n\r\n>优先执行。\r\n\r\n```js\r\nenforce: 'pre'\r\n```\r\n\r\n6. options\r\n\r\n>给某个loader进行配置特殊属性。\r\n\r\n```js\r\noptions: {}\r\n```\r\n\r\n7. oneOf\r\n\r\n>设置只有一个loader会生效。\r\n\r\n```js\r\noneOf: []\r\n```\r\n\r\n## 四、resolve\r\n1. alias\r\n\r\n>这个属性主要是帮助我们配置解析模块路径别名，有时候引入路径过于复杂，可以通过这个进行简写。\r\n\r\n```js\r\n  resolve: {\r\n    alias: {\r\n      $css: resolve(__dirname,'src/css')\r\n    }\r\n  }\r\n```\r\n\r\n>配置完上面的属性后，引入文件可以通过下面的形式进引入。\r\n\r\n```js\r\nimport '$css/index.css';\r\n```\r\n\r\n2. extensions\r\n\r\n>这个属性可以帮助我们在引入文件的时候，省略后缀，但是系统在查找文件的时候，是按照数组中出现的先后顺序来执行的。\r\n\r\n```js\r\nresolve: {\r\n    alias: {\r\n      $css: resolve(__dirname,'src/css')\r\n    },\r\n    // 配置省略文件路径的后缀名\r\n    extensions: ['.js','.json','.css']\r\n  }\r\n```\r\n\r\n3. modules\r\n\r\n>告诉webpack解析模块去找哪个目录，这样能够减少webpack的查找次数，提高打包的性能。\r\n\r\n```js\r\nresolve: {\r\n    alias: {\r\n      $css: resolve(__dirname,'src/css')\r\n    },\r\n    // 配置省略文件路径的后缀名\r\n    extensions: ['.js','.json','.css'],\r\n    modules: [resolve(__dirname,'../node_modules'),'node_modules']\r\n  }\r\n```\r\n\r\n## 五、dev-server\r\n>需要注意的是：dev-server只适用于开发环境中。关于dev-server的常见配置属性都在下面的代码中，具体的注释解释了属性的用途。\r\n\r\n```js\r\ndevServer: {\r\n    // 运行代码的目录\r\n    contentBase: resolve(__dirname,'build'),\r\n    // 监视contentBase目录下的所有文件，一旦文件变化就会reload\r\n    watchContentBase: true,\r\n    watchOptions: {\r\n      // 忽略文件\r\n      ignored: /node_modules/\r\n    },\r\n    // 启动gzip压缩\r\n    compress: true,\r\n    // 端口号\r\n    port: 5000,\r\n    // 域名\r\n    host: 'localhost',\r\n    // 自动打开浏览器\r\n    open: true,\r\n    // 开启HMR功能\r\n    hot: true,\r\n    // 不要显示启动服务器日志信息\r\n    clientLogLevel: 'none',\r\n    // 除了一些基本启动信息以外，其他内容都不要显示\r\n    quiet: true,\r\n    // 如果出错了，不要全屏提示\r\n    overlay: false,\r\n    // 服务器代理 --> 解决开发环境下的跨域问题\r\n    proxy: {\r\n      // 一旦devServer(5000)服务器接受到 /api/xxx 的请求，就会把请求转发到另外一个服务器（3000）\r\n      '/api': {\r\n        target: 'http://localhost:3000',\r\n        // 发送请求时，请求路径重写： 将/api/xxx --> /xxx (去掉/api)\r\n        pathRewrite: {\r\n          '^/api': ''\r\n        }\r\n      }\r\n    }\r\n  }\r\n```\r\n\r\n## 六、optimization\r\n>optimization的主要配置信息可以参见下面的代码。\r\n\r\n```js\r\noptimization: {\r\n    splitChunks: {\r\n      chunks: 'all'\r\n    },\r\n    // 将当前模块的记录其他模块的hash单独打包为一个文件 runtime\r\n    runtimeChunk: {\r\n      name: entrypoint => `runtime-${entrypoint.name}`\r\n    },\r\n    minimizer: [\r\n      new TerserWebpackPlugin({\r\n        // 开启多进程打包\r\n        parallel: true\r\n      })\r\n    ]\r\n  }\r\n```"
    },
    {
      "id": "/Vue3中的Teleport有什么用？",
      "metadata": {
        "permalink": "/blog/Vue3中的Teleport有什么用？",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Vue3中的Teleport有什么用？.md",
        "source": "@site/blog\\Vue3中的Teleport有什么用？.md",
        "title": "Vue3中的Teleport有什么用？",
        "description": "一、Teleport有什么用？",
        "date": "2021-12-25T00:00:00.000Z",
        "formattedDate": "2021年12月25日",
        "tags": [
          {
            "label": "Vue",
            "permalink": "/blog/tags/vue"
          }
        ],
        "readingTime": 0.58,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Vue3中的Teleport有什么用？",
          "date": "2021-12-25T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Vue",
          "tags": [
            "Vue"
          ]
        },
        "prevItem": {
          "title": "系统梳理Webpack配置",
          "permalink": "/blog/系统梳理Webpack配置"
        },
        "nextItem": {
          "title": "LeetCode——数组中重复的数据（使用符号表示是否出现过）",
          "permalink": "/blog/LeetCode——数组中重复的数据（使用符号表示是否出现过）"
        }
      },
      "content": "## 一、Teleport有什么用？\r\n>Vue3中的组件模板属于该组件，有时候我们想把模板的内容移动到当前组件之外的DOM中，这个时候就可以使用Teleport。\r\n\r\n## 二、如何使用？\r\n>只需将组件包裹在teleport组件中，并指示移动到哪个DOM元素中即可。\r\n\r\n```js\r\n<template>\r\n<teleport to=\"body\">\r\n    <div class=\"modal-bg\" v-if=\"visible\">\r\n        <div class=\"modal-content\">\r\n            <button class=\"close\" @click=\"$emit('close-modal')\"> X </button>\r\n            <div class=\"model-title\">{{title}}</div>\r\n            <div class=\"model-body\">\r\n                <slot>\r\n                    模态对话框\r\n                </slot>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</teleport>\r\n</template>\r\n```"
    },
    {
      "id": "/LeetCode——数组中重复的数据（使用符号表示是否出现过）",
      "metadata": {
        "permalink": "/blog/LeetCode——数组中重复的数据（使用符号表示是否出现过）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——数组中重复的数据（使用符号表示是否出现过）.md",
        "source": "@site/blog\\LeetCode——数组中重复的数据（使用符号表示是否出现过）.md",
        "title": "LeetCode——数组中重复的数据（使用符号表示是否出现过）",
        "description": "题目描述",
        "date": "2021-12-24T00:00:00.000Z",
        "formattedDate": "2021年12月24日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.435,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——数组中重复的数据（使用符号表示是否出现过）",
          "date": "2021-12-24T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "Vue3中的Teleport有什么用？",
          "permalink": "/blog/Vue3中的Teleport有什么用？"
        },
        "nextItem": {
          "title": "LeetCode——实现strStr()（KMP算法）",
          "permalink": "/blog/LeetCode——实现strStr()（KMP算法）"
        }
      },
      "content": "## 题目描述\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/74820c34dbb16dbe505c8e4a4974e345.png)\r\n\r\n## 题目核心\r\n\r\n1. 数组中的元素只出现过一次或者两次。\r\n2. 数组中每个元素的值都在1到N之间，其中N为数组的长度。\r\n3. 解题不得使用其他的额外空间，必须在nums数组本身上进行操作。\r\n\r\n## 解题思路\r\n\r\n> 本题的核心解题思路就是使用nums[i]的正负来表示值为i+1的元素是否出现，首次出现将其变为负数，再次出现则将其加入到结果数组中。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/b30127f79ffcdd716ec2e093fbef7f9c.png)\r\n\r\n## AC代码\r\n\r\n```js\r\n var findDuplicates = function(nums) {\r\n  const res = [];\r\n\r\n  for (let num of nums) {\r\n    let absNum = Math.abs(num);\r\n    if (nums[absNum - 1] < 0) {\r\n      res.push(absNum);\r\n    } else {\r\n      nums[absNum - 1] *= -1;\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n\r\n## 题目反思\r\n> 本题比较难以理解，最重要的核心就是使用正负号来表示元素是否出现过，之所以能这样做，是因为题目中每个元素的值都在1-N之间，因为这个条件的限制，造成了一个元素的值-1对应的元素的正负和自己出现的次数出现了关联。"
    },
    {
      "id": "/LeetCode——实现strStr()（KMP算法）",
      "metadata": {
        "permalink": "/blog/LeetCode——实现strStr()（KMP算法）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——实现strStr()（KMP算法）.md",
        "source": "@site/blog\\LeetCode——实现strStr()（KMP算法）.md",
        "title": "LeetCode——实现strStr()（KMP算法）",
        "description": "题目描述",
        "date": "2021-12-23T00:00:00.000Z",
        "formattedDate": "2021年12月23日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 2.07,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——实现strStr()（KMP算法）",
          "date": "2021-12-23T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "LeetCode——数组中重复的数据（使用符号表示是否出现过）",
          "permalink": "/blog/LeetCode——数组中重复的数据（使用符号表示是否出现过）"
        },
        "nextItem": {
          "title": "使用JS实现数组与树结构之间的互换",
          "permalink": "/blog/使用JS实现数组与树结构之间的互换"
        }
      },
      "content": "## 题目描述\r\n> 实现strStr()这个题目的本质考查KMP算法，也是前端的indexOf这个API的底层实现原理，因此这道题无论是原理上还是从面试角度来看都是非常重要的一道题目。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/cc578fe6ea1208bda4a00c9f6a525afa.png)\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/07866f2b667f6274eea3c228d9cdbdcb.png)\r\n\r\n## 解题思路\r\n> 这道题目想实现的是字符串匹配，即找到目标模式串在母串的位置，如果模式串为空，直接返回下标0，其余情况，返回模式串首次出现的位置。本题最核心的莫过于构建next数组，next数组代表的是模式串的前缀和后缀之间相同元素的个数，这个next数组可以指导后续模式串失配的时候的移动次数。这是kmp算法的核心，至于为什么是这样，本文不再进行详细赘述，更加详细的情况可以去搜索KMP算法。\r\n\r\n```js\r\n var strStr = function(haystack, needle) {\r\n  let n = haystack.length;\r\n  let m = needle.length;\r\n  if (m === 0) return 0;\r\n\r\n  // 构造next数组\r\n  let next = new Array(m).fill(0);\r\n  for (let j = 0,i = 1; i < m; i++) {\r\n    while (j > 0 && needle[i] != needle[j]) {\r\n      j = next[j-1];\r\n    }\r\n    if (needle[j] === needle[i]) {\r\n      j++;\r\n    }\r\n    next[i] = j;\r\n  }\r\n\r\n  // 使用next数组\r\n  for (let i = 0, j = 0; i < n;i++) {\r\n    while (j > 0 && haystack[i] != needle[j]) {\r\n      j = next[j-1];\r\n    }\r\n    if (haystack[i] === needle[j]) {\r\n      j++;\r\n    }\r\n    if (j === m) {\r\n      return i - m + 1;\r\n    }\r\n  }\r\n\r\n  return -1;\r\n\r\n};\r\n```\r\n\r\n## 题目反思\r\n> KMP算法是indexOf实现的底层原理，核心功能就是利用已经匹配的元素的已知信息，减少从头匹配的次数，从而提高匹配的效率。"
    },
    {
      "id": "/使用JS实现数组与树结构之间的互换",
      "metadata": {
        "permalink": "/blog/使用JS实现数组与树结构之间的互换",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/使用JS实现数组与树结构之间的互换.md",
        "source": "@site/blog\\使用JS实现数组与树结构之间的互换.md",
        "title": "使用JS实现数组与树结构之间的互换",
        "description": "为什么要构造树结构？",
        "date": "2021-12-22T00:00:00.000Z",
        "formattedDate": "2021年12月22日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 2.39,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "使用JS实现数组与树结构之间的互换",
          "date": "2021-12-22T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "LeetCode——实现strStr()（KMP算法）",
          "permalink": "/blog/LeetCode——实现strStr()（KMP算法）"
        },
        "nextItem": {
          "title": "从零开始掌握Vuex",
          "permalink": "/blog/从零开始掌握Vuex"
        }
      },
      "content": "## 为什么要构造树结构？\r\n> 这个问题不仅仅是一道面试题，也是一种常见的场景，假如后端给我们传来的是一个数组，数组中给的数据，需要前端根据这个数据来构造一个导航栏，此时我们就需要构建一个树型结构，因此学会如何将数组构建成一颗树是很有必要的。\r\n\r\n## 后端传过来的数据长什么样？\r\n```js\r\nlet data = [\r\n  {\r\n    \"id\": \"1\",\r\n    \"name\": \"1\",\r\n    \"fatherId\": \"0\",\r\n  },\r\n  {\r\n    \"id\": \"2\",\r\n    \"name\": \"1-1\",\r\n    \"fatherId\": \"1\"\r\n  },\r\n  {\r\n    \"id\": \"3\",\r\n    \"name\": \"1-2\",\r\n    \"fatherId\": \"1\"\r\n  },\r\n  {\r\n    \"id\": \"4\",\r\n    \"name\": \"1-1-1\",\r\n    \"fatherId\": \"2\"\r\n  },\r\n  {\r\n    \"id\": \"5\",\r\n    \"name\": \"1-1-2\",\r\n    \"fatherId\": \"2\"\r\n  },\r\n  {\r\n    \"id\": \"6\",\r\n    \"name\": \"2\",\r\n    \"fatherId\": \"0\"\r\n  },\r\n  {\r\n    \"id\": \"7\",\r\n    \"name\": \"1-2-1\",\r\n    \"fatherId\": \"3\"\r\n  }\r\n];\r\n```\r\n\r\n>从上面的数据我们可以看出几个特点：\r\n\r\n1. 根元素的fatherId是0，0是不存在的。\r\n2. id是唯一的。\r\n3. fatherId表示这个元素的父元素。\r\n\r\n## 构建树结构的方法\r\n\r\n1. 创建一个对象和数组作为容器\r\n2. 遍历data中的每一个元素并存储到对象中。\r\n3. 遍历每一个元素的parent并存储到对应的children中。\r\n\r\n```js\r\nlet data = [\r\n  {\r\n    \"id\": \"1\",\r\n    \"name\": \"1\",\r\n    \"fatherId\": \"0\",\r\n  },\r\n  {\r\n    \"id\": \"2\",\r\n    \"name\": \"1-1\",\r\n    \"fatherId\": \"1\"\r\n  },\r\n  {\r\n    \"id\": \"3\",\r\n    \"name\": \"1-2\",\r\n    \"fatherId\": \"1\"\r\n  },\r\n  {\r\n    \"id\": \"4\",\r\n    \"name\": \"1-1-1\",\r\n    \"fatherId\": \"2\"\r\n  },\r\n  {\r\n    \"id\": \"5\",\r\n    \"name\": \"1-1-2\",\r\n    \"fatherId\": \"2\"\r\n  },\r\n  {\r\n    \"id\": \"6\",\r\n    \"name\": \"2\",\r\n    \"fatherId\": \"0\"\r\n  },\r\n  {\r\n    \"id\": \"7\",\r\n    \"name\": \"1-2-1\",\r\n    \"fatherId\": \"3\"\r\n  }\r\n];\r\n\r\n// 首先构造一个map和root\r\nconst map = {};\r\nconst root = [];\r\n\r\n// 遍历每一个元素，并存储在map中\r\ndata.forEach(item => {\r\n  map[item.id] = item;\r\n})\r\n\r\n// 遍历每一个元素并获取响应的parent\r\ndata.forEach(item => {\r\n  let parent = map[item.fatherId];\r\n  if (parent) {\r\n    (parent.children || (parent.children = [])).push(item)\r\n  } else {\r\n    // parent不存在说明这是根元素\r\n    root.push(item)\r\n  }\r\n\r\n})\r\n\r\nroot\r\n```\r\n\r\n## CodeSandBox在线实现\r\n\r\n* [将JS转换为树形结构](https://codesandbox.io/s/jiang-shu-zu-zhuan-huan-wei-shu-xing-jie-gou-xiq5q)\r\n\r\n## 参考文献\r\n> 特别鸣谢\r\n\r\n* [原生JS实现树状结构列表](https://segmentfault.com/a/1190000023128084)"
    },
    {
      "id": "/从零开始掌握Vuex",
      "metadata": {
        "permalink": "/blog/从零开始掌握Vuex",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/从零开始掌握Vuex.md",
        "source": "@site/blog\\从零开始掌握Vuex.md",
        "title": "从零开始掌握Vuex",
        "description": "什么是Vuex？",
        "date": "2021-12-21T00:00:00.000Z",
        "formattedDate": "2021年12月21日",
        "tags": [
          {
            "label": "Vue",
            "permalink": "/blog/tags/vue"
          }
        ],
        "readingTime": 6.535,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "从零开始掌握Vuex",
          "date": "2021-12-21T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Vue",
          "tags": [
            "Vue"
          ]
        },
        "prevItem": {
          "title": "使用JS实现数组与树结构之间的互换",
          "permalink": "/blog/使用JS实现数组与树结构之间的互换"
        },
        "nextItem": {
          "title": "一文带你学习：Vue生命周期、this.$nextTick、将Axios绑定到全局、输入防抖",
          "permalink": "/blog/一文带你学习：Vue生命周期、this.$nextTick、将Axios绑定到全局、输入防抖"
        }
      },
      "content": "## 什么是Vuex？\r\n> Vuex是一个专门为Vue.js应用程序开发的状态管理模式，vuex可以实现vue不同组件之间的状态共享，可以实现组件里面数据的持久化。\r\n\r\n## Vuex的几个核心概念\r\n* State\r\n* Getters\r\n* Mutations\r\n* Actions\r\n* Modules\r\n\r\n## Vuex的基本使用\r\n\r\n1. 安装依赖\r\n\r\n```js\r\nnpm install vuex@next --save\r\n```\r\n\r\n2. 在src目录下新建一个vuex文件夹，文件夹里新建store.js\r\n\r\n```js\r\nimport { createStore } from 'vuex'\r\n\r\nconst store = createStore({\r\n  state() {\r\n    return {\r\n      count: 100\r\n    }\r\n  }\r\n})\r\n\r\nexport default store;\r\n```\r\n\r\n3. 将vuex挂载到vue身上\r\n\r\n```js\r\nimport { createApp } from 'vue'\r\nimport App from './App.vue'\r\nimport route from './routes'\r\nimport store from './vuex/store'\r\n\r\n// createApp(App).mount('#app')\r\nlet app=createApp(App);\r\n//挂载路由\r\napp.use(route)\r\n// 挂载vuex\r\napp.use(store);\r\napp.mount('#app')\r\n```\r\n\r\n4. 在组件中使用vuex\r\n\r\n```js\r\nthis.$store.state.count\r\n```\r\n\r\n## 使用mutations修改state\r\n1. 在mutations中定义好修改state的方法\r\n\r\n```js\r\nconst store = createStore({\r\n  state() {\r\n    return {\r\n      count: 100\r\n    }\r\n  },\r\n  mutations: {\r\n    incCount(state) {\r\n      state.count++;\r\n    }\r\n  }\r\n})\r\n```\r\n\r\n2. 在组件中通过commit来操作指定的方法\r\n\r\n```js\r\nmethods:{\r\n  incCount() {\r\n    this.$store.commit('incCount');\r\n  }\r\n}\r\n```\r\n\r\n## 通过mutations设置state\r\n\r\n1. 定义设置的方法\r\n\r\n```js\r\n  mutations: {\r\n    setCount(state,num) {\r\n      state.count = num;\r\n    }\r\n  }\r\n```\r\n\r\n2. 前端通过相关方法直接操作\r\n\r\n```js\r\nmethods:{\r\n  setCount() {\r\n    this.$store.commit('setCount',666);\r\n  }\r\n}\r\n```\r\n\r\n## 通过mapState读取store中的数据\r\n1. 在组件中通过mapState声明接收哪些数据\r\n\r\n```js\r\n  computed: {\r\n    ...mapState(['count'])\r\n  }\r\n```\r\n\r\n2. 然后可以直接在组件中使用这个数据\r\n\r\n```js\r\n<h1>这是mapState获取到的数据：{{count}}</h1>\r\n```\r\n\r\n3. 也可以对接收到的数据进行重命名\r\n\r\n```js\r\n  computed: {\r\n    ...mapState({\r\n      num: state => state.count     \r\n    })\r\n  }\r\n  <h1>这是mapState获取到的数据：{{num}}</h1>\r\n```\r\n\r\n## Vuex中的Getter\r\n### 通过this.$store获取\r\n1. 在store中添加属性getters\r\n\r\n```js\r\n  getters: {\r\n    reverseMsg(state) {\r\n      return state.msg.split('').reverse().join(\"\");\r\n    }\r\n  }\r\n```\r\n\r\n2. 组件中通过computed直接调用\r\n\r\n```js\r\n  computed: {\r\n    revMsg() {\r\n      return this.$store.getters.reverseMsg;\r\n    }\r\n  }\r\n```\r\n\r\n3. 组件中直接使用\r\n\r\n```js\r\n<h3>获取到的getters里面的数据--{{ revMsg }}</h3>\r\n```\r\n\r\n### 通过mapGetters获取\r\n\r\n```js\r\n  computed: {\r\n    ...mapGetters(['reverseMsg'])\r\n  }\r\n```\r\n\r\n>如果想要改名还可以这样写：\r\n\r\n```js\r\n  computed: {\r\n    ...mapGetters({\r\n      rev: 'reverseMsg'\r\n    })\r\n  }\r\n```\r\n\r\n### 当state中的数据发生变化时，Getter会进行重新计算\r\n\r\n## vuex中的actions\r\n> actions的主要作用时执行mutations里面的方法，异步操作放在actions。\r\n\r\n1. 在vuex中指定操作哪些mutations里面的方法\r\n\r\n```js\r\n  actions: {\r\n    incCount(context) {\r\n      context.commit('incCount')\r\n    }\r\n  }\r\n```\r\n\r\n2. 组件中通过$store.dispatch调用actions中的方法\r\n\r\n```js\r\n<button @click=\"$store.dispatch('incCount')\">incCount</button>\r\n```\r\n\r\n## Vuex中的Modules\r\n>modules主要解决的是多个store对外暴露的问题。\r\n\r\n### 如何获取某个store中的数据\r\n1. 对外暴露一个store\r\n\r\n```js\r\nlet userStore = {\r\n  state() {\r\n    return {\r\n      count: 100,\r\n      msg: '你好雅'\r\n    }\r\n  },\r\n  mutations: {\r\n    incCount(state) {\r\n      state.count++;\r\n    },\r\n    setCount(state,num) {\r\n      state.count = num;\r\n    },\r\n    setMsg(state,msg) {\r\n      state.msg = msg;\r\n    }\r\n  },\r\n  getters: {\r\n    reverseMsg(state) {\r\n      return state.msg.split('').reverse().join(\"\");\r\n    }\r\n  },\r\n  actions: {\r\n    incCount(context) {\r\n      context.commit('incCount')\r\n    },\r\n    setMsg(context,msg) {\r\n      setTimeout(() => {\r\n        context.commit('SetMsg',msg)\r\n      },1000)\r\n    }\r\n  }\r\n}\r\n\r\nexport default userStore\r\n```\r\n\r\n2. store.js对外声明\r\n\r\n```js\r\nimport { createStore } from 'vuex'\r\nimport newsStore from './newsStore';\r\nimport userStore from './userStore'\r\n\r\nconst store = createStore({\r\n  modules: {\r\n    \"user\": userStore,\r\n    \"news\": newsStore\r\n  }\r\n})\r\n\r\nexport default store;\r\n```\r\n\r\n3. 组件中通过$store.state.xxx.xxx进行调用\r\n\r\n```js\r\n{{$store.state.user.count}}\r\n```\r\n\r\n### 如何执行某个store中的方法\r\n>组件直接在methods中通过this.$store.commit('xxx)进行调用。\r\n\r\n```js\r\n  methods: {\r\n    incCount() {\r\n      this.$store.commit(\"incCount\")\r\n    }\r\n  }\r\n```\r\n\r\n> 通过上面我们发现，这种方式无需我们制定调用哪一个store中的方法，因此如果不同store中含有相同名字的方法，这些方法都将被调用。\r\n\r\n\r\n## Vuex结合Composition Api来使用\r\n1. 从vuex中引入useStore。\r\n\r\n```js\r\nimport {useStore} from 'vuex'\r\n```\r\n\r\n2. 在setup中调用store中的数据和方法\r\n\r\n```js\r\n  setup() {\r\n    const store = useStore();\r\n    return {\r\n      count: computed(() => {\r\n        return store.state.count\r\n      }),\r\n      incCount: () => {\r\n        store.commit('incCount');\r\n      }\r\n    }\r\n  }\r\n```\r\n\r\n3. 在setup中调用store中的getter\r\n\r\n```js\r\n  setup() {\r\n    const store = useStore();\r\n    return {\r\n      num: computed(() => {\r\n        return store.getters.num\r\n      })\r\n    }\r\n```\r\n\r\n> 核心就是通过store.getters.xxx\r\n\r\n>上文我们介绍到的都是如何执行mutations中的方法，下面我们介绍下如何执行actions中的方法。\r\n\r\n```js\r\n  setup() {\r\n    const store = useStore();\r\n    return {\r\n      incActionCount: () => {\r\n        store.dispatch('incCount');\r\n      }\r\n    }\r\n  }\r\n```\r\n\r\n> 要想在setup中执行actions中的方法核心就是通过store.dispatch来执行。\r\n\r\n> 如果在执行actions中的方法时想要传值，可以在store.js的actions中定义下面这样的方法。\r\n\r\n```js\r\nactions: {\r\n  setCount({commit},num) {\r\n    commit('setCount',num)\r\n  }\r\n}\r\n```\r\n\r\n## Vue结合TypeScript项目中使用Vuex\r\n\r\n1. 将store.js改为store.ts\r\n\r\n2. 引入下列声明\r\n\r\n```js\r\nimport { ComponentCustomProperties } from 'vue'\r\nimport { Store,createStore } from 'vuex'\r\n\r\ndeclare module '@vue/runtime-core' {\r\n  // 声明自己的 store state\r\n  interface State {\r\n    count: number,\r\n    list: string[],   // 这里要动态改变哦\r\n    msg: string\r\n  }\r\n\r\n  // 为 `this.$store` 提供类型声明\r\n  interface ComponentCustomProperties {\r\n    $store: Store<State>\r\n  }\r\n}\r\n```\r\n\r\n>具体的参考文档可以看：[vuex中ts支持](https://next.vuex.vuejs.org/zh/guide/typescript-support.html#vue-%E7%BB%84%E4%BB%B6%E4%B8%AD-store-%E5%B1%9E%E6%80%A7%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E)\r\n\r\n3. 然后只需给state声明为any，其他参数声明为对应的类型即可。\r\n\r\n4. 组件中通过lang=ts，即可正常使用this.$store.\r\n\r\n5. 组件可以通过下面的方式来触发store中mutations中的方法。\r\n\r\n```js\r\n  methods: {\r\n    incCount(): void {\r\n      this.$store.commit('incCount')\r\n    }\r\n  }\r\n```\r\n\r\n6. composition API中结合TS和Vuex\r\n\r\n> 在这种情况下通过setup中获取数据的方式主要是通过store.xxx\r\n\r\n```js\r\n<script lang=\"ts\">\r\nimport {computed, defineComponent} from 'vue'\r\nimport { useStore } from 'vuex'\r\nexport default defineComponent({\r\n  setup() {\r\n    const store = useStore();\r\n    return {\r\n      msg: computed(() => {\r\n        return store.state.msg\r\n      })\r\n    }\r\n  }\r\n})\r\n</script>\r\n```"
    },
    {
      "id": "/一文带你学习：Vue生命周期、this.$nextTick、将Axios绑定到全局、输入防抖",
      "metadata": {
        "permalink": "/blog/一文带你学习：Vue生命周期、this.$nextTick、将Axios绑定到全局、输入防抖",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/一文带你学习：Vue生命周期、this.$nextTick、将Axios绑定到全局、输入防抖.md",
        "source": "@site/blog\\一文带你学习：Vue生命周期、this.$nextTick、将Axios绑定到全局、输入防抖.md",
        "title": "一文带你学习：Vue生命周期、this.$nextTick、将Axios绑定到全局、输入防抖",
        "description": "生命周期图示",
        "date": "2021-12-20T00:00:00.000Z",
        "formattedDate": "2021年12月20日",
        "tags": [
          {
            "label": "Vue",
            "permalink": "/blog/tags/vue"
          }
        ],
        "readingTime": 3.23,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "一文带你学习：Vue生命周期、this.$nextTick、将Axios绑定到全局、输入防抖",
          "date": "2021-12-20T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Vue",
          "tags": [
            "Vue"
          ]
        },
        "prevItem": {
          "title": "从零开始掌握Vuex",
          "permalink": "/blog/从零开始掌握Vuex"
        },
        "nextItem": {
          "title": "一篇文章总结Vue3中的路由与路由配置",
          "permalink": "/blog/一篇文章总结Vue3中的路由与路由配置"
        }
      },
      "content": "## 生命周期图示\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/75d9c45527cb6de6aec889e968ff2c1d.png)\r\n\r\n## 触发顺序\r\n1. beforeCreate\r\n2. created\r\n3. beforeMount\r\n4. mounted\r\n5. beforeUpdate\r\n6. updated\r\n7. beforeUnmount\r\n8. unmounted\r\n\r\n## 动态组件keep-alive\r\n>当我们卸载组件后进行重新挂载的时候，如果想要保持组件的状态，避免反复重渲染带来的性能问题，这个时候可以使用keep-alive。\r\n\r\n### 使用方法\r\n>我们只需通过keep-alive这个组件进行包裹目标组件即可。\r\n\r\n```js\r\n<keep-alive>\r\n  <life-cycle v-if=\"isShow\"></life-cycle>\r\n</keep-alive>\r\n```\r\n\r\n>当keep-alive缓存的组件被激活时，activated这个生命周期函数被调用，当keep-alive缓存的组件被卸载时，deactivated这个生命周期函数被调用。\r\n\r\n## this.$nextTick的用法\r\n>有时候从远程获取到的值，改变了定义的变量，可以通过this.$nextTick获取到最新的。\r\n\r\n```js\r\n  mounted() {\r\n    /*请求数据，操作dom , 放在这个里面  mounted*/\r\n    const oDiv1 = document.querySelector('#msg');\r\n    console.log('1: ' + oDiv1.innerHTML);\r\n    this.msg = \"$nextTick演示\";\r\n    const oDiv2 = document.querySelector(\"#msg\");\r\n    console.log(\"2: \" + oDiv2.innerHTML);\r\n\r\n    this.$nextTick(() => {\r\n      const oDiv3 = document.querySelector(\"#msg\");\r\n      console.log(\"3: \",oDiv3.innerHTML);\r\n    })\r\n    console.log(\"模板编译完成4\");\r\n  }\r\n```\r\n\r\n>上面的输出1和2拿到的都是修改前的数据，只有nextTick拿到的是修改后的数据。\r\n\r\n## Vue3中使用Axios请求第三方接口\r\n1. 安装axios\r\n\r\n```shell\r\nnpm i axios\r\n```\r\n\r\n2. 引入axios\r\n\r\n```js\r\nimport axios from 'axios'\r\n```\r\n\r\n3. 发送get请求\r\n\r\n```js\r\ngetData() {\r\n  const api = \"http://www.phonegap100.com/appapi.php?a=getPortalList&catid=20&page=1\";\r\n  axios.get(api).then((response) => {\r\n    console.log(response);\r\n    this.list = response.data.result;\r\n  }).catch(err => {\r\n    console.log(err);\r\n  })\r\n}\r\n```\r\n\r\n## 将Axios绑定到全局\r\n\r\n1. 在main.js中注释下这个语句\r\n\r\n```js\r\n// 首先将下面的这句话注释掉\r\n// createApp(App).mount('#app')\r\n```\r\n\r\n2. 引入axios\r\n\r\n```js\r\nimport Axios from 'axios'\r\n```\r\n\r\n3. 将axios绑定到全局\r\n\r\n```js\r\nconst app = createApp(App);\r\napp.config.globalProperties.Axios = Axios;\r\n\r\napp.mount('#app');\r\n```\r\n\r\n## 使用fetch-jsonp请求jsonp接口\r\n>在已有axios的情况下，为什么还需要fetch-jsonp，因为axios不支持jsonp请求，如果服务端只提供了jsonp调用，这个方法就很有用了。\r\n\r\n1. 安装模块\r\n\r\n```js\r\nnpm i fetch-jsonp\r\n```\r\n\r\n2. 引入模块\r\n\r\n```js\r\nimport fetchJsonp from 'fetch-jsonp';\r\n```\r\n\r\n3. 绑定到全局\r\n\r\n```js\r\napp.config.globalProperties.fetchJsonp = fetchJsonp;\r\n```\r\n\r\n4. 发送请求\r\n\r\n```js\r\ngetData() {\r\n  const api = \"https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=javascript\";\r\n  this.fetchJsonp(api, {\r\n    jsonpCallback: \"cb\",\r\n  })\r\n    .then((response) => {\r\n      return response.json();\r\n    })\r\n    .then((data) => {\r\n      console.log(data);\r\n      this.list = data.s;\r\n    })\r\n    .catch((err) => {\r\n      console.log(err);\r\n    });\r\n}\r\n```\r\n\r\n## 输入防抖的实现\r\n>实现最后一个字符输入500ms后，才请求数据，新输入的会清空以前输入的定时器。\r\n\r\n```js\r\nexport default {\r\n  data() {\r\n    return {\r\n      keyword: \"\",\r\n      list: [],\r\n      timer: \"\",\r\n    };\r\n  },\r\n  methods: {\r\n    getData() {\r\n      if (this.keyword != \"\") {\r\n        clearTimeout(this.timer);\r\n        this.timer = setTimeout(() => {\r\n          const api =\r\n            \"https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=\" +\r\n            this.keyword;\r\n          this.fetchJsonp(api, {\r\n            jsonpCallback: \"cb\",\r\n          })\r\n            .then((response) => {\r\n              return response.json();\r\n            })\r\n            .then((data) => {\r\n              console.log(data);\r\n              this.list = data.s;\r\n            })\r\n            .catch((err) => {\r\n              console.log(err);\r\n            });\r\n        }, 500);\r\n      }\r\n    },\r\n  },\r\n};\r\n```"
    },
    {
      "id": "/一篇文章总结Vue3中的路由与路由配置",
      "metadata": {
        "permalink": "/blog/一篇文章总结Vue3中的路由与路由配置",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/一篇文章总结Vue3中的路由与路由配置.md",
        "source": "@site/blog\\一篇文章总结Vue3中的路由与路由配置.md",
        "title": "一篇文章总结Vue3中的路由与路由配置",
        "description": "路由的基本配置",
        "date": "2021-12-19T00:00:00.000Z",
        "formattedDate": "2021年12月19日",
        "tags": [
          {
            "label": "Vue",
            "permalink": "/blog/tags/vue"
          }
        ],
        "readingTime": 5.405,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "一篇文章总结Vue3中的路由与路由配置",
          "date": "2021-12-19T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Vue",
          "tags": [
            "Vue"
          ]
        },
        "prevItem": {
          "title": "一文带你学习：Vue生命周期、this.$nextTick、将Axios绑定到全局、输入防抖",
          "permalink": "/blog/一文带你学习：Vue生命周期、this.$nextTick、将Axios绑定到全局、输入防抖"
        },
        "nextItem": {
          "title": "这一次，彻底搞懂箭头函数",
          "permalink": "/blog/这一次，彻底搞懂箭头函数"
        }
      },
      "content": "## 路由的基本配置\r\n1. 安装插件\r\n\r\n```shell\r\nnpm install vue-router@next --save\r\n```\r\n\r\n2. 创建一个routers.ts文件\r\n\r\n3. 在routers.ts中引入组件并配置路径。\r\n\r\n```js\r\nimport { createRouter,createWebHashHistory } from 'vue-router';\r\n// 引入组件\r\nimport Home from './components/Home.vue';\r\nimport News from './components/News.vue';\r\nimport User from './components/User.vue';\r\n\r\nconst router = createRouter({\r\n  history: createWebHashHistory(),\r\n  routes: [\r\n    {path: '/', component: Home},\r\n    {path: '/news', component: News},\r\n    {path: '/user', component: User},\r\n  ]\r\n})\r\n\r\nexport default router;\r\n```\r\n\r\n4. 在main.ts中将路由文件挂载到vue身上。\r\n\r\n```js\r\nimport { createApp } from 'vue'\r\nimport App from './App.vue'\r\nimport routers from './routers';\r\n\r\n// createApp(App).mount('#app')\r\n\r\nconst app = createApp(App);\r\napp.use(routers);\r\napp.mount('#app');\r\n```\r\n\r\n5. 在用到路由的组件通过router-view组件或者router-link\r\n\r\n```js\r\n<template>\r\n  <img alt=\"Vue logo\" src=\"./assets/logo.png\">\r\n  <ul>\r\n    <li>\r\n      <router-link to=\"/\">首页</router-link>\r\n    </li>\r\n    <li>\r\n      <router-link to=\"/news\">新闻</router-link>\r\n    </li>\r\n    <li>\r\n      <router-link to=\"/user\">用户</router-link>\r\n    </li>\r\n  </ul>\r\n\r\n  <router-view></router-view>\r\n</template>\r\n```\r\n\r\n>挂载router-link后，只需要在组件对应的页面路径上输入指定路由即可完成跳转，router-link则实现a标签进行跳转的形式路由。\r\n\r\n## 动态路由的配置\r\n>在routes.ts中按照下面的方式进行配置路由，通过/:aid的方式来进行动态路由的配置。\r\n\r\n```js\r\n//配置路由\r\nconst router = createRouter({\r\n\r\n    history: createWebHashHistory(),\r\n    routes: [\r\n        { path: '/', component: Home , alias: '/home' },\r\n        { path: '/news', component: News },\r\n        { path: '/user', component: User },\r\n        { path: '/newscontent/:aid', component: NewsContent },\r\n    ], \r\n})\r\n```\r\n\r\n>通过router-link进行跳转的时候，需要模板字符串和冒号＋to。\r\n\r\n```js\r\n<ul>\r\n    <li v-for=\"(item, index) in list\" :key=\"index\">\r\n        <router-link  :to=\"`/newscontent/${index}`\"> {{item}}</router-link>\r\n    </li>\r\n</ul>\r\n```\r\n\r\n>通过this.$route.params获取动态路由传过来的值。\r\n\r\n```js\r\nmounted(){\r\n    // this.$route.params 获取动态路由的传值\r\n    console.log(this.$route.params)\r\n}\r\n```\r\n\r\n>如果我们想要实现类似与GET传值，我们可以通过下面的方式\r\n\r\n1. 将路由配置为普通路由。\r\n\r\n\r\n```js\r\nconst router = createRouter({\r\n\r\n    history: createWebHashHistory(),\r\n    routes: [\r\n        { path: '/', component: Home , alias: '/home' },\r\n        { path: '/news', component: News },\r\n        { path: '/user', component: User },\r\n        { path: '/newscontent', component: NewsContent },\r\n    ], \r\n})\r\n```\r\n\r\n2. router-link通过问号的形式进行跳转。\r\n\r\n```js\r\n<router-link  :to=\"`/newscontent?aid=${index}`\"> {{item}}</router-link>\r\n```\r\n\r\n3. 通过this.$route.query获取到get传值。\r\n\r\n```js\r\nconsole.log(this.$route.query);\r\n```\r\n\r\n## 路由编程式导航（JS跳转路由）\r\n> 只需要通过this.$router.push进行指定即可。\r\n\r\n```js\r\n  this.$router.push({\r\n    path: '/home'\r\n  })\r\n```\r\n\r\n>如果想要实现get传值，可以通过下列的方式。\r\n\r\n```js\r\nthis.$router.push({\r\n    path: '/home',\r\n    query: {aid: 14}\r\n  })\r\n}\r\n```\r\n\r\n>动态路由需要使用下面的这种方式。\r\n\r\n```js\r\n  this.$router.push({\r\n    path: '/home/123',\r\n    // query: {aid: 14}\r\n  })\r\n```\r\n\r\n## 路由模式\r\n### Hash模式\r\n>Hash模式的典型特点就是页面路由中含有一个井号。\r\n\r\n```js\r\nconst router = createRouter({\r\n\r\n    history: createWebHashHistory(),\r\n    routes: [\r\n        ...,\r\n    ], \r\n})\r\n```\r\n\r\n### HTML5 history模式\r\n1. 引入createWebHistory。\r\n2. router的配置项中的history属性设置为createWebHistory()。\r\n\r\n```js\r\nimport { createRouter, createWebHistory } from 'vue-router'\r\n\r\n//配置路由\r\nconst router = createRouter({\r\n    history: createWebHistory(),\r\n    routes: [\r\n        ...\r\n    ], \r\n})\r\n```\r\n\r\n> 注意：开启HTML5 History模式之后，发布到服务器需要配置伪静态。[配置伪静态的方法](https://router.vuejs.org/zh/guide/essentials/history-mode.html#%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE%E4%BE%8B%E5%AD%90)。\r\n\r\n## 命名路由\r\n### 一般情况\r\n1. 定义路由的时候配置name属性\r\n\r\n```js\r\n{ path: '/news', component: News,name:\"news\" }\r\n```\r\n\r\n2. 传入对象进行跳转\r\n\r\n```js\r\n<router-link :to=\"{name: 'news'}\">新闻</router-link>\r\n```\r\n\r\n### 通过GET传值的方式\r\n1. 定义路由的时候配置name属性\r\n\r\n```js\r\n{ path: '/newscontent', component: NewsContent, name: \"content\" },\r\n```\r\n\r\n2. 传入包括query的对象\r\n\r\n```js\r\n<li v-for=\"(item, index) in list\" :key=\"index\">\r\n    <router-link  :to=\"{name: 'content',query: {aid: index}}\"> {{item}}</router-link>\r\n</li>\r\n```\r\n\r\n### 通过动态路由的方式\r\n\r\n1. 定义动态路由并指定name属性\r\n\r\n```js\r\n{ path: '/userinfo/:id', name: \"userinfo\", component: UserInfo }\r\n```\r\n\r\n2. 传入包括params的对象\r\n\r\n```js\r\n<router-link :to=\"{name: 'userinfo',params: {id: 123}}\">跳转到用户详情</router-link>\r\n```\r\n\r\n### 编程式路由\r\n>和上面的方式很类似。\r\n\r\n```js\r\n<button @click=\"this.$router.push({name: 'userinfo',params: {id: 666}})\">点击跳转</button>\r\n```\r\n\r\n## 路由重定向\r\n\r\n```js\r\n{ path: '', redirect: \"/home\" },   // 路由重定向\r\n{ path: '/home', component: Home },\r\n```\r\n\r\n## 路由别名\r\n>下面的这个实例中，访问people这个路由和访问alias这个路由是一致的。\r\n\r\n```js\r\n{ path: '/user', component: User, alias: '/people' }\r\n```\r\n\r\n> alias也可以是一个数组。\r\n\r\n```js\r\n{ path: '/user', component: User, alias: ['/people','/u']}\r\n```\r\n\r\n> 动态路由的形式。\r\n\r\n```js\r\n{ path: '/userinfo/:id', name: \"userinfo\", component: UserInfo, alias: '/u/:id' }\r\n```\r\n\r\n## 嵌套路由\r\n>嵌套路由的应用场景一般在导航栏上。\r\n\r\n1. 定义嵌套路由\r\n\r\n```js\r\n{\r\n  path: '/user', component: User,\r\n  children: [\r\n    { path: '', redirect: \"/user/userlist\" },\r\n    { path: 'userlist', component: UserList },\r\n    { path: 'useradd', component: UserAdd }\r\n  ]\r\n}\r\n```\r\n\r\n2. router-link和router-view配合显示内容\r\n\r\n```js\r\n<div class=\"left\">\r\n  <ul>\r\n    <li>\r\n      <router-link to=\"/user/userlist\">用户列表</router-link>\r\n    </li>\r\n    <li>\r\n      <router-link to=\"/user/useradd\">增加用户</router-link>\r\n    </li>\r\n  </ul>\r\n</div>\r\n<div class=\"right\">\r\n  <router-view></router-view>\r\n</div>\r\n```"
    },
    {
      "id": "/这一次，彻底搞懂箭头函数",
      "metadata": {
        "permalink": "/blog/这一次，彻底搞懂箭头函数",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/这一次，彻底搞懂箭头函数.md",
        "source": "@site/blog\\这一次，彻底搞懂箭头函数.md",
        "title": "这一次，彻底搞懂箭头函数",
        "description": "一、箭头函数的特点",
        "date": "2021-12-18T00:00:00.000Z",
        "formattedDate": "2021年12月18日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 4.705,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "这一次，彻底搞懂箭头函数",
          "date": "2021-12-18T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "一篇文章总结Vue3中的路由与路由配置",
          "permalink": "/blog/一篇文章总结Vue3中的路由与路由配置"
        },
        "nextItem": {
          "title": "LeetCode——合并两个有序数组（双指针）",
          "permalink": "/blog/LeetCode——合并两个有序数组（双指针）"
        }
      },
      "content": "## 一、箭头函数的特点\r\n### 1. 相比普通函数，箭头函数有更加简洁的语法。\r\n> 普通函数\r\n\r\n```js\r\nfunction add(num) {\r\n  return num + 10\r\n}\r\n```\r\n\r\n> 箭头函数\r\n\r\n```js\r\nconst add = num => num + 10;\r\n```\r\n\r\n### 2. 箭头函数不绑定this，会捕获其所在上下文的this，作为自己的this。\r\n\r\n>这句话需要注意的是，箭头函数的外层如果有普通函数，那么箭头函数的this就是这个外层的普通函数的this，箭头函数的外层如果没有普通函数，那么箭头函数的this就是全局变量。\r\n\r\n>下面这个例子是箭头函数的外层有普通函数。\r\n\r\n```js\r\nlet obj = {\r\n  fn:function(){\r\n      console.log('我是普通函数',this === obj)   // true\r\n      return ()=>{\r\n          console.log('我是箭头函数',this === obj) // true\r\n      }\r\n  }\r\n}\r\nconsole.log(obj.fn()())\r\n```\r\n\r\n> 下面这个例子是箭头函数的外层没有普通函数。\r\n\r\n```js\r\nlet obj = {\r\n    fn:()=>{\r\n        console.log(this === window);\r\n    }\r\n}\r\nconsole.log(obj.fn())\r\n// true\r\n```\r\n\r\n### 3. 箭头函数是匿名函数，不能作为构造函数，不可以使用new命令，否则后抛出错误。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/280adf1068075c1e31a404ce581599fd.png)\r\n\r\n### 4. 箭头函数不绑定arguments，取而代之用rest参数解决，同时没有super和new.target。\r\n\r\n> 箭头函数没有arguments、super、new.target的绑定，这些值由外围最近一层非箭头函数决定。\r\n\r\n> 下面的这个函数会报错，在浏览器环境下。\r\n\r\n```js\r\nlet f = ()=>console.log(arguments);\r\n\r\n//报错\r\nf(); // arguments is not defined\r\n```\r\n\r\n> 下面的箭头函数不会报错，因为arguments是外围函数的。\r\n\r\n```js\r\nfunction fn(){\r\n  let f = ()=> {\r\n    console.log(arguments)\r\n  }\r\n  f();\r\n}\r\nfn(1,2,3) // [1,2,3]\r\n```\r\n\r\n> 箭头函数可以通过拓展运算符获取传入的参数。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/9a098bd1025e762ac34d19325f9a9a32.png)\r\n\r\n### 5. 使用call,apply,bind并不会改变箭头函数中的this指向。\r\n\r\n* 当对箭头函数使用call或apply方法时，只会传入参数并调用函数，并不会改变箭头函数中this的指向。\r\n* 当对箭头函数使用bind方法时，只会返回一个预设参数的新函数，并不会改变这个新函数的this指向。\r\n\r\n> 请看下面的代码\r\n\r\n```js\r\nwindow.name = \"window_name\";\r\n\r\nlet f1 = function () {\r\nreturn this.name;\r\n};\r\nlet f2 = () => this.name;\r\n\r\nlet obj = { name: \"obj_name\" };\r\n\r\nconsole.log(f1.call(obj));  //obj_name\r\nconsole.log(f2.call(obj));  // window_name\r\nconsole.log(f1.apply(obj)); // obj_name\r\nconsole.log(f2.apply(obj)); // window_name\r\nconsole.log(f1.bind(obj)());  // obj_name\r\nconsole.log(f2.bind(obj)());  // window_name\r\n```\r\n\r\n### 6. 箭头函数没有原型对象prototype这个属性\r\n\r\n>由于不可以通过new关键字调用，所以没有构建原型的需求，所以箭头函数没有prototype这个属性。\r\n\r\n```js\r\nlet F = ()=>{};\r\nconsole.log(F.prototype) // undefined\r\n```\r\n\r\n### 7. 不能使用yield关键字，不能用作Generator函数\r\n\r\n## 二、arguments辨析\r\n>既然上文我们提到了arguments，那么下面我们就仔细讲讲这个arguments。\r\n\r\n### arguments有什么用？\r\n>arguments对象是所有非箭头函数中都可用的局部变量，可以使用arguments对象在函数中引用函数的参数，此对象包含传递给函数的每一个参数，第一个参数在索引0的位置。\r\n\r\n### 如何将arguments对象转换为数组\r\n1. 通过slice\r\n2. 通过拓展运算符\r\n3. 通过Array.from\r\n\r\n```js\r\nvar args = Array.prototype.slice.call(arguments);\r\nvar args = [].slice.call(arguments);\r\n\r\nconst args = Array.from(arguments);\r\nconst args = [...arguments];\r\n```\r\n\r\n### arguments函数如何调用自身函数？\r\n\r\n>我们先看看下面这个函数，这个是可以正常运行的。\r\n\r\n```js\r\nfunction factorial (n) {\r\n    return !(n > 1) ? 1 : factorial(n - 1) * n;\r\n}\r\n\r\n[1,2,3,4,5].map(factorial);\r\n```\r\n\r\n>但是作为匿名函数则不行。\r\n\r\n```js\r\n[1,2,3,4,5].map(function (n) {\r\n    return !(n > 1) ? 1 : /* what goes here? */ (n - 1) * n;\r\n});\r\n```\r\n\r\n> 因此arguments.callee诞生了。\r\n\r\n```js\r\n[1,2,3,4,5].map(function (n) {\r\n    return !(n > 1) ? 1 : arguments.callee(n - 1) * n;\r\n});\r\n```\r\n\r\n> 所以arguments要想调用自身的匿名函数，可以通过arguments.callee来调用。"
    },
    {
      "id": "/LeetCode——合并两个有序数组（双指针）",
      "metadata": {
        "permalink": "/blog/LeetCode——合并两个有序数组（双指针）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——合并两个有序数组（双指针）.md",
        "source": "@site/blog\\LeetCode——合并两个有序数组（双指针）.md",
        "title": "LeetCode——合并两个有序数组（双指针）",
        "description": "题目描述",
        "date": "2021-12-17T00:00:00.000Z",
        "formattedDate": "2021年12月17日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.375,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——合并两个有序数组（双指针）",
          "date": "2021-12-17T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "这一次，彻底搞懂箭头函数",
          "permalink": "/blog/这一次，彻底搞懂箭头函数"
        },
        "nextItem": {
          "title": "这一次彻底搞懂CSRF与XSS",
          "permalink": "/blog/这一次彻底搞懂CSRF与XSS"
        }
      },
      "content": "## 题目描述\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/860cffda351e0350f20dd29d45b88786.png)\r\n\r\n## 解题思路\r\n\r\n1. 首先使用splice方法，将nums1和nums2指定位置之后的无关元素去除。\r\n2. 如果二者其中有一个是空数组，则直接push到nums1中。\r\n3. 定义双指针，进行依次比较，小的放到nums1中。\r\n4. 判断左右指针谁先走到头的情况。\r\n\r\n## AC代码\r\n\r\n```js\r\nvar merge = function(nums1, m, nums2, n) {\r\n  // 合并两个有序数组需要注意的是，是将nums2合并到nums1中，并且是原地排序，不允许出现赋值的情况。\r\n  // 1. 去除无关元素\r\n  nums1.splice(m);\r\n  nums2.splice(n);\r\n  // 2. 特殊情况判断\r\n  if (nums1.length === 0 || nums2.length === 0) {\r\n    nums1.push(...nums2);\r\n    return;\r\n  }\r\n  // 3. 一般情况判断\r\n  let left = 0;\r\n  let right = 0;\r\n  while (left < nums1.length && right < nums2.length) {\r\n    if (nums1[left] <= nums2[right]) {\r\n      left++;\r\n      continue;\r\n    } else {\r\n      nums1.splice(left,0,nums2[right]);\r\n      right++\r\n    }\r\n  }\r\n  if (left === nums1.length && right < nums2.length) {\r\n    nums1.push(...nums2.slice(right));\r\n  }\r\n\r\n};\r\n```\r\n\r\n## 题目反思\r\n* 学会使用splice方法添加元素。\r\n* 注意题目的要求是原地排序，直接赋值给一个参数是不会通过测试的。\r\n* 学会使用双指针。"
    },
    {
      "id": "/这一次彻底搞懂CSRF与XSS",
      "metadata": {
        "permalink": "/blog/这一次彻底搞懂CSRF与XSS",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/这一次彻底搞懂CSRF与XSS.md",
        "source": "@site/blog\\这一次彻底搞懂CSRF与XSS.md",
        "title": "这一次彻底搞懂CSRF与XSS",
        "description": "CSRF攻击",
        "date": "2021-12-17T00:00:00.000Z",
        "formattedDate": "2021年12月17日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 10.045,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "这一次彻底搞懂CSRF与XSS",
          "date": "2021-12-17T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "LeetCode——合并两个有序数组（双指针）",
          "permalink": "/blog/LeetCode——合并两个有序数组（双指针）"
        },
        "nextItem": {
          "title": "LeetCode——搜索插入位置（二分查找）",
          "permalink": "/blog/LeetCode——搜索插入位置（二分查找）"
        }
      },
      "content": "## CSRF攻击\r\n### 一、什么是CSRF攻击？\r\n>CSRF指的是跨站请求伪造，是一种挟制用户在当前已经登录的Web应用程序上执行非本意操作的攻击方法。CSRF利用的是：一旦用户通过网站服务的身份认证，网站就完全信任该用户，受害者持有的权限级别决定了CSRF攻击的影响范围。\r\n\r\n### 二、CSRF攻击流程\r\n>主要步骤包含下列六个步骤：\r\n\r\n1. 用户浏览并登陆信任网站A。\r\n2. 网站A验证通过后，在用户处产生A的Cookie。\r\n3. 用户在没有退出网站A的情况下，访问了危险网站B。\r\n4. 危险网站B要求用户访问第三方站点A，并发出了一个请求。\r\n5. 用户根据危险网站B的要求，携带着A的cookie对网站A进行了请求。\r\n6. 网站A并不知道这个请求是用户发出的还是危险网站B发出的，但是因为这个cookie的存在，A会处理这个请求，从而危险网站B达到了自己获取用户信息的目的。\r\n\r\n### 三、常见的CSRF攻击类型\r\n#### GET类型的CSRF攻击\r\n>这种方式可以通过向受害者访问的网页中注入一个img标签，这个标签的src属性指向共计发出者的服务器，这样攻击者就会获取到含有受害者登录信息的一次跨域请求。\r\n\r\n```js\r\n<img src=\"http://bank.example/withdraw?amount=10000&for=hacker\" > \r\n```\r\n\r\n#### POST类型的CSRF\r\n>这种类型的CSRF主要利用的是一个隐藏的input表单，当受害者访问该页面的时候，这个表单会自动提交获取到的用户信息。\r\n\r\n```js\r\n<form action=\"http://bank.example/withdraw\" method=POST>\r\n    <input type=\"hidden\" name=\"account\" value=\"xiaoming\" />\r\n    <input type=\"hidden\" name=\"amount\" value=\"10000\" />\r\n    <input type=\"hidden\" name=\"for\" value=\"hacker\" />\r\n</form>\r\n<script> document.forms[0].submit(); </script> \r\n```\r\n\r\n#### 链接类型的CSRF\r\n>链接类型的CSRF需要用户点击链接才会触发，这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户点击。\r\n\r\n```js\r\n<a href=\"http://test.com/csrf/withdraw.php?amount=1000&for=hacker\" taget=\"_blank\">\r\n    重磅消息！！\r\n<a/>\r\n```\r\n\r\n### 四、CSRF攻击有什么特点？\r\n* CSRF通常发生在第三方域名。\r\n* CSRF攻击者不能获取到Cookie等信息，只是使用。\r\n\r\n### 五、如何防范CSRF攻击？\r\n#### CSRF Token\r\n>token验证的CSRF防御机制是公认最合适的方案。CSRF Token的防护策略主要包括以下三个步骤：\r\n\r\n1. 将CSRF Token输出到页面中。\r\n\r\n>首先，用户打开页面的时候，服务器需要给用户生成一个Token,这个Token一般是随机字符串和时间戳通过加密算法加密后的结果，这个Token不能保存在cookie中，否则可能会被攻击者冒用，为了安全起见，这个Token可以存在服务器的Session中，使用JS遍历整个DOM树，对于DOM中所有的a和form标签后加入Token。\r\n\r\n2. 页面提交的请求需要携带Token。\r\n\r\n>对于GET请求，Token将附加在请求地址之后，对于POST请求来说，可以在form表单中加入一个隐藏的表单域input，这个input的value值中需要携带Token。\r\n\r\n3. 服务端验证Token是否正确。\r\n\r\n>当用户再次访问服务器的时候，服务器需要判断Token的有效性，验证过程是先解密Token，对比加密字符串和时间戳，如果加密字符串一致且时间未过期，则判断这个Token是有效的。\r\n\r\n#### 验证码\r\n>CSRF攻击往往是在用户不知情的情况下构造了网络请求，而验证码会强制用户必须与应用进行交互，才能完成最终请求，但是验证码不是万能的，不能给网站的所有操作都加上验证码。\r\n\r\n\r\n#### Referer check\r\n>根据HTTP协议，在HTTP头部字段中有一个字段交referer，它记录了该HTTP请求的来源地址，通过Referer check可以验证目标请求是否来自合法的源。\r\n\r\n#### cookie的SameSite属性设置为strict\r\n>设置了这个属性，会使得在跨站情况下，任何情况下都不会发送cookie。\r\n\r\n\r\n## XSS攻击\r\n### 一、什么是XSS攻击？\r\n> XSS攻击即Cross Site Script可以译为跨站脚本攻击，为了和CSS区分开来，所以叫做XSS，XSS攻击指的是攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。攻击者对客户端网页注入的恶意脚本一般包括JS，有时也会包含HTML。XSS攻击的共同点是将一些隐私数据像cookie、session发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。\r\n\r\n\r\n### 二、XSS攻击的类型\r\n#### 反射型（非持久型）\r\n>反射型XSS把用户输入的数据反射给浏览器，这种攻击的港式需要攻击者诱骗用户点击一个恶意连接或者提交一个表单，或者进入一个恶意网站时，将恶意脚本注入攻击者的网站。当用户点击恶意链接时，页面跳转到攻击者预先准备的页面，会发现在攻击者的页面执行了JS脚本，这样产生了反射型XSS攻击，攻击者可以注入任意的恶意脚本进行攻击，可能注入恶作剧脚本，也可以注入获取用户隐私数据的脚本。\r\n\r\n#### 存储型（持久型）\r\n>存储型XSS会把用户输入的数据存储在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行，这种XSS攻击具有很强的稳定性。一个比较常见的场景是攻击者在论坛上写下一篇包含恶意JS的评论，这个评论发表后，所有访问这个评论的用户都会执行这段恶意的JS代码。\r\n\r\n#### 基于DOM的XSS（非持久型）\r\n>DOM型XSS是基于DOM文档对象模型的一种漏洞，DOM型XSS是一种特殊的反射型XSS，区别在于DOM型XSS并不会和后端进行交互，首先客户端的脚本程序可以通过DOM动态的检查和修改页面内容，当攻击者可以控制一些DOM对象，输入一些恶意JS脚本，而客户端脚本并没有对用户输入的内容进行有效的过滤就执行这些脚本，就会导致DOM型XSS漏洞。\r\n\r\n\r\n### 三、XSS攻击的防范方法\r\n#### 1. HttpOnly防止窃取Cookie\r\n\r\n>将Cookie的属性HttpOnly置为true，浏览器将禁止页面的JS代码访问这个Cookie,这样能够阻止XSS攻击后的Cookie劫持攻击。\r\n\r\n\r\n#### 2. 输入检查\r\n> 不要相信用户的任何输入，对于用户的任何输入都要进行检查、过滤和转译。建立可信任的字符和HTML标签白名单，对于不在白名单之列的字符或者标签进行过滤或编码，在XSS防御中，输入检查一般是检查用户输入的数据中是否包含左尖括号或者右尖括号等特殊字符，有则对特殊字符进行过滤或编码来防止XSS攻击。\r\n\r\n\r\n#### 3. 输出检查\r\n> 用户的输入会存在问题，服务端的输出也会存在问题，一般来说，除了富文本的输出外，在变量输出到HTML页面时，可以使用编码或者转译的方式来防御XSS攻击。\r\n\r\n\r\n## 参考文档\r\n* [前端面试查漏补缺--(七) XSS攻击与CSRF攻击](https://juejin.cn/post/6844903781704925191#heading-15)\r\n\r\n* [浅说 XSS 和 CSRF](https://github.com/dwqs/blog/issues/68)"
    },
    {
      "id": "/LeetCode——搜索插入位置（二分查找）",
      "metadata": {
        "permalink": "/blog/LeetCode——搜索插入位置（二分查找）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——搜索插入位置（二分查找）.md",
        "source": "@site/blog\\LeetCode——搜索插入位置（二分查找）.md",
        "title": "LeetCode——搜索插入位置（二分查找）",
        "description": "题目描述",
        "date": "2021-12-16T00:00:00.000Z",
        "formattedDate": "2021年12月16日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.2,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——搜索插入位置（二分查找）",
          "date": "2021-12-16T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "这一次彻底搞懂CSRF与XSS",
          "permalink": "/blog/这一次彻底搞懂CSRF与XSS"
        },
        "nextItem": {
          "title": "Vue3中Composition API的核心用法",
          "permalink": "/blog/Vue3中Composition API的核心用法"
        }
      },
      "content": "## 题目描述\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/c493c9ef6935bad2b83e3a282d5ef02c.png)\r\n\r\n## 解题思路\r\n>本题的解题思路核心就是二分查找，这道题目是二分查找的经典题目，其解题思路也堪称是二分查找的模板，二分查找的判别就在于题目给的是一个已经排好序的数组，因此本题符合要求。\r\n\r\n```js\r\nvar searchInsert = function(nums, target) {\r\n\r\n  // 搜索插入位置使用的是二分查找的核心模板\r\n  function findLeft(nums,target) {\r\n    let left = 0;\r\n    let right = nums.length - 1;\r\n\r\n    while (left <= right) {\r\n      let mid = (left + right) >> 1;\r\n      if (nums[mid] < target) {\r\n        left = mid + 1;\r\n      } else {\r\n        right = mid - 1;\r\n      }\r\n    }\r\n    return left;\r\n  }\r\n\r\n  return findLeft(nums,target);\r\n};\r\n```\r\n\r\n## 题目反思\r\n* 二分查找的题目判别是已经排序好的数组。\r\n* 使用移位操作可以帮助我们求中位数。\r\n* 二分查找这类题目最好按类别进行做，因为都是一个思路，方便我们总结经验。"
    },
    {
      "id": "/Vue3中Composition API的核心用法",
      "metadata": {
        "permalink": "/blog/Vue3中Composition API的核心用法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Vue3中Composition API的核心用法.md",
        "source": "@site/blog\\Vue3中Composition API的核心用法.md",
        "title": "Vue3中Composition API的核心用法",
        "description": "什么是Composition API?",
        "date": "2021-12-15T00:00:00.000Z",
        "formattedDate": "2021年12月15日",
        "tags": [
          {
            "label": "Vue",
            "permalink": "/blog/tags/vue"
          }
        ],
        "readingTime": 7.11,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Vue3中Composition API的核心用法",
          "date": "2021-12-15T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Vue",
          "tags": [
            "Vue"
          ]
        },
        "prevItem": {
          "title": "LeetCode——搜索插入位置（二分查找）",
          "permalink": "/blog/LeetCode——搜索插入位置（二分查找）"
        },
        "nextItem": {
          "title": "Egg.js中配置跨域与路由分组",
          "permalink": "/blog/Egg.js中配置跨域与路由分组"
        }
      },
      "content": "## 什么是Composition API?\r\n>Composition API也叫组合式API，是Vue3.x中的新特性。通过创建Vue组件，我们可以将接口的可重复部分提取到可重用的代码段中，没有Composition API之前Vue相关业务的代码需要配置到option的特定区域，如果在大型项目中这种方式会导致后期的维护性比较复杂，同时代码可复用性不高，Vue3的Composition API就是解决这个问题的。\r\n\r\n## 在setup中使用ref和reactive定义响应式数据\r\n>使用ref和reactive定义数据前，需要从vue中进行解构。\r\n\r\n```js\r\nimport {ref,reactive} from 'vue';\r\n```\r\n\r\n>ref和reactive均可以定义响应式数据，定义的数据在Vue模板中可以直接获取，但是如果通过方法获取的话，ref和reactive定义的数据在获取上有一定的差异，ref定义的需要通过value属性间接获取，reactive定义的数据可以直接获取，在修改这两类数据也是如此。\r\n\r\n```js\r\nexport default {\r\n  setup() {\r\n    // 使用ref定义响应式数据\r\n    const title = ref(\"这是一个标题\");\r\n    // 使用reactive定义响应式数据\r\n    const userinfo = reactive({\r\n      username: \"张三\",\r\n      age: 20\r\n    });\r\n    // 获取reactive中的属性可以直接获取\r\n    const getUserName = () => {\r\n      alert(userinfo.username)\r\n    };\r\n    // 获取ref中的数据需要通过value属性\r\n    const getTitle = () => {\r\n      alert(title.value)\r\n    };\r\n    const setUserName = () => {\r\n      // 修改reactive中的属性可以直接修改\r\n      userinfo.username = \"修改后的张三\"\r\n    };\r\n    const setTitle = () => {\r\n      // 修改ref中的属性，需要通过value\r\n      title.value = \"这是修改后的标题\"\r\n    };\r\n    return {\r\n      title,\r\n      userinfo,\r\n      getUserName,\r\n      getTitle,\r\n      setTitle,\r\n      setUserName\r\n    }\r\n  },\r\n  data() {\r\n    return {\r\n      msg: \"这是Home组件的msg\"\r\n    }\r\n  },\r\n  methods: {\r\n    run() {\r\n      alert('这是Home组件的run方法')\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n>可以使用v-model直接进行双向数据绑定。\r\n\r\n```js\r\n<input type=\"text\" v-model=\"title\">\r\n<input type=\"text\" v-model=\"userinfo.username\">\r\n```\r\n\r\n## toRefs解构响应式对象数据\r\n>之所以需要toRefs是因为通过toRefs解构的数据还具有响应式的特性，通过传统的拓展运算符进行解构则不具备了响应式的特性，这就是为什么需要toRefs的原因。\r\n\r\n1. 从vue中解构出toRefs\r\n\r\n```js\r\nimport {ref,reactive,toRefs} from 'vue';\r\n```\r\n\r\n2. setup的返回数据中进行如下的修改\r\n\r\n```js\r\nreturn {\r\n  title,\r\n  userinfo,\r\n  getUserName,\r\n  getTitle,\r\n  setTitle,\r\n  setUserName,\r\n  ...toRefs(article)\r\n}\r\n```\r\n\r\n## setup中的计算属性\r\n>setup中的计算属性和一般的计算属性类似，区别在于无法读取到this。\r\n\r\n```js\r\nsetup() {\r\n    let userinfo = reactive({\r\n      firstName: \"\",\r\n      lastName: \"\"\r\n    });\r\n\r\n    let fullName = computed(() => {\r\n      return userinfo.firstName + \" \" + userinfo.lastName\r\n    })\r\n\r\n    return {\r\n      ...toRefs(userinfo),\r\n      fullName\r\n    }\r\n  }\r\n```\r\n\r\n## readonly:深层的只读代理\r\n>readonly存在的意义是能够将响应式对象转换为普通的原始对象。\r\n\r\n1. 引入readonly。\r\n\r\n```js\r\nimport {computed, reactive,toRefs,readonly} from 'vue'\r\n```\r\n\r\n2. 给readonly传入响应式对象。\r\n\r\n```js\r\nlet userinfo = reactive({\r\n  firstName: \"666\",\r\n  lastName: \"\"\r\n});\r\nuserinfo = readonly(userinfo);\r\n```\r\n\r\n## setup中的watchEffect\r\n>setup中的watchEffect具有以下几个特点。\r\n\r\n1. 能够监听setup中的数据变化，数据一旦变化就会执行watchEffect中的回调函数。\r\n2. 及时setup中的数据没有变化，初始的时候也会执行一次。\r\n\r\n```js\r\n  setup() {\r\n    let data = reactive({\r\n      num: 1\r\n    });\r\n    watchEffect(() => {\r\n      console.log(`num2=${data.num}`);\r\n    });\r\n    setInterval(() => {\r\n      data.num++;\r\n    },1000)\r\n    return {\r\n      ...toRefs(data)\r\n    }\r\n  }\r\n```\r\n\r\n## setup中的watch\r\n>使用watch监控数据的基本方法。\r\n\r\n```js\r\n  setup() {\r\n    let keyword = ref(\"111\");\r\n    watch(keyword,(newData,oldData) => {\r\n      console.log(\"newData是：\",newData);\r\n      console.log(\"oldData是：\",oldData);\r\n    })\r\n    return {\r\n      keyword\r\n    }\r\n  }\r\n```\r\n\r\n## watch与watchEffect的区别\r\n1. watch在首次页面渲染的时候不会执行，但是watchEffect会。\r\n2. watch能够获取到数据状态变化前后的值。\r\n\r\n\r\n## setup中的生命周期钩子函数\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/ae5ee47a577fe5db6161f37677987ce0.png)\r\n\r\n>在setup中生命周期钩子类似于直接调用一个函数。\r\n\r\n```js\r\n  setup() {\r\n    let keyword = ref(\"111\");\r\n    watch(keyword,(newData,oldData) => {\r\n      console.log(\"newData是：\",newData);\r\n      console.log(\"oldData是：\",oldData);\r\n    })\r\n    onMounted(() => {\r\n      console.log('onMounted');\r\n    })\r\n    onUpdated(() => {\r\n      console.log('onUpdated');\r\n    })\r\n    return {\r\n      keyword\r\n    }\r\n  }\r\n```\r\n\r\n## setup中的props\r\n1. 父组件进行传值。\r\n\r\n```js\r\n<Search :msg=\"msg\" />\r\n```\r\n\r\n2. 声明接收\r\n\r\n```js\r\nprops: ['msg'],\r\n  setup(props) {\r\n    console.log(props);\r\n  }\r\n```\r\n\r\n## Provide与inject\r\n>有时，我们需要将数据从父组件传递到子组件，但是如果父组件到子组件是一个嵌套很深的关系，通过props进行传递将变得很麻烦，这种情况下，我们可以使用provide和inject来实现。\r\n\r\n### 一般用法\r\n1. 根组件通过provide传递数据。\r\n\r\n```js\r\nexport default {\r\n  data() {\r\n    return {\r\n\r\n    }\r\n  },\r\n  components: {\r\n    Home\r\n  },\r\n  provide() {\r\n    return {\r\n      title: \"app组件里面的标题\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n2. 需要接收数据的组件通过inject声明接收\r\n\r\n```js\r\nexport default {\r\n  inject: ['title'],\r\n  data() {\r\n    return {\r\n\r\n    }\r\n  },\r\n  components: {\r\n\r\n  }\r\n}\r\n```\r\n\r\n3. 声明接收后可以直接使用。\r\n\r\n```js\r\n<template>\r\n  <div class=\"container\">\r\n    这是Location组件\r\n    {{title}}\r\n  </div>\r\n</template>\r\n```\r\n\r\n### provide能够获取到this中的数据\r\n\r\n```js\r\nexport default {\r\n  data() {\r\n    return {\r\n      title: \"根组件的数据\"\r\n    }\r\n  },\r\n  components: {\r\n    Home\r\n  },\r\n  provide() {\r\n    return {\r\n      title: this.title\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n>`注意:`上面的一般用法中，如果父组件中的数据发生了变化，子组件的不会发生变化，因此推荐使用下面的composition API中的provide与inject能够实现同步变化。\r\n\r\n## setup中的provide与inject\r\n\r\n* 根组件\r\n\r\n```js\r\nimport Home from './components/Home.vue'\r\nimport {ref,provide} from 'vue'\r\nexport default {\r\n  setup() {\r\n    let title = ref('app根组件里面的title');\r\n    let setTitle = () => {\r\n      title.value = \"改变后的title\"\r\n    }\r\n    provide(\"title\",title);\r\n    return {\r\n      title,\r\n      setTitle\r\n    }\r\n  },\r\n  data() {\r\n    return {\r\n    }\r\n  },\r\n  components: {\r\n    Home\r\n  }\r\n}\r\n```\r\n\r\n* 用到数据的组件\r\n\r\n```js\r\nimport {inject} from 'vue'\r\nexport default {\r\n  setup() {\r\n    let title = inject('title');\r\n    return {\r\n      title\r\n    }\r\n  },\r\n  data() {\r\n    return {\r\n\r\n    }\r\n  },\r\n  components: {\r\n\r\n  }\r\n}\r\n```\r\n\r\n>与props不同的是，子组件中的数据如果使用了双向数据绑定会同步到父组件。"
    },
    {
      "id": "/Egg.js中配置跨域与路由分组",
      "metadata": {
        "permalink": "/blog/Egg.js中配置跨域与路由分组",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Egg.js中配置跨域与路由分组.md",
        "source": "@site/blog\\Egg.js中配置跨域与路由分组.md",
        "title": "Egg.js中配置跨域与路由分组",
        "description": "一、跨域配置",
        "date": "2021-12-14T00:00:00.000Z",
        "formattedDate": "2021年12月14日",
        "tags": [
          {
            "label": "Egg.js",
            "permalink": "/blog/tags/egg-js"
          }
        ],
        "readingTime": 1.425,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Egg.js中配置跨域与路由分组",
          "date": "2021-12-14T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Egg.js",
          "tags": [
            "Egg.js"
          ]
        },
        "prevItem": {
          "title": "Vue3中Composition API的核心用法",
          "permalink": "/blog/Vue3中Composition API的核心用法"
        },
        "nextItem": {
          "title": "LeetCode——组合总和（DFS）",
          "permalink": "/blog/LeetCode——组合总和（DFS）"
        }
      },
      "content": "## 一、跨域配置\r\n>egg.js中实现跨域主要是通过egg-cors这个插件，更多信息可以通过npm官网去查看这个插件的用法。\r\n\r\n1. 安装插件\r\n\r\n```shell\r\ncnpm i egg-cors --save\r\n```\r\n\r\n2. 在plugin.js中配置\r\n\r\n```js\r\n  cors: {\r\n    enable: true,\r\n    package: 'egg-cors'\r\n  }\r\n```\r\n\r\n3. 在config.default.js中配置\r\n\r\n```js\r\nconfig.cors = {\r\n    origin: '*',\r\n    allowMethods: 'GET,PUT,POST,DELETE'\r\n  }\r\n\r\n  config.security = {\r\n    csrf: {\r\n      ignore: ctx => {\r\n        if (ctx.request.url === `/${config.adminPath}/product/doUpload`) {\r\n          return true;\r\n        } else {\r\n          return false;\r\n        }\r\n      }\r\n    },\r\n    domainWhiteList: ['http://localhost:8081']\r\n  }\r\n```\r\n\r\n## 二、设置前端API路由POST数据无需进行CSRF验证\r\n>只需在config.default.js中的csrf属性配置中进行配置即可。\r\n\r\n```js\r\n  config.security = {\r\n    csrf: {\r\n      ignore: ctx => {\r\n        if (ctx.request.url === `/${config.adminPath}/product/doUpload`) {\r\n          return true;\r\n        } else if (ctx.request.url.indexOf(\"/api\") != -1) {\r\n          return true\r\n        } else {\r\n          return false;\r\n        }\r\n      }\r\n    },\r\n    domainWhiteList: ['http://localhost:8081']\r\n  }\r\n```\r\n\r\n## 三、获取数据库中指定字段的数据\r\n>主要是通过attributes这个字段来进行获取。\r\n\r\n```js\r\nlet result = await this.ctx.model.ProductCate.findAll({\r\n  include: {\r\n    model: this.ctx.model.Product,\r\n    attributes: ['id','cid','title','price','imgUrl','sort']\r\n  }\r\n});\r\n```\r\n\r\n>如果想要将获取到的数据按照某种顺序进行排列，可以通过order属性进行配置。\r\n\r\n```js\r\nlet result = await this.ctx.model.ProductCate.findAll({\r\n  include: {\r\n    model: this.ctx.model.Product,\r\n    attributes: ['id','cid','title','price','imgUrl','sort']\r\n  },\r\n  order: [\r\n    ['sort','DESC'],\r\n    [this.ctx.model.Product,'sort','DESC']\r\n  ]\r\n});\r\n```"
    },
    {
      "id": "/LeetCode——组合总和（DFS）",
      "metadata": {
        "permalink": "/blog/LeetCode——组合总和（DFS）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——组合总和（DFS）.md",
        "source": "@site/blog\\LeetCode——组合总和（DFS）.md",
        "title": "LeetCode——组合总和（DFS）",
        "description": "题目描述",
        "date": "2021-12-13T00:00:00.000Z",
        "formattedDate": "2021年12月13日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.31,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——组合总和（DFS）",
          "date": "2021-12-13T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "Egg.js中配置跨域与路由分组",
          "permalink": "/blog/Egg.js中配置跨域与路由分组"
        },
        "nextItem": {
          "title": "这一次，彻底搞懂EventLoop",
          "permalink": "/blog/这一次，彻底搞懂EventLoop"
        }
      },
      "content": "## 题目描述\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/4b8de592a62bc4f504e6e75f90543c37.png)\r\n\r\n## 解题思路\r\n>DFS是解决这道题的核心思路，DFS函数总共接收三个参数。\r\n\r\n* 第一个参数是遍历的起始位置，这个参数存在的意义在于防止重复遍历，只添加这个元素后面的元素，这个元素前面的不再遍历。\r\n* 第二个参数是临时数组，用来记录一次遍历的数组。\r\n* 第三个参数是临时数组内的和。\r\n\r\n>边界条件是如果临时和大于等于target则继续判断，如果等于则存储，不等于则返回。\r\n\r\n```js\r\nvar combinationSum = function(candidates, target) {\r\n\r\n  const res = [];\r\n\r\n  function dfs(start,temp,sum) {\r\n    if (sum >= target) {\r\n      if (sum === target) {\r\n        res.push(temp.slice());\r\n      }\r\n      return;\r\n    }\r\n    for (let i = start; i < candidates.length ;i++) {\r\n      temp.push(candidates[i]);\r\n      dfs(i,temp,sum + candidates[i]);\r\n      temp.pop();\r\n    }\r\n  }\r\n\r\n  dfs(0,[],0);\r\n\r\n  return res;\r\n};\r\n```\r\n\r\n## 题目反思\r\n>DFS是一类题目的思想，我们要想彻底掌握这类题目，一定要多做相关的题目，然后进行总结，类似的经典题目有全排列、组合总和等。"
    },
    {
      "id": "/这一次，彻底搞懂EventLoop",
      "metadata": {
        "permalink": "/blog/这一次，彻底搞懂EventLoop",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/这一次，彻底搞懂EventLoop.md",
        "source": "@site/blog\\这一次，彻底搞懂EventLoop.md",
        "title": "这一次，彻底搞懂EventLoop",
        "description": "一、为什么要有事件循环？",
        "date": "2021-12-12T00:00:00.000Z",
        "formattedDate": "2021年12月12日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 11.645,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "这一次，彻底搞懂EventLoop",
          "date": "2021-12-12T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "LeetCode——组合总和（DFS）",
          "permalink": "/blog/LeetCode——组合总和（DFS）"
        },
        "nextItem": {
          "title": "Egg.js中封装Ajax，异步改变数据状态与分页功能的实现",
          "permalink": "/blog/Egg.js中封装Ajax，异步改变数据状态与分页功能的实现"
        }
      },
      "content": "## 一、为什么要有事件循环？\r\n>`JS是单线程、非阻塞的。`JS的主要用途是与用户互动，并操作DOM，如果涉及成多线程的，一个线程要删除当前DOM节点，另一个线程要修改当前DOM节点，这就会带来很严重的同步问题。这就是为什么JS要设计成单线程的原因，而JS的非阻塞特性就是由event loop实现的。\r\n\r\n## 二、浏览器的事件循环\r\n### 执行栈和事件队列\r\n#### 同步代码，按照顺序添加到执行栈中\r\n\r\n>以下面的代码为例，分析执行栈的执行顺序。\r\n\r\n```js\r\nfunction a() {\r\n    b();\r\n    console.log('a');\r\n}\r\nfunction b() {\r\n    console.log('b')\r\n}\r\na();\r\n```\r\n\r\n1. 函数a入栈。\r\n2. 函数b入栈。\r\n3. console.log('b')入栈。\r\n4. 输出b，console.log('b')出栈。\r\n5. 函数b()执行完毕，出栈。\r\n6. console.log('a')入栈，执行完毕后出栈。\r\n7. 函数a执行完毕，出栈。\r\n\r\n#### 异步代码，通过事件队列\r\n>异步代码的执行，遇到异步事件不会等待它返回结果，而是将这个事件挂起，继续执行执行栈中的其他任务，当异步事件返回结果后，将它放到事件队列中，被放入事件队列中的语句不会立刻执行，而是等待当前执行栈中所有的任务都执行完毕，主线程空闲时，主线程会询问事件队列汇总是否有任务，如果有则取出排在第一位的事件，并把这个事件对应的回调放到执行栈中，然后执行其中的同步代码。\r\n\r\n```js\r\nfunction a() {\r\n    b();\r\n    console.log('a');\r\n}\r\nfunction b() {\r\n    console.log('b')\r\n    setTimeout(function() {\r\n        console.log('c');\r\n    }, 2000)\r\n}\r\na();\r\n```\r\n>输出顺序如下：b a c。\r\n\r\n>执行栈、事件队列、Web API三者之间的关系。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/d0a0bea1755111e3725bef09bfb9c8fe.png)\r\n\r\n\r\n\r\n### 宏任务和微任务\r\n#### 为什么要区分宏任务和微任务？\r\n>页面渲染事件和各种IO事件等随时被添加到任务队列中，会一直保持先进先出的原则，但是这样我们无法对各种事件进行区分优先级，因为有些任务需要优先执行，所以我们对异步任务进行了区分，引入了宏任务和微任务队列。\r\n\r\n#### 典型的宏任务\r\n* 全局代码\r\n* script(整体代码)\r\n* setTimeout()\r\n* setInterval()\r\n* setImmediate\r\n* postMessage\r\n* I/O\r\n* UI交互事件\r\n* requestAnimationFrame()\r\n\r\n#### 典型的微任务\r\n* Promise().then(回调)\r\n* MutationObserver\r\n* process.nextTick\r\n\r\n#### 运行机制\r\n>在事件循环中，先执行宏任务，因为全局代码属于宏任务，然后执行宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，微任务执行完毕后，执行宏任务，当前宏任务执行完毕之后，开始进行GUI渲染，渲染完毕之后继续执行下一个宏任务。\r\n\r\n```js\r\nconsole.log('start')\r\n\r\nsetTimeout(function() {\r\n  console.log('setTimeout')\r\n}, 0)\r\n\r\nPromise.resolve().then(function() {\r\n  console.log('promise1')\r\n}).then(function() {\r\n  console.log('promise2')\r\n})\r\n\r\nconsole.log('end')\r\n```\r\n\r\n>上文的代码执行顺序如下：\r\n\r\n1. 全局代码当作宏任务开始执行，遇到同步任务直接执行，输出start.\r\n2. setTimeout中的函数压入宏任务队列，promise.then回调放入微任务队列，然后执行同步代码输出end.\r\n3. 当调用栈中的所有同步代码执行完毕之后，开始执行微任务中的代码，执行promise的回调，输出promise1,此时返回undefined，promise状态变为fulfilled，触发接下来的then回调，产生了新的微任务，继续执行这个微任务，输出promise2。\r\n4. 当微任务队列执行完毕之后，开始进行UI渲染，然后开始下一轮的事件循环，执行setTimeout的回调，输出setTimeout.\r\n\r\n>最终输出结果为：\r\n\r\n* start\r\n* end\r\n* promise1\r\n* promise2\r\n* setTimeout\r\n\r\n## 浏览器渲染时机\r\n>浏览器会等到当前的微任务队列为空的时候，进行一次重新渲染，所以如果需要在异步的操作后重新渲染DOM的最好方法就是将其包装为微任务。\r\n\r\n## Node.js的事件循环\r\n>Node中的事件循环和浏览器中的有很大不同，Node.js采用V8作为JS的解析引擎，而I/O处理方面使用了自己设计的libuv。libuv库负责Node API的执行，它将不同的任务分配给不用的线程，形成一个事件循环，然后以异步的方式将任务的执行结果返回给V8引擎。\r\n\r\n### Node中的事件循环流程图\r\n>libuv引擎中的事件循环分为六个阶段，他们会按照顺序反复执行，每当进入某一个阶段时，都会从对应的回调队列中取出函数去执行，当队列为空或者执行的回调函数数量达到系统设定的阈值就会进入下一阶段。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/6b129b5317c77171d8e16ddcdeddfbe2.png)\r\n\r\n### 阶段分析\r\n* timers：执行setTimout和setInterval的回调，看是否满足delay的要求，不满足则直接离开这个阶段。\r\n* I/O callbacks阶段：执行除了下面操作以外的所有回调。\r\n    * setTimeout和setInterval的回调\r\n    * setImmediate的回调\r\n    * 用于关闭请求的回调函数，比如socket.on('close')\r\n* idle,prepare阶段：这个阶段仅在libuv内部使用，可以不用理会。\r\n* poll阶段：这个阶段是轮询阶段，首先会判断poll队列是否为空，如果不为空就会遍历回调队列并执行，直到队列为空或者达到系统限制。如果poll队列不为空，查看是否有setImmediate需要执行，如果有，就结束poll阶段，进入check阶段。如果没有，就会等待新的回调IO事件的到来，然后执行，如果此时设定了timer，会判断timer是否超时，如果超时的话会回到timer阶段执行回调。\r\n* check阶段：这个阶段主要执行setImmediate的回调函数。\r\n* close callbacks阶段：这个阶段执行关闭请求的回调函数，例如socket.on('close')。\r\n\r\n### setTimeout和setImmedate的执行顺序问题\r\n\r\n>关于setTimeout，官网给出的注意事项是：当延迟大于2147483647或小于1时，延迟将被设置为1。非整数的延时将被截断为整数。\r\n\r\n>请看下面的代码：会有怎样的执行顺序呢？\r\n\r\n```js\r\nsetTimeout(() => console.log(1),0);\r\nsetImmediate(() => console.log(2));\r\n```\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/a6ecf83f67bd089c2b92af044f57e5f9.png)\r\n\r\n>`之所以会出现上面的情况，就是因为进入timer阶段时，可能到了1ms，也有可能没到，如果没到timer阶段就会跳过这个语句，进入下一个阶段了，这也就是为什么执行顺序会出现不同的情况。`\r\n\r\n### process.nextTick的执行时机\r\n>process.nextTick是Node.js提供的一个异步执行函数，它不是setTimeout(fn,0)的别名，它的效率更高，它的执行顺序要先于setTimeout和setInterval。\r\n\r\n>下面这段代码的执行顺序说明了一切。\r\n\r\n```js\r\nconsole.log(1);\r\nsetTimeout(() => console.log('setTimeout=> 1'), 0);\r\nprocess.nextTick(() => console.log('nextTick=> 1'));\r\nconsole.log(2);\r\nsetTimeout(() => console.log('setTimeout=> 2'), 0);\r\nprocess.nextTick(() => {\r\n  console.log('nextTick=> 2');\r\n  for (let i = 0; i < 1000; i++) { }    //一直等待它执行完毕后，才会执行下一个nextTick()和之后的任务队列中的回调函数\r\n});\r\nconsole.log(3);\r\nprocess.nextTick(() => console.log('nextTick=> 3'));\r\nsetTimeout(() => console.log('setTimeout=> 3'), 0);\r\nconsole.log(4);\r\nsetTimeout(() => console.log('setTimeout=> 4'), 0);\r\nprocess.nextTick(() => console.log('nextTick=> 4'));\r\nconsole.log(5);\r\n\r\nfor (let i = 0; i < 1000; i++) { }        //一直等待它执行完毕后，才会执行nextTick和setTimeout的回调。\r\n```\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/95b28eb763392c2fbcbbf6981007d61d.png)\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/4383e2d72782fc32a4ecd849cd5a1d32.png)\r\n\r\n## Node.js与浏览器事件循环的区别\r\n\r\n>下面的这段代码很好的说明了Node.js与浏览器事件循环的区别，准确的说Node11以下版本和浏览器的事件循环是有区别的，Node11及以上版本和浏览器的执行顺序就一致了。\r\n\r\n>Node11以下版本在会在执行宏任务的时候，会先执行完所有的宏任务在执行微任务，而Node11及以上版本和浏览器在执行宏任务的时候，如果产生了微任务，会把微任务执行完再去执行其他的宏任务。\r\n\r\n```js\r\nfunction test () {\r\n  console.log('start')\r\n   setTimeout(() => {\r\n       console.log('children2')\r\n       Promise.resolve().then(() => {console.log('children2-1')})\r\n   }, 0)\r\n   setTimeout(() => {\r\n       console.log('children3')\r\n       Promise.resolve().then(() => {console.log('children3-1')})\r\n   }, 0)\r\n   Promise.resolve().then(() => {console.log('children1')})\r\n   console.log('end') \r\n}\r\n\r\ntest()\r\n// 以上代码在node11以下版本的执行结果(先执行所有的宏任务，再执行微任务)\r\n// start\r\n// end\r\n// children1\r\n// children2\r\n// children3\r\n// children2-1\r\n// children3-1\r\n\r\n// 以上代码在node11及浏览器的执行结果(顺序执行宏任务和微任务)\r\n// start\r\n// end\r\n// children1\r\n// children2\r\n// children2-1\r\n// children3\r\n// children3-1\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 典型题目分析\r\n* 网易云考题\r\n\r\n```js\r\nconst foo = new Promise(resolve => {\r\n  console.log(1);\r\n  resolve();\r\n  console.log(2);\r\n})\r\nfoo.then(() => {\r\n  console.log(3);\r\n})\r\nconsole.log(4);\r\n```\r\n\r\n>执行顺序是1 2 4 3，resolve并不具备阻塞性质，因为会先输出1 2 ，3会被加入到微任务队列，所以最后输出的是3，4属于同步代码。\r\n\r\n* 字节跳动考题\r\n\r\n```js\r\nconsole.log(1);\r\nsetTimeout(() => {\r\n  console.log(2);\r\n}, 0);\r\nasync function echo() {\r\n  console.log(5);\r\n  await Promise.resolve()\r\n  console.log(6);\r\n}\r\n\r\necho();\r\n\r\nrequestAnimationFrame(() => {\r\n  console.log(8);\r\n})\r\n\r\nnew Promise((resolve) => {\r\n  console.log(3);\r\n  resolve()\r\n}).then(() => {\r\n  console.log(4);\r\n})\r\n\r\nconsole.log(7);\r\n```\r\n\r\n>上述代码的输出顺序为：1 5 3 7 6 4 8 2，我们需要把requestAnimation当作一个宏任务，但是这个宏任务和其他宏任务的执行顺序是不确定的，因此也有可能输出是1 5 3 7 6 4 2 8。\r\n\r\n\r\n## 参考文献\r\n* [JavaScript中的Event Loop（事件循环）机制](https://segmentfault.com/a/1190000022805523)"
    },
    {
      "id": "/Egg.js中封装Ajax，异步改变数据状态与分页功能的实现",
      "metadata": {
        "permalink": "/blog/Egg.js中封装Ajax，异步改变数据状态与分页功能的实现",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Egg.js中封装Ajax，异步改变数据状态与分页功能的实现.md",
        "source": "@site/blog\\Egg.js中封装Ajax，异步改变数据状态与分页功能的实现.md",
        "title": "Egg.js中封装Ajax，异步改变数据状态与分页功能的实现",
        "description": "实现点击页面上的符号即修改数据库中的数据并进行显示",
        "date": "2021-12-11T00:00:00.000Z",
        "formattedDate": "2021年12月11日",
        "tags": [
          {
            "label": "Egg.js",
            "permalink": "/blog/tags/egg-js"
          }
        ],
        "readingTime": 2.465,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Egg.js中封装Ajax，异步改变数据状态与分页功能的实现",
          "date": "2021-12-11T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Egg.js",
          "tags": [
            "Egg.js"
          ]
        },
        "prevItem": {
          "title": "这一次，彻底搞懂EventLoop",
          "permalink": "/blog/这一次，彻底搞懂EventLoop"
        },
        "nextItem": {
          "title": "有趣的算法题：反转不包含字母的字符串",
          "permalink": "/blog/有趣的算法题：反转不包含字母的字符串"
        }
      },
      "content": "## 实现点击页面上的符号即修改数据库中的数据并进行显示\r\n\r\n### 静态页面设置\r\n```js\r\n<td class=\"text-center chStatus\" data-adminPath=\"<%=adminPath%>\" data-id=\"<%=list[i].id%>\" data-model=\"Product\" data-field=\"status\">\r\n<%if(list[i].status == 1){%>\r\n  <img src=\"/public/admin/images/yes.gif\" alt=\"\">\r\n  <%}else{%>\r\n    <img src=\"/public/admin/images/no.gif\" alt=\"\">\r\n  <%}%>\r\n</td>\r\n```\r\n\r\n### 通过Jquery进行逻辑控制\r\n1. 首先获取静态页面的数据。\r\n2. 然后将数据通过ajax请求发送到指定的路由。\r\n3. 根据控制器返回的数据，进一步控制页面的显示。\r\n\r\n```js\r\n$(function () {\r\n  app.init();\r\n})\r\n\r\nvar app = {\r\n  init: function () {\r\n    this.changeStatus();\r\n  },\r\n  changeStatus: function() {\r\n    $(\".chStatus\").click(function() {\r\n      var adminPath = $(this).attr(\"data-adminPath\");\r\n      var id = $(this).attr(\"data-id\");\r\n      var model = $(this).attr(\"data-model\");\r\n      var field = $(this).attr(\"data-field\");\r\n      var el = $(this).find(\"img\");\r\n      $.get(\"/\" + adminPath + \"/changeStatus\",{\"adminPath\": adminPath,\"id\" :id,\"model\": model,\"field\": field},function (response) {\r\n        if (response.success) {\r\n          if (el.attr(\"src\").indexOf(\"yes\") != -1) {\r\n            el.attr(\"src\",\"/public/admin/images/no.gif\");\r\n          } else {\r\n            el.attr(\"src\",\"/public/admin/images/yes.gif\");\r\n          }\r\n        }\r\n      })\r\n    })\r\n  }\r\n}\r\n```\r\n\r\n### 控制器动态控制数据的值\r\n>控制器主要是获取传过来的数据，然后根据model和field进行动态的显示，这是一种复用的方法，指的我们学习和借鉴。\r\n\r\n```js\r\nasync changeStatus() {\r\n    let model = this.ctx.request.query.model;\r\n    let field = this.ctx.request.query.field;\r\n    let id = this.ctx.request.query.id;\r\n    \r\n    let modelObj = await this.ctx.model[model].findByPk(id);\r\n    let json = {};\r\n    if (!modelObj) {\r\n      this.ctx.body = {\"success\": false,\"msg\": \"参数错误\"};\r\n      return;\r\n    } else {\r\n      if (modelObj[field] == 1) {\r\n        json = {\r\n          [field]: 0\r\n        }\r\n      } else {\r\n        json={\r\n          [field]: 1\r\n        }\r\n      }\r\n    }\r\n    await modelObj.update(json);\r\n    this.ctx.body = {\r\n      \"success\": true,\"msg\": \"更新数据成功\"\r\n    }\r\n  }\r\n```\r\n\r\n## 分页功能的实现\r\n### 后端通过egg-sequelize实现\r\n>下面的代码中重点通过limit和offset实现，offset设置为(page - 1) * pageSize是一个分页公式。\r\n\r\n```js\r\nasync index() {\r\n    let page = this.ctx.request.query.page ? this.ctx.request.query.page : 1;\r\n    let pageSize = 5;\r\n    let result = await this.ctx.model.Product.findAll({\r\n      include: { model: this.ctx.model.ProductCate },\r\n      limit: pageSize,\r\n      offset: (page - 1) * pageSize\r\n    });\r\n    await this.ctx.render('admin/product/index', {\r\n      list: result\r\n    })\r\n  }\r\n```\r\n\r\n### 前端通过引入jqPaginator.js实现\r\n1. 引入文件\r\n\r\n```js\r\n<script type=\"text/javascript\" src=\"/public/admin/js/jqPaginator.js\"></script>\r\n```\r\n\r\n2. 定义容器\r\n\r\n```js\r\n<div id=\"pagination\" class=\"pagination\" style=\"display: flex; justify-content: center\" >\r\n\r\n</div>\r\n```\r\n\r\n3. 定义跳转逻辑\r\n\r\n>注意：此时要注意避免出现死循环的情况。\r\n\r\n```js\r\n<script>\r\n  $('#pagination').jqPaginator({\r\n    totalPages: <%=totalPages%>,\r\n    visiblePages: 5,\r\n    currentPage: <%=page%>,\r\n    onPageChange: function(num,type) {\r\n      if (type == \"change\") {\r\n        location.href=\"/<%=adminPath%>/product?page=\" + num;\r\n      }  \r\n    }\r\n  });\r\n</script>\r\n```"
    },
    {
      "id": "/有趣的算法题：反转不包含字母的字符串",
      "metadata": {
        "permalink": "/blog/有趣的算法题：反转不包含字母的字符串",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/有趣的算法题：反转不包含字母的字符串.md",
        "source": "@site/blog\\有趣的算法题：反转不包含字母的字符串.md",
        "title": "有趣的算法题：反转不包含字母的字符串",
        "description": "题目描述",
        "date": "2021-12-10T00:00:00.000Z",
        "formattedDate": "2021年12月10日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 1.44,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "有趣的算法题：反转不包含字母的字符串",
          "date": "2021-12-10T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "Egg.js中封装Ajax，异步改变数据状态与分页功能的实现",
          "permalink": "/blog/Egg.js中封装Ajax，异步改变数据状态与分页功能的实现"
        },
        "nextItem": {
          "title": "LeetCode——二叉树的最大深度（递归法+层序遍历）",
          "permalink": "/blog/LeetCode——二叉树的最大深度（递归法+层序遍历）"
        }
      },
      "content": "## 题目描述\r\n>博主最近看面经的时候，发现字节在面试的时候，问了候选人一道这样的算法题：请反转不包含字母的字符串。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/81c8150eac790ae7c45103377d58130b.png)\r\n\r\n## 解题思路\r\n* 首先将字符串分割为单个的字符。\r\n* 使用一个变量记录遍历到的字符是字母还是数字。\r\n* 如果属于数字或者横线则将其倒序加入到临时数组中，如果不属于数字或者横线则将临时数组的内容加入到结果数组并拼接字符，然后将临时数组给清空。\r\n* 最后返回数组。\r\n\r\n```js\r\nfunction reverseStr(str) {\r\n  const result = [];\r\n  const arr = str.split('');\r\n  let temp = [];\r\n  let isNumber = false;\r\n  for (let i = 0; i < arr.length; i++) {\r\n    if (Number(arr[i]) >= 0 || Number(arr[i] <= 9 || arr[i] === '-')) {\r\n      isNumber = true;\r\n      temp.unshift(arr[i]);\r\n    } else {\r\n      isNumber = false;\r\n      result.push(...temp);\r\n      result.push(arr[i]);\r\n      temp = [];\r\n    }\r\n  }\r\n  return result.join('');\r\n}\r\nreverseStr('123abd3-adfz-34-akjkfaf')\r\n```\r\n\r\n## 题目反思\r\n>遇到陌生的题目时，不要慌张，借助第三方数组和变量来辅助我们解题是一个很关键的思路，本题就是通过借助数组和flag来帮助解题的。"
    },
    {
      "id": "/LeetCode——二叉树的最大深度（递归法+层序遍历）",
      "metadata": {
        "permalink": "/blog/LeetCode——二叉树的最大深度（递归法+层序遍历）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——二叉树的最大深度（递归法+层序遍历）.md",
        "source": "@site/blog\\LeetCode——二叉树的最大深度（递归法+层序遍历）.md",
        "title": "LeetCode——二叉树的最大深度（递归法+层序遍历）",
        "description": "题目描述",
        "date": "2021-12-09T00:00:00.000Z",
        "formattedDate": "2021年12月9日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.45,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——二叉树的最大深度（递归法+层序遍历）",
          "date": "2021-12-09T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "有趣的算法题：反转不包含字母的字符串",
          "permalink": "/blog/有趣的算法题：反转不包含字母的字符串"
        },
        "nextItem": {
          "title": "Webpack面试题系统梳理（完美应对90%场景）",
          "permalink": "/blog/Webpack面试题系统梳理"
        }
      },
      "content": "## 题目描述\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/7e5e43ad3c819aee3f2f5294f9165077.png)\r\n\r\n## 解题思路\r\n>二叉树的最大深度的解题方法有很多种，但是我们要做的是使用通用的思路来求解，比如使用层序遍历的方法首先用数组保存整个树的所有节点到数组中，然后返回这个二维数组的长度就是这个二叉树的最大深度，之所以要这样做，是因为我们的解题方法是通用的，这个思路既可以求解这个问题，也可以进行二叉树的遍历。\r\n\r\n```js\r\nvar maxDepth = function(root) {\r\n  // 使用递归法层序遍历二叉树\r\n  if (!root) return 0;\r\n  let result = [];\r\n\r\n  function levelOrder(root,level) {\r\n    if (!root) return;\r\n    result[level] = result[level] || [];\r\n    result[level].push(root.val);\r\n    levelOrder(root.left,level + 1);\r\n    levelOrder(root.right,level + 1);\r\n  }\r\n  levelOrder(root,0);\r\n  return result.length;\r\n};\r\n```\r\n\r\n## 题目反思\r\n>在刷题的时候，我们一定不能只是一味追求数量，当然了数量也很重要，但是对不同的题目追求统一的思路，绝对是有帮助的，因为这样我们可以用一个思路来求解一类题目。\r\n\r\n## 参考链接\r\n* [剑指Offer——二叉树的深度（JS实现](https://juejin.cn/post/6948664418787917861)"
    },
    {
      "id": "/Webpack面试题系统梳理",
      "metadata": {
        "permalink": "/blog/Webpack面试题系统梳理",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Webpack面试题系统梳理.md",
        "source": "@site/blog\\Webpack面试题系统梳理.md",
        "title": "Webpack面试题系统梳理（完美应对90%场景）",
        "description": "一、什么是Webpack？",
        "date": "2021-12-07T00:00:00.000Z",
        "formattedDate": "2021年12月7日",
        "tags": [
          {
            "label": "Webpack",
            "permalink": "/blog/tags/webpack"
          }
        ],
        "readingTime": 15.385,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Webpack面试题系统梳理（完美应对90%场景）",
          "date": "2021-12-07T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Webpack",
          "tags": [
            "Webpack"
          ]
        },
        "prevItem": {
          "title": "LeetCode——二叉树的最大深度（递归法+层序遍历）",
          "permalink": "/blog/LeetCode——二叉树的最大深度（递归法+层序遍历）"
        },
        "nextItem": {
          "title": "Webpack中懒加载、预加载、PWA与多进程打包",
          "permalink": "/blog/Webpack中懒加载、预加载、PWA与多进程打包"
        }
      },
      "content": "## 一、什么是Webpack？\r\n\r\n>webpack是用于现代JavaScript应用程序的静态模块打包工具。webpack会分析我们的项目结构，找到JavaScript模块以及其他的一些浏览器不能直接运行的拓展语言（例如Sass、TypeScript等）,并将其打包为合适的格式供浏览器使用。\r\n\r\n## 二、为什么需要Webpack?\r\n>如今在开发前端项目时，为了简化开发的复杂程度，引入了模块化、TypeScript、less、sass等CSS预处理器实践方法，但是使用它们开发的文件需要进行额外的处理才能被浏览器识别，webpack的出现就是为了解决这个需求的。\r\n\r\n## 三、Webpack的使用场景\r\n1. 根据模板生成HTML，并自动处理css/js引用路径。\r\n2. 自动处理img里面的图片路径，字体引用等。\r\n3. 开启本地服务器，实现修改代码即热更新的功能。\r\n4. 编译jsx、es6、sass、less等并添加sourcemap等辅助。\r\n5. 异步加载内容，不需要时不加载到DOM。\r\n6. 配合Vue.js、react.js等框架的开发。\r\n\r\n## 四、Webpack的构建流程\r\n1. 初始化参数：从配置文件和shell语句中读取与合并参数，得出最终的参数。\r\n2. 开始编译：用上一步得到的参数初始化Compiler对象，加载所有配置的插件，执行对象的run方法开始执行编译。\r\n3. 确定入口：根据配置中的entry找到所有的入口文件。\r\n4. 编译模块：从入口文件出发，调用所有配置的Loader对模块进行翻译，再找出改模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。\r\n5. 完成模块编译：在经过第四步使用Loader翻译完所有模块后，得到了每个模块翻译后的最终内容以及它们之间的依赖关系。\r\n6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的Chunk,再把每个chunk转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会。\r\n7. 输出完成：在确定好输出内容之后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统中。\r\n\r\n## 五、Loader和Plugins的区别\r\n1. 用法不同\r\n\r\n>loader是一个转换器，将A文件编译成B文件，比如将A.less转换为A.css，单纯的文件转换过程。webpack将一切文件视为模块，但是webpack原生只能解析JS文件，如果想将其他文件也打包的话，就会用到loader。plugin是一个扩展器，它丰富了webpack本身，会监听webpack打包过程中的某些节点，在合适的时机通过Webpack提供的API改变输出的结果。比如HtmlWebpackPlugin是用来生成一个HTML文件的。\r\n\r\n2. 运行时机不同\r\n\r\n>loader运行在打包文件之前，plugins则在整个编译周期都起作用。\r\n\r\n## 六、常用的Loader与plugins\r\n### 常用Loader及其作用\r\n1. style-loader\r\n\r\n>用于将css编译后的样式，挂载到页面的style标签上。\r\n\r\n2. css-loader\r\n\r\n>用于识别.css文件，处理css必须配合style-loader共同使用，只安装css-loader样式不会生效。\r\n\r\n3. sass-loader\r\n\r\n>css预处理器，sass的特点是编写css更加便捷。\r\n\r\n4. postcss-loader\r\n\r\n>用于补充css样式各种浏览器内核前缀，可以实现更好的兼容性。\r\n\r\n5. babel-loader\r\n\r\n>用于将ES6及以上的语法转换为ES5语法。\r\n\r\n6. ts-loader\r\n\r\n>用于配置项目TypeScript。\r\n\r\n7. html-loader\r\n\r\n>如果有时候需要引入一个html页面代码片段赋值给DOM元素内容使用，这时就用到html-loader。\r\n\r\n8. file-loader\r\n\r\n>用于处理文件类型资源，如jpg,png等图片。\r\n\r\n9. url-loader\r\n\r\n>url-loader也是处理图片类型资源，这个与file-loader的不同之处是，url-loader可以根据图片大小进行不同的操作，如果图片大小大于指定的大小则将图片进行打包，反之则将其转换为base64字符串合并到js文件中。\r\n\r\n10. html-withimg-loader\r\n\r\n>我们在编译图片时，都是使用file-loader和url-loader，这两个loader都是查找js文件中的相关图片资源的，但是HTML文件中的图片不会进行打包，因此，要想实现打包就要使用html-withimg-loader。\r\n\r\n11. vue-loader\r\n\r\n>用于编译.vue文件，如果我们自己搭建vue项目就可以使用vue-loader。\r\n\r\n12. eslint-loader\r\n\r\n>用于检查代码是否符合规范，是否存在语法错误。\r\n\r\n### 常用Plugins及其作用\r\n1. html-webpack-plugin\r\n\r\n>可以根据模板自动生成html代码，并自动引用css和js文件。\r\n\r\n2. extract-text-webpack-plugin\r\n\r\n>将js文件中引用的样式单独抽离成css文件。\r\n\r\n3. HotModuleReplacementPlugin\r\n\r\n>热更新插件。\r\n\r\n4. optimize-css-assets-webpack-plugin\r\n\r\n>不同组件中重复的css可以快速去重，压缩CSS代码的。\r\n\r\n5. compression-webpack-plugin\r\n\r\n>生产环境下可以采用gzip压缩JS和CSS文件。\r\n\r\n6. clean-webpack-plugin\r\n\r\n>清理每次打包下没有使用的文件。\r\n\r\n7. mini-css-extract-plugin\r\n\r\n>是一个专门用于将打包的CSS内容提取到单独文件的插件。\r\n\r\n## 七、Webpack生产环境和开发环境的区别\r\n>开发环境和生产环境的需求不同。\r\n\r\n>开发环境的需求\r\n\r\n* 模块热更新\r\n* sourceMap\r\n* 接口代理\r\n* 代码规范检查\r\n* dev server\r\n\r\n>生产环境的需求\r\n\r\n* 提取公共代码\r\n* 压缩混淆\r\n* 文件压缩\r\n* 去除无用的代码\r\n* 改善加载时间\r\n\r\n## 八、如何提高打包速度，减少打包体积？\r\n### 第一步：对打包的速度和体积进行分析\r\n1. 使用speed-measure-webpack-plugin来进行速度分析，分析整个打包的总耗时，查看每个loader和plugin的耗时情况。\r\n2. 采用webpack-bundle-analyzer进行体积分析，主要分析依赖的第三方库的文件大小和业务代码里的组件大小。\r\n\r\n### 第二步：提高Webpack打包速度\r\n#### 一、 确定影响打包速度的因素\r\n1. 开始打包时，首先需要搜索所有的依赖项，这需要占用一定的时间即搜索时间，所以我们要优化`搜索时间`。\r\n2. webpack会根据我们配置的loader解析相应的文件，所以我们需要优化这个`解析时间`。\r\n3. webpack会将所有依赖的模块打包到一个文件中，其中JS压缩时发布编译的最后阶段，JS压缩时需要先将代码转换为抽象语法树，然后处理这个抽象语法树最后还原成JS，这个过程涉及到大量计算，因此我们需要对这个`压缩时间`进行优化。\r\n4. 当更改项目中的一个文件，需要重新进行打包，但是很多没有更改的文件也需要重新打包，因此我们需要对`二次打包的时间`进行优化。\r\n\r\n#### 二、 优化解析时间\r\n>运行在Node.js上的webpack是单线程模式的，因此在打包大量文件时，就会比较漫长。\r\n\r\n1. 使用thread-loader并行解析资源，只需要把这个loader放置在其他loader之前，就会开启多进程处理。\r\n2. 在webpack的构建过程中，大多数时间消耗在loader的解析转换上，可以利用happyPack使用多进程对文件进行打包，对多核CPU利用率更高，HappyPack可以让Webpack同一时间处理多个任务，将任务分解给多个子进程去并发的执行，子进程处理完后，再把结果发送给主进程。\r\n\r\n#### 三、 合理利用缓存\r\n1. 在性能开销较大的loader之前添加cache-loader，将会显著提升二次构建的速度。\r\n2. 使用DLLPlugin将第三方模块单独打包生成一个文件，因为一般情况下，第三方模块的代码是不会轻易改变的。这样只有第一次打包的时候去分析这个文件里的代码，再次打包的时候回使用上次已经打包过的代码。\r\n\r\n#### 四、 优化压缩时间\r\n>webpack4默认内置使用terser-webpack-plugin来压缩优化代码，同时terser可以启动多进程并行运行来提高压缩的速度。\r\n\r\n#### 五、 优化搜索时间\r\n>我们在使用Loader的时候可以通过test、include、exclude三个配置项来优化Loader的文件搜索范围。比如说将node_modules给排除掉，因为node_modules中使用的代码都是经过编译过的。\r\n\r\n### 第三步：减少Webpack的打包体积\r\n#### 一、 按需加载\r\n>在开发项目时，避免引入不需要的代码，尽可能的进行按需加载。\r\n\r\n#### 二、Scope Hoisting\r\n>Scope Hoisting会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中。\r\n\r\n#### 三、Tree Shaking\r\n>利用Tree Shaking可以实现删除项目中共未被引用的代码。\r\n\r\n\r\n## 九、 实现Loader和Plugin\r\n### 实现Loader\r\n>Loader的本质是一个函数，这个函数会接收一个参数，这个参数是待匹配文件的源码，函数会返回处理后的源码。\r\n\r\n>下面我们写一个Loader，将var关键字替换为let\r\n\r\n```js\r\nmodule.exports = function (source) {\r\n    return source.replace(/var/g,'let');\r\n}\r\n```\r\n\r\n>调用这个Loader只需在webpack.config.js中使用下面的方法\r\n\r\n```js\r\nmodule: {\r\n  rules: [\r\n    {\r\n      test: /\\.js$/,\r\n      use: [\r\n        {\r\n          loader: path.resolve('./src/myLoader.js')\r\n        }\r\n      ]\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n\r\n\r\n### 实现Plugin \r\n>一个Webpack Plugin包含以下五个部分。\r\n\r\n1. 一个JavaScript命名函数。\r\n2. 在函数的prototype上有一个apply方法。\r\n3. 有一个绑定到webpack自身的事件钩子。\r\n4. 处理webpack内部实例的特定数据。\r\n5. 功能完成后调用webpack提供的回调。\r\n\r\n```js\r\nfunction myPlugin(options) {}\r\n\r\nmyPlugin.prototype.apply = function (compiler) {\r\n  compiler.plugin('emit',function(compilation,callback) {\r\n    // 功能完成后调用webpack提供的回调\r\n    console.log('Hello Webpack');\r\n    callback();\r\n  })\r\n}\r\n\r\nmodule.exports = myPlugin;\r\n```\r\n\r\n>如何调用我们手写的插件呢？\r\n\r\n```js\r\nconst myPlugin = require('./src/myPlugin.js');\r\n\r\nmodule.exports = {\r\n  ...,\r\n  plugins: [\r\n    new Plugin()\r\n  ]\r\n}\r\n```\r\n\r\n## 十、 Webpack热更新的原理（HMR）\r\n### 什么是HMR？\r\n>HMR即（Hot Module Replacement模块热替换）是指当代码发生修改并保存后，webpack会对更新的部分代码进行重新打包，并将新的模块发送到浏览器端，浏览器将新的模块替换掉旧的模块，这样能够在不刷新浏览器的前提下对应用进行更新。\r\n\r\n### Webpack热更新的工作流程\r\n1. 第一步：webpack启动监听模式之后，webpack第一次编译项目，并将结果存储在内存文件系统中，内存webpack服务器通知浏览器加载资源，浏览器获取的静态资源除了JS代码之外，还有一部分是通过webpack-dev-server注入的HMR runtime代码，作为浏览器和webpack通信的客户端。\r\n2. 第二步：文件系统中的一个文件或者模块发生了变化，webpack监听到文件变化对文件重新编译打包，每次编译生成唯一的hash值，根据变化的内容生成两个补丁文件，说明变化内容的manifest和chunk.js。\r\n3. 第三步：HMR-server通过websocket将manifest推送给浏览器。\r\n4. 第四步：浏览器端的HMR runtime根据manifest的hash和chunkid使用ajax拉取最新的模块chunk。\r\n5. 第五步：触发render流程实现局部热重载。\r\n\r\n## 十一、webpack、babel和babel-loader三者之间的关系\r\n* babel是编译工具，把ES6及以上语法编译成ES5等低版本语法。\r\n* webpack是打包工具，定义入口文件，将所有的模块引入整理后，通过loader和plugin处理后，打包输出。\r\n* webpack通过babel-loader使用babel。\r\n\r\n\r\n## 十二、webpack的Tree shaking的作用及原理\r\n### 作用\r\n>Tree Shaking是一种通过清除多余代码来优化项目打包体积的技术。\r\n\r\n### 原理\r\n>借助ES6模块语法的静态结构，通过编译阶段的静态分析，找到没有引入的模块并打上标记，然后在压缩阶段利用像uglify-js这样的压缩工具删除没有用到的代码。\r\n\r\n\r\n## 参考链接\r\n* [分享12个Webpack中常用的Loader](https://juejin.cn/post/6942322281913778206)"
    },
    {
      "id": "/Webpack中懒加载、预加载、PWA与多进程打包",
      "metadata": {
        "permalink": "/blog/Webpack中懒加载、预加载、PWA与多进程打包",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Webpack中懒加载、预加载、PWA与多进程打包.md",
        "source": "@site/blog\\Webpack中懒加载、预加载、PWA与多进程打包.md",
        "title": "Webpack中懒加载、预加载、PWA与多进程打包",
        "description": "懒加载的实现方法",
        "date": "2021-12-06T00:00:00.000Z",
        "formattedDate": "2021年12月6日",
        "tags": [
          {
            "label": "Webpack",
            "permalink": "/blog/tags/webpack"
          }
        ],
        "readingTime": 3.235,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Webpack中懒加载、预加载、PWA与多进程打包",
          "date": "2021-12-06T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Webpack",
          "tags": [
            "Webpack"
          ]
        },
        "prevItem": {
          "title": "Webpack面试题系统梳理（完美应对90%场景）",
          "permalink": "/blog/Webpack面试题系统梳理"
        },
        "nextItem": {
          "title": "Webpack中的tree shaking与code split的核心用法",
          "permalink": "/blog/Webpack中的tree shaking与code split的核心用法"
        }
      },
      "content": "## 懒加载的实现方法\r\n>通过动态import的方法来实现懒加载。（下面的函数，不点击按钮是不会加载test.js这个文件的）。\r\n\r\n```js\r\nconsole.log(\"index.js文件被加载了~\");\r\n\r\ndocument.getElementById('btn').onclick = function() {\r\n  // 懒加载\r\n  import(/* webpackChunkName: 'test' */'./test').then(({mul}) => {\r\n    console.log(mul(4,5));\r\n  });\r\n}\r\n```\r\n\r\n## 预加载的开启方式\r\n>只需在动态导入的时候，添加如下的参数即可。\r\n\r\n```js\r\nwebpackPrefetch: true\r\n```\r\n\r\n>完整配置请看下面的代码。\r\n\r\n```js\r\nconsole.log(\"index.js文件被加载了~\");\r\n\r\ndocument.getElementById('btn').onclick = function() {\r\n  // 懒加载\r\n  import(/* webpackChunkName: 'test',webpackPrefetch: true */'./test').then(({mul}) => {\r\n    console.log(mul(4,5));\r\n  });\r\n}\r\n```\r\n\r\n## 懒加载、预加载、正常加载的区别\r\n* 懒加载：当文件需要用到的时候才会去加载，不用的时候不加载。\r\n* 正常加载：正常的时候是并发去加载，但是一般受到6个个数的限制。\r\n* 预加载：等其他资源加载完毕后，浏览器空闲了，再加载资源，但是不会运行这个文件。\r\n\r\n## PWA的使用方法\r\n### 什么是PWA？PWA有什么用？\r\n>PWA可以让我们在离线的时候依然能够正常放问指定的资源。\r\n\r\n### 如何实现PWA？\r\n1. 安装插件\r\n\r\n```shell\r\nnpm i workbox-webpack-plugin@5.0.0\r\n```\r\n\r\n2. 引入插件\r\n\r\n```js\r\nconst WorkboxWebpackPlugin = require('workbox-webpack-plugin')\r\n```\r\n\r\n3. 在webpack.config.js中配置插件\r\n\r\n>下面的配置会生成一个serviceworker配置文件。\r\n\r\n```js\r\nnew WorkboxWebpackPlugin.GenerateSW({\r\n  clientsClaim: true,\r\n  skipWaiting: true\r\n})\r\n```\r\n\r\n4. 在package.json中配置eslint允许其访问浏览器的全局变量\r\n\r\n```js\r\n  \"eslintConfig\": {\r\n    \"extends\": \"airbnb-base\",\r\n    \"env\": {\r\n      \"browser\": true\r\n    }\r\n  }\r\n```\r\n\r\n5. 在入口文件处注册serviceWorker\r\n\r\n```js\r\nif ('serviceWorker' in navigator) {\r\n  window.addEventListener('load', () => {\r\n    navigator.serviceWorker\r\n      .register('/service-worker.js')\r\n      .then(() => {\r\n        console.log('sw注册成功~');\r\n      })\r\n      .catch(() => {\r\n        console.log('注册出错！');\r\n      });\r\n  });\r\n}\r\n```\r\n\r\n6. 通过服务器运行测试（sw代码必须运行在服务器上）\r\n\r\n```js\r\nserve -s build\r\n```\r\n\r\n> 上述的代码会将build文件当做静态文件对外允许访问。\r\n\r\n## 多进程打包\r\n\r\n### 为什么要有多进程打包？\r\n>之所以要有多进程打包，是为了提高打包的速度。\r\n\r\n### 如何开启多线程打包？\r\n1. 安装插件\r\n\r\n```shell\r\nnpm i thread-loader@2.1.3\r\n```\r\n\r\n2. 在需要开启的loader前面添加下面的代码\r\n\r\n>重要的是下面的babel-loader。\r\n\r\n```js\r\n{\r\n// 进行js兼容性的处理\r\ntest: /\\.js$/,\r\nexclude: /node_modules/,\r\nuse: [\r\n  // 开启多进程打包\r\n  'thread-loader',\r\n  {\r\n    loader: 'babel-loader',\r\n    options: {\r\n      presets: [\r\n        ['@babel/preset-env',\r\n          {\r\n            useBuiltIns: 'usage',\r\n            corejs: { version: 3 },\r\n            targets: {\r\n              chrome: '60',\r\n              firefox: '50'\r\n            }\r\n          }\r\n        ]\r\n      ],\r\n      cacheDirectory: true\r\n    }\r\n  }\r\n]\r\n}\r\n```\r\n\r\n>指的注意的是：当资源比较小的时候，通过上面的代码甚至会更加耗时，这是正常现象，因为启动也需要一定的时间。"
    },
    {
      "id": "/Webpack中的tree shaking与code split的核心用法",
      "metadata": {
        "permalink": "/blog/Webpack中的tree shaking与code split的核心用法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Webpack中的tree shaking与code split的核心用法.md",
        "source": "@site/blog\\Webpack中的tree shaking与code split的核心用法.md",
        "title": "Webpack中的tree shaking与code split的核心用法",
        "description": "什么是tree shaking?",
        "date": "2021-12-05T00:00:00.000Z",
        "formattedDate": "2021年12月5日",
        "tags": [
          {
            "label": "Webpack",
            "permalink": "/blog/tags/webpack"
          }
        ],
        "readingTime": 2.525,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Webpack中的tree shaking与code split的核心用法",
          "date": "2021-12-05T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Webpack",
          "tags": [
            "Webpack"
          ]
        },
        "prevItem": {
          "title": "Webpack中懒加载、预加载、PWA与多进程打包",
          "permalink": "/blog/Webpack中懒加载、预加载、PWA与多进程打包"
        },
        "nextItem": {
          "title": "Webpack中的source-map、oneOf、缓存的核心用法",
          "permalink": "/blog/Webpack中的source-map、oneOf、缓存的核心用法"
        }
      },
      "content": "## 什么是tree shaking?\r\n>我们可以将我们的项目比作一棵树，树上每一个用到的第三方模块或者函数都可以比作一个绿色的树叶，但是我们的项目中可能存在很多没有被用到的模块或者函数，这些就是需要我们摇晃掉的树叶，这个过程我们叫做tree shaking。\r\n\r\n## 如何开启tree shaking？\r\n>开启tree shaking只需满足下面两个条件，即可自动开启。\r\n\r\n1. 必须使用ES6模块化。\r\n2. 开启production环境。\r\n\r\n>如果想要把所有的代码都进行tree shaking还需要在package.json中进行如下的配置。\r\n\r\n* package.json\r\n\r\n```js\r\n\"sideEffects\": [\"*.css\"]\r\n```\r\n\r\n## Webpack中设置多入口文件\r\n1. 通过对象的形式个entry进行赋值\r\n\r\n```js\r\n  entry: {\r\n    main: './src/js/index.js',\r\n    test: './src/js/test.js'\r\n  }\r\n```\r\n\r\n2. 给output指定输出的文件名以便于区分。\r\n\r\n```js\r\n  output: {\r\n    filename: 'js/[name].[contenthash:10].js',\r\n    path: resolve(__dirname, 'build')\r\n  }\r\n```\r\n\r\n## 设置公用的模块只打包生成一次\r\n>之所以设置将公用的模块之打包一次，是为了进行复用，举个栗子，A文件和B文件都引用了Jquery，不使用下面的配置进行打包的话，会将jquery这个模块打包两次，这显然不合理。但是，通过下面的配置允许只打包一次。（在多入口的情况下）\r\n\r\n```js\r\noptimization: {\r\n    splitChunks: {\r\n      chunks: 'all'\r\n    }\r\n  }\r\n```\r\n\r\n## 通过JS代码，让某个文件被单独打包成一个chunk\r\n>这种使用方式适用于单入口文件的情况。只需在使用的地方，通过下面的使用方式即可。\r\n\r\n```js\r\nimport(/* webpackChunkName: 'test' */'./test')\r\n  .then(({ mul, count }) => {\r\n    // eslint-disable-next-line\r\n    console.log(mul(2, 5));\r\n  })\r\n  .catch(() => {\r\n    // eslint-disable-next-line\r\n    console.log('文件加载出错');\r\n  })\r\n```\r\n\r\n>下面给出完整代码，以方便大家理解。\r\n\r\n```js\r\nfunction sum(...args) {\r\n  return args.reduce((p, c) => p + c, 0);\r\n}\r\n\r\nimport(/* webpackChunkName: 'test' */'./test')\r\n  .then(({ mul, count }) => {\r\n    // eslint-disable-next-line\r\n    console.log(mul(2, 5));\r\n  })\r\n  .catch(() => {\r\n    // eslint-disable-next-line\r\n    console.log('文件加载出错');\r\n  })\r\n\r\n\r\n// eslint-disable-next-line\r\nconsole.log(mul(2, 3));\r\n// eslint-disable-next-line\r\nconsole.log(sum(1, 2, 3, 4));\r\n```"
    },
    {
      "id": "/Webpack中的source-map、oneOf、缓存的核心用法",
      "metadata": {
        "permalink": "/blog/Webpack中的source-map、oneOf、缓存的核心用法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Webpack中的source-map、oneOf、缓存的核心用法.md",
        "source": "@site/blog\\Webpack中的source-map、oneOf、缓存的核心用法.md",
        "title": "Webpack中的source-map、oneOf、缓存的核心用法",
        "description": "source-map是什么?",
        "date": "2021-12-04T00:00:00.000Z",
        "formattedDate": "2021年12月4日",
        "tags": [
          {
            "label": "Webpack",
            "permalink": "/blog/tags/webpack"
          }
        ],
        "readingTime": 3.89,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Webpack中的source-map、oneOf、缓存的核心用法",
          "date": "2021-12-04T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Webpack",
          "tags": [
            "Webpack"
          ]
        },
        "prevItem": {
          "title": "Webpack中的tree shaking与code split的核心用法",
          "permalink": "/blog/Webpack中的tree shaking与code split的核心用法"
        },
        "nextItem": {
          "title": "LeetCode——在排序数组中查找元素的第一个和最后一个位置（二分查找核心模板）",
          "permalink": "/blog/LeetCode——在排序数组中查找元素的第一个和最后一个位置（二分查找核心模板）"
        }
      },
      "content": "## source-map是什么?\r\n>source-map是一种提供构建后代码到源代码的映射技术，可以根据这个映射来追踪源代码的错误。\r\n\r\n### 设置source-map的方法\r\n>我们只需在webpack.config.js中添加一个配置项即可。\r\n\r\n```js\r\ndevtool: \"source-map\"\r\n```\r\n\r\n### 选择类型\r\n* 开发环境：eval-source-map\r\n* 生产环境：source-map\r\n\r\n## oneOf是什么？\r\n>有时候，我们在webpack配置中写了很多的loader，这也就意味着，一个文件要被多个loader过滤一遍，这在有些情况下是很冗余的，因此，我们希望只匹配一个loader，这就是我们为什么需要oneOf的原因。\r\n\r\n### oneOf如何使用？\r\n```js\r\nmodule: {\r\n    rules: [\r\n      {\r\n        // 进行Eslint检查\r\n        test: /\\.js$/,\r\n        // 排除其他文件\r\n        exclude: /node_modules/,\r\n        // 优先执行\r\n        enforce: 'pre',\r\n        loader: 'eslint-loader',\r\n        options: {\r\n          // 设置自动修复\r\n          fix: true\r\n        }\r\n      },\r\n      {\r\n        oneOf: [\r\n          {\r\n            // 处理CSS\r\n            test: /\\.css$/,\r\n            use: [...commonCssLoader]\r\n          },\r\n          {\r\n            test: /\\.less$/,\r\n            use: [...commonCssLoader, 'less-loader']\r\n          },\r\n          \r\n          {\r\n            // 进行js兼容性的处理\r\n            test: /\\.js$/,\r\n            exclude: /node_modules/,\r\n            loader: 'babel-loader',\r\n            options: {\r\n              presets: [\r\n                ['@babel/preset-env',\r\n                  {\r\n                    useBuiltIns: 'usage',\r\n                    corejs: { version: 3 },\r\n                    targets: {\r\n                      chrome: '60',\r\n                      firefox: '50'\r\n                    }\r\n                  }\r\n                ]\r\n              ]\r\n            }\r\n          },\r\n          {\r\n            // 打包图片资源\r\n            test: /\\.(jpg|png|gif)/,\r\n            loader: 'url-loader',\r\n            options: {\r\n              limit: 8 * 1024,\r\n              name: '[hash:10].[ext]',\r\n              outputPath: 'imgs',\r\n              esModule: false\r\n            }\r\n          },\r\n          {\r\n            // 处理HTML中的图片资源\r\n            test: /\\.html$/,\r\n            loader: 'html-loader'\r\n          },\r\n          {\r\n            // 处理其他资源\r\n            exclude: /\\.(js|css|less|html|jpg|png|gif)/,\r\n            loader: 'file-loader',\r\n            options: {\r\n              outputPath: 'media'\r\n            }\r\n          }\r\n        ]\r\n      }\r\n    ]\r\n  }\r\n```\r\n\r\n>需要注意的是：被oneOf包裹的所有loader中，不能存在两个配置处理同一种类型的文件，如果存在这样的两个loader，可以将其中一个提取出来，就像上面的那种处理方式一样。\r\n\r\n## 缓存\r\n>之所以需要缓存的原因在于，以babel为例，对一个项目进行编译，如果每次都是对整个项目进行重新编译比较浪费资源，因为我们可能只是对项目中进行了细微的改动，这就是为什么需要缓存的原因。\r\n\r\n### babel-loader开启缓存\r\n>只需给babel-loader的options中添加一个配置项即可。\r\n\r\n```js\r\n{\r\n    // 进行js兼容性的处理\r\n    test: /\\.js$/,\r\n    exclude: /node_modules/,\r\n    loader: 'babel-loader',\r\n    options: {\r\n      presets: [\r\n        ['@babel/preset-env',\r\n          {\r\n            useBuiltIns: 'usage',\r\n            corejs: { version: 3 },\r\n            targets: {\r\n              chrome: '60',\r\n              firefox: '50'\r\n            }\r\n          }\r\n        ]\r\n      ],\r\n      cacheDirectory: true\r\n    }\r\n  }\r\n```\r\n\r\n### 文件资源缓存\r\n#### hash配置\r\n>每次进行webpack打包的时候，给文件生成不同的文件名，这样静态资源的引入路径名也会发生变化，所以一旦进行重新打包，即使是强缓存，也能够感知到最新的变化，因为文件名变啦。\r\n\r\n* 修改js文件的哈希后缀\r\n\r\n```js\r\noutput: {\r\n    filename: 'js/built.[hash:10].js',\r\n    path: resolve(__dirname, 'build')\r\n  }\r\n```\r\n\r\n* 修改CSS文件的哈希后缀\r\n\r\n```js\r\nnew MiniCssExtractPlugin({\r\n  filename: 'css/built.[hash:10].css'\r\n})\r\n```\r\n\r\n>注意：上面的这种方式存在一个缺点，就是一旦重新打包，会导致所有的缓存失效，即使只改动了一个文件。\r\n\r\n#### contenthash(推荐使用)\r\n>contenthash根据文件的内容生成hash值，不同文件hash值一定不一样。\r\n\r\n* 处理JS文件\r\n\r\n```js\r\noutput: {\r\n    filename: 'js/built.[contenthash:10].js',\r\n    path: resolve(__dirname, 'build')\r\n  }\r\n```\r\n\r\n* 处理CSS文件\r\n\r\n```js\r\nnew MiniCssExtractPlugin({\r\n  filename: 'css/built.[contenthash:10].css'\r\n})\r\n```"
    },
    {
      "id": "/LeetCode——在排序数组中查找元素的第一个和最后一个位置（二分查找核心模板）",
      "metadata": {
        "permalink": "/blog/LeetCode——在排序数组中查找元素的第一个和最后一个位置（二分查找核心模板）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——在排序数组中查找元素的第一个和最后一个位置（二分查找核心模板）.md",
        "source": "@site/blog\\LeetCode——在排序数组中查找元素的第一个和最后一个位置（二分查找核心模板）.md",
        "title": "LeetCode——在排序数组中查找元素的第一个和最后一个位置（二分查找核心模板）",
        "description": "题目描述",
        "date": "2021-12-03T00:00:00.000Z",
        "formattedDate": "2021年12月3日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.855,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——在排序数组中查找元素的第一个和最后一个位置（二分查找核心模板）",
          "date": "2021-12-03T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "Webpack中的source-map、oneOf、缓存的核心用法",
          "permalink": "/blog/Webpack中的source-map、oneOf、缓存的核心用法"
        },
        "nextItem": {
          "title": "Webpack中生产环境的基本配置与HMR的使用",
          "permalink": "/blog/Webpack中生产环境的基本配置与HMR的使用"
        }
      },
      "content": "## 题目描述\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/bf96a440ec8959cf4a0103b611435435.png)\r\n\r\n## 解题思路\r\n>这道题目堪称是二分查找的经典题型，核心题型，模板题型。只要会了这道题目，几乎所有的二分查找的问题都迎刃而解了。\r\n\r\n1. 定义二分查找中查找左边界的函数，这个函数能够返回左边界的下标，如果数组中有目标元素返回第一个下标，如果数组中的所有元素都小于目标元素，返回的是数组的长度，如果数组中的所有元素都比目标元素大，返回的是下标0，如果数组中没有该元素，但是有比该元素大的值，返回的是第一个比目标值大的下标。\r\n2. 如果函数返回的下标对应的值不等于target，则返回[-1,-1].\r\n3. 如果存在则返回[findLeft(nums,target),findLeft(nums,target+1)-1]。\r\n\r\n```js\r\nvar searchRange = function (nums, target) {\r\n  // 二分查找查找左边界的模板\r\n  function findLeft(nums, target) {\r\n    let left = 0;\r\n    let right = nums.length - 1;\r\n    while (left <= right) {\r\n      let mid = (left + right) >> 1;\r\n      if (nums[mid] < target) {\r\n        left = mid + 1;\r\n      } else if (nums[mid] > target) {\r\n        right = mid - 1;\r\n      } else {\r\n        right = mid - 1;\r\n      }\r\n    }\r\n    return left;\r\n  }\r\n\r\n  if (nums[findLeft(nums, target)] != target) {\r\n    return [-1, -1];\r\n  } else {\r\n    return [findLeft(nums, target), findLeft(nums, target + 1) - 1]\r\n  }\r\n};\r\n```\r\n\r\n## 题目反思\r\n>这是二分查找的经典题型，只要是排好序的数组，几乎都可以使用这个题目进行求解。"
    },
    {
      "id": "/Webpack中生产环境的基本配置与HMR的使用",
      "metadata": {
        "permalink": "/blog/Webpack中生产环境的基本配置与HMR的使用",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Webpack中生产环境的基本配置与HMR的使用.md",
        "source": "@site/blog\\Webpack中生产环境的基本配置与HMR的使用.md",
        "title": "Webpack中生产环境的基本配置与HMR的使用",
        "description": "在文章开始之前，首先想让大家知道一个知识点，那就是loader的加载顺序问题，是从下到上开始进行加载的。",
        "date": "2021-12-02T00:00:00.000Z",
        "formattedDate": "2021年12月2日",
        "tags": [
          {
            "label": "Webpack",
            "permalink": "/blog/tags/webpack"
          }
        ],
        "readingTime": 4.25,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Webpack中生产环境的基本配置与HMR的使用",
          "date": "2021-12-02T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Webpack",
          "tags": [
            "Webpack"
          ]
        },
        "prevItem": {
          "title": "LeetCode——在排序数组中查找元素的第一个和最后一个位置（二分查找核心模板）",
          "permalink": "/blog/LeetCode——在排序数组中查找元素的第一个和最后一个位置（二分查找核心模板）"
        },
        "nextItem": {
          "title": "Webpack中处理Eslint、处理JS兼容性、压缩JS与HTML",
          "permalink": "/blog/Webpack中处理Eslint、处理JS兼容性、压缩JS与HTML"
        }
      },
      "content": ">在文章开始之前，首先想让大家知道一个知识点，那就是loader的加载顺序问题，是从下到上开始进行加载的。\r\n\r\n## 定义nodejs的环境变量，决定使用browserslist的哪个环境\r\n\r\n```js\r\nprocess.env.NODE_ENV = 'production';\r\n```\r\n\r\n## 复用loader\r\n>首先定义好需要复用的loader。\r\n\r\n```js\r\nconst commonCssLoader = [\r\n  MiniCssExtractPlugin.loader,\r\n  'css-loader',\r\n  {\r\n    // 还需要再package.json中定义browserslist\r\n    loader: 'postcss-loader',\r\n    options: {\r\n      ident: 'postcss',\r\n      plugins: () => [require('postcss-preset-env')()]\r\n    }\r\n  }\r\n]\r\n```\r\n\r\n>在需要进行使用的地方，通过拓展运算符来进行使用。\r\n\r\n```js\r\nmodule: {\r\n    rules: [\r\n      {\r\n        // 处理CSS\r\n        test: /\\.css$/,\r\n        use: [...commonCssLoader]\r\n      },\r\n      {\r\n        test: /\\.less$/,\r\n        use: [...commonCssLoader,'less-loader']\r\n      }\r\n    ]\r\n  }\r\n```\r\n\r\n## 生产环境下基本文件的配置方式\r\n>下面的配置包含了HTML、CSS、JS、图片、压缩、兼容性等的处理方式。\r\n\r\n```js\r\nconst { resolve } = require('path');\r\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\r\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\r\n// 下面的这个插件是压缩CSS的插件\r\nconst OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')\r\n\r\n// 定义nodejs的环境变量，决定使用browserslist的哪个环境\r\nprocess.env.NODE_ENV = 'production';\r\n\r\n// 复用loader\r\nconst commonCssLoader = [\r\n  MiniCssExtractPlugin.loader,\r\n  'css-loader',\r\n  {\r\n    // 还需要再package.json中定义browserslist\r\n    loader: 'postcss-loader',\r\n    options: {\r\n      ident: 'postcss',\r\n      plugins: () => [require('postcss-preset-env')()]\r\n    }\r\n  }\r\n]\r\n\r\nmodule.exports = {\r\n  entry: './src/js/index.js',\r\n  output: {\r\n    filename: 'js/built.js',\r\n    path: resolve(__dirname, 'build')\r\n  },\r\n  module: {\r\n    rules: [\r\n      {\r\n        // 处理CSS\r\n        test: /\\.css$/,\r\n        use: [...commonCssLoader]\r\n      },\r\n      {\r\n        test: /\\.less$/,\r\n        use: [...commonCssLoader, 'less-loader']\r\n      },\r\n      {\r\n        // 进行Eslint检查\r\n        test: /\\.js$/,\r\n        // 排除其他文件\r\n        exclude: /node_modules/,\r\n        // 优先执行\r\n        enforce: 'pre',\r\n        loader: 'eslint-loader',\r\n        options: {\r\n          // 设置自动修复\r\n          fix: true\r\n        }\r\n      },\r\n      {\r\n        // 进行js兼容性的处理\r\n        test: /\\.js$/,\r\n        exclude: /node_modules/,\r\n        loader: 'babel-loader',\r\n        options: {\r\n          presets: [\r\n            ['@babel/preset-env',\r\n              {\r\n                useBuiltIns: 'usage',\r\n                corejs: { version: 3 },\r\n                targets: {\r\n                  chrome: '60',\r\n                  firefox: '50'\r\n                }\r\n              }\r\n            ]\r\n          ]\r\n        }\r\n      },\r\n      {\r\n        // 打包图片资源\r\n        test: /\\.(jpg|png|gif)/,\r\n        loader: 'url-loader',\r\n        options: {\r\n          limit: 8 * 1024,\r\n          name: '[hash:10].[ext]',\r\n          outputPath: 'imgs',\r\n          esModule: false\r\n        }\r\n      },\r\n      {\r\n        // 处理HTML中的图片资源\r\n        test: /\\.html$/,\r\n        loader: 'html-loader'\r\n      },\r\n      {\r\n        // 处理其他资源\r\n        exclude: /\\.(js|css|less|html|jpg|png|gif)/,\r\n        loader: 'file-loader',\r\n        options: {\r\n          outputPath: 'media'\r\n        }\r\n      }\r\n    ]\r\n  },\r\n  plugins: [\r\n    new MiniCssExtractPlugin({\r\n      filename: 'css/built.css'\r\n    }),\r\n    new OptimizeCssAssetsWebpackPlugin(),\r\n    new HtmlWebpackPlugin({\r\n      template: './src/index.html',\r\n      minify: {\r\n        collapseWhitespace: true,\r\n        removeComments: true\r\n      }\r\n    })\r\n  ],\r\n  mode: \"production\"\r\n}\r\n```\r\n\r\n## 使用HMR\r\n### 什么是HMR？\r\n>HMR可以理解为模块热替换，所谓的模块热替换指的是一个模块重新发生变化，只会重新打包这一个模块，而不是打包所有的模块，这可以极大的提升构建速度。\r\n\r\n### 开启HMR\r\n>只需在devServer中开启hot为true即可。\r\n\r\n```js\r\ndevServer: {\r\n    contentBase: resolve(__dirname,'build'),\r\n    compress: true,\r\n    port: 3000,\r\n    open: true,\r\n    // 开启HMR功能\r\n    hot: true\r\n  }\r\n```\r\n\r\n### 哪些文件支持HMR，哪些文件不支持HMR？\r\n#### 支持HMR的文件\r\n>样式文件（CSS文件）可以使用HMR功能，因为style-loader内部实现了。\r\n\r\n#### 不支持HMR的文件\r\n* HTML文件：HTML文件默认不能使用HMR功能，并且设置了HMR会使得HTML的热更新失效，如果要解决这个热更新的问题，需要修改entry入口。\r\n\r\n```js\r\nentry: ['./src/index.js','./src/index.html']\r\n```\r\n\r\n* JS文件：默认不能使用HMR功能的，如果想要使用HMR功能，需要添加支持HMR功能的代码。\r\n\r\n>下面我们在入口文件中来检测print.js这个文件的变化，只有这个文件发生了变化的时候，才会热加载这个模块，并且只加载这个模块。\r\n\r\n```js\r\nif (module.hot) {\r\n  module.hot.accept('./print.js',function() {\r\n    // 一旦print.js这个文件发生了变化，会执行下面的函数\r\n    print();\r\n  })\r\n}\r\n```\r\n\r\n>注意：上面的这段代码是添加到入口文件中的。"
    },
    {
      "id": "/Webpack中处理Eslint、处理JS兼容性、压缩JS与HTML",
      "metadata": {
        "permalink": "/blog/Webpack中处理Eslint、处理JS兼容性、压缩JS与HTML",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Webpack中处理Eslint、处理JS兼容性、压缩JS与HTML.md",
        "source": "@site/blog\\Webpack中处理Eslint、处理JS兼容性、压缩JS与HTML.md",
        "title": "Webpack中处理Eslint、处理JS兼容性、压缩JS与HTML",
        "description": "一、引入Eslint",
        "date": "2021-12-01T00:00:00.000Z",
        "formattedDate": "2021年12月1日",
        "tags": [
          {
            "label": "Webpack",
            "permalink": "/blog/tags/webpack"
          }
        ],
        "readingTime": 2.615,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Webpack中处理Eslint、处理JS兼容性、压缩JS与HTML",
          "date": "2021-12-01T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Webpack",
          "tags": [
            "Webpack"
          ]
        },
        "prevItem": {
          "title": "Webpack中生产环境的基本配置与HMR的使用",
          "permalink": "/blog/Webpack中生产环境的基本配置与HMR的使用"
        },
        "nextItem": {
          "title": "Webpack引入dev-server实现自动编译运行并搭建基本的开发环境与CSS处理",
          "permalink": "/blog/Webpack引入dev-server实现自动编译运行并搭建基本的开发环境与CSS处理"
        }
      },
      "content": "## 一、引入Eslint\r\n1. 安装相关工具包\r\n\r\n```js\r\nnpm install eslint eslint-loader eslint-config-airbnb-base eslint-plugin-import\r\n```\r\n\r\n2. loader配置的核心写法\r\n\r\n```js\r\nmodule: {\r\n    rules: [\r\n      {\r\n        test: /\\.js$/,\r\n        exclude: /node_modules/,\r\n        loader: 'eslint-loader',\r\n        options: {\r\n          // 自动修复\r\n          fix: true\r\n        }\r\n      }\r\n    ]\r\n  }\r\n```\r\n\r\n3. 在package.json中引入下面的配置\r\n\r\n```js\r\n  \"eslintConfig\": {\r\n    \"extends\": \"airbnb-base\"\r\n  }\r\n```\r\n\r\n4. 如果想要忽略某些语句，可以在语句的上方通过下面的注释来实现。\r\n\r\n```js\r\n// eslint-disable-next-line\r\n```\r\n\r\n## 二、JS兼容性处理\r\n### 方式1：基本兼容处理（缺点：并不能完全兼容新特性）\r\n1. 安装相关工具包\r\n\r\n```js\r\nnpm install babel-loader @babel/preset-env @babel/core\r\n```\r\n\r\n2. 配置核心module\r\n\r\n```js\r\nmodule: {\r\n    rules: [\r\n      {\r\n        test: /\\.js$/,\r\n        exclude: /node_modules/,\r\n        loader: 'babel-loader',\r\n        options: {\r\n          presets: ['@babel/preset-env']\r\n        }\r\n      }\r\n    ]\r\n  }\r\n```\r\n\r\n>上面提到的方法只能解决基础的兼容性问题，却不能解决类似于Promise等ES6语法的兼容性问题，如果想要实现全部的兼容可以通过下面的方法。\r\n\r\n### 方式2：全部兼容处理（缺点：占用内存大）\r\n\r\n1. 安装babel/polyfill\r\n\r\n```shell\r\nnpm i @babel/polyfill@7.8.3\r\n```\r\n\r\n2. 无需进行配置，只需在需要进行兼容处理的js文件中进行引入即可。\r\n\r\n```js\r\nimport '@babel/polyfill';\r\n```\r\n\r\n### 方式3：按需处理（推荐方式1+3）\r\n1. 安装相关模块\r\n\r\n```js\r\nnpm i core-js@3.6.4\r\n```\r\n\r\n2. 核心webpack配置文件（重点看module部分）\r\n\r\n```js\r\nconst { resolve } = require('path');\r\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\r\n\r\nmodule.exports = {\r\n  entry: './src/js/index.js',\r\n  output: {\r\n    filename: 'js/built.js',\r\n    path: resolve(__dirname, 'build')\r\n  },\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.js$/,\r\n        exclude: /node_modules/,\r\n        loader: 'babel-loader',\r\n        options: {\r\n          presets: [\r\n            ['@babel/preset-env',\r\n              {\r\n                // 按需加载\r\n                useBuiltIns: 'usage',\r\n                corejs: {\r\n                  version: 3\r\n                },\r\n                // 指定兼容性做到哪个版本的浏览器\r\n                targets: {\r\n                  chrome: \"60\",\r\n                  firefox: \"60\",\r\n                  ie: \"9\",\r\n                  safari: \"10\",\r\n                  edge: \"17\"\r\n                }\r\n              }]\r\n          ]\r\n        }\r\n      }\r\n    ]\r\n  },\r\n  plugins: [\r\n    new HtmlWebpackPlugin({\r\n      template: './src/index.html'\r\n    })\r\n  ],\r\n  mode: 'development'\r\n}\r\n```\r\n\r\n## 三、压缩JS\r\n>只要我们开启了生产环境JS会自动帮我们压缩代码。\r\n\r\n```js\r\nmode: 'production'\r\n```\r\n\r\n## 四、压缩HTML\r\n>如果想要压缩HTML的话，只需在HtmlWebpackPlugin插件中添加如下配置即可。\r\n\r\n```js\r\n  plugins: [\r\n    new HtmlWebpackPlugin({\r\n      template: './src/index.html',\r\n      minify: {\r\n        // 移出空格\r\n        collapseWhitespace: true,\r\n        // 移除注释\r\n        removeComments: true\r\n      }\r\n    })\r\n  ]\r\n```"
    },
    {
      "id": "/Webpack引入dev-server实现自动编译运行并搭建基本的开发环境与CSS处理",
      "metadata": {
        "permalink": "/blog/Webpack引入dev-server实现自动编译运行并搭建基本的开发环境与CSS处理",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Webpack引入dev-server实现自动编译运行并搭建基本的开发环境与CSS处理.md",
        "source": "@site/blog\\Webpack引入dev-server实现自动编译运行并搭建基本的开发环境与CSS处理.md",
        "title": "Webpack引入dev-server实现自动编译运行并搭建基本的开发环境与CSS处理",
        "description": "配置dev-server",
        "date": "2021-11-30T00:00:00.000Z",
        "formattedDate": "2021年11月30日",
        "tags": [
          {
            "label": "Webpack",
            "permalink": "/blog/tags/webpack"
          }
        ],
        "readingTime": 3.8,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Webpack引入dev-server实现自动编译运行并搭建基本的开发环境与CSS处理",
          "date": "2021-11-30T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Webpack",
          "tags": [
            "Webpack"
          ]
        },
        "prevItem": {
          "title": "Webpack中处理Eslint、处理JS兼容性、压缩JS与HTML",
          "permalink": "/blog/Webpack中处理Eslint、处理JS兼容性、压缩JS与HTML"
        },
        "nextItem": {
          "title": "Egg.js中使用富文本编辑器的方法",
          "permalink": "/blog/Egg.js中使用富文本编辑器的方法"
        }
      },
      "content": "## 配置dev-server\r\n### 安装相关包\r\n```shell\r\nnpm i webpack-dev-server@3.10.3\r\n```\r\n\r\n### 增加配置项\r\n\r\n```js\r\n  devServer: {\r\n    contentBase: resolve(__dirname,'build'),\r\n    compress: true,\r\n    port: 3000,\r\n    open: true\r\n  }\r\n```\r\n\r\n>下面我们对配置项进行一一解读。\r\n\r\n* contentBase：指定服务器的启动路径。\r\n* compress：是否进行压缩。\r\n* port：服务器的启动端口号。\r\n* open: 是否默认打开浏览器。\r\n\r\n>进行完上面的配置后，我们便可以实现在源文件中编写代码，自动编译打包了。\r\n\r\n## 搭建开发环境\r\n>下面的开发环境具有以下几个特点：\r\n\r\n* 能够处理Less资源\r\n* 能够处理CSS资源\r\n* 能够处理图片资源\r\n* 能够处理HTML中的img资源\r\n* 能够处理字体等其他资源\r\n* 能够将打包的文件加入到HTML中。\r\n* 包含devServer\r\n\r\n```js\r\nconst {resolve} = require('path');\r\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\r\n\r\nmodule.exports = {\r\n  entry: './src/index.js',\r\n  output: {\r\n    filename: 'built.js',\r\n    path: resolve(__dirname,'build')\r\n  },\r\n  module: {\r\n    rules: [\r\n      {\r\n        // 处理less资源\r\n        test: /\\.less$/,\r\n        use: ['style-loader','css-loader','less-loader']\r\n      },\r\n      {\r\n        // 处理CSS资源\r\n        test: /\\.css$/,\r\n        use: ['style-loader','css-loader']\r\n      },\r\n      {\r\n        // 处理图片资源\r\n        test: /\\.(jpg|png|gif)$/,\r\n        loader: 'url-loader',\r\n        options: {\r\n          limit: 8 * 1024,\r\n          name: '[hash:10].[ext]',\r\n          // 关闭es6模块\r\n          esModule: false\r\n        }\r\n      },\r\n      {\r\n        // 处理html中的img资源\r\n        test: /\\.html$/,\r\n        loader: 'html-loader'\r\n      },\r\n      {\r\n        // 处理其他资源\r\n        exclude: /\\.(html|js|css|less|jpg|png|gif)/,\r\n        loader: 'file-loader',\r\n        options: {\r\n          name: '[hash:10].[ext]'\r\n        }\r\n      }\r\n    ]\r\n  },\r\n  plugins: [\r\n    new HtmlWebpackPlugin({\r\n      template: './src/index.html'\r\n    })\r\n  ],\r\n  mode: 'development',\r\n  devServer: {\r\n    contentBase: resolve(__dirname,'build'),\r\n    compress: true,\r\n    port: 3000,\r\n    open: true\r\n  }\r\n}\r\n```\r\n\r\n## 将文件打包输出到指定的路径\r\n### built.js\r\n>通过路径拼接的形式。\r\n\r\n```js\r\noutput: {\r\n    filename: 'js/built.js',\r\n    path: resolve(__dirname,'build')\r\n}\r\n```\r\n\r\n### 图片资源\r\n>在options中添加outPath配置项\r\n\r\n```js\r\n{\r\n    // 处理图片资源\r\n    test: /\\.(jpg|png|gif)$/,\r\n    loader: 'url-loader',\r\n    options: {\r\n      limit: 8 * 1024,\r\n      name: '[hash:10].[ext]',\r\n      // 关闭es6模块\r\n      esModule: false,\r\n      outputPath: 'imgs'\r\n    }\r\n  }\r\n```\r\n\r\n## 提取多个CSS文件为单独文件\r\n>之所以要提取CSS文件为单独文件，是因为webpack在打包的过程中默认将CSS代码写入到JS文件中了，所以我们希望的是CSS打包后变成单独的文件。\r\n\r\n* 核心配置文件\r\n\r\n```js\r\nconst { resolve } = require('path');\r\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\r\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\r\n\r\nmodule.exports = {\r\n  entry: './src/js/index.js',\r\n  output: {\r\n    filename: 'js/built.js',\r\n    path: resolve(__dirname, 'build')\r\n  },\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.css$/,\r\n        use: [\r\n          MiniCssExtractPlugin.loader,\r\n          'css-loader'\r\n        ]\r\n      }\r\n    ]\r\n  },\r\n  plugins: [\r\n    new HtmlWebpackPlugin({\r\n      template: './src/index.html'\r\n    }),\r\n    new MiniCssExtractPlugin({\r\n      filename: 'css/built.css'\r\n    })\r\n  ],\r\n  mode: 'development'\r\n}\r\n```\r\n\r\n## CSS兼容性处理\r\n1. 安装指定插件\r\n\r\n```shell\r\nnpm i postcss-loader@3.0.0 postcss-preset-env@6.7.0 -D\r\n```\r\n\r\n2. 在package.json中添加下面的配置\r\n\r\n```js\r\n\"browserslist\": {\r\n    \"development\": [\r\n      \"last 1 chrome version\",\r\n      \"last 1 firefox version\",\r\n      \"last 1 safari version\"\r\n    ],\r\n    \"production\": [\r\n      \">0.2%\",\r\n      \"not dead\",\r\n      \"not op_mini all\"\r\n    ]\r\n  }\r\n```\r\n\r\n3. webpack配置文件\r\n\r\n```js\r\nconst { resolve } = require('path');\r\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\r\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\r\n\r\n// 设置nodejs环境变量\r\nprocess.env.NODE_ENV = 'development';\r\n\r\nmodule.exports = {\r\n  entry: './src/js/index.js',\r\n  output: {\r\n    filename: 'js/built.js',\r\n    path: resolve(__dirname, 'build')\r\n  },\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.css$/,\r\n        use: [\r\n          MiniCssExtractPlugin.loader,\r\n          'css-loader',\r\n          {\r\n            loader: 'postcss-loader',\r\n            options: {\r\n              ident: 'postcss',\r\n              plugins: () => [\r\n                require('postcss-preset-env')()\r\n              ]\r\n            }\r\n          }\r\n        ]\r\n      }\r\n    ]\r\n  },\r\n  plugins: [\r\n    new HtmlWebpackPlugin({\r\n      template: './src/index.html'\r\n    }),\r\n    new MiniCssExtractPlugin({\r\n      filename: 'css/built.css'\r\n    })\r\n  ],\r\n  mode: 'development'\r\n}\r\n```\r\n\r\n## 压缩CSS\r\n1. 安装指定版本的插件\r\n\r\n```shell\r\nnpm i optimize-css-assets-webpack-plugin@5.0.3\r\n```\r\n\r\n2. 引入插件\r\n\r\n```js\r\nconst OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin');\r\n```\r\n\r\n3. 调用插件\r\n\r\n```js\r\nplugins: [\r\n    new HtmlWebpackPlugin({\r\n      template: './src/index.html'\r\n    }),\r\n    new MiniCssExtractPlugin({\r\n      filename: 'css/built.css'\r\n    }),\r\n    new OptimizeCssAssetsWebpackPlugin()\r\n  ]\r\n```"
    },
    {
      "id": "/Egg.js中使用富文本编辑器的方法",
      "metadata": {
        "permalink": "/blog/Egg.js中使用富文本编辑器的方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Egg.js中使用富文本编辑器的方法.md",
        "source": "@site/blog\\Egg.js中使用富文本编辑器的方法.md",
        "title": "Egg.js中使用富文本编辑器的方法",
        "description": "通过wysiwyg-editor实现",
        "date": "2021-11-29T00:00:00.000Z",
        "formattedDate": "2021年11月29日",
        "tags": [
          {
            "label": "Egg.js",
            "permalink": "/blog/tags/egg-js"
          }
        ],
        "readingTime": 2.345,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Egg.js中使用富文本编辑器的方法",
          "date": "2021-11-29T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Egg.js",
          "tags": [
            "Egg.js"
          ]
        },
        "prevItem": {
          "title": "Webpack引入dev-server实现自动编译运行并搭建基本的开发环境与CSS处理",
          "permalink": "/blog/Webpack引入dev-server实现自动编译运行并搭建基本的开发环境与CSS处理"
        },
        "nextItem": {
          "title": "LeetCode——最长回文串（Set + 打牌思路）",
          "permalink": "/blog/LeetCode——最长回文串（Set + 打牌思路）"
        }
      },
      "content": "## 通过wysiwyg-editor实现\r\n>wysiwyg-editor的主要参考文档包括下面两个：\r\n\r\n* Github官方文档：https://github.com/froala/wysiwyg-editor\r\n* 配置参考文档：https://froala.com/wysiwyg-editor/docs/options\r\n\r\n\r\n### 方式一：通过CDN引入\r\n>在需要使用富文本编辑器的页面，通过下面的cdn进行引入。\r\n\r\n```js\r\n<link href=\"https://cdn.jsdelivr.net/npm/froala-editor@latest/css/froala_editor.pkgd.min.css\" rel=\"stylesheet\" type=\"text/css\" />\r\n\r\n<textarea></textarea>\r\n\r\n<script type=\"text/javascript\" src=\"https://cdn.jsdelivr.net/npm/froala-editor@latest/js/froala_editor.pkgd.min.js\"></script>\r\n\r\n<script>\r\n  new FroalaEditor('textarea');\r\n</script>\r\n```\r\n\r\n>给富文本编辑器指定高度\r\n\r\n```js\r\n  <script>\r\n    new FroalaEditor('#content',{\r\n      height: 200\r\n    });\r\n  </script>\r\n```\r\n\r\n>给富文本编辑器指定语言。\r\n\r\n```js\r\n<link href=\"/public/wysiwyg/css/froala_editor.pkgd.min.css\" rel=\"stylesheet\" type=\"text/css\" /> \r\n<script type=\"text/javascript\" src=\"/public/wysiwyg/js/froala_editor.pkgd.min.js\"></script>\r\n<script type=\"text/javascript\" src=\"/public/wysiwyg/js/languages/zh_cn.js\"></script>\r\n  <script>\r\n    new FroalaEditor('#content',{\r\n      height: 200,\r\n      language: \"zh_cn\"\r\n    });\r\n  </script>\r\n```\r\n\r\n>去掉富文本编辑器的版权。\r\n\r\n```js\r\n  <script>\r\n    new FroalaEditor('#content',{\r\n      height: 200,\r\n      language: \"zh_cn\",\r\n      attribution: false\r\n    });\r\n  </script>\r\n```\r\n\r\n### 方式二：通过Github将源码下载下来后手动引入。\r\n\r\n## 富文本编辑器实现图片的上传\r\n\r\n### Egg.js中配置针对一些地址关闭CSRF安全验证\r\n>只需在config.default.js中进行下面的配置即可，返回true的地址是不会进行CSRF校验的。\r\n\r\n```js\r\n  config.security = {\r\n    csrf: {\r\n      ignore: ctx => {\r\n        if (ctx.request.url === `/${config.adminPath}/product/doUpload`) {\r\n          return true;\r\n        } else {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n  }\r\n```\r\n\r\n### 实现上传到富文本编辑器即上传到COS上\r\n1. 在静态文件上添加imageUploadURL属性\r\n\r\n```js\r\n    new FroalaEditor('#content',{\r\n      height: 200,\r\n      language: \"zh_cn\",\r\n      attribution: false,\r\n      imageUploadURL: `/<%=adminPath%>/product/doUpload`\r\n    });\r\n```\r\n\r\n2. 关闭CSRF验证。\r\n\r\n3. 控制器中实现如下逻辑，需要注意的是需要给编辑器返回指定类型的json对象。\r\n\r\n```js\r\nasync doUpload() {\r\n\r\n    const { ctx } = this;\r\n    const body = ctx.request.body;\r\n    const file = ctx.request.files[0];\r\n    if (file) {\r\n      var source = fs.createReadStream(file.filepath);\r\n      var filename = this.ctx.service.tools.getCosUploadFile(file.filename);\r\n\r\n      await this.ctx.service.tools.uploadCos(filename,source);\r\n    }\r\n\r\n    ctx.body = {link: this.config.cosUrl + \"/\" + filename};\r\n\r\n  }\r\n```\r\n\r\n## 总结\r\n>通过上文介绍的插件来实现富文本编辑器，可以让我们站在巨人的肩膀上继续前进，本文只是给出了基本的使用方法，更加详细的配置文件和配置信息请查看上文的两个在线地址。"
    },
    {
      "id": "/LeetCode——最长回文串（Set + 打牌思路）",
      "metadata": {
        "permalink": "/blog/LeetCode——最长回文串（Set + 打牌思路）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——最长回文串（Set + 打牌思路）.md",
        "source": "@site/blog\\LeetCode——最长回文串（Set + 打牌思路）.md",
        "title": "LeetCode——最长回文串（Set + 打牌思路）",
        "description": "题目描述",
        "date": "2021-11-28T00:00:00.000Z",
        "formattedDate": "2021年11月28日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 2.38,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——最长回文串（Set + 打牌思路）",
          "date": "2021-11-28T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "Egg.js中使用富文本编辑器的方法",
          "permalink": "/blog/Egg.js中使用富文本编辑器的方法"
        },
        "nextItem": {
          "title": "Egg.js上传图片到对象存储COS并按照日期存储图片",
          "permalink": "/blog/Egg.js上传图片到对象存储COS并按照日期存储图片"
        }
      },
      "content": "## 题目描述\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/67d3f6fdf5e4fad1a0ea1d72114492c5.png)\r\n\r\n## 解题思路\r\n>这道题和最长回文子串有本质不同，这道题相当于给我们一个字符串，让我们根据这个字符串来自己组合最长回文串，我第一次尝试解决这个问题的时候，采用的是Map的思路，但是需要考虑很多种情况，后来看到使用Set+打牌思路的题解，感觉甚是巧妙，特此分享给大家。\r\n\r\n1. 创建一个Set。\r\n2. 遍历每一个字符，如果这个字符出现在了集合中，则将这个字符从集合中删去，并且给sum+2，表示这个字符出现过两次，如果这个字符没有出现在集合中，则将其添加到集合中去。\r\n3. 最后判断集合中是否还有元素，有则给结果+1，没有则返回结果。\r\n\r\n```js\r\nvar longestPalindrome = function(s) {\r\n  // 通过Set实现打牌的思路\r\n  const set = new Set();\r\n  let sum = 0;\r\n  for (let v of s.split('')) {\r\n    if (set.has(v)) {\r\n      sum = sum + 2;\r\n      set.delete(v);\r\n    } else {\r\n      set.add(v);\r\n    }\r\n  }\r\n  sum = set.size ? sum + 1 : sum;\r\n  return sum;\r\n};\r\n```\r\n\r\n## 题目反思\r\n>解决一个题目的方法往往不止一种，我们可以首先使用自己的思路来解决，解决后和别人较为优秀的题解进行对比，学习别人优秀的思路，本题就是一个很好的例子，通过Set结合打牌的思路确实较为精简，也方便我们去记忆，所谓的打牌思路，就是我们每抽到一张牌，如果手中已经有了和这张牌一样的牌，就将这两张牌打出去，放到题目中，也就是sum+2,没有这张牌则放到手中，最后如果手中还有牌就将结果+1。\r\n\r\n* 集合Set的常用API包括size、delete、add等需要我们掌握。"
    },
    {
      "id": "/Egg.js上传图片到对象存储COS并按照日期存储图片",
      "metadata": {
        "permalink": "/blog/Egg.js上传图片到对象存储COS并按照日期存储图片",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Egg.js上传图片到对象存储COS并按照日期存储图片.md",
        "source": "@site/blog\\Egg.js上传图片到对象存储COS并按照日期存储图片.md",
        "title": "Egg.js上传图片到对象存储COS并按照日期存储图片",
        "description": "上传到COS上的参考文档可以参考官方的文档：https://cloud.tencent.com/document/product/436/8629#.E4.B8.8A.E4.BC.A0.E5.AF.B9.E8.B1.A1",
        "date": "2021-11-27T00:00:00.000Z",
        "formattedDate": "2021年11月27日",
        "tags": [
          {
            "label": "Egg.js",
            "permalink": "/blog/tags/egg-js"
          }
        ],
        "readingTime": 2.685,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Egg.js上传图片到对象存储COS并按照日期存储图片",
          "date": "2021-11-27T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Egg.js",
          "tags": [
            "Egg.js"
          ]
        },
        "prevItem": {
          "title": "LeetCode——最长回文串（Set + 打牌思路）",
          "permalink": "/blog/LeetCode——最长回文串（Set + 打牌思路）"
        },
        "nextItem": {
          "title": "高级前端可能都不知道的checkbox传递value问题",
          "permalink": "/blog/高级前端可能都不知道的checkbox传递value问题"
        }
      },
      "content": ">上传到COS上的参考文档可以参考官方的文档：https://cloud.tencent.com/document/product/436/8629#.E4.B8.8A.E4.BC.A0.E5.AF.B9.E8.B1.A1\r\n\r\n## 上传图片到腾讯云的COS上\r\n1. 控制器中写法\r\n\r\n```js\r\nasync doAdd() {\r\n\r\n    const { ctx } = this;\r\n    const body = ctx.request.body;\r\n    const file = ctx.request.files[0];\r\n    const source = fs.createReadStream(file.filepath);\r\n    if (file) {\r\n      await this.ctx.service.tools.uploadCos(file.filename,source);\r\n    }\r\n    ctx.body = {\r\n      body, file\r\n    }\r\n  }\r\n  \r\n```\r\n\r\n2. 在service中定义好要上传的函数\r\n\r\n```js\r\nasync uploadCos(filename, body) {\r\n    var cos = new COS({\r\n      SecretId: 'xxx',\r\n      SecretKey: 'xxx'\r\n    });\r\n    return new Promise((resolve,reject) => {\r\n      cos.putObject({\r\n        Bucket: 'eggshop-1301559367', /* 必须 */\r\n        Region: 'ap-beijing',    /* 必须 */\r\n        Key: filename,              /* 必须 */\r\n        StorageClass: 'STANDARD',\r\n        Body: body, // 上传文件对象\r\n        onProgress: function (progressData) {\r\n          console.log(JSON.stringify(progressData));\r\n        }\r\n      }, function (err, data) {\r\n        // console.log(err || data);\r\n        if (!err) {\r\n          resolve(data);\r\n        } else {\r\n          reject(err);\r\n        }\r\n      });\r\n    })\r\n  }\r\n```\r\n\r\n## 上传文件根据时间进行文件夹分类\r\n1. 在service中定义好上传到COS上的文件路径\r\n\r\n```js\r\n  // 上传到COS上的路径格式\r\n  getCosUploadFile(filename) {\r\n    // 获取当前的日期\r\n    let dir = sd.format(new Date(), 'YYYYMMDD');\r\n    // 生成文件名称\r\n    let unix = this.getUnixTime();\r\n    let saveDir = dir + \"/\" + unix + path.extname(filename)\r\n    return saveDir;\r\n  }\r\n```\r\n\r\n2. 在service中定义好上传到COS上的函数\r\n\r\n```js\r\n  async uploadCos(filename, body) {\r\n    var cos = new COS({\r\n      SecretId: 'xxx',\r\n      SecretKey: 'xxx'\r\n    });\r\n    return new Promise((resolve,reject) => {\r\n      cos.putObject({\r\n        Bucket: 'eggshop-1301559367', /* 必须 */\r\n        Region: 'ap-beijing',    /* 必须 */\r\n        Key: filename,              /* 必须 */\r\n        StorageClass: 'STANDARD',\r\n        Body: body, // 上传文件对象\r\n        onProgress: function (progressData) {\r\n          console.log(JSON.stringify(progressData));\r\n        }\r\n      }, function (err, data) {\r\n        // console.log(err || data);\r\n        if (!err) {\r\n          resolve(data);\r\n        } else {\r\n          reject(err);\r\n        }\r\n      });\r\n    })\r\n  }\r\n```\r\n\r\n3. 在控制器中的写法\r\n\r\n```js\r\n  async doAdd() {\r\n\r\n    const { ctx } = this;\r\n    const body = ctx.request.body;\r\n    const file = ctx.request.files[0];\r\n    if (file) {\r\n      const source = fs.createReadStream(file.filepath);\r\n      let filename = this.ctx.service.tools.getCosUploadFile(file.filename);\r\n\r\n      await this.ctx.service.tools.uploadCos(filename,source);\r\n    }\r\n    ctx.body = {\r\n      body, file\r\n    }\r\n  }\r\n```\r\n\r\n>注意：如果上传到COS上的图片路径中包含小数点，是因为获取时间戳的时间需要向上进行取整。\r\n\r\n```js\r\ngetUnixTime() {\r\n    let obj = new Date();\r\n    return Math.ceil(obj.getTime() / 1000);\r\n}\r\n```\r\n\r\n## 将本地数据库上传到云上\r\n1. 将数据库的结构和数据存储到本地\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/c10868130b35c81c15897bd4914eb5a8.png)\r\n\r\n2. 建立一个云数据库并通过Navicat进行连接后，通过运行SQL文件导入我们第一步创建的SQL文件。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/2b619ed4d209602fbfcd0e9dab3d86d8.png)\r\n\r\n3. 修改数据库配置\r\n\r\n```js\r\n  config.sequelize = {\r\n    dialect: 'mysql',\r\n    host: 'rm-2zenx6363vhj8129ryo.mysql.rds.aliyuncs.com',\r\n    port: 3306,\r\n    username: \"xxx\",\r\n    password: \"xxx\",\r\n    database: 'eggshop',\r\n  };\r\n```"
    },
    {
      "id": "/高级前端可能都不知道的checkbox传递value问题",
      "metadata": {
        "permalink": "/blog/高级前端可能都不知道的checkbox传递value问题",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/高级前端可能都不知道的checkbox传递value问题.md",
        "source": "@site/blog\\高级前端可能都不知道的checkbox传递value问题.md",
        "title": "高级前端可能都不知道的checkbox传递value问题",
        "description": "问题描述",
        "date": "2021-11-26T00:00:00.000Z",
        "formattedDate": "2021年11月26日",
        "tags": [
          {
            "label": "HTML",
            "permalink": "/blog/tags/html"
          }
        ],
        "readingTime": 2.135,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "高级前端可能都不知道的checkbox传递value问题",
          "date": "2021-11-26T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "HTML",
          "tags": [
            "HTML"
          ]
        },
        "prevItem": {
          "title": "Egg.js上传图片到对象存储COS并按照日期存储图片",
          "permalink": "/blog/Egg.js上传图片到对象存储COS并按照日期存储图片"
        },
        "nextItem": {
          "title": "Egg.js中实现单文件上传、多文件上传、按照日期存储",
          "permalink": "/blog/Egg.js中实现单文件上传、多文件上传、按照日期存储"
        }
      },
      "content": "## 问题描述\r\n>在博主使用Egg.js写一个管理系统的时候，在静态页面中有一个表单，表单中含有两个checkbox，但是博主发现，在通过这个表单进行post数据的时候，如果checkbox没有选中是不会传递value的，这令我很震惊，当然也让我付出了将近两个小时的努力，因此特地分享出来，为后续遇到这个问题的兄弟填下坑。\r\n\r\n### 未修改前代码\r\n\r\n```html\r\n<input type=\"checkbox\" value=\"1\" name=\"isBest\"  <%if(product.isBest == 1){%>checked<%}%>  id=\"is_best\"> <label for=\"is_best\">精品</label>  &nbsp;&nbsp;\r\n<input type=\"checkbox\" value=\"1\" name=\"isHot\"  <%if(product.isHot == 1){%>checked<%}%>  id=\"is_hot\"> <label for=\"is_hot\">热销</label> \r\n```\r\n\r\n## 解决办法\r\n>通过设置两个隐藏的input表单来解决这个问题，因为如果这两个checkbox的value是0的话，隐藏的表单会代替这两个表达进行post数据，当我第一次看到这个方法的时候，我感觉很妙啊。\r\n\r\n```html\r\n<input type=\"hidden\" name=\"isBest\" value=\"0\">\r\n<input type=\"hidden\" name=\"isHot\" value=\"0\">\r\n<input type=\"checkbox\" value=\"1\" name=\"isBest\"  <%if(product.isBest == 1){%>checked<%}%>  id=\"is_best\"> <label for=\"is_best\">精品</label>  &nbsp;&nbsp;\r\n<input type=\"checkbox\" value=\"1\" name=\"isHot\"  <%if(product.isHot == 1){%>checked<%}%>  id=\"is_hot\"> <label for=\"is_hot\">热销</label> \r\n```\r\n\r\n## 注意事项\r\n* 一定要将隐藏表单放到前面，你想啊，首先默认是0，下边的数据如果是0，则就传递上边的数据，如果下边的不是0，下边的会覆盖上面的数据。\r\n* 表单中含有checkbox的时候，一定要注意这个问题，一旦不注意极有可能带来不可预知的Bug。\r\n* 尽量避免将checkbox的value设置为0，可以考虑设置其他的值，如果无法避免，可以考虑使用隐藏表单的方式来解决这个问题。\r\n\r\n## 参考文档\r\n* [checkbo不选中传值](https://www.cnblogs.com/hsd1727728211/p/6516129.html)"
    },
    {
      "id": "/Egg.js中实现单文件上传、多文件上传、按照日期存储",
      "metadata": {
        "permalink": "/blog/Egg.js中实现单文件上传、多文件上传、按照日期存储",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Egg.js中实现单文件上传、多文件上传、按照日期存储.md",
        "source": "@site/blog\\Egg.js中实现单文件上传、多文件上传、按照日期存储.md",
        "title": "Egg.js中实现单文件上传、多文件上传、按照日期存储",
        "description": "上传功能的实现",
        "date": "2021-11-25T00:00:00.000Z",
        "formattedDate": "2021年11月25日",
        "tags": [
          {
            "label": "Egg.js",
            "permalink": "/blog/tags/egg-js"
          }
        ],
        "readingTime": 3.315,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Egg.js中实现单文件上传、多文件上传、按照日期存储",
          "date": "2021-11-25T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Egg.js",
          "tags": [
            "Egg.js"
          ]
        },
        "prevItem": {
          "title": "高级前端可能都不知道的checkbox传递value问题",
          "permalink": "/blog/高级前端可能都不知道的checkbox传递value问题"
        },
        "nextItem": {
          "title": "二刷--从上到下打印二叉树 III（层序递归+反转）",
          "permalink": "/blog/二刷--从上到下打印二叉树 III（层序递归+反转）"
        }
      },
      "content": "## 上传功能的实现\r\n1. 将上传表单的类型置为file.\r\n\r\n>注意：name属性不可缺少。\r\n```js\r\n<li>菜品图片：<input type=\"file\" name=\"picUrl\" /></li>\r\n```\r\n\r\n2. 配置文件上传的模式\r\n\r\n```js\r\n  // 配置文件上传的模式\r\n  config.multipart = {\r\n    mode: 'file'\r\n  };\r\n```\r\n\r\n3. 配置csrf属性\r\n\r\n>enctype属性不可缺少。\r\n\r\n```js\r\n <form action=\"/<%=adminPath%>/product/doAdd?_csrf=<%=csrf%>\" method=\"post\" enctype=\"multipart/form-data\">\r\n```\r\n\r\n4. 将路由设置为post\r\n\r\n```js\r\nrouter.post(`/${config.adminPath}/product/doAdd`,controller.admin.product.doAdd);\r\n```\r\n\r\n5. 控制器中读取file\r\n\r\n```js\r\n  async doAdd() {\r\n    const {ctx} = this;\r\n    const body = ctx.request.body;\r\n    const file = ctx.request.files[0];\r\n    ctx.body = {\r\n      body: body,\r\n      file: file\r\n    }\r\n  }\r\n```\r\n\r\n## 将上传的文件保存在指定的位置\r\n1. 安装工具包\r\n\r\n```shell\r\nnpm i mz mz-modules --save\r\n```\r\n\r\n2. 在控制器中引入相关工具包\r\n\r\n```js\r\nconst path = require('path');\r\nconst fs = require('mz/fs');\r\nconst pump = require('mz-modules/pump');\r\n```\r\n\r\n3. 创建上传到哪个文件夹，这个文件夹要提前创建好(public/upload)\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/572770db0a1536688569ed2028bd9e36.png)\r\n\r\n4. 控制器读写逻辑的实现\r\n\r\n```js\r\nasync doAdd() {\r\n    const {ctx} = this;\r\n    const body = ctx.request.body;\r\n    const file = ctx.request.files[0];\r\n    // 获取文件名称\r\n    const filename = file.filename;\r\n    const targetPath = path.join('app/public/upload',filename);\r\n    // 读取文件\r\n    const source = fs.createReadStream(file.filepath);\r\n    // 创建写入流\r\n    const target = fs.createWriteStream(targetPath);\r\n    try {\r\n      await pump(source,target);\r\n    } finally {\r\n      await ctx.cleanupRequestFiles();\r\n    }\r\n    ctx.body = \"写入成功\"\r\n  }\r\n```\r\n\r\n## 实现多文件上传\r\n1. 静态页面设置如下所示：\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/ca9874f559913ea53823ac2fec620ff8.png)\r\n\r\n2. 控制器的核心实现逻辑\r\n\r\n```js\r\n  // 实现多文件上传\r\n  async doAdd() {\r\n    const { ctx } = this;\r\n    const body = ctx.request.body;\r\n    const files = ctx.request.files;\r\n    try {\r\n      for (let file of files) {\r\n        const filename = file.filename;\r\n        const targetPath = path.join('app/public/upload', filename);\r\n        // 读取文件\r\n        const source = fs.createReadStream(file.filepath);\r\n        // 创建写入流\r\n        const target = fs.createWriteStream(targetPath);\r\n        await pump(source,target);\r\n      }\r\n    } finally {\r\n      await ctx.cleanupRequestFiles();\r\n    }\r\n    ctx.body = {\r\n      body, files\r\n    }\r\n  }\r\n```\r\n\r\n## 以日期文件夹进行分类上传图片\r\n>下面是实现的效果：\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/cca8dfed38552006471675037562c088.png)\r\n\r\n1. 在service中引入相关工具包\r\n\r\n```js\r\nconst sd = require('silly-datetime');\r\nconst path = require('path');\r\nconst mkdirp = require('mz-modules/mkdirp');\r\n```\r\n\r\n2. 在配置文件中定义上传的路径\r\n\r\n```js\r\n  // 配置上传图片时的拼接路径\r\n  config.uploadDir = \"app/public/upload\";\r\n```\r\n\r\n3. 在service中定义创建路径和文件夹的函数\r\n\r\n```js\r\n  async getUploadFile(filename) {\r\n    // 获取当前的日期\r\n    let day = sd.format(new Date(),'YYYYMMDD');\r\n    // 创建图片的保存路径\r\n    let dir = path.join(this.config.uploadDir,day);\r\n    await mkdirp(dir);\r\n\r\n    // 生成文件名称\r\n    let unix = this.getUnixTime();\r\n    let saveDir = path.join(dir,unix + path.extname(filename));\r\n    return saveDir;\r\n  }\r\n```\r\n\r\n4. 在控制器中异步调用文件路径\r\n\r\n```js\r\nconst targetPath = await this.ctx.service.tools.getUploadFile(filename);\r\n```\r\n\r\n>下面附录下全部的控制器代码\r\n\r\n```js\r\nasync doAdd() {\r\n    const { ctx } = this;\r\n    const body = ctx.request.body;\r\n    const files = ctx.request.files;\r\n    try {\r\n      for (let file of files) {\r\n        const filename = file.filename;\r\n        // const targetPath = path.join('app/public/upload', filename);\r\n        const targetPath = await this.ctx.service.tools.getUploadFile(filename);\r\n        // 读取文件\r\n        const source = fs.createReadStream(file.filepath);\r\n        // 创建写入流\r\n        const target = fs.createWriteStream(targetPath);\r\n        await pump(source,target);\r\n      }\r\n    } finally {\r\n      await ctx.cleanupRequestFiles();\r\n    }\r\n    ctx.body = {\r\n      body, files\r\n    }\r\n  }\r\n```"
    },
    {
      "id": "/二刷--从上到下打印二叉树 III（层序递归+反转）",
      "metadata": {
        "permalink": "/blog/二刷--从上到下打印二叉树 III（层序递归+反转）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/二刷--从上到下打印二叉树 III（层序递归+反转）.md",
        "source": "@site/blog\\二刷--从上到下打印二叉树 III（层序递归+反转）.md",
        "title": "二刷--从上到下打印二叉树 III（层序递归+反转）",
        "description": "题目描述",
        "date": "2021-11-24T00:00:00.000Z",
        "formattedDate": "2021年11月24日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 2.365,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "二刷--从上到下打印二叉树 III（层序递归+反转）",
          "date": "2021-11-24T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "Egg.js中实现单文件上传、多文件上传、按照日期存储",
          "permalink": "/blog/Egg.js中实现单文件上传、多文件上传、按照日期存储"
        },
        "nextItem": {
          "title": "LeetCode——岛屿的最大面积（DFS）",
          "permalink": "/blog/LeetCode——岛屿的最大面积（DFS）"
        }
      },
      "content": "## 题目描述\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/5e1f819498e2982b7668cb2247102f87.png)\r\n\r\n## 解题思路\r\n### 实现方式一：递归法进行层序遍历然后根据层次的奇偶进行反转\r\n\r\n```js\r\nvar levelOrder = function (root) {\r\n  // 核心思路：二叉树的层序遍历--递归实现\r\n  if (!root) return [];\r\n  let result = [];\r\n\r\n  function levelOrder(root,level) {\r\n    if (!root) return null;\r\n    result[level] = result[level] || [];\r\n\r\n    result[level].push(root.val);\r\n    levelOrder(root.left,level + 1);\r\n    levelOrder(root.right,level + 1);\r\n  }\r\n  levelOrder(root,0);\r\n  for (let i = 0; i < result.length; i++) {\r\n    if (i % 2 != 0) {\r\n      result[i] = result[i].reverse();\r\n    }\r\n  }\r\n  return result;\r\n};\r\n```\r\n\r\n### 方式2：将节点加入数组时判断层次是奇数还是偶数，进而选择是push还是unshift\r\n\r\n```js\r\nvar levelOrder = function (root) {\r\n  // 核心思路：二叉树的层序遍历--递归实现\r\n  if (!root) return [];\r\n  let result = [];\r\n\r\n  function levelOrder(root,level) {\r\n    if (!root) return null;\r\n    result[level] = result[level] || [];\r\n\r\n    if (level % 2 === 0) {\r\n      result[level].push(root.val);\r\n    } else {\r\n      result[level].unshift(root.val);\r\n    }\r\n    levelOrder(root.left,level + 1);\r\n    levelOrder(root.right,level + 1);\r\n  }\r\n  levelOrder(root,0);\r\n  return result;\r\n};\r\n```\r\n\r\n## 题目反思\r\n>本题给我们的经验是，本题是对二叉树的层序遍历的改编题，本质还是想要考查我们对二叉树的层序遍历的熟系程度，二叉树的层序遍历分为迭代法和递归法，本次我们使用的是递归法，但是递归实现的时候，二叉树的同一层是从左到右进行遍历的，我最开始尝试解决这个问题的时候，想的是先判断层次的奇数还是偶数，然后将不同的左右子树投入递归，其实这样是不行的，本质上还是没有理解递归的顺序，上述递归的方式本质上还是先遍历完左子树然后遍历右子树，之所以能够实现层序遍历，是因为在递归的过程中，加入了辅助判断条件层次这一变量，这个题目的解题思路指的我们反复揣摩学习。"
    },
    {
      "id": "/LeetCode——岛屿的最大面积（DFS）",
      "metadata": {
        "permalink": "/blog/LeetCode——岛屿的最大面积（DFS）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——岛屿的最大面积（DFS）.md",
        "source": "@site/blog\\LeetCode——岛屿的最大面积（DFS）.md",
        "title": "LeetCode——岛屿的最大面积（DFS）",
        "description": "题目描述",
        "date": "2021-11-23T00:00:00.000Z",
        "formattedDate": "2021年11月23日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 2.38,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——岛屿的最大面积（DFS）",
          "date": "2021-11-23T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "二刷--从上到下打印二叉树 III（层序递归+反转）",
          "permalink": "/blog/二刷--从上到下打印二叉树 III（层序递归+反转）"
        },
        "nextItem": {
          "title": "Webpack处理CSS、Less、HTML、图片与其他资源的方法",
          "permalink": "/blog/Webpack处理CSS、Less、HTML、图片与其他资源的方法"
        }
      },
      "content": "## 题目描述\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/79da66feffddb420ec05addf146d22d0.png)\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/21f7bc43af376a6faae112df2d420f77.png)\r\n\r\n## 解题思路\r\n>本题的核心解题思路是使用DFS，所谓的DFS就是递归加标记，符合条件的元素遍历过后将其标记为已经遍历过，在本题中我们无需使用哈希表进行标记，只需将遍历过的位置变为0即可。\r\n\r\n1. 定义二维数组的行数，即grid的长度。\r\n2. 定义二维数组的列数，即grid[0]的长度。\r\n3. 二层循环遍历每一个元素，不断更新最大值。\r\n4. 将当前位置和行列数投入DFS函数中，首先进行边界条件的判断，如果不符合则返回0，如果符合则将其标记为0，表示已经遍历过，然后递归上下左右四个方向进行判断。\r\n\r\n```js\r\nvar maxAreaOfIsland = function (grid) {\r\n  // 本题核心是使用DFS 将遍历过的1标记为0\r\n  let row = grid.length;\r\n  let column = grid[0].length;\r\n  // 定义最大面积\r\n  let maxArea = 0;\r\n  // 二层循环遍历每一个元素\r\n  for (let i = 0; i < row; i++) {\r\n    for (let j = 0; j < column; j++) {\r\n      maxArea = Math.max(maxArea, dfs(grid, i, j, row, column));\r\n    }\r\n  }\r\n  function dfs(grid, i, j, row, column) {\r\n    // 边界条件判断\r\n    if (i < 0 || j < 0 || i >= row || j >= column || grid[i][j] === 0) return 0;\r\n    let temp = 1;\r\n    grid[i][j] = 0;\r\n    temp = temp + dfs(grid, i + 1, j, row, column);\r\n    temp = temp + dfs(grid, i - 1, j, row, column);\r\n    temp = temp + dfs(grid, i, j + 1, row, column);\r\n    temp = temp + dfs(grid, i, j - 1, row, column);\r\n    return temp;\r\n  }\r\n  return maxArea;\r\n};\r\n```\r\n\r\n## 题目反思\r\n* DFS是一个重要的编程思想，其中通过DFS能解决的问题非常广泛，也是面试官的宠儿，例如岛屿的最大面积、全排列都是DFS的应用实例，DFS在我看来本质就是递归 + 标记，只要符合上述两个条件即可判断为DFS。"
    },
    {
      "id": "/Webpack处理CSS、Less、HTML、图片与其他资源的方法",
      "metadata": {
        "permalink": "/blog/Webpack处理CSS、Less、HTML、图片与其他资源的方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Webpack处理CSS、Less、HTML、图片与其他资源的方法.md",
        "source": "@site/blog\\Webpack处理CSS、Less、HTML、图片与其他资源的方法.md",
        "title": "Webpack处理CSS、Less、HTML、图片与其他资源的方法",
        "description": "安装指定版本的webpack",
        "date": "2021-11-22T00:00:00.000Z",
        "formattedDate": "2021年11月22日",
        "tags": [
          {
            "label": "Webpack",
            "permalink": "/blog/tags/webpack"
          }
        ],
        "readingTime": 3.635,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Webpack处理CSS、Less、HTML、图片与其他资源的方法",
          "date": "2021-11-22T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Webpack",
          "tags": [
            "Webpack"
          ]
        },
        "prevItem": {
          "title": "LeetCode——岛屿的最大面积（DFS）",
          "permalink": "/blog/LeetCode——岛屿的最大面积（DFS）"
        },
        "nextItem": {
          "title": "在Egg.js中实现RBAC权限管理",
          "permalink": "/blog/在Egg.js中实现RBAC权限管理"
        }
      },
      "content": "## 安装指定版本的webpack\r\n```shell\r\nnpm i webpack@4.41.6 webpack-cli@3.3.11 -D\r\n```\r\n\r\n## 安装指定版本的loader\r\n```shell\r\nnpm i css-loader@3.4.2 style-loader@1.1.3 -D\r\n```\r\n\r\n## 配置Webpack使得JS能够处理CSS样式\r\n>下面是配置文件webpack.config.js\r\n\r\n```js\r\n// 引入用于拼接绝对路径的方法\r\n\r\nconst { resolve } = require('path');\r\n\r\nmodule.exports = {\r\n  // 入口起点\r\n  entry: './src/index.js',\r\n  // 输出\r\n  output: {\r\n    // 输出文件名\r\n    filename: 'built.js',\r\n    // 输出路径\r\n    path: resolve(__dirname,'build')\r\n  },\r\n  module: {\r\n    rules: [\r\n      {\r\n        // 匹配哪些文件\r\n        test: /\\.css$/,\r\n        use: [\r\n          // use数组中loader执行顺序是从下到上，依次执行\r\n          // 创建style标签，将JS中的样式资源插入其中，添加到header标签中\r\n          'style-loader',\r\n          'css-loader'\r\n        ]\r\n      }\r\n    ]\r\n  },\r\n  // plugins的配置\r\n  plugins: [\r\n\r\n  ],\r\n  mode: 'development'\r\n}\r\n```\r\n>执行上述的配置命令只需在根目录输入webpack回车即可将打包后的文件输出到指定的路径。\r\n\r\n## 配置Webpack能够处理less样式\r\n>只需在webpack的配置文件中的rules下面添加下面的规则即可，需要安装下面的工具包。\r\n\r\n```shell\r\nnpm i less-loader@5.0.0 less@3.11.1 -D\r\n```\r\n\r\n```js\r\n{\r\n    // 匹配哪些文件\r\n    test: /\\.less$/,\r\n    use: [\r\n      'style-loader',\r\n      'css-loader',\r\n      'less-loader'\r\n    ]\r\n}\r\n```\r\n\r\n## 配置Webpack能够处理HTML资源\r\n>主要是引入插件HtmlWebpackPlugin，这个插件能够将打包后的所有资源自动引入到HTML文件中。\r\n\r\n>主要配置如下：\r\n\r\n```js\r\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\r\nconst {resolve} = require('path');\r\n\r\nmodule.exports = {\r\n  entry: './src/index.js',\r\n  output: {\r\n    filename: 'built.js',\r\n    path: resolve(__dirname,'build')\r\n  },\r\n  module: {\r\n    rules: [\r\n\r\n    ]\r\n  },\r\n  plugins: [\r\n    new HtmlWebpackPlugin({\r\n      template: './src/index.html'\r\n    })\r\n  ],\r\n  mode: 'development'\r\n}\r\n```\r\n\r\n## 打包图片资源\r\n>下面我们首先看看主要的webpack配置文件的代码，然后我将带着大家逐一分析每一个loader的作用。\r\n\r\n```js\r\nconst {resolve} = require('path');\r\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\r\n\r\n\r\nmodule.exports = {\r\n  entry: './src/index.js',\r\n  output: {\r\n    filename: 'built.js',\r\n    path: resolve(__dirname,'build')\r\n  },\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.less$/,\r\n        use: ['style-loader','css-loader','less-loader']\r\n      },\r\n      {\r\n        test: /\\.(jpg|png|gif)$/,\r\n        loader: 'url-loader',\r\n        options: {\r\n          // 小于限制大小的图片资源将采用base64编码\r\n          limit: 40 * 1024,\r\n          esModule: false,\r\n          name: '[hash:10].[ext]'\r\n        }\r\n      },\r\n      {\r\n        test: /\\.html$/,\r\n        // 负责处理HTML中的图片处理\r\n        loader: 'html-loader'\r\n      }\r\n    ]\r\n  },\r\n  plugins: [\r\n    new HtmlWebpackPlugin({\r\n      template: './src/index.html'\r\n    })\r\n  ],\r\n  mode: 'development'\r\n}\r\n```\r\n\r\n* style-loader、css-loader、less-loader\r\n\r\n>将处理好的css样式、less样式插入到style标签中。\r\n\r\n* url-loader\r\n\r\n>将指定格式的图片进行打包，但是这个loader只能打包css或less文件中的图片，无法打包HTML中引入的图片，因此我们引入了下面的html-loader。\r\n\r\n* html-loader\r\n\r\n## 打包其他资源\r\n>这里我们以字体图标为例，来演示如何进行打包，主要是打包后缀为ttf的文件，主要是使用file-loader来进行打包。\r\n\r\n```js\r\nconst {resolve} = require('path');\r\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\r\nmodule.exports = {\r\n  entry: './src/index.js',\r\n  output: {\r\n    filename: 'built.js',\r\n    path: resolve(__dirname,'build')\r\n  },\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.css$/,\r\n        use: ['style-loader','css-loader']\r\n      },\r\n      {\r\n        // 打包其他资源，使用排除的方式\r\n        exclude: /\\.(css|js|html)$/,\r\n        loader: 'file-loader',\r\n        options: {\r\n          // 定义哈希值的长度\r\n          name: '[hash:10].[ext]'\r\n        }\r\n      }\r\n    ]\r\n  },\r\n  plugins: [\r\n    new HtmlWebpackPlugin({\r\n      template: './src/index.html'\r\n    })\r\n  ],\r\n  mode: 'development'\r\n}\r\n```"
    },
    {
      "id": "/在Egg.js中实现RBAC权限管理",
      "metadata": {
        "permalink": "/blog/在Egg.js中实现RBAC权限管理",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/在Egg.js中实现RBAC权限管理.md",
        "source": "@site/blog\\在Egg.js中实现RBAC权限管理.md",
        "title": "在Egg.js中实现RBAC权限管理",
        "description": "什么是RBAC？",
        "date": "2021-11-21T00:00:00.000Z",
        "formattedDate": "2021年11月21日",
        "tags": [
          {
            "label": "Egg.js",
            "permalink": "/blog/tags/egg-js"
          }
        ],
        "readingTime": 7.34,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "在Egg.js中实现RBAC权限管理",
          "date": "2021-11-21T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Egg.js",
          "tags": [
            "Egg.js"
          ]
        },
        "prevItem": {
          "title": "Webpack处理CSS、Less、HTML、图片与其他资源的方法",
          "permalink": "/blog/Webpack处理CSS、Less、HTML、图片与其他资源的方法"
        },
        "nextItem": {
          "title": "LeetCode——比较版本号（分割-去零-填零-比较）",
          "permalink": "/blog/LeetCode——比较版本号（分割-去零-填零-比较）"
        }
      },
      "content": "## 什么是RBAC？\r\n>RBAC是基于角色的权限访问控制，在RBAC中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限，也就是说权限是和角色绑定在一起的。\r\n\r\n## RBAC权限管理树形图\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/bde90ef7781e5550894e6263062eae38.png)\r\n\r\n## 角色管理\r\n### 增加角色\r\n* 静态页面中通过post进行提交的时候，需要配置csrf\r\n\r\n```js\r\n<input type=\"hidden\" name=\"_csrf\" value=\"<%=csrf%>\" />\r\n```\r\n\r\n* 在增加角色的控制器中首先获取到请求的角色名，如果角色名为空，则渲染基类控制器中的错误提示，如果不为空，则通过sequelize中的model来操作数据库，并将指定内容添加到数据库中。\r\n\r\n```js\r\n  async doAdd() {\r\n    const title = this.ctx.request.body.title;\r\n    if (title != '') {\r\n      await this.ctx.model.Role.create({\r\n        title,\r\n        description: this.ctx.request.body.description,\r\n        status: 1,\r\n        addTime: this.service.tools.getUnixTime()\r\n      })\r\n      await this.success(\"增加角色成功\", `/${this.config.adminPath}/role`)\r\n    } else {\r\n      await this.error(\"角色名不能为空\", `/${this.config.adminPath}/role/add`)\r\n    }\r\n  }\r\n```\r\n\r\n### 编辑角色\r\n#### 跳转到编辑页面\r\n>为了防止前端请求到错误的id，需要通过异常处理的方式，让错误的请求跳转到基类控制器中的错误提示页面，如果请求正常，则查询请求id，然后渲染到编辑的页面。\r\n\r\n```js\r\n  // 跳转编辑页面\r\n  async edit() {\r\n    try {\r\n      const id = this.ctx.request.query.id;\r\n      let result = await this.ctx.model.Role.findAll({\r\n        where: {\r\n          id\r\n        }\r\n      })\r\n      console.log(result);\r\n      await this.ctx.render('admin/role/edit', {\r\n        list: result[0]\r\n      });\r\n    } catch (error) {\r\n      await this.error(\"非法请求\", `/${this.config.adminPath}/role`)\r\n    }\r\n  }\r\n```\r\n\r\n#### 执行编辑功能\r\n>首先获取到post请求的id，然后根据这个id到数据库中去查询，然后判断是否查询到，如果没有查询到则报错，查询到了则更新数据。\r\n\r\n```js\r\n  // 执行编辑功能\r\n  async doEdit() {\r\n    let id = this.ctx.request.body.id;\r\n    let role = await this.ctx.model.Role.findByPk(id);\r\n    if (!role) {\r\n      await this.error(\"非法请求\", `/${this.config.adminPath}/role/edit?id=${id}`)\r\n      return\r\n    }\r\n    await role.update(this.ctx.request.body);\r\n    await this.success(\"修改数据成功\", `/${this.config.adminPath}/role`);\r\n    this.ctx.body = \"修改已被执行\"\r\n  }\r\n```\r\n\r\n>注意：在编辑角色的时候，静态页面传递id的时候可以通过隐藏表单的形式来进行传递。\r\n\r\n```js\r\n<input type=\"hidden\" name=\"id\" value=\"<%=list.id%>\">\r\n```\r\n\r\n\r\n### 删除角色\r\n>首先获取到要删除的id，然后根据主键去查询这个角色，如果没有查到则报错，查到的话则删除。\r\n\r\n```js\r\n  // 删除角色功能的实现\r\n  async delete() {\r\n    let id = this.ctx.request.query.id;\r\n    let role = await this.ctx.model.Role.findByPk(id);\r\n    if (!role) {\r\n      await this.error(\"非法请求\", `/${this.config.adminPath}/role`);\r\n      return;\r\n    }\r\n    await role.destroy();\r\n    await this.success(\"删除数据成功\", `/${this.config.adminPath}/role`);\r\n  }\r\n```\r\n\r\n## 管理员数据表与角色表进行关联\r\n>首先，我们要明确管理员数据表和角色表是通过哪一个字段进行关联的，是通过角色id进行关联的，所以，我们首先在admin的model中通过belongsTo进行关联。\r\n\r\n* model下的admin.js\r\n\r\n```js\r\n  Admin.associate = function() {\r\n    app.model.Admin.belongsTo(app.model.Role,{foreignKey: 'roleId'})\r\n  }\r\n```\r\n\r\n* 在控制器中进行关联查询的方式\r\n\r\n```js\r\nlet result = await this.ctx.model.Admin.findAll({\r\n      include: {model: this.ctx.model.Role}\r\n    });\r\n```\r\n\r\n## 权限管理\r\n### 权限表的自关联\r\n>之所以要进行自关联是因为，一个菜单或者模块如果属于一个顶级模块的话，顶级模块的id和其子项的module_id是一致的，这一点可以从下面的数据表中可以看出。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/bfecd5ac5a0054df9005ee5ea94fb066.png)\r\n\r\n>在access.js中实现下面的功能。\r\n\r\n```js\r\n  // 进行数据表的自关联\r\n  Access.associate = function() {\r\n    app.model.Access.hasMany(app.model.Access,{foreignKey: 'moduleId'});\r\n  }\r\n```\r\n\r\n### 修改权限\r\n\r\n```js\r\n  async edit() {\r\n    // 修改权限\r\n    let id = this.ctx.request.query.id;\r\n    // console.log(id);\r\n    let accessResult = await this.ctx.model.Access.findAll({\r\n      where: {\r\n        id\r\n      }\r\n    });\r\n    // console.log(accessResult[0]);\r\n    // 获取顶级模块\r\n    let accessList = await this.ctx.model.Access.findAll({\r\n      where: {moduleId: 0}\r\n    });\r\n\r\n    await this.ctx.render(\"admin/access/edit\",{\r\n      access: accessResult[0],\r\n      accessList\r\n    })\r\n  }\r\n```\r\n\r\n## 角色与权限进行关联\r\n>角色与权限进行关联主要是通过一个中间数据表来进行关联，下面是这个数据表的结构。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/bbfbafd71bfe896e5fd9c2a1731bc4dd.png)\r\n\r\n## 进入角色授权界面，显示该角色已经拥有的权限\r\n>进入显示授权页面的控制器。\r\n\r\n1. 获取要授权的角色ID。\r\n2. 获得所有的权限列表。\r\n3. 定义一个临时数组并找到第一步角色id对应的权限，并将其权限id添加到临时数组中。\r\n4. 将所有权限数组通过转换为字符串后再转换为JSON，然后通过两层循环将其添加标记后再进行渲染。\r\n\r\n```js\r\n  // 授权\r\n  async auth() {\r\n    // 获取要给哪个id的角色进行授权\r\n    let roleId = this.ctx.request.query.id;\r\n    let allAuthResult = await this.ctx.model.Access.findAll({\r\n      where: {moduleId: 0},\r\n      include: {model: this.ctx.model.Access}\r\n    });\r\n    let tempArr = [];\r\n    let roleAuthResult = await this.ctx.model.RoleAccess.findAll({where: {roleId}});\r\n\r\n    for (let v of roleAuthResult) {\r\n      tempArr.push(v.accessId);\r\n    }\r\n\r\n    allAuthResult = JSON.parse(JSON.stringify(allAuthResult));\r\n\r\n    for (let i = 0; i < allAuthResult.length; i++) {\r\n      if (tempArr.indexOf(allAuthResult[i].id) != -1) {\r\n        allAuthResult[i].checked = true;\r\n      }\r\n      for (let j = 0; j < allAuthResult[i].accesses.length; j++) {\r\n        if (tempArr.indexOf(allAuthResult[i].accesses[j].id) != -1) {\r\n          allAuthResult[i].accesses[j].checked = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    // this.ctx.body = allAuthResult;\r\n\r\n    await this.ctx.render('admin/role/auth',{\r\n      authList: allAuthResult,\r\n      roleId\r\n    });\r\n  }\r\n```\r\n\r\n## 用户权限判断\r\n>判断当前登录用户的权限，防止用户访问没有授权的页面。\r\n\r\n1. 在service中定义函数来判断用户请求的URL是否有权限访问。\r\n2. 定义一个可以忽略的URL数组，在这个数组中的请求都是直接允许所有用户访问的，比如退出登录，如果是超级管理员或者请求URL在上述的数组中，直接返回true。\r\n3. 获取角色id对应的所有权限，然后去权限表中查询当前请求URL对应的id，如果在上述的数组中，则返回true，反之返回true。\r\n\r\n```js\r\nclass AdminService extends Service {\r\n  async checkAuth() {\r\n    let roleId = this.ctx.session.userinfo.roleId;\r\n    let isSuper = this.ctx.session.userinfo.isSuper;\r\n    let adminPath = this.config.adminPath;\r\n    let pathname = this.ctx.request.url;\r\n    pathname = pathname.split(\"?\")[0];\r\n\r\n    // 忽略权限判断的地址\r\n    \r\n    if (this.config.ignoreUrl.indexOf(pathname) != -1 || isSuper === 1) {\r\n      return true;\r\n    }\r\n    let roleAccessArr = [];\r\n    let roleAuthResult = await this.ctx.model.RoleAccess.findAll({\r\n      where: {roleId}\r\n    });\r\n    for (let i = 0; i < roleAuthResult.length; i++) {\r\n      roleAccessArr.push(roleAuthResult[i].accessId);\r\n    }\r\n\r\n    // 获取当前访问的URL，对应的权限ID\r\n    let accessUrl = pathname.replace(`/${adminPath}/`,'');\r\n    let accessUrlResult = await this.ctx.model.Access.findAll({\r\n      where: {url: accessUrl}\r\n    });\r\n    if (accessUrlResult.length) {\r\n      if (roleAccessArr.indexOf(accessUrlResult[0].id) != -1) {\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n    return false;\r\n\r\n  }\r\n}\r\n```"
    },
    {
      "id": "/LeetCode——比较版本号（分割-去零-填零-比较）",
      "metadata": {
        "permalink": "/blog/LeetCode——比较版本号（分割-去零-填零-比较）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——比较版本号（分割-去零-填零-比较）.md",
        "source": "@site/blog\\LeetCode——比较版本号（分割-去零-填零-比较）.md",
        "title": "LeetCode——比较版本号（分割-去零-填零-比较）",
        "description": "题目描述",
        "date": "2021-11-20T00:00:00.000Z",
        "formattedDate": "2021年11月20日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 2.615,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——比较版本号（分割-去零-填零-比较）",
          "date": "2021-11-20T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "在Egg.js中实现RBAC权限管理",
          "permalink": "/blog/在Egg.js中实现RBAC权限管理"
        },
        "nextItem": {
          "title": "面试官：请实现单行文本居中，多行文本左对齐？",
          "permalink": "/blog/面试官：请实现单行文本居中，多行文本左对齐？"
        }
      },
      "content": "## 题目描述\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/2dafc44aea1f6493687f2ba748b224b1.png)\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/1fb684c5a6cde54724a2e5ce04624b0a.png)\r\n\r\n## 解题思路\r\n1. 首先使用split将元素根据标点符号点，进行分割。\r\n2. 对数组中的每一个元素进行去零操作，并不是所有的元素都要进行去零操作，只有该元素包含了两个字符或者以上内容的时候，并且该元素的第一个字母是0才需要进行去零操作，其余则不需要去零操作。\r\n3. 填0操作：首先比较两个数组的长度，长度较短的数组通过填0操作，补充到相同的长度，这样可以方便后续的比较。\r\n4. 比较：定义两个指针，分别指向这两个数组，同时往后遍历，只要比较到大小关系则进行返回对应的值。\r\n\r\n## AC代码\r\n```js\r\nvar compareVersion = function (version1, version2) {\r\n  const arr1 = version1.split('.');\r\n  const arr2 = version2.split('.');\r\n\r\n  // 对数组中的每一个字符串进行去0操作：只有两位以上的才需要进行去0操作\r\n  function deleteZero(arr) {\r\n    for (let i = 0; i < arr.length; i++) {\r\n      while (arr[i].length > 1 && arr[i][0] === '0') {\r\n        let temp = arr[i].split('');\r\n        temp.shift();\r\n        arr[i] = temp.join('');\r\n      }\r\n    }\r\n  }\r\n\r\n  deleteZero(arr1);\r\n  deleteZero(arr2);\r\n\r\n  // 进行填0操作\r\n  // 首先比较两个数组的长度\r\n  if (arr1.length > arr2.length) {\r\n    let flag = arr2.length\r\n    for (let i = flag; i < arr1.length; i++) {\r\n      arr2[i] = '0';\r\n    }\r\n  }\r\n  else if (arr1.length < arr2.length) {\r\n    let flag = arr1.length;\r\n    for (let i = flag; i < arr2.length; i++) {\r\n      arr1[i] = '0';\r\n    }\r\n  }\r\n\r\n  let left = 0;\r\n  let right = 0;\r\n  while (left < arr1.length) {\r\n    if (Number(arr1[left]) === Number(arr2[right])) {\r\n      left++;\r\n      right++;\r\n      continue;\r\n    }\r\n    if (Number(arr1[left]) < Number(arr2[right])) {\r\n      return -1;\r\n    }\r\n    if (Number(arr1[left]) > Number(arr2[right])) {\r\n      return 1;\r\n    }\r\n  }\r\n  return 0;\r\n\r\n};\r\n```\r\n\r\n## 题目反思\r\n>本题可能不是最优解，但是通过这个题目告诉我们的是面对问题不要畏惧，只要理清思路，找到题目中的案例之间的规律，题目都是能够迎刃而解的，下面让我们分析下本题都用到了哪些知识点。\r\n\r\n* 学会使用split将字符串分割为数组。\r\n* 学会给数组中的元素进行去除和填充操作。"
    },
    {
      "id": "/面试官：请实现单行文本居中，多行文本左对齐？",
      "metadata": {
        "permalink": "/blog/面试官：请实现单行文本居中，多行文本左对齐？",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/面试官：请实现单行文本居中，多行文本左对齐？.md",
        "source": "@site/blog\\面试官：请实现单行文本居中，多行文本左对齐？.md",
        "title": "面试官：请实现单行文本居中，多行文本左对齐？",
        "description": "什么是单行文本居中，多行文本左对齐？",
        "date": "2021-11-19T00:00:00.000Z",
        "formattedDate": "2021年11月19日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 2.99,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "面试官：请实现单行文本居中，多行文本左对齐？",
          "date": "2021-11-19T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "LeetCode——比较版本号（分割-去零-填零-比较）",
          "permalink": "/blog/LeetCode——比较版本号（分割-去零-填零-比较）"
        },
        "nextItem": {
          "title": "Egg.js创建基类、配置公共的页面、后台地址与退出登录",
          "permalink": "/blog/Egg.js创建基类、配置公共的页面、后台地址与退出登录"
        }
      },
      "content": "## 什么是单行文本居中，多行文本左对齐？\r\n>为了准确的向大家阐述，这是什么意思？我特意做了一个GIF动图，这样能够更好的帮助大家理解什么是单行文本居中，多行文本左对齐。\r\n\r\n![单行文本居中，多行左对齐.gif](https://img-blog.csdnimg.cn/img_convert/9369ae63793d84d952f91b2f29511b8c.gif)\r\n\r\n## 实现方法\r\n### 实现方式1：相对定位 + transform + inline-block\r\n>之所以要设置inline-block是因为这样可以让元素的宽度有子元素决定。\r\n\r\n* HTML结构\r\n\r\n```html\r\n  <div class=\"father\">\r\n    <div class=\"text\">测试单行文字居中，多行文本左对齐。测试单行文字居中，多行文本左对齐。</div>\r\n  </div>\r\n```\r\n\r\n* css结构\r\n\r\n```css\r\n.father {\r\n  height: 300px;\r\n  margin: 0 auto;\r\n  border: 1px solid red;\r\n}\r\n.text {\r\n  display: inline-block;\r\n  position: relative;\r\n  left: 50%;\r\n  transform: translateX(-50%);\r\n}\r\n```\r\n\r\n### 实现方式2：父级text-align: center，子级inline-block + text-align: left\r\n>这种方式的实现原理是，当子元素的宽度没有父元素的宽度宽的时候，此时应用的是行内块元素和左对齐，但是父盒子设置了居中对齐，所以显示的是居中，一旦子元素的宽度达到了两行，第二行就开始应用左对齐了。\r\n\r\n* HTML结构\r\n\r\n```html\r\n  <div class=\"father\">\r\n    <div class=\"text\">测试单行文字居中，多行文本左对齐。测试单行文字居中，多行文本左对齐。</div>\r\n  </div>\r\n```\r\n\r\n* CSS样式\r\n\r\n```css\r\n.father {\r\n  height: 300px;\r\n  margin: 0 auto;\r\n  border: 1px solid red;\r\n  text-align: center;\r\n}\r\n.text {\r\n  display: inline-block;\r\n  text-align: left;\r\n}\r\n```\r\n\r\n### 实现方式3：table布局 + margin: 0 auto;\r\n\r\n* HTML结构\r\n\r\n```html\r\n  <div class=\"father\">\r\n    <div class=\"text\">测试单行文字居中，多行文本左对齐。测试单行文字居中，多行文本左对齐。</div>\r\n  </div>\r\n```\r\n\r\n* CSS样式\r\n\r\n```css\r\n.father {\r\n  height: 300px;\r\n  margin: 0 auto;\r\n  border: 1px solid red;\r\n}\r\n.text {\r\n  display: table;\r\n  margin: 0 auto;\r\n}\r\n```\r\n\r\n### 实现方式4：flex布局 + justify-content: center\r\n\r\n* HTML结构\r\n\r\n```js\r\n  <div class=\"father\">\r\n    <div class=\"text\">测试单行文字居中，多行文本左对齐。测试单行文字居中，多行文本左对齐。</div>\r\n  </div>\r\n```\r\n\r\n* CSS样式\r\n\r\n```css\r\n.father {\r\n  height: 300px;\r\n  margin: 0 auto;\r\n  border: 1px solid red;\r\n}\r\n.text {\r\n  display: flex;\r\n  justify-content: center;\r\n}\r\n```\r\n\r\n### 实现方式5：grid布局 + justify-items: center\r\n\r\n```css\r\n.text {\r\n  display: grid;\r\n  justify-items: center;\r\n}\r\n```\r\n\r\n>单行文本居中，多行文本左对齐，是一道非常考查候选人CSS基本功的题目，从这个问题可以看出，我们的CSS基础还仍待提高。"
    },
    {
      "id": "/Egg.js创建基类、配置公共的页面、后台地址与退出登录",
      "metadata": {
        "permalink": "/blog/Egg.js创建基类、配置公共的页面、后台地址与退出登录",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Egg.js创建基类、配置公共的页面、后台地址与退出登录.md",
        "source": "@site/blog\\Egg.js创建基类、配置公共的页面、后台地址与退出登录.md",
        "title": "Egg.js创建基类、配置公共的页面、后台地址与退出登录",
        "description": "通过HTML的meta标签实现指定时间后的页面跳转",
        "date": "2021-11-18T00:00:00.000Z",
        "formattedDate": "2021年11月18日",
        "tags": [
          {
            "label": "Egg.js",
            "permalink": "/blog/tags/egg-js"
          }
        ],
        "readingTime": 3.58,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Egg.js创建基类、配置公共的页面、后台地址与退出登录",
          "date": "2021-11-18T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Egg.js",
          "tags": [
            "Egg.js"
          ]
        },
        "prevItem": {
          "title": "面试官：请实现单行文本居中，多行文本左对齐？",
          "permalink": "/blog/面试官：请实现单行文本居中，多行文本左对齐？"
        },
        "nextItem": {
          "title": "Egg.js中复用静态页面逻辑、局部刷新架构、生成验证码",
          "permalink": "/blog/Egg.js中复用静态页面逻辑、局部刷新架构、生成验证码"
        }
      },
      "content": "## 通过HTML的meta标签实现指定时间后的页面跳转\r\n\r\n```html\r\n<meta http-equiv=\"refresh\" content=\"3;url=http://www.baidu.com\"> \r\n```\r\n\r\n## 创建基类\r\n### 为什么要创建基类？\r\n>之所以要创建基类，是因为我们希望复用一些通用的逻辑，比如登录成功如何操作，登录出现错误如何操作，这就是我们为什么要创建基类的根本原因。\r\n\r\n### 实现方法\r\n1. 首先在控制器下创建一个base.js文件\r\n\r\n2. 在文件中定义需要被复用的异步函数。\r\n\r\n```js\r\n'use strict';\r\n\r\nconst Controller = require('egg').Controller;\r\n\r\nclass BaseController extends Controller {\r\n  async success(msg,redirectUrl) {\r\n    await this.ctx.render(\"admin/public/success\",{\r\n      msg,\r\n      redirectUrl\r\n    })\r\n  }\r\n  async error(msg,redirectUrl) {\r\n    await this.ctx.render(\"admin/public/error\",{\r\n      msg,\r\n      redirectUrl\r\n    })\r\n  }\r\n}\r\n\r\nmodule.exports = BaseController;\r\n```\r\n\r\n3. 需要用到基类的地方需要修改继承。\r\n\r\n```js\r\nconst BaseController = require('./base.js');\r\nclass LoginController extends BaseController{};\r\n```\r\n\r\n4. 通过this异步调用this中的方法\r\n\r\n```js\r\nawait this.success(\"登录成功\",\"/admin\")\r\n```\r\n\r\n## 配置公共的成功失败的页面\r\n1. 在view下的指定文件夹内部定义成功的静态页面和错误的静态页面。\r\n2. 通过meta标签实现指定时间后跳转。\r\n3. 通过ejs模板接收传入的参数。\r\n\r\n```js\r\n<%- include ../public/page_header.html %>\r\n\r\n <meta http-equiv=\"refresh\" content=\"1;url=<%=redirectUrl%>\"> \r\n\r\n <div class=\"container\" style=\"width: 480px;margin-top:100px;\">\r\n\r\n    <div class=\"row\">                 \r\n            <div class=\"alert alert-success\">            \t\r\n                <h2><%=msg%></h2>   \r\n            \t\r\n            \t<br />\r\n            \t\t\r\n            \t<p>如果您不做出选择，将在 3秒后跳转到第一个链接地址。</p>            \r\n            \r\n            </div>       \r\n    </div>\r\n</div>\r\n\r\n</body>\r\n</html>\r\n```\r\n\r\n## 配置可以修改的后台地址\r\n>之所以要配置可以修改的后台地址是为了在修改路径的时候，只需修改配置文件中的地址即可，避免了一个一个修改的繁琐。\r\n\r\n1. 在config.default.js中指定后台路径。\r\n2. 指定中间件匹配上文提到的路径，并将这个指定的路径传入到中间件中。\r\n\r\n```js\r\n  config.adminPath = \"aaa\";\r\n  config.adminAuth = {\r\n    match: `/${config.adminPath}`,\r\n    adminPath: config.adminPath\r\n  }\r\n```\r\n\r\n3. 路由中获取指定路径的方法\r\n\r\n```js\r\nconst {\r\n    router,\r\n    controller,\r\n    config\r\n  } = app\r\nrouter.get(`/${config.adminPath}/manager`, controller.admin.manager.index);\r\n```\r\n\r\n4. 中间件中通过配置全局变量的方式拿到adminPath\r\n\r\n```js\r\nctx.state.adminPath = options.adminPath;\r\n```\r\n\r\n5. 控制器中通过this.config获取路径\r\n\r\n```js\r\nawait this.error('用户名或密码错误',`/${this.config.adminPath}/login`)\r\n```\r\n\r\n6. 静态页面中直接通过模板引擎获取\r\n\r\n```js\r\n<li class=\"list-group-item\"> <a href=\"/<%=adminPath%>/role\" target=\"rightMain\"> 角色管理</a></li>\r\n```\r\n\r\n>静态页面之所以能够获取到是因为我们第四步配置的中间件，把adminPath配置到了全局变量中了。\r\n\r\n## 退出登录功能的实现\r\n1. 在控制器中定义退出的异步函数\r\n\r\n>在异步函数中首先要清空session，因为中间件判断登录与否是通过session实现的，退出登录后跳转到登录页面。\r\n\r\n```js\r\n  // 退出登录\r\n  async loginOut() {\r\n    this.ctx.session.userinfo = null;\r\n    await this.success(\"退出成功\",`/${this.config.adminPath}/login`);\r\n  }\r\n```\r\n\r\n2. 配置路由\r\n\r\n```js\r\nrouter.get(`/${config.adminPath}/login/loginOut`,controller.admin.login.loginOut)\r\n```\r\n\r\n3. 点击退出处的静态页面配置\r\n\r\n```js\r\n<li><a href=\"/<%=adminPath%>/login/loginOut\">安全退出</a>\r\n```"
    },
    {
      "id": "/Egg.js中复用静态页面逻辑、局部刷新架构、生成验证码",
      "metadata": {
        "permalink": "/blog/Egg.js中复用静态页面逻辑、局部刷新架构、生成验证码",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Egg.js中复用静态页面逻辑、局部刷新架构、生成验证码.md",
        "source": "@site/blog\\Egg.js中复用静态页面逻辑、局部刷新架构、生成验证码.md",
        "title": "Egg.js中复用静态页面逻辑、局部刷新架构、生成验证码",
        "description": "配置ejs模板引擎",
        "date": "2021-11-17T00:00:00.000Z",
        "formattedDate": "2021年11月17日",
        "tags": [
          {
            "label": "Egg.js",
            "permalink": "/blog/tags/egg-js"
          }
        ],
        "readingTime": 3.345,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Egg.js中复用静态页面逻辑、局部刷新架构、生成验证码",
          "date": "2021-11-17T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Egg.js",
          "tags": [
            "Egg.js"
          ]
        },
        "prevItem": {
          "title": "Egg.js创建基类、配置公共的页面、后台地址与退出登录",
          "permalink": "/blog/Egg.js创建基类、配置公共的页面、后台地址与退出登录"
        },
        "nextItem": {
          "title": "Egg中使用Sequelize ORM框架操作MySQL--关联查询",
          "permalink": "/blog/Egg中使用Sequelize ORM框架操作MySQL--关联查询"
        }
      },
      "content": "## 配置ejs模板引擎\r\n* 安装插件\r\n\r\n```js\r\nnpm i egg-view-js\r\n```\r\n\r\n* 在plugin.js中添加下列代码\r\n\r\n```js\r\nmodule.exports = {\r\n  // had enabled by egg\r\n  static: {\r\n    enable: true\r\n  },\r\n  ejs: {\r\n    enable: true,\r\n    package: 'egg-view-ejs'\r\n  }\r\n}\r\n```\r\n\r\n* 在config.default.js中添加下列代码\r\n\r\n```js\r\nconst userConfig = {\r\n    view: {\r\n      mapping: {\r\n        '.html': 'ejs'\r\n      }\r\n    }\r\n  }\r\n```\r\n\r\n\r\n## 对视图进行分组\r\n>将所有的页面都放在view文件夹中是不合理的，所以可以将view文件夹进行分组。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/c82c6aa49894d3979cf2c47ee3873a4d.png)\r\n\r\n## 复用静态逻辑\r\n1. 把需要复用的静态页面抽离到一个文件夹中。\r\n\r\n2. 在需要复用的地方，通过下面的方式进行引入。\r\n\r\n```js\r\n<% include ../public/page_header.html %>\r\n```\r\n\r\n## 配置局部刷新架构\r\n>之所以要配置局部刷新架构，就是希望当我们点击某个链接的时候，能够保存原有的状态，例如浏览器导航栏的状态。\r\n\r\n>配置局部刷新的核心在于跳转路由的时候，通过target指向iframe。\r\n\r\n```js\r\n<li class=\"list-group-item\"> <a href=\"/admin/role/add\" target=\"rightMain\">增加角色</a></li>\r\n<iframe name=\"rightMain\" src=\"/admin/welcome\" frameborder=\"0\" width=\"100%\" height=\"500\"></iframe>\r\n```\r\n\r\n## 基于Serverless的Egg.js后台管理系统配置Session\r\n>腾讯云的Serverless云函数如果30分钟内没有访问的话就会销毁容器，所以如果session要保存30分钟以上的话，就需要把session存储到数据库中。\r\n\r\n### 配置session\r\n\r\n* 在config.default.js\r\n\r\n```js\r\n  config.session = {\r\n    key: 'session_id_test',\r\n    maxAge: 30*60*1000;\r\n    httpOnly: true,\r\n    encrypt: true,\r\n    renew: true\r\n  }\r\n```\r\n\r\n* 在控制器中设置session\r\n\r\n```js\r\nthis.ctx.session.username = \"张三\";\r\n```\r\n\r\n* 在控制器中读取session\r\n\r\n```js\r\nthis.ctx.body = this.ctx.session.username;\r\n```\r\n\r\n\r\n## 生成图形验证码\r\n1. 安装依赖\r\n\r\n```shell\r\nnpm install --save svg-captcha\r\n```\r\n\r\n2. 在控制器中进行下面的定义\r\n\r\n```js\r\nconst svgCaptcha = require('svg-captcha');\r\n  // 验证码模块\r\n  async captcha() {\r\n    const captcha = svgCaptcha.create({\r\n      size: 4,\r\n      fontSize: 50,\r\n      width: 100,\r\n      height: 40,\r\n      background: \"#cc9966\"\r\n    });\r\n    console.log(captcha.text);\r\n    this.ctx.response.type = 'image/svg+xml';\r\n    this.ctx.body = captcha.data;\r\n  }\r\n```\r\n\r\n3. 静态页面获取验证码\r\n\r\n>静态验证码获取验证码是通过访问路由，让控制器返回图片来实现的。\r\n\r\n```html\r\ndd>验　证　码：<input id=\"verify\" type=\"text\" name=\"verify\">\r\n<img id=\"verify_img\" src=\"/admin/login/captcha\" title=\"看不清？点击刷新\" onclick=\"javascript:this.src='/admin/login/captcha?mt='+Math.random()\">\r\n</dd>\r\n```\r\n\r\n4. 将验证码保存在session中\r\n\r\n```js\r\nthis.ctx.session.code = captcha.text;\r\n```\r\n\r\n>如果你想复用上述的验证码逻辑，可以通过下面的方式进行封装。\r\n\r\n* 首先在app文件夹下创建service文件夹，并在service文件夹下创建tools.js\r\n\r\n```js\r\n'use strict';\r\n\r\nconst Service = require('egg').Service;\r\nconst svgCaptcha = require('svg-captcha');\r\nclass ToolsService extends Service {\r\n  async getCaptcha() {\r\n    const captcha = svgCaptcha.create({\r\n      size: 4,\r\n      fontSize: 50,\r\n      width: 100,\r\n      height: 40,\r\n      background: \"#cc9966\"\r\n    });\r\n    return captcha;\r\n  }\r\n}\r\n\r\nmodule.exports = ToolsService;\r\n```\r\n\r\n* 在控制器中调用即可\r\n\r\n```js\r\nasync captcha() {\r\n    let captcha = await this.service.tools.getCaptcha();\r\n    console.log(captcha.text);\r\n    // 将验证码保存在session中\r\n    this.ctx.session.code = captcha.text;\r\n    this.ctx.response.type = 'image/svg+xml';\r\n    this.ctx.body = captcha.data;\r\n  }\r\n```"
    },
    {
      "id": "/Egg中使用Sequelize ORM框架操作MySQL--关联查询",
      "metadata": {
        "permalink": "/blog/Egg中使用Sequelize ORM框架操作MySQL--关联查询",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Egg中使用Sequelize ORM框架操作MySQL--关联查询.md",
        "source": "@site/blog\\Egg中使用Sequelize ORM框架操作MySQL--关联查询.md",
        "title": "Egg中使用Sequelize ORM框架操作MySQL--关联查询",
        "description": "一、Sequelize自定义表名",
        "date": "2021-11-16T00:00:00.000Z",
        "formattedDate": "2021年11月16日",
        "tags": [
          {
            "label": "Egg.js",
            "permalink": "/blog/tags/egg-js"
          }
        ],
        "readingTime": 2.53,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Egg中使用Sequelize ORM框架操作MySQL--关联查询",
          "date": "2021-11-16T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Egg.js",
          "tags": [
            "Egg.js"
          ]
        },
        "prevItem": {
          "title": "Egg.js中复用静态页面逻辑、局部刷新架构、生成验证码",
          "permalink": "/blog/Egg.js中复用静态页面逻辑、局部刷新架构、生成验证码"
        },
        "nextItem": {
          "title": "这一次，彻底搞懂垂直水平居中",
          "permalink": "/blog/这一次，彻底搞懂垂直水平居中"
        }
      },
      "content": "## 一、Sequelize自定义表名\r\n>只需在定义model的时候，加入tableName字段即可。\r\n\r\n```js\r\nmodule.exports = app => {\r\n  const { STRING, INTEGER, DATE } = app.Sequelize;\r\n\r\n  const User = app.model.define('user', {\r\n    id: { type: INTEGER, primaryKey: true, autoIncrement: true },\r\n    username: STRING(30),\r\n    age: INTEGER,\r\n    sex: STRING(30),\r\n    created_at: DATE,\r\n    updated_at: DATE,\r\n  },{\r\n    tableName: \"usera\"\r\n  });\r\n\r\n  return User;\r\n};\r\n```\r\n\r\n* 设置不显示createdAt等时间戳字段\r\n\r\n```js\r\n{\r\n    tableName: \"usera\",\r\n    timestamps: false\r\n}\r\n```\r\n\r\n## 使用Sequelize实现多表查询\r\n>注意：如果数据库中使用的是下划线命名法，在model中需要使用驼峰命名法。\r\n\r\n### 一对一查询\r\n\r\n* article表的结构\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/08dbdc25a0082ec04a496d65db0aeb97.png)\r\n\r\n* article_cate表的结构\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/6fe24d92b5e495a32c7d7885c2979e99.png)\r\n\r\n* article的model\r\n\r\n```js\r\n'use strict';\r\n\r\nmodule.exports = app => {\r\n  const { STRING, INTEGER, DATE } = app.Sequelize;\r\n\r\n  const Article = app.model.define('article', {\r\n    id: { type: INTEGER, primaryKey: true, autoIncrement: true },\r\n    title: STRING(255),\r\n    description: STRING(255),\r\n    cateId: INTEGER,\r\n    state: INTEGER\r\n  },{\r\n    tableName: \"article\",\r\n    timestamps: false\r\n  });\r\n  // 实现关联的核心代码是下面的语句\r\n  Article.associate = function() {\r\n    // 1对1\r\n    app.model.Article.belongsTo(app.model.ArticleCate,{foreignKey: 'cateId'});\r\n  }\r\n\r\n  return Article;\r\n};\r\n```\r\n\r\n* article_cate的model\r\n\r\n```js\r\n'use strict';\r\n\r\nmodule.exports = app => {\r\n  const { STRING, INTEGER, DATE } = app.Sequelize;\r\n\r\n  const ArticleCate = app.model.define('article_cate', {\r\n    id: { type: INTEGER, primaryKey: true, autoIncrement: true },\r\n    title: STRING(255),\r\n    state: INTEGER\r\n  },{\r\n    tableName: \"article_cate\",\r\n    timestamps: false\r\n  });\r\n\r\n  return ArticleCate;\r\n};\r\n```\r\n\r\n* 一对一查询方法\r\n\r\n```js\r\nasync onevsone() {\r\n    const result = await this.ctx.model.Article.findAll({\r\n      include: {\r\n        model: this.ctx.model.ArticleCate\r\n      }\r\n    });\r\n    this.ctx.body = result;\r\n  }\r\n```\r\n\r\n>查询到的结果如下图所示：\r\n\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/ad148cedc17a0f67e088a8290b718f26.png)\r\n\r\n### 一对多查询\r\n\r\n* article_cate.js\r\n\r\n```js\r\nArticleCate.associate = function () {\r\n    // 1对1\r\n    app.model.ArticleCate.hasMany(app.model.Article, { foreignKey: 'cateId' });\r\n    \r\n  }\r\n```\r\n\r\n* 路由\r\n\r\n```js\r\n  async onevsmany() {\r\n    const result = await this.ctx.model.ArticleCate.findAll({\r\n      include: {\r\n        model: this.ctx.model.Article\r\n      }\r\n    });\r\n    this.ctx.body = result;\r\n  }\r\n```\r\n\r\n### 多对多查询\r\n>多对多查询主要是使用belongsToMany。\r\n\r\n* 一门课程可以被多个学生选修\r\n\r\n```js\r\nLesson.associate = function(){\r\n//一个课程可以被多个学生选修\r\n    app.model.Lesson.belongsToMany(app.model.Student, {\r\n    through: app.model.LessonStudent,\r\n    foreignKey: 'lessonId',\r\n    otherKey: 'studentId'\r\n    });\r\n}\r\n```\r\n\r\n* 一个学生可以选修多门课程（代码中的through指的是中间表）\r\n\r\n```js\r\nStudent.associate = function (){\r\n    //一个学生可以选修多门课程\r\n    app.model.Student.belongsToMany(app.model.Lesson, {\r\n    through: app.model.LessonStudent,\r\n    foreignKey: 'studentId', //注意写法\r\n    otherKey: 'lessonId'\r\n    });\r\n}\r\n```\r\n\r\n* 查询语句\r\n\r\n```js\r\nconst { ctx } = this;\r\nlet result = await ctx.model.Student.findAll({\r\n    include: {\r\n    model: ctx.model.Lesson\r\n    }\r\n});\r\n```"
    },
    {
      "id": "/这一次，彻底搞懂垂直水平居中",
      "metadata": {
        "permalink": "/blog/这一次，彻底搞懂垂直水平居中",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/这一次，彻底搞懂垂直水平居中.md",
        "source": "@site/blog\\这一次，彻底搞懂垂直水平居中.md",
        "title": "这一次，彻底搞懂垂直水平居中",
        "description": "无论是在面试中还是在工作中，将一个元素置为水平或垂直居中，都是一个前端工程师必备的基本功，接下来让我们一起来对居中这个话题进行系统性的梳理和总结。",
        "date": "2021-11-15T00:00:00.000Z",
        "formattedDate": "2021年11月15日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 8.615,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "这一次，彻底搞懂垂直水平居中",
          "date": "2021-11-15T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "Egg中使用Sequelize ORM框架操作MySQL--关联查询",
          "permalink": "/blog/Egg中使用Sequelize ORM框架操作MySQL--关联查询"
        },
        "nextItem": {
          "title": "使用JS打印九九乘法表",
          "permalink": "/blog/使用JS打印九九乘法表"
        }
      },
      "content": ">无论是在面试中还是在工作中，将一个元素置为水平或垂直居中，都是一个前端工程师必备的基本功，接下来让我们一起来对居中这个话题进行系统性的梳理和总结。\r\n\r\n##  一、水平居中\r\n### 行内元素\r\n\r\n> HTML结构\r\n\r\n```js\r\n  <div class=\"parent\">\r\n    <span class=\"child\">111</span>\r\n  </div>\r\n```\r\n\r\n>居中方法：给其父元素设置text-align: center;\r\n\r\n```css\r\ntext-align: center;\r\n```\r\n\r\n### 块级元素\r\n\r\n#### 一般块元素\r\n>只需给该元素设置margin: 0 auto即可。\r\n\r\n```css\r\nmargin: 0 auto;\r\n```\r\n\r\n#### 子元素包含float的情况\r\n>可以给父元素设置宽度为：fit-content。\r\n\r\n\r\n```css\r\n.parent {\r\n    margin: 0 auto;\r\n    width: fit-content;\r\n}\r\n.child {\r\n    float: left\r\n}\r\n```\r\n\r\n#### flex布局实现水平居中\r\n>通过给父元素设置下面两个属性：\r\n\r\n```css\r\ndisplay: flex;\r\njustify-content: center;\r\n```\r\n\r\n#### 绝对定位 + left + transform\r\n>给子元素设置下面的css样式。（注意：下面的translate是相对于自身进行移动的）\r\n\r\n```css\r\nposition: absolute;\r\nleft: 50%;\r\ntransform: translate(-50%,0);\r\n```\r\n\r\n#### 绝对定位 + left + margin-left\r\n>给子元素设置下面的CSS样式。\r\n\r\n```css\r\nposition: absolute;\r\nleft: 50%;\r\nmargin-left: calc(-0.5*100px);\r\n```\r\n\r\n#### 绝对定位 + left/right + margin\r\n>给父元素设置下面的CSS样式。\r\n\r\n```css\r\nposition: absolute;\r\nleft: 0;\r\nright: 0;\r\nmargin: 0 auto;\r\n```\r\n\r\n## 二、垂直居中\r\n### 行内元素\r\n\r\n#### 单行文本\r\n>给子元素的行高设置为父元素的高度即可。\r\n\r\n```css\r\n.parent {\r\n  width: 200px;\r\n  height: 200px;\r\n  text-align: center;\r\n  border: 1px solid red;\r\n  margin: 0 auto;\r\n}\r\n.child {\r\n  line-height: 200px;\r\n  background-color: pink;\r\n}\r\n```\r\n\r\n>将行高和高度均设置在父元素身上也是可行的。\r\n\r\n```css\r\n.parent {\r\n  width: 200px;\r\n  height: 200px;\r\n  line-height: 200px;\r\n  border: 1px solid red;\r\n}\r\n```\r\n\r\n### 块级元素\r\n#### 行内块元素\r\n>可以给行内块元素，添加一个兄弟元素，将这个兄弟元素的高度设置和父元素高度一致，字体大小设置为0.\r\n\r\n```css\r\n.parent {\r\n  width: 400px;\r\n  height: 400px;\r\n\r\n  border: 1px solid red;\r\n}\r\n.child,.brother {\r\n  display: inline-block;;\r\n  vertical-align: middle;\r\n}\r\n.child {\r\n  background: blue;\r\n  font-size: 12px;\r\n}\r\n.brother {\r\n  height: 400px;\r\n  font-size: 0;\r\n}\r\n```\r\n\r\n```html\r\n  <div class=\"parent\">\r\n    <div class=\"child\">child</div>\r\n    <div class=\"brother\">brother</div>\r\n  </div>\r\n```\r\n\r\n#### flex布局\r\n>只需给父元素设置display:flex和align-items: center即可。\r\n\r\n```css\r\ndisplay: flex;\r\nalign-items: center;\r\n```\r\n\r\n#### 绝对定位 + left/top/right/bottom + margin: auto\r\n>子级绝对定位，父级相对定位，同时给自己的四个定位边置为0，然后设置为，margin: auto即可。\r\n\r\n```css\r\n.parent {\r\n  position: relative;\r\n  width: 400px;\r\n  height: 400px;\r\n  border: 1px solid red;\r\n}\r\n\r\n.child {\r\n  width: 200px;\r\n  height: 100px;\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  right: 0;\r\n  bottom: 0; \r\n  margin: auto;\r\n  background: blue;\r\n  font-size: 12px;\r\n}\r\n```\r\n\r\n#### table-cell + vertical-align\r\n>这种垂直居中方法只需给父元素设置display: table-cell,同时设置vertical-align：middle即可。\r\n\r\n```css\r\n.parent {\r\n  width: 400px;\r\n  height: 400px;\r\n  border: 1px solid red;\r\n  display: table-cell;\r\n  vertical-align: middle;\r\n}\r\n\r\n.child {\r\n  width: 200px;\r\n  height: 100px;\r\n  background: blue;\r\n}\r\n```\r\n\r\n#### 子绝对父相对 + margin偏移\r\n>这种定位，首先需要子绝父相，然后通过margin进行偏移，缺点是需要知道宽高才可以。\r\n\r\n```css\r\n.parent {\r\n  width: 400px;\r\n  height: 400px;\r\n  border: 1px solid red;\r\n  position: relative;\r\n}\r\n\r\n.child {\r\n  width: 200px;\r\n  height: 100px;\r\n  background: blue;\r\n  position: absolute;\r\n  top: 50%;\r\n  margin-top: -50px;\r\n}\r\n```\r\n\r\n#### 自绝对父相对 + transform\r\n>子元素设置绝对定位，父元素设置相对定位，然后通过transform进行平移偏移量。\r\n\r\n```css\r\n.parent {\r\n  width: 400px;\r\n  height: 400px;\r\n  border: 1px solid red;\r\n  position: relative;\r\n}\r\n\r\n.child {\r\n  width: 200px;\r\n  height: 100px;\r\n  background: blue;\r\n  position: absolute;\r\n  top: 50%;\r\n  transform: translate(0,-50%);\r\n}\r\n```\r\n\r\n#### 借助伪元素\r\n>给父元素内部设置before伪元素，这个伪元素的高度设置为100%，内容设置为空，并设置为行内块元素，然后设置行内垂直对齐。子元素也要设置为行内块元素，行内垂直对齐。\r\n\r\n```css\r\n.parent {\r\n  width: 400px;\r\n  height: 400px;\r\n  border: 1px solid red;\r\n  text-align: center;\r\n}\r\n\r\n.child {\r\n  width: 200px;\r\n  height: 100px;\r\n  background: blue;\r\n  display: inline-block;\r\n  vertical-align: middle;\r\n}\r\n.parent::before {\r\n  height: 100%;\r\n  content: '';\r\n  display: inline-block;\r\n  vertical-align: middle;\r\n}\r\n```\r\n\r\n## 三、垂直水平居中\r\n### 不定宽高\r\n>注意：这里的不定宽高指的是子元素的宽高不知道，并不是父元素的不知道。\r\n\r\n#### 方式1：绝对定位 +  transform\r\n\r\n* HTML结构\r\n\r\n```html\r\n  <div class=\"parent\">\r\n    <div class=\"child\">child</div>\r\n  </div>\r\n```\r\n\r\n* CSS样式\r\n\r\n```css\r\n  <style>\r\n    .parent {\r\n      width: 200px;\r\n      height: 200px;\r\n      border: 1px solid red;\r\n      position: relative;\r\n    }\r\n    .child {\r\n      position: absolute;\r\n      background: yellow;\r\n      left: 50%;\r\n      top: 50%;\r\n      transform: translate(-50%,-50%);\r\n    }\r\n  </style>\r\n```\r\n\r\n#### 方式2：table-cell布局\r\n\r\n* HTML样式\r\n\r\n```html\r\n  <div class=\"parent\">\r\n    <div class=\"child\">child</div>\r\n  </div>\r\n```\r\n\r\n* css样式\r\n\r\n```css\r\n  <style>\r\n    .parent {\r\n      width: 200px;\r\n      height: 200px;\r\n      border: 1px solid red;\r\n      display: table-cell;\r\n      text-align: center;\r\n      vertical-align: middle;\r\n    }\r\n    .child {\r\n      background: yellow;\r\n      display: inline-block;\r\n    }\r\n  </style>\r\n```\r\n\r\n#### 方式3：flex布局\r\n\r\n* HTML样式\r\n\r\n```html\r\n  <div class=\"parent\">\r\n    <div class=\"child\">child</div>\r\n  </div>\r\n```\r\n\r\n* css样式\r\n\r\n```css\r\n  <style>\r\n    .parent {\r\n      width: 200px;\r\n      height: 200px;\r\n      border: 1px solid red;\r\n      display: flex;\r\n      align-items: center;\r\n      justify-content: center;\r\n    }\r\n    .child {\r\n      background: yellow;\r\n    }\r\n  </style>\r\n```\r\n\r\n#### 方式4：flex + margin:auto\r\n\r\n* HTML样式\r\n\r\n```html\r\n  <div class=\"parent\">\r\n    <div class=\"child\">child</div>\r\n  </div>\r\n```\r\n\r\n* css样式\r\n\r\n```css\r\n  <style>\r\n    .parent {\r\n      width: 200px;\r\n      height: 200px;\r\n      border: 1px solid red;\r\n      display: flex;\r\n    }\r\n    .child {\r\n      margin: auto;\r\n      background: yellow;\r\n    }\r\n  </style>\r\n```\r\n\r\n#### 方式5：grid布局 + flex布局\r\n\r\n* HTML样式\r\n\r\n```html\r\n  <div class=\"parent\">\r\n    <div class=\"child\">child</div>\r\n  </div>\r\n```\r\n\r\n* css样式\r\n\r\n```css\r\n  <style>\r\n    .parent {\r\n      width: 200px;\r\n      height: 200px;\r\n      border: 1px solid red;\r\n      display: grid;\r\n    }\r\n    .child {\r\n      background: yellow;\r\n      align-self: center;\r\n      justify-self: center;\r\n    }\r\n  </style>\r\n```\r\n\r\n#### 方式6：grid布局 + margin: auto\r\n\r\n* HTML样式\r\n\r\n```html\r\n  <div class=\"parent\">\r\n    <div class=\"child\">child</div>\r\n  </div>\r\n```\r\n\r\n* css样式\r\n\r\n```css\r\n  <style>\r\n    .parent {\r\n      width: 200px;\r\n      height: 200px;\r\n      border: 1px solid red;\r\n      display: grid;\r\n    }\r\n    .child {\r\n      background: yellow;\r\n      margin: auto\r\n    }\r\n  </style>\r\n```\r\n\r\n### 定宽高\r\n>注意：这里的定宽高指的是子元素的宽高是已知的。\r\n\r\n#### 方式1：绝对定位 + 负margin值\r\n\r\n* HTML样式\r\n\r\n```html\r\n  <div class=\"parent\">\r\n    <div class=\"child\">child</div>\r\n  </div>\r\n```\r\n\r\n* CSS样式\r\n\r\n```css\r\n  <style>\r\n    .parent {\r\n      width: 200px;\r\n      height: 200px;\r\n      border: 1px solid red;\r\n      position: relative;\r\n    }\r\n    .child {\r\n      background: yellow;\r\n      position: absolute;\r\n      width: 100px;\r\n      height: 100px;\r\n      left: 50%;\r\n      top: 50%;\r\n      margin-left: -50px;\r\n      margin-top: -50px;\r\n    }\r\n  </style>\r\n```\r\n\r\n#### 方式2：绝对定位 + transform (定宽/不定宽 通用)\r\n\r\n* HTML样式\r\n\r\n```html\r\n  <div class=\"parent\">\r\n    <div class=\"child\">child</div>\r\n  </div>\r\n```\r\n\r\n* CSS样式\r\n\r\n```css\r\n.parent {\r\n  width: 200px;\r\n  height: 200px;\r\n  border: 1px solid red;\r\n  position: relative;\r\n}\r\n.child {\r\n  background: yellow;\r\n  position: absolute;\r\n  width: 100px;\r\n  height: 100px;\r\n  left: 50%;\r\n  top: 50%;\r\n  transform: translate(-50%,-50%);\r\n}\r\n```\r\n\r\n#### 方式3：绝对定位 + left/top/right/bottom + margin: auto\r\n\r\n* HTML样式\r\n\r\n```html\r\n  <div class=\"parent\">\r\n    <div class=\"child\">child</div>\r\n  </div>\r\n```\r\n\r\n* css样式\r\n\r\n```css\r\n  <style>\r\n    .parent {\r\n      width: 200px;\r\n      height: 200px;\r\n      border: 1px solid red;\r\n      position: relative;\r\n    }\r\n    .child {\r\n      background: yellow;\r\n      position: absolute;\r\n      width: 100px;\r\n      height: 100px;\r\n      left: 0;\r\n      right: 0;\r\n      top: 0;\r\n      bottom: 0;\r\n      margin: auto;\r\n    }\r\n  </style>\r\n```\r\n\r\n#### 方式4：flex布局（定宽高和不定宽高：通用）\r\n\r\n* HTML样式\r\n\r\n```html\r\n  <div class=\"parent\">\r\n    <div class=\"child\">child</div>\r\n  </div>\r\n```\r\n\r\n* CSS样式\r\n\r\n```css\r\n    .parent {\r\n      width: 200px;\r\n      height: 200px;\r\n      border: 1px solid red;\r\n      display: flex;\r\n      align-items: center;\r\n      justify-content: center;\r\n    }\r\n    .child {\r\n      background: yellow;\r\n      width: 100px;\r\n      height: 100px;\r\n    }\r\n```\r\n \r\n#### 方式5：grid布局 + margin: auto（通用）\r\n \r\n* HTML样式\r\n \r\n```html\r\n<div class=\"parent\">\r\n   <div class=\"child\">child</div>\r\n</div>\r\n```\r\n\r\n* CSS样式\r\n\r\n```css\r\n.parent {\r\n  width: 200px;\r\n  height: 200px;\r\n  border: 1px solid red;\r\n  display: grid;\r\n}\r\n.child {\r\n  background: yellow;\r\n  width: 100px;\r\n  height: 100px;\r\n  margin: auto;\r\n}\r\n```\r\n\r\n#### 方式6：table-cell布局（通用）\r\n\r\n* HTML样式\r\n\r\n```html\r\n  <div class=\"parent\">\r\n    <div class=\"child\">child</div>\r\n  </div>\r\n```\r\n\r\n* CSS样式\r\n\r\n```css\r\n.parent {\r\n  width: 200px;\r\n  height: 200px;\r\n  border: 1px solid red;\r\n  display: table-cell;\r\n  text-align: center;\r\n  vertical-align: middle;\r\n}\r\n.child {\r\n  background: yellow;\r\n  width: 100px;\r\n  height: 100px;\r\n  display: inline-block;\r\n}\r\n```\r\n\r\n## 四、图片居中的方法\r\n>关于图片的垂直水平居中，可以参考上文提到的几种通用垂直水平居中的方法，原理是一样的。\r\n\r\n* 绝对定位 + transform\r\n\r\n* flex布局\r\n\r\n* grid布局 + margin: auto\r\n\r\n* table-cell布局\r\n\r\n## 五、自适应垂直水平居中\r\n\r\n* 方式1：绝对定位 + left/top/right/bottom + margin: auto\r\n\r\n* 方式2：绝对定位 + transform \r\n\r\n* 方式3：flex布局"
    },
    {
      "id": "/使用JS打印九九乘法表",
      "metadata": {
        "permalink": "/blog/使用JS打印九九乘法表",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/使用JS打印九九乘法表.md",
        "source": "@site/blog\\使用JS打印九九乘法表.md",
        "title": "使用JS打印九九乘法表",
        "description": "今天博主看到天眼查的一道面试题，让候选人说出如何使用JS打印九九乘法表，这道题目对很多人来说可能很简单，但是博主还是想和大家分享一下，如何解决这个问题，分析下这个问题的思路，以帮助大家巩固基础，让我们来一起探究这个问题吧~",
        "date": "2021-11-14T00:00:00.000Z",
        "formattedDate": "2021年11月14日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 2.455,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "使用JS打印九九乘法表",
          "date": "2021-11-14T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "这一次，彻底搞懂垂直水平居中",
          "permalink": "/blog/这一次，彻底搞懂垂直水平居中"
        },
        "nextItem": {
          "title": "Egg.js中间件进行登录鉴权的核心思路",
          "permalink": "/blog/Egg.js中间件进行登录鉴权的核心思路"
        }
      },
      "content": "> 今天博主看到天眼查的一道面试题，让候选人说出如何使用JS打印九九乘法表，这道题目对很多人来说可能很简单，但是博主还是想和大家分享一下，如何解决这个问题，分析下这个问题的思路，以帮助大家巩固基础，让我们来一起探究这个问题吧~\r\n\r\n## 题目描述\r\n>使用JS打印九九乘法表，目标是实现下图的样式。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/af3c91101a6e6167d100b8bc49ae711c.png)\r\n\r\n## 解题思路\r\n>从上图的九九乘法表我们能够看出什么规律，总共有九行，从第二行开始每一行比前一行多一列，这就是我们的核心解决思路，通过两层循环即可解决这个问题，外层循环用于控制行数，总共有九行，也就是r从1-9，内层循环从1到r即可，然后通过模板字符串进行一个字符串拼接即可，每次内层循环的for结束后，便开始打印当前行的结果。\r\n\r\n```js\r\n// 外层循环控制的是行数，表示的是1-9行\r\n// 内层循环控制的是列数\r\nfor (let r = 1; r <= 9; r++) {\r\n  let char = \"\";\r\n  for (let c = 1; c <= r; c++) {\r\n    char += (`${c}*${r} = ${c*r}\\t`)\r\n  };\r\n  console.log(char);\r\n}\r\n```\r\n\r\n## 题目反思\r\n>通过这个题目，我想告诉大家的是，一定要重视基础，不要小看任何基础的题目，一旦在面试的时候遇到了，不一定就能做得出来，而这些基础的题目，反而容易造成面试官对我们的真实水平的误判，因此，请大家一定要注意基础题目的解法。\r\n\r\n* 九九乘法表的本质就是从打印顺序中找出规律，通过循环来控制行列之间的关系，内层循环次数和外层循环次数的关系是本题的核心。"
    },
    {
      "id": "/Egg.js中间件进行登录鉴权的核心思路",
      "metadata": {
        "permalink": "/blog/Egg.js中间件进行登录鉴权的核心思路",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Egg.js中间件进行登录鉴权的核心思路.md",
        "source": "@site/blog\\Egg.js中间件进行登录鉴权的核心思路.md",
        "title": "Egg.js中间件进行登录鉴权的核心思路",
        "description": "无论是在实际项目中还是在面试中，只要涉及到项目的问题，注册登录如何验证的问题，总是面试官的宠儿，这一次让我们来系统性的梳理如何完成一次登录的验证。（注意：项目实现的基础是以Egg.js作为后台实现的）",
        "date": "2021-11-13T00:00:00.000Z",
        "formattedDate": "2021年11月13日",
        "tags": [
          {
            "label": "Egg.js",
            "permalink": "/blog/tags/egg-js"
          }
        ],
        "readingTime": 4,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Egg.js中间件进行登录鉴权的核心思路",
          "date": "2021-11-13T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Egg.js",
          "tags": [
            "Egg.js"
          ]
        },
        "prevItem": {
          "title": "使用JS打印九九乘法表",
          "permalink": "/blog/使用JS打印九九乘法表"
        },
        "nextItem": {
          "title": "LeetCode——K个一组翻转链表（三指针）",
          "permalink": "/blog/LeetCode——K个一组翻转链表（三指针）"
        }
      },
      "content": ">无论是在实际项目中还是在面试中，只要涉及到项目的问题，注册登录如何验证的问题，总是面试官的宠儿，这一次让我们来系统性的梳理如何完成一次登录的验证。（注意：项目实现的基础是以Egg.js作为后台实现的）\r\n\r\n## 第一步：配置中间件\r\n\r\n1. 在middleware下创建adminAuth.js文件\r\n\r\n* 中间件中需要配置csrf全局变量，让表单post的数据能够正常的到达控制器login.js\r\n* 通过url模块拿到用户不带请求参数的请求路径\r\n* 首先判断session中userinfo是否存在，并且username是否存在，两个条件都满足的时候，才允许继续执行，只要有一个不满足则判断路径是否是涉及到登录的路径，如果是则允许继续进行，这样是为了防止死锁现象的发生，如果不是涉及到登录的路径，则跳转到登录页面，让用户登录。\r\n\r\n```js\r\nconst url = require(\"url\");\r\n\r\nmodule.exports = (options) => {\r\n  return async function adminAuth(ctx,next) {\r\n    console.log(\"中间件\");\r\n    console.log(ctx.request.url);\r\n    // 配置全局变量\r\n    ctx.state.csrf = ctx.csrf;\r\n    const pathname = url.parse(ctx.request.url).pathname;\r\n    if (ctx.session.userinfo && ctx.session.userinfo.username) {\r\n      await next();\r\n    } else {\r\n      // 没有权限则跳转到登录\r\n      if (pathname === \"/admin/login\" || pathname === \"/admin/doLogin\" || pathname === \"/admin/login/captcha\") {\r\n        await next();        \r\n      } else {\r\n        ctx.redirect(\"/admin/login\");\r\n      }\r\n    }\r\n    // await next();\r\n  }\r\n}\r\n```\r\n\r\n2. 在config.default.js中注册中间件\r\n\r\n* 设置中间件只拦截路径包含/admin。\r\n\r\n```js\r\n  config.middleware = [\"adminAuth\"];\r\n  config.adminAuth = {\r\n    match: '/admin'\r\n  }\r\n```\r\n\r\n## 第二步：使用Sequelize操作数据库\r\n### 数据库结构\r\n\r\n* 数据表结构\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/6e088c53dd4c1f86d5a78fc0ede37100.png)\r\n\r\n* 安装sequelize插件\r\n\r\n```shell\r\nnpm install --save egg-sequelize mysql2\r\n```\r\n\r\n* 在plugin.js中引入插件\r\n\r\n```js\r\nmodule.exports = {\r\n  // had enabled by egg\r\n  static: {\r\n    enable: true\r\n  },\r\n  ejs: {\r\n    enable: true,\r\n    package: 'egg-view-ejs'\r\n  },\r\n  sequelize: {\r\n    enable: true,\r\n    package: 'egg-sequelize',\r\n  }\r\n}\r\n```\r\n\r\n* 在config.default.js中配置数据库的基本信息\r\n\r\n```js\r\n  config.sequelize = {\r\n    dialect: 'mysql',\r\n    host: 'localhost',\r\n    port: 3306,\r\n    username: \"root\",\r\n    password: \"123456\",\r\n    database: 'eggshop',\r\n  };\r\n```\r\n\r\n* 在app下新建model文件夹并在这个文件夹下建立admin.js\r\n\r\n```js\r\n'use strict';\r\n\r\nmodule.exports = app => {\r\n  const { STRING, INTEGER, DATE } = app.Sequelize;\r\n\r\n  const Admin = app.model.define('admin', {\r\n    id: {type: INTEGER,primaryKey: true,autoIncrement: true},\r\n    username: STRING(255),\r\n    password: STRING(32),\r\n    mobile: STRING(32),\r\n    email: STRING(255),\r\n    status: INTEGER(1),\r\n    roleId: INTEGER(11),\r\n    addTime: INTEGER(11),\r\n    isSuper: INTEGER(1),\r\n    lastLogin: INTEGER(11),\r\n  },{\r\n    timestamps: false,\r\n    tableName: 'admin'     \r\n  });\r\n\r\n  return Admin;\r\n};\r\n```\r\n\r\n## 第三步：处理登录信息\r\n### 将用户的密码进行md5加密\r\n1. 安装md5模块\r\n\r\n```shell\r\nnpm install md5\r\n```\r\n\r\n2. 在服务中封装md5\r\n\r\n```js\r\nconst md5 = require('md5');\r\nclass ToolsService extends Service {\r\n  md5(msg) {\r\n    return md5(msg);\r\n  }\r\n}\r\n```\r\n\r\n### 在控制器中处理核心登录逻辑\r\n1. 获取用户输入的用户名、密码、验证码。\r\n2. 首先判断用户输入的验证码和session中存在的验证码是否一致，如果不一致则跳转到登录页面，一致则进行第三步。\r\n3. 通过sequelize框架去数据库中查询该用户名和密码是否存在，如果存在则跳转到管理模块，如果不存在则跳转到登录登录模块。\r\n\r\n>注意：服务器存储验证码的时候是用户获取验证码的时候，也就是说用户获取验证码的时候同时将这个验证码存储在了服务器端。"
    },
    {
      "id": "/LeetCode——K个一组翻转链表（三指针）",
      "metadata": {
        "permalink": "/blog/LeetCode——K个一组翻转链表（三指针）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——K个一组翻转链表（三指针）.md",
        "source": "@site/blog\\LeetCode——K个一组翻转链表（三指针）.md",
        "title": "LeetCode——K个一组翻转链表（三指针）",
        "description": "题目描述",
        "date": "2021-11-12T00:00:00.000Z",
        "formattedDate": "2021年11月12日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 2.455,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——K个一组翻转链表（三指针）",
          "date": "2021-11-12T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "Egg.js中间件进行登录鉴权的核心思路",
          "permalink": "/blog/Egg.js中间件进行登录鉴权的核心思路"
        },
        "nextItem": {
          "title": "Egg中使用Sequelize ORM框架操作MySQL--增删改查",
          "permalink": "/blog/Egg中使用Sequelize ORM框架操作MySQL--增删改查"
        }
      },
      "content": "## 题目描述\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/b5e72973697fc02eb24bd50bc40767a4.png)\r\n\r\n## 解题思路\r\n1. 首先判断传入的链表的长度是否小于K，如果小于K则返回原链表。\r\n2. 如果传入的链表的长度大于等于k，则继续下面的判断。\r\n3. 初始化两个指针，prev和cur,prev指针初始的时候为null,cur初始的时候为head指针指向的位置。\r\n4. 核心循环：首先保存当前指针的下一个指针，然后让prev前进一个，让cur前进一个，最后将cur指针指向的投入递归，所有递归结束的时候，返回prev。\r\n\r\n## AC代码\r\n```js\r\nvar reverseKGroup = function(head, k) {\r\n  // 首先判断传入的链表的长度是否小于k，如果小于k，则返回原链表\r\n  let flag = 0;\r\n  let temp = head;\r\n  while (temp) {\r\n    temp = temp.next;\r\n    flag++;\r\n  }\r\n  if (flag < k) {\r\n    return head;\r\n  }\r\n  // 初始化指针\r\n  let prev = null;\r\n  let cur = head;\r\n  let n = k;\r\n  while (cur != null && n-- > 0) {\r\n    // 首先保存后一个节点\r\n    let next = cur.next;\r\n    // cur指针的next域指向前一个节点\r\n    cur.next = prev;\r\n    prev = cur;\r\n    cur = next;\r\n  }\r\n  // 修改head指针的next域指向递归的返回结果\r\n  head.next = reverseKGroup(cur,k);\r\n  return prev;\r\n};\r\n```\r\n\r\n## 图解核心思路\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/b9c34525dc547d9dad167255923006c4.png)\r\n\r\n## 题目反思\r\n* 关于链表反转类题目，可能会用到三指针，我们要想到这一点。\r\n* 指针反转的时候，很重要的一步就是保存后一个指针，防止这个指针丢失。\r\n* 循环的时候，一定要搞清楚当循环结束的时候，每一个指针所在的位置，以及每一个指针的含义，只有搞清楚这一点，才知道将哪一个指针投入递归，才明白递归返回的结果的含义。\r\n* 链表类的题目中，反转各种链表是面试的常考题，这道题目指的我们反复揣摩。\r\n\r\n## 参考链接\r\n* [LeetCode题解](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/25-k-ge-yi-zu-fan-zhuan-lian-biao-by-xin-wves/)"
    },
    {
      "id": "/Egg中使用Sequelize ORM框架操作MySQL--增删改查",
      "metadata": {
        "permalink": "/blog/Egg中使用Sequelize ORM框架操作MySQL--增删改查",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Egg中使用Sequelize ORM框架操作MySQL--增删改查.md",
        "source": "@site/blog\\Egg中使用Sequelize ORM框架操作MySQL--增删改查.md",
        "title": "Egg中使用Sequelize ORM框架操作MySQL--增删改查",
        "description": "一、什么是Sequelize？",
        "date": "2021-11-11T00:00:00.000Z",
        "formattedDate": "2021年11月11日",
        "tags": [
          {
            "label": "Egg.js",
            "permalink": "/blog/tags/egg-js"
          }
        ],
        "readingTime": 2.385,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Egg中使用Sequelize ORM框架操作MySQL--增删改查",
          "date": "2021-11-11T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Egg.js",
          "tags": [
            "Egg.js"
          ]
        },
        "prevItem": {
          "title": "LeetCode——K个一组翻转链表（三指针）",
          "permalink": "/blog/LeetCode——K个一组翻转链表（三指针）"
        },
        "nextItem": {
          "title": "LeetCode——Excel表列名称（进制转换）",
          "permalink": "/blog/LeetCode——Excel表列名称（进制转换）"
        }
      },
      "content": "## 一、什么是Sequelize？\r\n>Sequelize是一个基于Promise的Node.js ORM，它具有强大的事务支持，关联关系，预读和延迟加载，读取复制等功能。\r\n\r\n## 二、使用Sequelize操作MySQL数据库\r\n>更多操作方法，请参考官方文档：https://eggjs.org/zh-cn/tutorials/sequelize.html\r\n\r\n1. 安装egg-sequelize以及mysql2\r\n\r\n2. 在config/plugin.js中引入egg-sequelize插件\r\n\r\n```js\r\nexports.sequelize = {\r\n    enable: true,\r\n    package: 'egg-sequelize'\r\n};\r\n```\r\n\r\n3. 在config/config.default.js中添加下面的配置\r\n\r\n```js\r\nconfig.sequelize = {\r\n    dialect: 'mysql',\r\n    host: '127.0.0.1',\r\n    port: 3306,\r\n    database: 'bank',\r\n    username: 'root',\r\n    password: \"123456\"\r\n  };\r\n```\r\n\r\n## 三、Sequelize操作MySQL实现数据的增删改查\r\n1. 在app下新建文件夹model，并在model中创建文件user.js\r\n\r\n>注意：如果define中的是user，我们定义的数据表要是users，也就是说需要是复数形式。\r\n\r\n```js\r\n'use strict';\r\n\r\nmodule.exports = app => {\r\n  const { STRING, INTEGER, DATE } = app.Sequelize;\r\n\r\n  const User = app.model.define('user', {\r\n    id: { type: INTEGER, primaryKey: true, autoIncrement: true },\r\n    username: STRING(30),\r\n    age: INTEGER,\r\n    sex: STRING(30),\r\n    created_at: DATE,\r\n    updated_at: DATE,\r\n  });\r\n\r\n  return User;\r\n};\r\n```\r\n\r\n2. 可以通过Navicat可视化工具建立下面的数据表结构\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/24bfb7648cc587679d94fbe5e428a223.png)\r\n\r\n### 增加数据\r\n\r\n```js\r\n  // 增加数据\r\n  async create() {\r\n    const user = await this.ctx.model.User.create({username: \"张三\",age: 20});\r\n    this.ctx.body = user;\r\n  }\r\n```\r\n\r\n### 查询数据\r\n\r\n>更多其他的查询方法,请查看官方文档:https://www.sequelize.com.cn/core-concepts/model-querying-finders\r\n\r\n1. 查询所有数据\r\n\r\n```js\r\n  // 查询数据\r\n  async query() {\r\n    const userList = await this.ctx.model.User.findAll();\r\n    this.ctx.body = userList;\r\n  }\r\n```\r\n\r\n2. 查询指定字段的数据\r\n\r\n```js\r\n// 查询指定字段的数据\r\nconst userList = await this.ctx.model.User.findAll({attributes: ['id','username']});\r\n```\r\n\r\n3. 应用where进行查询\r\n\r\n```js\r\nconst userList = await this.ctx.model.User.findAll({where: {\"id\": 2}});\r\n```\r\n\r\n4. 对数据进行排序\r\n\r\n```js\r\nconst userList = await this.ctx.model.User.findAll({order: [['id', 'ASC']]});\r\n```\r\n\r\n### 修改数据\r\n\r\n* 根据主键进行修改\r\n\r\n```js\r\n  async update() {\r\n    // 根据主键修改\r\n    const user = await this.ctx.model.User.findByPk(2);\r\n    user.update({\"username\": \"秦二世\",\"age\": 10});\r\n    this.ctx.body = \"修改成功\"\r\n  }\r\n```\r\n\r\n### 删除数据\r\n\r\n* 根据主键删除某个数据\r\n\r\n```js\r\n  async delete() {\r\n    const data = await this.ctx.model.User.findByPk(2);\r\n    if (!data) {\r\n      this.ctx.state = 404;\r\n      return;\r\n    }\r\n    data.destroy();\r\n    this.ctx.body = \"删除成功\";\r\n  }\r\n```"
    },
    {
      "id": "/LeetCode——Excel表列名称（进制转换）",
      "metadata": {
        "permalink": "/blog/LeetCode——Excel表列名称（进制转换）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——Excel表列名称（进制转换）.md",
        "source": "@site/blog\\LeetCode——Excel表列名称（进制转换）.md",
        "title": "LeetCode——Excel表列名称（进制转换）",
        "description": "题目描述",
        "date": "2021-11-10T00:00:00.000Z",
        "formattedDate": "2021年11月10日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 2.09,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——Excel表列名称（进制转换）",
          "date": "2021-11-10T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "Egg中使用Sequelize ORM框架操作MySQL--增删改查",
          "permalink": "/blog/Egg中使用Sequelize ORM框架操作MySQL--增删改查"
        },
        "nextItem": {
          "title": "使用egg-mysql操作MySQL数据库",
          "permalink": "/blog/使用egg-mysql操作MySQL数据库"
        }
      },
      "content": "## 题目描述\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/cb8d01e57fb0a825819f7a2a010a7e0b.png)\r\n\r\n## 解题思路\r\n1. 定义一个存储结果的数组。\r\n2. 以输入的数字为循环条件，首先将数字-1，之所以要减1，是因为题目中字母和数字的对应顺序，并不是真正的26进账，通过-1，可以将其装换为26进制。\r\n3. 变为26进制之后，数字对26取余，得出的结果+65,然后使用String.fromCharCode转换为对应的字符，每次都放在数组的头部，然后除以26，向下取整即可。\r\n4. 将结果数组拼接为字符串。\r\n\r\n## AC代码\r\n\r\n```js\r\nvar convertToTitle = function(columnNumber) {\r\n  \r\n  const res = [];\r\n\r\n  while (columnNumber) {\r\n    // 将数字-1，是这道题目的灵魂，之所以减一，是为了让该数字变为正常的26进制\r\n    columnNumber--;\r\n    let remain = columnNumber % 26;\r\n    res.unshift(String.fromCharCode(remain + 65));\r\n    columnNumber = Math.floor(columnNumber / 26);\r\n  }\r\n\r\n  return res.join(\"\");\r\n\r\n};\r\n```\r\n\r\n\r\n## 题目反思\r\n* 学会使用String.fromCharCode(number)，将一个数字装换为对应的ASCII码值。\r\n* 学会进制转换，通过循环的方式。\r\n\r\n## 以十进制为例，泛化题解\r\n```js\r\nvar convertToTitle = function (n) {\r\n  if (n <= 0) return \"\";\r\n\r\n  let res = [];\r\n  while (n) {\r\n    let remain = n % 10;\r\n    res.unshift(String.fromCharCode(remain + 65));\r\n    n = Math.floor(n / 10);\r\n  }\r\n  return res.join(\"\");\r\n};\r\n```\r\n\r\n## 还有没有类似fromCharCode的API？\r\n>类似的有charAt和charCodeAt，下面让我们一一来解决他们，做题的时候，就要举一反三。\r\n\r\n* charAt()：根据字符串的索引找到对应的字符。（个人感觉这个API，可能不太常用，因为我们可以直接str[i]来获取）\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/16c7c1d912445e2362b6135d6692e507.png)\r\n\r\n* charCodeAt()：返回对应字符的ASCII码。（内部传的是索引）\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/dbdc867b5dfc6e1d4392ef918f40f6d8.png)\r\n\r\n\r\n## 参考链接\r\n[MDN：String.fromCharCode](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode)\r\n\r\n[LeetCode题解](https://leetcode-cn.com/problems/excel-sheet-column-title/solution/javascript-shi-26jin-zhi-dan-bu-wan-quan-yjmm/)"
    },
    {
      "id": "/使用egg-mysql操作MySQL数据库",
      "metadata": {
        "permalink": "/blog/使用egg-mysql操作MySQL数据库",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/使用egg-mysql操作MySQL数据库.md",
        "source": "@site/blog\\使用egg-mysql操作MySQL数据库.md",
        "title": "使用egg-mysql操作MySQL数据库",
        "description": "MySQL事务",
        "date": "2021-11-09T00:00:00.000Z",
        "formattedDate": "2021年11月9日",
        "tags": [
          {
            "label": "Egg.js",
            "permalink": "/blog/tags/egg-js"
          }
        ],
        "readingTime": 4.15,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "使用egg-mysql操作MySQL数据库",
          "date": "2021-11-09T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Egg.js",
          "tags": [
            "Egg.js"
          ]
        },
        "prevItem": {
          "title": "LeetCode——Excel表列名称（进制转换）",
          "permalink": "/blog/LeetCode——Excel表列名称（进制转换）"
        },
        "nextItem": {
          "title": "晨兴夜寐：这一次，彻底搞懂Cookie,LocalStorage,SessionStorage",
          "permalink": "/blog/晨兴夜寐：这一次，彻底搞懂Cookie,LocalStorage,SessionStorage"
        }
      },
      "content": "## MySQL事务\r\n>事务处理可以用来维护数据库的完整性，保证成批的SQL语句，要么全部执行，要么全部不执行。当批量执行SQL的时候，事务可以保证我们数据的一致性。\r\n\r\n>下面是完整的执行流程\r\n\r\n```shell\r\nbegin;\r\n\r\nupdate user set balance = balance - 100 where id = 1;\r\n\r\nupdate user set balance = balance + 100 where id = 2;\r\n\r\ncommit;\r\n```\r\n\r\n>如果遇到错误，可以不commit，而是使用rollback进行事务回滚。\r\n\r\n## MySQL锁\r\n### 1. 添加读锁\r\n>设置读锁期间，在没释放锁之前是不能进行写操作的。\r\n\r\n```shell\r\nlock table user read;\r\n\r\nupdate user set username=\"李四\" where id = 3;\r\n```\r\n\r\n>上面的用法会报错：Table 'user' was locked with a READ lock and can't be updated。\r\n\r\n>只有解除锁的时候才可以进行写操作。\r\n\r\n```shell\r\nlock table user read;\r\nunlock tables;\r\n\r\nupdate user set username=\"李四\" where id = 3;\r\n```\r\n\r\n>上面的写法是正确的。\r\n\r\n### 2. 添加写锁\r\n>只有锁表的用户可以进行读写操作，其他用户即不能读也不能写。只有释放这个锁的时候才可以进行读写，因此在演示的时候，建议开启两个不同的命令行进行演示。\r\n\r\n```shell\r\nlock table user write;\r\n\r\nselect * from user;\r\n\r\nupdate user set username = \"333\" where id = 3;\r\n\r\nunlock tables;\r\n```\r\n\r\n## 使用egg-mysql操作MySQL数据库\r\n### 配置egg-mysql\r\n>egg-mysql的插件地址：https://www.npmjs.com/package/egg-mysql\r\n\r\n1. 安装插件\r\n\r\n```shell\r\nnpm i egg-mysql\r\n```\r\n\r\n2. 启用插件\r\n\r\n>在config/plugin.js中启用这个插件，如果此时已经有了其他的插件，我们可以通过并行的方式进行添加，请看下面的例子。\r\n\r\n```js\r\nexports.ejs = {\r\n  enable: true,\r\n  package: 'egg-view-ejs'\r\n};\r\n\r\nexports.mysql = {\r\n  enable: true,\r\n  package: 'egg-mysql',\r\n};\r\n```\r\n\r\n3. 配置数据库的连接\r\n\r\n>找到config.default.js文件，并在其中添加下面的语句进行配置连接数据库。\r\n\r\n```js\r\nexports.mysql = {\r\n  // database configuration\r\n  client: {\r\n    // host\r\n    host: 'mysql.com',\r\n    // port\r\n    port: '3306',\r\n    // username\r\n    user: 'test_user',\r\n    // password\r\n    password: 'test_password',\r\n    // database\r\n    database: 'test',    \r\n  },\r\n  // load into app, default is open\r\n  app: true,\r\n  // load into agent, default is close\r\n  agent: false,\r\n};\r\n```\r\n\r\n### 对数据库数据的增删改查\r\n>更多关于对数据库的操作方法，请查询网址：https://eggjs.org/zh-cn/tutorials/mysql.html#read\r\n\r\n#### 读取数据\r\n\r\n```js\r\n// 查询一条数据\r\nconst result = await this.app.mysql.get('user',{\"id\": 3});\r\n// 查询全部数据\r\nconst all = await this.app.mysql.select('user',{});\r\n// 带限制条件的\r\nconst all = await this.app.mysql.select('user',{\r\n  where: {\"id\": 3}，\r\n  // 升序排列\r\n  orders: [[\"id\",\"asc\"]]\r\n});\r\n```\r\n\r\n#### 添加数据\r\n```js\r\nconst add = await this.app.mysql.insert('user',{username: '秦始皇',balance: '100000'});\r\n```\r\n\r\n#### 修改数据\r\n1. 根据主键进行修改\r\n\r\n```js\r\n// 根据主键进行修改\r\nconst row = {\r\n  id: 3,\r\n  username: '王五'\r\n}\r\nconst result = await this.app.mysql.update('user',row);\r\n```\r\n\r\n2. 通过原生SQL语句来修改数据\r\n\r\n```js\r\nconst result = await this.app.mysql.query('update user set username=? where id = ?',[\"皇家礼炮\",5]);\r\n```\r\n\r\n#### 删除数据\r\n>下面的删除方式会把所有符合条件的都删除掉。\r\n\r\n```js\r\nconst result = await this.app.mysql.delete('user',{\r\n      username: '秦始皇'\r\n    })\r\n```\r\n\r\n### 操作MySQL事务\r\n>使用事务的时候，如果出现错误，不会真正的执行SQL语句，防止造成不同步的问题。\r\n\r\n```js\r\n// mysql事务\r\nconst conn = await this.app.mysql.beginTransaction();\r\n\r\ntry {\r\n  // await conn.insert(table, row1);\r\n  // await conn.update(table, row2);\r\n\r\n  // 增加数据\r\n  await conn.query('update user set username=? where id = ?',[\"皇家礼炮666\",5]);\r\n  await conn.insert('user',{username: '秦始皇2',balance: '100000'});\r\n\r\n  await conn.commit();\r\n} catch (err) {\r\n  // error, rollback\r\n  await conn.rollback(); // rollback call won't throw err\r\n  throw err;\r\n}\r\n```"
    },
    {
      "id": "/晨兴夜寐：这一次，彻底搞懂Cookie,LocalStorage,SessionStorage",
      "metadata": {
        "permalink": "/blog/晨兴夜寐：这一次，彻底搞懂Cookie,LocalStorage,SessionStorage",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/晨兴夜寐：这一次，彻底搞懂Cookie,LocalStorage,SessionStorage.md",
        "source": "@site/blog\\晨兴夜寐：这一次，彻底搞懂Cookie,LocalStorage,SessionStorage.md",
        "title": "晨兴夜寐：这一次，彻底搞懂Cookie,LocalStorage,SessionStorage",
        "description": "博主在总结了大量的面试经验贴之后，发现关于Cookie的考点是面试官的宠儿，无论是在入职后的工作场景中，还是面试上，这都是我们不可避免的一道坎，所以，让我们一起来跨越这道坎吧，勇于面对它，没有什么困难是不能解决的。",
        "date": "2021-11-08T00:00:00.000Z",
        "formattedDate": "2021年11月8日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 15.455,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "晨兴夜寐：这一次，彻底搞懂Cookie,LocalStorage,SessionStorage",
          "date": "2021-11-08T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "使用egg-mysql操作MySQL数据库",
          "permalink": "/blog/使用egg-mysql操作MySQL数据库"
        },
        "nextItem": {
          "title": "MySQL之跨表查询与索引",
          "permalink": "/blog/MySQL之跨表查询与索引"
        }
      },
      "content": ">博主在总结了大量的面试经验贴之后，发现关于Cookie的考点是面试官的宠儿，无论是在入职后的工作场景中，还是面试上，这都是我们不可避免的一道坎，所以，让我们一起来跨越这道坎吧，勇于面对它，没有什么困难是不能解决的。\r\n\r\n## 一、Cookie\r\n### 什么是Cookie\r\n>HTTP是无状态的协议，对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息，每个请求都是完全独立的，如果服务端想要确认当前访问者的身份信息，就必须主动维护一个状态，这个状态是用来告知服务器前后两个请求是否来自同一个客户端，这个状态就是需要通过cookie或session来实现，cookie就是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器发起请求时被携带并发送到服务器上。\r\n\r\n### Cookie是否可以跨域\r\n>Cookie是不可跨域的，每个Cookie都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间通过domain是允许共享使用的。例如baidu.com是一级域名，asdx.iisp.com则是二级域名。\r\n\r\n\r\n### Cookie的主要用途\r\n* 会话状态管理（如用户登录状态、购物车、游戏分数或其他需要记录的信息）\r\n* 个性化设置（如用户自定义设置、主题等）\r\n* 浏览器行为跟踪（如跟踪分析用户行为等）\r\n\r\n### 如何实现Cookie跨域\r\n>浏览器发起跨域请求的时候，是不会主动带上cookie的，如果想要实现跨域获取cookie，可以进行如下的设置。\r\n\r\n1. 前端发送请求时将withCredentials置为true。\r\n2. 后端将Access-Control-Allow-Origin字段的值设置为发起请求的域名。\r\n3. 后端设置请求头Access-Control-Allow-Credentials置为true。\r\n\r\n### cookie是如何保存到本地的？\r\n>服务端通过返回响应头，set-cookie字段，然后设置对应的值即可。\r\n\r\n### Cookie的各种属性\r\n\r\n#### 1. name\r\n>name表示的是cookie的名字，一个域名下的cookie，name不能相同，相同的name会被覆盖掉。\r\n\r\n#### 2. value\r\n>value属性表示的是对应cookie的值。\r\n\r\n#### 3. domain\r\n>domain属性代表的是cookie绑定的域名，如果没有设置就会自动绑定到执行语句的当前页面，同一个域名下的二级域名是不能交换使用cookie的，比如 www.baidu.com 和image.baidu.com，但是如果设置为.taobao.com，这样无论是a.taobao.com还是b.taobao.com都可以使用cookie，需要注意的是不能跨域设置cookie，比如阿里域名下的页面吧domain设置为百度是无效的。\r\n\r\n#### 4. path\r\n>path指定了可以共享Cookie的子目录，一般情况下默认是根目录你，这样所有的子目录都可以共享，如果设置了子目录，其上级目录是无法访问cookie的，但是其下级目录可以共享该cookie。domain和path共同标识了Cookie的作用域，即Cookie应该发送给哪些URL。\r\n\r\n#### 5. Expires/Max-Age\r\n>这个属性用于设置cookie的有效期，如果没有设置则默认是在会话期间有效即session,所谓的会话期间就是指当客户端被关闭的时候，cookie就会被移除。Expires用于指定具体的过期时间，而Max-Age则以秒为单位设置多少秒之后过期，如果这个值为0表示删除cookie，如果这个值为负数的情况，表示的是临时存储，不会产生cookie文件，如果Max-Age和Expires同时存在，那么Max-Age优先级更高。\r\n\r\n#### 6. HttpOnly\r\n>设置了HttpOnly属性的Cookie不能被JS代码获取到，也就意味着无法通过在浏览器控制台通过document.cookie获取到该cookie，所以这是一种安全措施，能够有效的防止xss攻击。\r\n\r\n#### 7. Secure\r\n>这是cookie的安全属性，标记为Secure的Cookie只能通过HTTPS写加密过的请求发送给服务端，这样可以保护Cookie在浏览器和服务器之间的传输过程中不被窃取和篡改，防止出现HTTP劫持的情况。\r\n\r\n#### 8. SameSite\r\n>该属性用于限制第三方Cookie的发送场景，有下面三种取值：\r\n\r\n* Strict：跨站情况下，任何情况都不会发送Cookie。\r\n* Lax：默认值，除了下面三种情况外，不发送第三方Cookie\r\n    * a标签\r\n    * link标签\r\n    * 方法是GET的form表单请求\r\n* None：所有的跨站都允许发送cookie，如果设置为None的话，必须开启Secure属性。\r\n\r\n### Cookie的优缺点\r\n#### 优点\r\n1. 极高的拓展性和可用性。\r\n2. 通过加密和安全传输技术SSL，减少cookie被破解的可能性。\r\n3. 可以配置cookie的生命周期，使得即使cookie被盗，但是拿到的是一个过期的cookie。\r\n\r\n#### 缺点\r\n1. 特定域名下的cookie的数量有限，当超过这个限制之后，再设置cookie，浏览器就会清除以前设置的cookie。\r\n2. cookie的大小限制为4kb。\r\n3. 需要自己封装获取、设置和删除cookie的方法。\r\n4. 存在安全问题，如果cookie被拦截了，拦截者无需解密cookie，只需转发cookie就能达到某种目的。\r\n5. 有些状态不可能保存在客户端。\r\n6. cookie无法跨域使用。\r\n\r\n\r\n### 当HTTP协议的域名访问HTTPS协议的域名会携带cookie吗？\r\n>当Cookie的属性Secure设置为true的时候，此时不会进行cookie共享，但是如果没有进行这个设置的情况下，是可以共享的。\r\n\r\n### 为什么Cookie不安全？\r\n>因为Cookie存储在浏览器端，一些不法分子可能通过抓包工具等截获cookie。\r\n\r\n\r\n### 如何解决Cookie安全性问题？\r\n1. 设置cookie的有效期的时候，尽量不要设置过长。\r\n2. 设置HttpOnly属性为true。防止JS脚本读取cookie信息，可以防止XSS攻击。\r\n3. 对cookie进行加密。\r\n4. 用户第一次登录的时候，将IP和cookie进行加密后，然后保存为一个token，每次请求时都将cookie和IP组合起来加密进行对比，只有完全对应才能验证成功。\r\n5. session和cookie同时使用。\r\n6. 尽可能使用HTTPS。\r\n\r\n\r\n## 二、Session\r\n### 什么是Session？\r\n>Session代表着服务器和客户端一次会话的过程，session对象中存储着特定用户会话所需的属性和配置信息，这样当用户在应用程序的Web页面之间跳转时，存储在session对象中的变量将不会丢失，而是在整个用户会话中一直存在下去，当客户端关闭会话或者session超时失效的时候会话结束。服务器使用Cookies实现session，cookies里面包含一个Session Id，web应用程序将此session id和其内部数据进行配对，并检索存储的变量以供请求的页面使用。\r\n\r\n### Session如何区别用户？\r\n>当服务器第一次收到请求时，开辟了一块session空间，并创建了session对象，同时生成一个sessionId，并通过响应头set-cookie: jsessionid=xxxx向客户端进行响应，客户端收到该响应后，会在本机客户端的cookie信息中设置jsessionid，接下来客户端每次向同一个网站发送请求的时候，该请求头都会带上该cookie信息，这个cookie信息中包含了sessionid，服务器以此来区分不同的用户。\r\n\r\n### Session的缺点是什么？\r\n>假如A服务器存储了Session，如果做了负载均衡之后，A可能会将用户的请求转发到服务器B，但是服务器B并没有存储A的session，就会导致session的失效问题。\r\n\r\n### Session和Cookie的区别\r\n1. cookie数据存在客户端，session数据存储在服务器上。\r\n2. cookie因为存储在客户端，安全性不如session。\r\n3. session因为存储在服务器上，如果访问增多的情况下，会比较占用服务器的性能。\r\n4. 单个cookie存储数据的大小不能超过4K，很多浏览器都对存储cookie的数量进行了限制，session存储的数据量可能高于cookie。\r\n5. session的实现依赖于cookies,需要把session id存储在cookies中。\r\n6. 有效期不同，cookie可能设置为长时间保存，但是session一般失效时间较短，客户端关闭或者session超时都可能失效。\r\n\r\n## 三、sessionStorage\r\n\r\n### 什么是sessionStorage?\r\n>sessionStorage是HTML5新增的一个会话存储对象，用于临时保存同一窗口或者标签页的数据，在关闭窗口或标签页之后将会删除这些数据。\r\n\r\n#### sessionStorage刷新浏览器会丢失嘛？\r\n>sessionStorage的数据只存在于当前浏览器的标签页中，相同页面的另一个标签页中是不同的存储，数据在页面刷新后仍然保留，即使你使用的是强制刷新，sessionStorage依然存在，但是如果关闭或者重新打开浏览器的标签页后将不会被保留。如果一个标签页包含多个iframe标签，并且他们属于同源页面，他们之间时可以共享sessionStorage的。\r\n\r\n#### sessionStorage两个tab可以共享吗？\r\n>在浏览器中一个标签页代表的是一个会话，两个不同的tab，sessionStorage不会共享。\r\n\r\n#### sessionStorage在同一个标签页跳转之后还在吗？\r\n>在同一个标签页中，如果使用的是target=\"_blank\"的方式进行跳转，上一个页面的sessionStorage是可以带过来的。\r\n\r\n\r\n## 四、LocalStorage\r\n### 什么是LocalStorage?\r\n>LocalStorage时HTML5本地存储web storage特性的API之一，本质是一个哈希表，是一个存在于浏览器上的哈希表，用于将大量数据保存在浏览器中，保存的数据不存在失效时间，除非用户主动进行清除，存储的数据最大为5M，而且仅在客户端保存，不参与和服务器的通信，localStorage受同源策略的限制，键值对最终的存储形式为字符串。\r\n\r\n#### LocalStorage的具体存储方式\r\n* 存储数据使用setItem方法，它接受两个参数，一个是键名，另一个是保存的数据。\r\n\r\n```js\r\nlocalStorage.setItem(\"key\",\"value\");\r\n```\r\n\r\n* 读取数据使用getItem方法。\r\n\r\n```js\r\nlocalStorage.getItem(\"key\");\r\n```\r\n\r\n#### LocalStorage存在跨域吗？\r\n>localStorage受同源策略的限制，所以存在跨域问题。\r\n\r\n#### LocalStorage如何设置过期时间？\r\n>LocalStorage本身并没有提供过期机制，所以我们可以给其原型对象上添加一个方法来实现过期时间的设置，设置值的时候将当前时间记录进去，然后取值的时候进行一下判断，判断当前时间和之前的时间差是否在指定范围内，如果超出则清空当前项，并返回null，在设置的时候不能为对象，需要通过JSON.stringify将其转换为字符串。\r\n\r\n## 五、Cookie和LocalStorage与SessionStorage的区别\r\n\r\n### 生命周期的区别\r\n* cookie：可以设置失效时间，如果没有设置则是默认关闭浏览器后失效。\r\n* localStorage：除非被手动清除，否则将会永久保存。\r\n* sessionStorage：仅在当前会话网页下有效，关闭页面或浏览器就会被清除。\r\n\r\n### 存储容量的区别\r\n* cookie存储数据的大小在4KB左右。\r\n* localStorage和sessionStorage可以保存5MB的信息。\r\n\r\n### 与服务器端通信的区别\r\n* cookie：每次与服务器端通信都会携带在HTTP头中，如果使用cookie保存过多会带来性能的问题。\r\n* localStorage和sessionStorage：仅保存在客户端中，不参与和服务器的通信。\r\n\r\n### 易用性不同\r\n* cookie：原生的cookie接口不友好，需要程序员自己封装。\r\n* localStorage和sessionStorage：原生接口可以接受，也可以再次封装。\r\n\r\n\r\n## 参考文献\r\n>非常感谢下列博主提供的优秀文章，本人受益匪浅，感恩。\r\n\r\n* [傻傻分不清之 Cookie、Session、Token、JWT](https://juejin.cn/post/6844904034181070861)"
    },
    {
      "id": "/MySQL之跨表查询与索引",
      "metadata": {
        "permalink": "/blog/MySQL之跨表查询与索引",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/MySQL之跨表查询与索引.md",
        "source": "@site/blog\\MySQL之跨表查询与索引.md",
        "title": "MySQL之跨表查询与索引",
        "description": "一、笛卡尔积连接",
        "date": "2021-11-07T00:00:00.000Z",
        "formattedDate": "2021年11月7日",
        "tags": [
          {
            "label": "MySQL",
            "permalink": "/blog/tags/my-sql"
          }
        ],
        "readingTime": 1.95,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "MySQL之跨表查询与索引",
          "date": "2021-11-07T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "MySQL",
          "tags": [
            "MySQL"
          ]
        },
        "prevItem": {
          "title": "晨兴夜寐：这一次，彻底搞懂Cookie,LocalStorage,SessionStorage",
          "permalink": "/blog/晨兴夜寐：这一次，彻底搞懂Cookie,LocalStorage,SessionStorage"
        },
        "nextItem": {
          "title": "MySql基础命令与查询方法",
          "permalink": "/blog/MySql基础命令与查询方法"
        }
      },
      "content": "## 一、笛卡尔积连接\r\n>在演示笛卡尔积连接之前，我们先看看相关表的结构：\r\n\r\n* article表\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/c5b9bf60cec23803053de4f809fffb71.png)\r\n\r\n* article_cate表\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/0020900a48bec5aa879069343b377c38.png)\r\n\r\n>笛卡尔积连接就是实现跨表查询的一种方式。\r\n\r\n```shell\r\nselect article.id as id,article.title as title,article.state as state,article_cate.title as cate from article,article_cate where article.cate_id=article_cate.id\r\n```\r\n\r\n## 二、内连接\r\n>项目中使用比较多的是内连接来进行跨表查询。内连接主要是加入了INNER JOIN和ON两个关键字。\r\n\r\n```shell\r\nselect article.id as id,article.title as title,article.state as state,article_cate.title as cate from article INNER JOIN article_cate on article.cate_id = article_cate.id; \r\n```\r\n\r\n>其他方法：使用IN来进行查询，例如：张三选修的课程id对应的课程名称是什么，我们首先看下数据表的结构：\r\n\r\n* lesson表\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/4a732035774793bbe1509b305318b1e8.png)\r\n\r\n* student表\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/8f49738ee4289bf02a3341ac3797ee2d.png)\r\n\r\n* lesson_student表\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/d57bb1fdd815a5d06bb609c3aa39cfd2.png)\r\n\r\n>查询张三选修的课程的名称\r\n\r\n```shell\r\nselect * from lesson where id in (select lessonId from lesson_student where studentId=1);\r\n```\r\n\r\n>查询哪些学生选修了Java程序设计\r\n\r\n```shell\r\nselect * from student where id in (select studentId from lesson_student where lessonId=2);\r\n```\r\n\r\n## 三、MySQL索引\r\n>当查询海量数据的时候，通过索引可以增加查询的效率，极大的降低查找的时间。\r\n\r\n1. 创建索引\r\n\r\n>给name创建索引名为index_name。\r\n\r\n```shell\r\ncreate index index_name on student(name);  \r\n```\r\n\r\n2. 查看索引\r\n\r\n```shell\r\nshow index from student;\r\n```\r\n\r\n3. 删除索引\r\n\r\n```shell\r\ndrop index index_name on student;\r\n```\r\n\r\n4. 创建唯一索引\r\n\r\n```shell\r\ncreate unique index index_name on student(name);\r\n```\r\n\r\n>我们也可以通Navicat等可视化工具来设置索引，通过右键选择某个数据表，选择设计表，然后添加索引。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/c090938874c2e6efe7f14c9cc686d508.png)"
    },
    {
      "id": "/MySql基础命令与查询方法",
      "metadata": {
        "permalink": "/blog/MySql基础命令与查询方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/MySql基础命令与查询方法.md",
        "source": "@site/blog\\MySql基础命令与查询方法.md",
        "title": "MySql基础命令与查询方法",
        "description": "一、连接MySQL",
        "date": "2021-11-06T00:00:00.000Z",
        "formattedDate": "2021年11月6日",
        "tags": [
          {
            "label": "MySQL",
            "permalink": "/blog/tags/my-sql"
          }
        ],
        "readingTime": 3.395,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "MySql基础命令与查询方法",
          "date": "2021-11-06T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "MySQL",
          "tags": [
            "MySQL"
          ]
        },
        "prevItem": {
          "title": "MySQL之跨表查询与索引",
          "permalink": "/blog/MySQL之跨表查询与索引"
        },
        "nextItem": {
          "title": "阿里前端面试题之获取嵌套数组的深度",
          "permalink": "/blog/阿里前端面试题之获取嵌套数组的深度"
        }
      },
      "content": "## 一、连接MySQL\r\n1. 首先安装MySQL,然后开启相关服务。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/f56fb95408bbed4444eeb74c746b2664.png)\r\n\r\n2. 运行MySQL\r\n\r\n```shell\r\nmysql -u root -p\r\n```\r\n\r\n## 二、运行Navicat可视化工具\r\n1. 在Navicat中连接MySQL数据库\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/99d8a3d95179aab1f3d0a0acfc4389c9.png)\r\n\r\n2. 在本地新建一个数据库\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/8671a5025268c9822063ffd3f3880b02.png)\r\n\r\n3. 在数据库中新建一个表，表建立相应的字段\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/55b7598330feca6039663fda3b05c9d3.png)\r\n\r\n## 三、MySQL的基础命令\r\n* 首先启动MySQL服务，然后通过下面的命令连接数据库\r\n\r\n```shell\r\nmysql -u root -p\r\n```\r\n\r\n* 显示当前存在的数据库\r\n\r\n```shell\r\nshow databases;\r\n```\r\n\r\n* 选择想要操作的数据库\r\n\r\n```shell\r\nuse xxx;\r\n```\r\n\r\n>当出现Database changed表示切换成功！\r\n\r\n* 查看当前数据库都有哪些数据表\r\n\r\n```shell\r\nshow tables;\r\n```\r\n\r\n* 查看指定表中都有哪些数据\r\n\r\n```shell\r\nselect * from xxx\r\n```\r\n\r\n* 指定查询表中的哪些字段\r\n\r\n```shell\r\nselect xxx from xxx;\r\n```\r\n\r\n* 指定查询条件\r\n\r\n```shell\r\nselect * from user where id=1;\r\nselect * from user where id>1;\r\n```\r\n\r\n* 创建一个数据库\r\n\r\n```shell\r\ncreate database xxx;\r\n```\r\n\r\n* 添加数据表\r\n\r\n```shell\r\ncreate table users(\r\nid int(11),\r\nusername varchar(255),\r\nage int(3)\r\n);\r\n```\r\n\r\n* 显示表的结构\r\n\r\n```shell\r\ndescribe users;\r\n```\r\n\r\n* 向表中添加数据\r\n\r\n```shell\r\ninsert into users(id,username,age) values (1,'王五',18);\r\n```\r\n\r\n* 修改指定的数据(将user表中id为1的字段的username修改为：王五)\r\n\r\n```shell \r\nupdate user set username=\"王五\" where id=1;\r\n```\r\n\r\n* 修改多个字段的情况\r\n\r\n```shell\r\nupdate user set username=\"王五\",id=666 where id=1;\r\n```\r\n\r\n* 删除指定的数据\r\n\r\n```shell\r\ndelete from user where id=666;\r\n```\r\n\r\n* 对数据进行升序排列\r\n\r\n```shell\r\nselect * from user order by id asc;\r\n```\r\n\r\n* 对数据进行降序排列\r\n\r\n```shell\r\nselect * from user order by id desc;\r\n```\r\n\r\n* 对某个表统计数量\r\n\r\n```shell\r\nselect count(1) from user;\r\n```\r\n\r\n* 只查询指定数量的数据\r\n\r\n>下面的方法只会查询前两条数据。\r\n\r\n```shell\r\nselect * from user limit 1;\r\n```\r\n\r\n* 跳过两条，查询1条\r\n\r\n```shell\r\nselect * from user limit 2,1;\r\n```\r\n\r\n* 删除指定的表\r\n\r\n```shell \r\ndrop table test;\r\n```\r\n\r\n* 删除指定的数据库\r\n\r\n```shell\r\ndrop database test;\r\n```\r\n\r\n## 四、MySQL中的模糊查询\r\n* 将邮件信息中包含qq.com的都选出来\r\n\r\n```shell\r\nselect * from class where email like \"%qq.com%\";\r\n```\r\n\r\n* 查询email中以node开头的\r\n\r\n```shell\r\nselect * from class where email like \"node%\";\r\n```\r\n\r\n* 查询email中以163.com结尾的元素\r\n\r\n```shell\r\nselect * from class where email like \"%163.com\";\r\n```\r\n\r\n## 五、MySQL中的分组函数\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/355f4b120a354b56d8e96dfe4c2a5591.png)\r\n\r\n\r\n```shell\r\nselect avg(score) from class;\r\nselect count(score) from class;\r\nselect max(score) from class;\r\nselect min(score) from class;\r\nselect sum(score) from class;\r\n```\r\n\r\n>复合条件查询\r\n\r\n```shell\r\nselect * from class where score in (select max(score) from class);\r\n```\r\n\r\n## 六、MySQL别名\r\n\r\n```shell\r\nselect id,name as n,email as e,score as s from class;\r\n```\r\n\r\n## 七、MySQL表与表之间的关系\r\n>表与表之间一般存在三种关系，即一对一，一对多和多对多关系。"
    },
    {
      "id": "/阿里前端面试题之获取嵌套数组的深度",
      "metadata": {
        "permalink": "/blog/阿里前端面试题之获取嵌套数组的深度",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/阿里前端面试题之获取嵌套数组的深度.md",
        "source": "@site/blog\\阿里前端面试题之获取嵌套数组的深度.md",
        "title": "阿里前端面试题之获取嵌套数组的深度",
        "description": "题目描述",
        "date": "2021-11-05T00:00:00.000Z",
        "formattedDate": "2021年11月5日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 1.59,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "阿里前端面试题之获取嵌套数组的深度",
          "date": "2021-11-05T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "MySql基础命令与查询方法",
          "permalink": "/blog/MySql基础命令与查询方法"
        },
        "nextItem": {
          "title": "LRU缓存机制（链表实现）",
          "permalink": "/blog/LRU缓存机制（链表实现）"
        }
      },
      "content": "## 题目描述\r\n>获取嵌套数组的深度，给定一个带嵌套的数组，实现一个方法可获取嵌套数组的最大深度，数组无嵌套子数组则返回0，有一层嵌套子数组则返回1，以此类推。\r\n\r\n>示例：\r\n\r\n* getArrayDeep([1,2,[3,[1,[0]]]]); 返回3\r\n* getArrayDeep([]);   返回0\r\n* getArrayDeep([[[[]]]]) 返回3\r\n* getArrayDeep([0,[2],[2,[3]]]); 返回2\r\n\r\n\r\n## 解题思路\r\n>使用递归的思想进行遍历，同时使用flag标识符来标记目标元素是否是数组，如果是数组，存储到临时数组中，然后投入递归，所有的递归结束后，判断flag是true还是false，如果是true，则返回临时数组中的最大值，如果是false则返回1。\r\n\r\n```js\r\nfunction recursiveMax(input) {\r\n  var flag = false;\r\n  var num = [];\r\n  for (var i = 0; i < input.length; i++) {\r\n    if (input[i] instanceof Array) {\r\n      flag = true;\r\n      num.push(recursiveMax(input[i]));\r\n    }\r\n  }\r\n  if (flag) {\r\n    return Math.max.apply(null, num) + 1;\r\n  } else {\r\n    return 1\r\n  }\r\n\r\n}\r\nvar res = recursiveMax([0,[2],[2,[3]]]) - 1;\r\nvar res = recursiveMax([1,2,[3,[1,[0]]]]) - 1;\r\nconsole.log(res) // 4\r\n```\r\n\r\n## 题目反思\r\n* 这道题目是递归的经典用法，必须熟练掌握。\r\n* 使用标识符对元素进行标记，来辅助递归是解决递归问题的关键思路。\r\n* 使用Math.max.apply(num)，可以求出一个数组中的最大值。"
    },
    {
      "id": "/LRU缓存机制（链表实现）",
      "metadata": {
        "permalink": "/blog/LRU缓存机制（链表实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LRU缓存机制（链表实现）.md",
        "source": "@site/blog\\LRU缓存机制（链表实现）.md",
        "title": "LRU缓存机制（链表实现）",
        "description": "题目描述",
        "date": "2021-11-04T00:00:00.000Z",
        "formattedDate": "2021年11月4日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 3.815,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LRU缓存机制（链表实现）",
          "date": "2021-11-04T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "阿里前端面试题之获取嵌套数组的深度",
          "permalink": "/blog/阿里前端面试题之获取嵌套数组的深度"
        },
        "nextItem": {
          "title": "Egg.js中定时任务的核心用法",
          "permalink": "/blog/Egg.js中定时任务的核心用法"
        }
      },
      "content": "## 题目描述\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/91b12e01229b5fbfdefa3871570f1912.png)\r\n\r\n## 解题思路\r\n1. 构造一个链表节点类和一个LRU缓存类。\r\n2. 一个链表的节点应该具有key,value,和next指针和prev指针。\r\n3. 一个LRU的实例应该具有容量capacity，hash对象，表示这个LRU中节点的数量值的count,两个辅助链表节点，分别指向最近使用的元素，和最久未使用的元素。\r\n4. get方法：无论是get方法还是put方法，都要首先取出key对应的节点，判断这个节点是否是undefined，如果不存在，直接返回-1，如果存在，将其从链表中删除，然后添加到辅助链表Head的指向位置，然后返回该节点的值。\r\n5. put方法：首先取出key对应的节点，判断这个节点是否是undefined,如果不是undefiend,更新其值，然后从链表中删除，然后添加到辅助头节点指向的位置，如果不存在，首先判断LRU中节点的数量和容量是否相等，如果相等，则说明已经满了，此时从尾部辅助链表前取出该元素，然后删除链表中的该元素，然后从hash对象中也删除，同时count--，然后创造一个新节点，存入key,value，然后添加到链表和hash对象中，同时更新count的值。\r\n\r\n## AC代码\r\n\r\n```js\r\n// 首先构造一个链表节点类\r\nclass ListNode {\r\n  constructor(key,value) {\r\n    this.key = key;\r\n    this.value = value;\r\n    this.next = null;\r\n    this.prev = null;\r\n  }\r\n}\r\n\r\n// 构造一个LRU缓存类\r\nclass LRUCache {\r\n  constructor(capacity) {\r\n    this.capacity = capacity;\r\n    this.hash = {};\r\n    this.count = 0;\r\n    // 这里的head可以理解为最近使用过的，tail则可以理解为最久未使用的\r\n    this.dummyHead = new ListNode();\r\n    this.dummyTail = new ListNode();\r\n    this.dummyHead.next = this.dummyTail;\r\n    this.dummyTail.prev = this.dummyHead;\r\n  }\r\n\r\n  // 实现get方法\r\n  get(key) {\r\n    // 首先取出hash对象中这个键对应的节点\r\n    let node = this.hash[key];\r\n    // 如果这个节点不存在，返回-1\r\n    if (node === undefined) return -1;\r\n    // 如果这个节点存在的话，从链表中移除已有节点，然后再添加到头部\r\n    this.deleteFromList(node);\r\n    this.addToHead(node);\r\n    return node.value;\r\n  }\r\n\r\n  // 实现put方法\r\n  put(key,value) {\r\n    // 首先取出哈希对象中这个键对应的节点\r\n    let node = this.hash[key];\r\n    // 分存在和不存在两种情况进行讨论\r\n    if (node === undefined) {\r\n      // 如果LRU是满的\r\n      if (this.count === this.capacity) {\r\n        // 取出最久未使用的\r\n        let tail = this.dummyTail.prev;\r\n        // 从LRU中删除\r\n        this.deleteFromList(tail);\r\n        // 从hash对象中删除\r\n        delete this.hash[tail.key];\r\n        // LRU的数量-1\r\n        this.count--;\r\n      }\r\n      // 创造一个新的节点\r\n      let newNode = new ListNode(key,value);\r\n      this.hash[key] = newNode;\r\n      this.addToHead(newNode);\r\n      this.count++;\r\n    } else {\r\n      // 更新value\r\n      node.value = value;\r\n      this.deleteFromList(node);\r\n      this.addToHead(node);\r\n    }\r\n  }\r\n\r\n\r\n  deleteFromList(node) {\r\n    let temp1 = node.prev;\r\n    let temp2 = node.next;\r\n    temp1.next = temp2;\r\n    temp2.prev = temp1;\r\n  }\r\n  addToHead(node) {\r\n    node.prev = this.dummyHead;\r\n    node.next = this.dummyHead.next;\r\n    this.dummyHead.next.prev = node;\r\n    this.dummyHead.next = node;\r\n  }\r\n}\r\n```\r\n\r\n## 题目反思\r\n>关于LRU缓存机制这个题目，我们可以采用Map做，也可以采用hash对象+链表的形式做，但是从题目简洁的程度看，Map的方法更加易懂，更加简洁。"
    },
    {
      "id": "/Egg.js中定时任务的核心用法",
      "metadata": {
        "permalink": "/blog/Egg.js中定时任务的核心用法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Egg.js中定时任务的核心用法.md",
        "source": "@site/blog\\Egg.js中定时任务的核心用法.md",
        "title": "Egg.js中定时任务的核心用法",
        "description": "一、定时任务的基本使用",
        "date": "2021-11-03T00:00:00.000Z",
        "formattedDate": "2021年11月3日",
        "tags": [
          {
            "label": "Egg.js",
            "permalink": "/blog/tags/egg-js"
          }
        ],
        "readingTime": 1.615,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Egg.js中定时任务的核心用法",
          "date": "2021-11-03T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Egg.js",
          "tags": [
            "Egg.js"
          ]
        },
        "prevItem": {
          "title": "LRU缓存机制（链表实现）",
          "permalink": "/blog/LRU缓存机制（链表实现）"
        },
        "nextItem": {
          "title": "Egg.js中控制器基类的简明用法",
          "permalink": "/blog/Egg.js中控制器基类的简明用法"
        }
      },
      "content": "## 一、定时任务的基本使用\r\n1. 在app文件夹下新建一个schedule文件夹，并在下面建立一个watchfile.js（可以自定义）\r\n\r\n```js\r\nconst Subscription = require('egg').Subscription;\r\n\r\nlet i = 0;\r\n\r\nclass WatchFile extends Subscription {\r\n  static get schedule() {\r\n    return {\r\n      interval: '1s',\r\n      type: 'all'      // 指定所有的进程都需要执行\r\n    }\r\n  }\r\n  async subscribe() {\r\n    i++;\r\n    console.log(i);\r\n  }\r\n}\r\nmodule.exports = WatchFile;\r\n```\r\n\r\n2. 控制台将每隔1s打印下面的内容\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/89990d683194597efc34d941d29e66ab.png)\r\n\r\n3. 下面是一种简写的方式\r\n\r\n```js\r\nlet i = 0;\r\nmodule.exports = {\r\n  schedule: {\r\n    interval: '1s', // 1 分钟间隔\r\n    type: 'all', // 指定所有的 worker 都需要执行\r\n  },\r\n  async task(ctx) {\r\n    i++;\r\n    console.log(i);\r\n  },\r\n};\r\n```\r\n\r\n## 二、定时爬取指定网页的内容\r\n1. 安装cheerio模块\r\n\r\n>这个模块能够解析HTML页面的内容，使用的是JQuery语法。\r\n\r\n```shell\r\nnpm install cheerio\r\n```\r\n\r\n2. 导入模块\r\n\r\n```shell\r\nconst cheerio = require('cheerio');\r\n```\r\n\r\n3. 在服务中定义爬虫模块spider.js\r\n\r\n```js\r\n'use strict';\r\n\r\nconst Service = require('egg').Service;\r\n\r\nclass SpiderService extends Service {\r\n  async requestUrl(url) {\r\n    const result = await this.ctx.curl(url);\r\n    return result;\r\n  }\r\n}\r\n\r\nmodule.exports = SpiderService;\r\n```\r\n\r\n4. 定时任务解析服务获取到的内容\r\n\r\n```js\r\nmodule.exports = {\r\n  schedule: {\r\n    interval: '1s', // 1 分钟间隔\r\n    type: 'all', // 指定所有的 worker 都需要执行\r\n  },\r\n  async task(ctx) {\r\n    const url = \"https://news.baidu.com\";\r\n    const result = await ctx.service.spider.requestUrl(url);\r\n    const htmlData = result.data.toString();\r\n    const $ = cheerio.load(htmlData,{decodeEntities: false});\r\n\r\n    $('.hotnews a').each(function() {\r\n      console.log($(this).html());\r\n    })\r\n  },\r\n};\r\n```"
    },
    {
      "id": "/Egg.js中控制器基类的简明用法",
      "metadata": {
        "permalink": "/blog/Egg.js中控制器基类的简明用法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Egg.js中控制器基类的简明用法.md",
        "source": "@site/blog\\Egg.js中控制器基类的简明用法.md",
        "title": "Egg.js中控制器基类的简明用法",
        "description": "一、指定时间后跳转到指定页面",
        "date": "2021-11-02T00:00:00.000Z",
        "formattedDate": "2021年11月2日",
        "tags": [
          {
            "label": "Egg.js",
            "permalink": "/blog/tags/egg-js"
          }
        ],
        "readingTime": 0.805,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Egg.js中控制器基类的简明用法",
          "date": "2021-11-02T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Egg.js",
          "tags": [
            "Egg.js"
          ]
        },
        "prevItem": {
          "title": "Egg.js中定时任务的核心用法",
          "permalink": "/blog/Egg.js中定时任务的核心用法"
        },
        "nextItem": {
          "title": "Egg.js中路由的核心用法",
          "permalink": "/blog/Egg.js中路由的核心用法"
        }
      },
      "content": "## 一、指定时间后跳转到指定页面\r\n>通过meta标签\r\n\r\n```js\r\n<meta http-equiv=\"refresh\" content=\"3;url=/\">\r\n```\r\n\r\n## 二、控制器基类BaseController\r\n>可以通过自定义Controller基类的方式封装应用中常用的方法。\r\n\r\n1. 在app文件夹下新建文件夹core,并在其中新建base.js\r\n\r\n```js\r\n'use strict';\r\n\r\nconst Controller = require('egg').Controller;\r\n\r\nclass BaseController extends Controller {\r\n  async success() {\r\n    await this.ctx.render('success')\r\n  }\r\n}\r\n\r\nmodule.exports = BaseController;\r\n```\r\n\r\n2. 需要使用基类方法的控制器修改控制器继承来源\r\n\r\n```js\r\n'use strict';\r\n\r\nconst BaseController = require('../core/base.js');\r\n\r\nclass UserController extends BaseController {\r\n  async doLogin() {\r\n    console.log(this.ctx.request.body);\r\n    await this.success();\r\n  }\r\n}\r\n\r\nmodule.exports = UserController;\r\n```\r\n\r\n3. 封装的方法已经在this上了\r\n\r\n```js\r\nawait this.success();\r\n```"
    },
    {
      "id": "/Egg.js中路由的核心用法",
      "metadata": {
        "permalink": "/blog/Egg.js中路由的核心用法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Egg.js中路由的核心用法.md",
        "source": "@site/blog\\Egg.js中路由的核心用法.md",
        "title": "Egg.js中路由的核心用法",
        "description": "一、路由的几种写法",
        "date": "2021-11-01T00:00:00.000Z",
        "formattedDate": "2021年11月1日",
        "tags": [
          {
            "label": "Egg.js",
            "permalink": "/blog/tags/egg-js"
          }
        ],
        "readingTime": 1.345,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Egg.js中路由的核心用法",
          "date": "2021-11-01T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Egg.js",
          "tags": [
            "Egg.js"
          ]
        },
        "prevItem": {
          "title": "Egg.js中控制器基类的简明用法",
          "permalink": "/blog/Egg.js中控制器基类的简明用法"
        },
        "nextItem": {
          "title": "（最系统、最全面）这一次，彻底搞懂HTTP面试",
          "permalink": "/blog/（最系统、最全面）这一次，彻底搞懂HTTP面试"
        }
      },
      "content": "## 一、路由的几种写法\r\n1. 一般写法\r\n\r\n```js\r\nrouter.get('/news', controller.news.index);\r\n```\r\n\r\n2. 带有中间件的写法\r\n\r\n```js\r\nconst auth = app.middleware.auth();\r\nrouter.get('/news', auth,controller.news.index);\r\n```\r\n\r\n3. 包含名字的路由写法\r\n\r\n>相当于给路由起一个名字，直接访问/news还是正常的。\r\n\r\n```js\r\nrouter.get('新闻','/news', controller.news.index);\r\n```\r\n\r\n## 二、路由重定向\r\n### 外部重定向\r\n>在控制器中写出下面的代码。\r\n\r\n```js\r\nthis.ctx.redirect('/news')\r\n```\r\n\r\n### 内部重定向\r\n>访问/news跳转到/shop页面。\r\n\r\n```js\r\nrouter.redirect('/news','/shop',302)\r\n```\r\n\r\n## 三、路由分组（路由映射）\r\n>之所以要进行路由分组是因为，如果一个项目中包含太多路由，会给问题的排查带来很大的困难，因此可以采用将同一类的路由归为一个文件，然后对外暴露，这种方式就是路由分组。\r\n\r\n1. 在app下新建一个routers文件夹，然后在该文件夹下建立类似下面的文件。\r\n\r\n* admin.js\r\n```js\r\nmodule.exports = app => {\r\n  const { router, controller } = app;\r\n  router.get('/admin/user',controller.admin.user.index)\r\n};\r\n```\r\n\r\n2. 在routers.js文件中通过下面的方式进行调用。\r\n\r\n```js\r\nrequire('./routers/admin')(app);\r\n```"
    },
    {
      "id": "/（最系统、最全面）这一次，彻底搞懂HTTP面试",
      "metadata": {
        "permalink": "/blog/（最系统、最全面）这一次，彻底搞懂HTTP面试",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/（最系统、最全面）这一次，彻底搞懂HTTP面试.md",
        "source": "@site/blog\\（最系统、最全面）这一次，彻底搞懂HTTP面试.md",
        "title": "（最系统、最全面）这一次，彻底搞懂HTTP面试",
        "description": "无论是大厂面试还是小厂面试，无论是社招还是校招，博主做了大量的统计分析，计算机网络中的HTTP协议相关的考点，几乎是必考的，让我们一起来学习这个知识吧。",
        "date": "2021-10-31T00:00:00.000Z",
        "formattedDate": "2021年10月31日",
        "tags": [
          {
            "label": "HTTP",
            "permalink": "/blog/tags/http"
          }
        ],
        "readingTime": 52.425,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "（最系统、最全面）这一次，彻底搞懂HTTP面试",
          "date": "2021-10-31T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "HTTP",
          "tags": [
            "HTTP"
          ]
        },
        "prevItem": {
          "title": "Egg.js中路由的核心用法",
          "permalink": "/blog/Egg.js中路由的核心用法"
        },
        "nextItem": {
          "title": "Egg.js中间件的核心用法",
          "permalink": "/blog/Egg.js中间件的核心用法"
        }
      },
      "content": ">无论是大厂面试还是小厂面试，无论是社招还是校招，博主做了大量的统计分析，计算机网络中的HTTP协议相关的考点，几乎是必考的，让我们一起来学习这个知识吧。\r\n\r\n## 一、HTTP2新特性\r\n>首先，我们要明确HTTP2到底有哪些新特性。博主总结了多篇文章，HTTP2新特性主要围绕着下面六个方面。\r\n\r\n1. 二进制分帧\r\n2. 首部压缩\r\n3. 流量控制\r\n4. 多路复用\r\n5. 请求优先级\r\n6. 服务器推送\r\n\r\n### 二进制分帧\r\n>在介绍二进制分帧之前，首先介绍下什么是帧，但是介绍帧的时候，又不可避免的要介绍到消息和数据流的概念，为了便于大家的理解，博主还是决定对这些内容分别进行系统的介绍。\r\n\r\n#### 帧、消息和数据流的关系\r\n* 帧(frame)：可以理解为一个连续的消息流中的一个片段，是最小单位。\r\n* 消息(message)：对应于HTTP1中的请求或者响应，包含一条或者多条message。\r\n* 数据流(stream)：包含1条或者多条message。\r\n\r\n#### HTTP2突破HTTP1.1协议性能限制的核心\r\n>HTTP2所有性能增强的核心就在于应用层和传输层之间增加了一个二进制分帧层。\r\n\r\n#### 二进制分帧层原理\r\n>二进制分帧层通过将所有传输的信息分割为更小的消息和帧，并采用二进制格式进行编码，其中，HTTP1.1中的首部信息header封装到Headers帧中，而request body则封装到Data帧中。HTTP2的通信都在一个TCP连接上完成，这个连接可以承载任意数量的双向数据流，相应的每个数据流以消息的形式发送，而消息由一个或多个帧组成，这些帧可以乱序发送，然后根据每个帧的首部流标识符重新组装。二进制分帧为HTTP2的其他特性提供了基础。\r\n\r\n#### 二进制帧的结构\r\n>下图是二进制帧的结构图\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/6e0165e39fe7ab0b763dac676af2a3d8.png)\r\n\r\n>HTTP2的二进制帧主要包括头部帧和数据帧，其中头部帧包括3个字节的帧长度，1字节的帧类型和1字节的标志位以及31bit的流标识符，接下来将详细介绍每一部分的作用。\r\n\r\n* 帧长度：表示的是数据帧的长度。\r\n* 帧类型：表示这个帧是数据帧还是控制帧。\r\n* 标志位：用于携带简单的控制信息，例如通过标志位来表示流的优先级。\r\n* 流标识符：用来表示这个帧属于哪个流的，接收方可以根据这个信息从乱序的帧里面找到相同流id的帧，从而有序的组装信息。\r\n* 数据帧：存放的时经过HPACK算法压缩后的HTTP头部和数据体。\r\n\r\n\r\n\r\n### 首部压缩\r\n#### 首部压缩的原理\r\n>HTTP2使用HPACK算法压缩请求和响应标头的元数据，这种格式支持通过静态霍夫曼编码对传输的头部字段进行编码，从而减小了传输的大小，同时这种压缩算法要求客户端和服务器同时维护和更新一个首部表，这个首部表能够跟踪和存储之前发送过的键值对，对于相同的数据不再通过每次请求和响应进行发送，假如第一个请求发送了所有的头部字段，第二个请求则只需发送有差异的字段，这样可以减少冗余的数据，降低开销。HPACK主要包含两个压缩模块，索引表和静态霍夫曼编码，其中索引表又包含静态表和动态表。静态表包含61个预定义Header的Key value，传输的时候使用对应的索引Index替换。动态表是一个先进先出的队列，初始的时候是空的，解压header的时候按需添加，每次添加的时候放在队首，移除的时候从队尾开始，动态表的大小不是无限制的。\r\n\r\n#### HPACK算法\r\n>HPACK算法主要包括三个组成部分。\r\n\r\n* 静态表\r\n* 动态表\r\n* Huffman压缩算法\r\n\r\n>客户端和服务端都会建立和维护一张字典，主要目的时使用长度较小的索引号表示重复的头部字符串，再用Huffman编码压缩数据，可以达到较高的压缩率。\r\n\r\n>静态表：HTTP2为出现在头部的字符串和字段建立了一张静态表，它是写入到HTTP2客户端和服务器的代码中的，静态表里共有61组，例如，在静态表中GET方法的索引号是2，POST方法的索引号是3。静态表的索引表示的是头部名，value表示的是头部名对应的内容。\r\n\r\n>动态表：因为静态表只包含了61中高频出现在头部的字符串，不在静态表范围的头部字符串就需要我们自行构建动态表，这个动态表的索引从62起步，比如第一次发送user-agent，会将这个字符串对应的索引号，字符串和对应的数据经过霍夫曼编码后的二进制值发送给服务端，在第二次发送的时候，就不用重复发送这个字段的数据了，只用发送一个字节的索引号即可，因为双方都可以根据自己的动态表获取到该字段的值。这样避免了大量的冗余数据的传输，节约了带宽。\r\n\r\n>动态表会无限制扩大吗？答案是否定的，因为动态表越大占用的内存也就越大，是会影响服务器性能的，所以web服务器会提供相应的配置，避免动态表无限增大，达到上限后便会关闭HTTP2连接释放内存。\r\n\r\n### 流量控制\r\n>在HTTP2协议中，我们可以在同一个TCP连接中，建立多个数据流，这些数据流之间也是存在相互竞争的，因此也需要对流中的帧进行流量控制，但是只有流量帧受流量控制，而其他类型的帧不受流量控制，HTTP2通过使用WINDOW_UPDATE帧来提供流量控制。\r\n\r\n>HTTP2协议中的流量控制有以下几个特征：\r\n\r\n* 流量控制基于HTTP连接的每一跳进行的，而非端到端的控制。（这里的每一跳指的是HTTP连接中间可能的代理服务器）\r\n* 接收方公布自己打算在每个流以及整个连接上分别接收多少字节，这是一个以信用为基础的方案。\r\n* 流量控制是有方向的，由接收者全面控制，接收方可以为每个流和整个连接设置任意的窗口大小，发送方必须尊重接收方设置的流量控制限制。\r\n* 无论是新流还是整个连接，流量控制窗口的初始值是65535字节。\r\n* HTTP2只定义了WINDOW_UPDATE帧的格式和语义，并没有对通信双方如何实现进行约束。\r\n\r\n### 多路复用\r\n>在HTTP1.1中，如果客户端想发送多个并行的请求，必须使用多个TCP连接，而HTTP2的二进制分帧层突破了这一限制，所有的请求和响应都在同一个TCP连接上完成，单个连接可以承载任意数量的双向数据流，数据流以消息的形式发送，消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为可以根据帧首部的流标识符进行重新组装。\r\n\r\n>上面的特性使得性能有了极大的性能提升，原因如下：\r\n\r\n* 因为同一个域名只需要占用一个TCP连接，使用这个连接并行发送多个请求和响应，这样使得整个页面的资源的下载过程只需要一次慢启动，同时也避免了多个TCP连接带来的竞争问题。\r\n* 可以并行交错的发送多个请求或响应，这些请求或响应之间互不影响。\r\n\r\n### 请求优先级\r\n>HTTP2中每个流都可以带有一个31bit的优先值，0表示做高优先级，数值越大优先级越低，在一个TCP连接上，可以发送多个请求，并不等于说这些请求对于服务器来说都是一视同仁的，因为客户端对资源的需求不同，比如客户端对css和js的需求远大于对文档内图片的需求，所以每一个流的headers帧中可以带有一个优先级，服务端可以因此适当分配资源，优先发送优先级高的帧。服务端在使用请求优先级的时候要避免带来队头阻塞的问题。\r\n\r\n### 服务器推送\r\n>HTTP2改变了传统的请求应答模式，服务器不再完全被动地响应请求，也可以新建流主动向客户端发送消息，比如，浏览器刚请求HTML页面的时候，服务器可能会将主页内容，logo以及样式表都响应到客户端的缓存，当客户端需要这些资源的时候，这些资源已经在缓存中了，这样可以减少等待的延迟，不过只有建立连接后，服务器才可以推送资源，这种机制就是服务器推送。\r\n\r\n>服务器推送的特点：\r\n\r\n* 针对每一个希望发送的资源，服务器会发送一个PUSH_PROMISE帧，当然客户端有权选择拒绝这个资源，通过RST_STREAM帧，这一步的操作先于父响应(index.html)，客户端了解到服务器端打算推送哪些资源，就不会为这些资源创建重复的请求，当客户端收到index.html的响应时，script.js和style.css已经存在于缓存中了。\r\n\r\n## 二、HTTP2有什么缺点？\r\n\r\n1. TCP以及TCP+TLS建立连接的延时，HTTP2使用TCP协议来传输，而如果使用HTTPS还需要使用TLS协议进行安全传输，而使用TLS也需要一个握手的过程，这也会带来一些延时。\r\n2. TCP的队头阻塞并没有彻底解决，在HTTP2中，多个请求是在一个TCP管道中的，当HTTP2出现丢包的时候，整个TCP都要开始等待重传，此时会阻塞该TCP连接中的所有请求。此时可能还不如HTTP1.1中的多个TCP连接效率高。队头阻塞分为TCP队头阻塞和HTTP队头阻塞，HTTP2解决的是HTTP队头阻塞，但是TCP的队头阻塞并未解决。因为HTTP是应用层协议，TCP是传输层协议。\r\n3. 多路复用导致服务器压力上升，多路复用由于没有限制同时请求数量，有可能出现短时间内请求数爆发的情况，会导致服务器压力上升。\r\n4. 多路复用容易超时，大批量的请求同时发送，但是网络的带宽和服务器的资源是有限的，此时可能会出现请求超时的情况。\r\n\r\n### HTTP2.0多路复用在什么情况下效率不如1.1？\r\n>HTTP2.0在丢包的时候效率可能不如1.1，因为在出现丢包的情况下，整个TCP都要开始等待重传，也就导致后面的所有数据都被阻塞了，但是对于HTTP1.1来说，可以开启多个TCP连接，出现这种情况只会影响到其中一个连接，剩余的TCP连接还可以正常传输数据。\r\n\r\n### 二进制分帧的根本目的是什么，只是为了读取速度快吗？\r\n\r\n>二进制分帧的根本目的是为了更有效的利用底层TCP协议，同时也是HTTP2协议中的其他功能和性能优化的基础。\r\n\r\n### HTTP2中的长连接相比于http1中手动指定keep-alive的优势、原理\r\n1. HTTP1.X中的keep-alive必须按照请求发送的顺序返回响应，但是HTTP2多路复用可以不按顺序进行响应。\r\n2. HTTP1.X中的keep-alive单个TCP连接在同一时刻只能处理一个请求，HTTP2单个TCP在同一时刻可以发送多个请求和响应。\r\n\r\n\r\n## 三、HTTP3.0\r\n### 为什么要有HTTP3.0？\r\n>之所以要有HTTP3主要原因还在于上文提到的HTTP2存在的问题，这些问题的根源是底层支撑的TCP协议造成的。Google意识到这些问题之后，于是就提出了基于UDP协议的QUIC协议，让HTTP跑在QUIC上，而不是TCP上，这就是HTTP3，HTTP3解决了HTTP2存在的队头阻塞问题。\r\n\r\n### HTTP3为什么选择UDP？\r\n>HTTP3选择UDP主要有以下一些原因：\r\n\r\n* 基于TCP开发的设备和协议非常多，兼容起来困难。\r\n* TCP协议栈是Linux内部的重要部分，修改和升级成本很大。\r\n* UDP本身是无连接的、没有建链和拆链成本。\r\n* UDP的数据包无队头阻塞问题。\r\n* UDP改造成本小。\r\n\r\n### HTTP3新特性\r\n1. 多路复用，解决了TCP队头阻塞问题。\r\n\r\n>HTTP2.0协议的多路复用机制解决了HTTP层的队头阻塞问题，但是在TCP层仍然存在队头阻塞问题，如果基于TCP协议，会出现某个数据包丢失导致整个连接数据被阻塞。QUIC协议是基于UDP协议实现的，在一条链上可以有多个流，流与流之间是互不影响的，一个流的包发生丢包只需这个流的包进行重传，其他流的包不受影响，这样就解决了TCP存在的队头阻塞问题，同时QUIC协议在移动端的表现也比TCP好，因为TCP是基于IP和端口号去识别连接的，这种变化在多变的移动端网络环境下是很脆弱的，QUIC通过Id的方式去识别连接，不管网络环境如何变化，只要ID不变，就能迅速连上。\r\n\r\n2. 0RTT建链\r\n\r\n>RTT指的是数据包在网络中一来一回的时间消耗。RTT包括三部分：往返传播时延、网络设备内排队时延、应用程序数据处理时延。\r\n\r\n>一般来说HTTPS协议建立完整的链接需要TCP握手和TLS我受不，总计至少需要2-3个RTT，普通的HTTP协议也需要至少一个RTT才可以完成握手，然而QUIC协议可以实现在第一个包就包含有效的应用数据，从而实现0RTT，但是这是有前提条件的，对于第一次交互的客户端和服务端0RTT也是做不到的，因为双方需要进行1RTT的密钥交换，首次连接客户端对密钥信息进行了缓存，在缓存有效时间内，再次连接可以跳过这个1RTT，实现0RTT的数据交互。\r\n\r\n3. 前向纠错机制\r\n\r\n>QUIC协议的的每个数据包除了它本身的内容之外，还包括了部分其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传，向前纠错牺牲了每个数据包可以发送数据的上限，但是减少了因为丢包导致的数据重传，因为数据重传将会消耗更多的时间，假如要发送三个包，协议会计算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包，当非校验包丢失的时候，可以通过另外三个包计算出丢失的数据包的内容，当然这种技术只能使用在丢失一个包的情况，如果出现丢失多个包的情况，就只能使用重传机制了。\r\n\r\n4. 连接迁移\r\n\r\n>网络切换几乎无时无刻都在发生。TCP协议使用五元组来表示一条唯一的连接，当我们从4G环境切换到WiFi环境的时候，手机的IP地址会发生变化，此时就必须创建新的TCP连接才能继续传输数据。QUIC协议摒弃了五元组的概念，使用64位随机数作为连接的ID，并使用该ID表示连接，基于QUIC协议，在切换流量和WiFi的时候，不会出现重连的情况，提高了效率。\r\n\r\n5. 加密认证的报文\r\n\r\n>TCP协议头部没有经过任何加密和认证，所以在传输过程中很容易被中间网络设备篡改，注入和窃听，但是QUIC除了个别报文外，所有报文头部都是经过加密认证的。\r\n\r\n6. 实现了类似TCP的流量控制，传输可靠性的功能。\r\n\r\n>虽然UDP不提供可靠性的传输，但QUIC在UDP的基础上增加了一层来保证数据可靠性的可靠性传输，它提供了数据包重传，拥塞控制以及其他一些TCP中存在的特性。\r\n\r\n## 四、HTTP.0 HTTP1.1 HTTP2.0的区别\r\n### HTTP1.0和HTTP1.1之间的区别\r\n1. 缓存处理\r\n\r\n>在HTTP1.0中主要是用header里面的If-Modified-Since，Expires作为缓存判断的标准，而HTTP1.1则引入了更多的缓存控制策略，例如Etag,If-Unmodified-Since,If-Match,If-None-Match等更多可供选择的缓存头来控制缓存策略。\r\n\r\n2. 带宽优化及网络连接的使用\r\n\r\n>在HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的某一部分，而服务器却将整个对象传送过来了，并且不支持断点续传功能。HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。\r\n\r\n3. 错误通知的管理\r\n\r\n>在HTTP1.1中新增了24个错误状态响应码，如409（Conflit）表示请求的资源和资源的当前状态发生冲突，410(Gone)表示服务器上的某个资源被永久的删除。\r\n\r\n4. Host头处理\r\n\r\n>在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此请求消息中的URL并没有传递主机名Hostname,但是随着虚拟主机的发展，在一台物理服务器上可以存在多个虚拟主机，并且共享一个IP地址，HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误400 Bad Request。\r\n\r\n5. 长连接\r\n\r\n>HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection: keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。\r\n\r\n### HTTP2.0和HTTP1.1之间的区别\r\n1. 新的二进制格式\r\n\r\n>HTTP1.1的解析是基于文本的，基于文本协议的格式解析存在天然缺陷，二进制则不同，只有0和1的组合，基于这种考虑HTTP2.0的协议解析采用二进制格式，实现方便且健壮。\r\n\r\n2. 多路复用\r\n\r\n>关于这部分的介绍请看HTTP2.0新特性关于多路复用的介绍。\r\n\r\n3. 首部压缩\r\n\r\n>关于这部分的介绍请看HTTP2.0新特性关于首部压缩的介绍。\r\n\r\n4. 服务器推送\r\n\r\n>关于这部分的介绍请看HTTP2.0新特性关于服务器推送的介绍。\r\n\r\n\r\n## 五、Keep-Alive机制\r\n>说起keep-alive，我们首先要明确的是，有两种keepalive，一种是TCP的keepalive，另一种是HTTP的keep-alive。\r\n\r\n### TCP的keepalive\r\n>TCP的keepalive存在的主要意义是保持客户端和服务端的连接，一方会不定期的发送心跳包给另一方，如果间隔发送几次，对方返回的都是RST，而不是ACK，那么就释放当前的连接，如果TCP层没有keepalive的机制，一旦一方断开连接却没有发送FIN给另外一方，那么另外一方会一直以为这个连接还存在，长时间的话，这对服务器的资源的影响是很大的。\r\n\r\n### HTTP的keep-alive\r\n>HTTP层的keep-alive主要是为了复用TCP连接，HTTP服务的发起方一般都是浏览器，一般先执行完逻辑并传输完数据的一定是服务端，假如没有keep-alive机制的存在，服务端在传输完数据之后会首先断开连接，由于TCP的四次挥手的机制，先发起断开连接的一方会进入TIME_WAIT状态并等待2MSL的时间，客户端的每一次请求服务端都要消耗这个时间，但是服务器的资源是非常有限的，这对服务器端的消耗是巨大的，所以HTTP层的keep-alive是非常重要的。\r\n\r\n### 二者区别\r\n>TCP的keepalive是在ESTABLISHED状态，主要是用于检测连接的可用性，而TCP的keep-alive主要是为了进行TCP连接的复用，避免频繁的TCP三次握手和四次挥手的环节。\r\n\r\n## 六、HTTP基本结构\r\n### HTTP协议在哪一层？下面那一层是什么协议？\r\n>HTTP协议在应用层，如果是TCP/IP四层网络模型的话，下一层是传输层，这一层一般是TCP/UDP协议。\r\n\r\n### HTTP有哪些请求方法？\r\n>HTTP1.0定义了三种请求方法：GET、HEAD、POST方法。\r\n>HTTP1.1新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE和CONNECT方法。\r\n\r\n* GET：请求指定的页面信息，并返回实体主体。\r\n* HEAD：类似GET请求，只不过返回的响应中没有具体的内容，用于获取报头。\r\n* POST：向指定资源提交数据，例如提交表单。\r\n* PUT：通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定资源的内容。\r\n* DELETE：请求服务器删除指定的资源。\r\n* CONNECT：当浏览器配置为使用代理服务器时才会用到CONNECT方法。\r\n* OPTIONS：用于描述目标资源的通信选项，查看服务器支持哪些请求方法。\r\n* TRACE：沿着到目标资源的路径执行一个消息环回测试，可用于debug测试。\r\n* PATCH：对已知资源进行局部更新。\r\n\r\n### HTTP有哪些常见的请求头？\r\n>下面介绍一些常用的请求头。\r\n\r\n* Accept: 浏览器可以接受服务器返回的类型。\r\n* Accept-Encoding：浏览器申明自己能够处理的压缩或编码方法。\r\n* Accept-Language：用于浏览器声明自己接收的语言。\r\n* Connection\r\n    * Connection: keep-alive 当一个网页打开完成之后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。即TCP连接的复用。\r\n    * Connection：close 代表一个Request完成之后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭，当客户端再次发送请求的时候，需要重新建立TCP连接。\r\n    \r\n* Host: 发送请求时，该报头域是必需的，主要用于指定被请求资源的主机和端口号。\r\n* Referer：这个字段主要是告诉服务器，该请求是从哪个页面链接过来的。\r\n* User-Agent：告诉服务器，客户端使用的操作系统和浏览器的名称和版本。\r\n* Cache-Control:\r\n    * private：告诉服务器响应只能作为私有缓存，不能再用户间共享。\r\n    * public：响应可以被缓存并再多用户间共享\r\n    * no-cache：使用协商缓存。\r\n    * no-store：不缓存。\r\n* cookie：用于存储一些用户信息以便让服务器辨别用户身份，例如cookie中可能会存储用户的id和密码，当用户登录后就会再客户端产生一个cookie来存储相关信息，这样浏览器通过读取cookie信息去服务器上验证并通过后可以认定是否是合法用户。\r\n\r\n* Range：用于断点续传，告知服务器自己想要获取对象的哪一部分。\r\n\r\n### HTTP请求体的内容\r\n>HTTP的请求体一般有三种形式，例如：\r\n\r\n* application/json\r\n* text/xml\r\n* application/x-www-form-urlencoded\r\n\r\n### HTTP的报文结构\r\n>HTTP的报文结构包括请求报文的报文结构和响应报文的报文结构。\r\n\r\n#### 请求报文的报文结构\r\n* 请求行：请求方法 + 请求URL + HTTP版本\r\n* 请求头：字段名和对应的值\r\n* 空行：请求头之后是一个空行，主要是告知服务器下面不在有请求头。\r\n* 请求体：由用户自定义添加，例如post方法的body部分。\r\n\r\n#### 响应报文的报文结构\r\n* 状态行： HTTP版本 + 状态码 + 状态描述符（OK）\r\n* 响应头：字段名 + 对应的值\r\n* 空行\r\n* 响应体\r\n\r\n### 什么是HTTP劫持？\r\n>当用户的浏览器和目标服务器建立连接通道后，当浏览器发起HTTP请求后，运营商的路由器会首先收到这次HTTP请求，之后运营商路由器的旁路设备会将此TCP连接为HTTP协议，然后抢在网站服务器返回数据之前发送HTTP协议的302状态码进行劫持，浏览器以为是临时重定向，便跳转到目标URL上，旁路设备完成标记后会返回修改后的HTML代码，导致浏览器中被插入了运营商的广告，随后网站服务器的真正数据会被丢弃。\r\n\r\n## 七、HTTP1.0存在的问题\r\n>HTTP1.0主要存在以下几个问题：\r\n\r\n1. 无法复用连接，每次发送请求都需要进行一次TCP连接，而TCP的连接释放过程又是比较增加延时的，这样会使得网络带宽的利用率比较低。\r\n2. 存在队头阻塞的问题，一个请求必须在前一个请求响应到达之后才能发送。\r\n3. 不支持断点续传，也就是说每次都会传送全部的页面和数据。\r\n\r\n## 八、HTTPS加密原理\r\n### 为什么要有HTTPS？\r\n>之所以要有HTTPS，是因为HTTP协议是一种不安全的传输协议，HTTP在传输数据的过程中，所有的数据都是明文传输，即使在前端通过一些加密算法进行加密后，服务端也是无法直接进行解密的。\r\n\r\n### 对称加密和非对称加密\r\n>HTTPS解决数据传输安全问题的方案就是使用加密算法，具体来说是对称加密和非对称加密的混合使用，下面我们先介绍下这两种加密算法的特点。\r\n\r\n#### 对称加密\r\n>对称加密指的是加密和解密都用的同一个密钥，常用的对称加密算法有DES，AES等。\r\n\r\n* 优点：算法公开，计算量小、加密速度快、加密效率高、适合对比较大的数据进行加密。\r\n* 缺点：由于交易双方使用的是相同的密钥，所以无法避免密钥的传输，密钥在传输的过程中可能会被截获，用户每次使用对称加密算法，都需要使用其他人不知道的唯一密钥，这会使得双方所拥有的的钥匙数量急剧增长，密钥管理更加困难。\r\n\r\n#### 非对称加密\r\n>非对称加密就是加密和解密使用两个不同的密钥：公钥和私钥。其中公钥和私钥是一堆，如果使用公钥对数据进行加密，只有用对应的私钥才能进行解密。如果使用私钥对数据进行加密，那么只有使用对应的公钥才能进行解密。非对称加密算法实现信息交换的基本过程是：客户端拿到服务器的公钥后，会生成一个随机KEY，然后使用公钥把这个KEY进行加密然后发送给服务器，服务器使用私钥将其解密，这样双方都拥有了同一个密钥KEY，然后就可以使用这个KEY进行对称加密交互数据，同时避免了KEY传输被拦截的情况，也就保证了加密数据的安全。\r\n\r\n* 优点：算法公开，加密和解密使用的是不同的钥匙，私钥不需要通过网络进行传输，安全性很高。\r\n* 缺点：计算量比较大，加密和解密速度相比对称机密慢很多。\r\n\r\n### HTTP和HTTPS之间的关系\r\n* HTTPS = HTTP + SSL/TLS\r\n\r\n### HTTPS的加密流程\r\n>HTTPS的整个通信过程可以分为两大阶段，一是证书验证阶段，二是数据传输阶段，其中数据传输阶段又可以分为非对称加密和对称加密两个阶段。\r\n\r\n1. 客户端请求HTTPS的网址，然后连接到服务器的443端口。（HTTPS默认的端口是443，HTTP默认的端口是80）。\r\n2. 采用HTTPS协议的服务器必须要有一套由数字证书认证机构颁发的CA证书，颁发证书的同时会产生一个私钥和公钥，私钥是由服务端保存的，不可泄露，公钥则是附带在证书的信息中，可以公开的。证书本身也带有一个证书电子签名，这个签名是用来验证证书的完整性和真实性，可以防止证书被篡改。\r\n3. 服务器响应客户端请求，将证书传递给客户端，证书中包含公钥和大量其他信息，比如证书颁发机构信息、公司信息和证书有效期等，通过chrome浏览器点击地址栏的锁标志可以查看证书的详细信息。\r\n4. 客户端解析证书并对其进行验证，如果证书不是可信机构颁发的，或者证书中的域名和实际域名不一致，或者证书过期，就会对访问者显示警告信息，如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥A，然后客户端还会生成一个随机码KEY，并使用公钥A将其加密。\r\n5. 客户端把加密后的随机码KEY发送给服务器，作为后面对称加密的密钥。\r\n6. 服务器在收到密文后，会通过私钥解析出随机码KEY。\r\n7. 服务器使用上述步骤获取到的KEY，对数据进行对称加密并发送给客户端，客户端使用相同的KEY对数据进行解密。\r\n8. 然后双方使用对称加密传输完所有数据。\r\n\r\n### HTTP和HTTPS的区别\r\n1. 安全性不同。HTTP明文传输，不对数据进行加密安全性较差，HTTPS的数据传输过程是加密的，安全性较好。\r\n2. 是否需要申请CA证书。HTTPS协议需要申请证书，HTTP协议不需要。\r\n3. 页面响应速度不同。HTTP页面响应速度比HTTPS快，因为HTTPS多了一层加密层，所以会影响速度。HTTP协议使用TCP三次握手建立连接，客户端和服务器交换需要三个包，而HTTPS除了TCP的三个包之外，还要加上ssl的九个包。\r\n4. 端口不同。HTTP默认的是80端口，HTTPS默认的是443端口。\r\n5. 消耗服务器资源不同。HTTPS是构建在SSL/TLS之上的HTTP协议，所以更加消耗服务器的资源。\r\n\r\n### HTTPS的缺点\r\n1. HTTPS协议握手阶段比较费时，会使页面的加载时间延长50%，增加10%到20%的耗电。\r\n2. SSL证书需要一定的费用，功能越强大的证书费用较高。\r\n3. HTTPS需要较高的服务器资源，会导致成本上升。\r\n4. HTTPS协议的加密范围比较有限，某些国家如果能够控制CA根证书的情况下，中间人攻击也是可行的。\r\n\r\n### TLS工作原理及详细握手过程\r\n>HTTPS相比于HTTP最大的不同就是多了一层SSL或TLS，SSL和TLS协议可以为通信双方提供识别和认证通道，从而保证了通信的机密性和数据完整性，不过目前SSL逐渐被TLS协议取代，因此下文主要对TLS进行介绍。TLS握手是启动HTTPS通信的过程，类似于TCP建立连接时的三次握手，在TLS握手的过程中，通信双方交换消息以相互验证，相互确认，并确立它们所使用的加密算法以及用于对称加密的密钥，所以TLS握手时HTTPS通信的基础部分。\r\n\r\n#### TLS握手的主要目的\r\n1. 协商双方通信所使用的TLS版本（例如TLS1.0还是1.2）。\r\n2. 确定双方要使用的密码组合。\r\n3. 客户端通过服务器的公钥和数字证书上的数字签名验证服务端的身份。\r\n4. 生成会话密钥，该密钥将用于握手结束后的对称加密。\r\n\r\n#### TLS握手的详细过程(重看 RSA 1.2 1.3)\r\n>不同的密钥交换算法，TLS的握手过程有一些区别，当前TLS握手有三个版本，分别是RSA版本、TLS1.2和TLS1.3。\r\n\r\n>下面详细介绍下RSA版的TLS握手。传统的TLS握手基本都是使用RSA算法来实现密钥交换的。，接下来，我们对RSA版的TLS的每一次握手进行介绍。\r\n\r\n* 第一次握手：客户端首先会发送一个Client Hello消息，这个消息中包含了客户端使用TLS版本号，支持的密码套件列表，以及客户端生成的随机数，这个随机数会被服务器端保留，是生成对称加密密钥的参数之一。\r\n\r\n* 第二次握手：服务端收到客户端的Client Hello消息后，会确认TLS版本号是否支持，然后从客户端支持的密码套件列表中选择一个密码套件，然后生成服务端随机数，然后返回Server Hello消息，消息里面包含了服务器选择的TLS版本号，和服务端随机数，和服务端选择的密码套件，同时服务端还会将自己的数字证书发送给客户端。（客户端和服务端都会各自生成一个随机数，并且会把随机数传递给对方，这两个随机数是作为后续生成会话密钥的条件）\r\n\r\n* 第三次握手：客户端验证完服务端的证书后，如果该证书是可信证书的话，客户端会生成一个随机数pre-master（预主密钥）,然后用服务器的RSA公钥加密该随机数（RSA公钥是从服务端发过来的数字证书中提取的），然后传递给服务端。服务端收到后，会用RSA私钥进行解密，得到客户端发过来的随机数pre-master，至此，客户端和服务端均拥有了三个随机数，分别是Client Random、Server Random、pre-master，双方会根据这三个随机数，生成会话密钥，它是对称密钥，用于对后续的HTTP请求和响应数据的加密和解密，生成完会话密钥之后，客户端会发送一个密码策略已经改变的报文给服务端，告诉服务端开始使用加密方式发送消息，然后客户端还会发送一个消息把之前所有发送的数据做一个摘要，然后使用会话密钥加密一下，让服务器做个验证，以验证之前的握手信息有没有被中途篡改过。\r\n\r\n* 第四次握手：服务器也会进行同样的操作，发送一个密码策略已经改变的报文，然后也会把之前所有发送的数据做一个摘要，然后使用会话密钥加密之后，让客户端做一个验证，如果双方都验证加密和解密没有问题，那么握手正式完成，之后就会使用会话密钥来加解密HTTP请求和响应了。\r\n\r\n>RSA算法的缺陷\r\n\r\n>使用RSA密钥协商算法的最大问题是不支持前向保密，一旦服务端的私钥泄露了，过去第三方截获的所有TLS通讯密文都会被破解，于是有了基于ECDHE算法的TLS1.2,下面简要介绍下TLS1.2的握手过程。\r\n\r\n* 第一次握手：客户端向服务端发送Client Hello，这个消息包含了客户端支持的TLS版本号，支持的密码套件列表以及客户端生成的随机数。\r\n* 第二次握手：服务端收到后，会立即返回一个服务端随机数，与服务端选择的密码套件和包含公钥的数字证书，然后服务器将利用私钥将客户端随机数、服务端随机数、和服务端DH参数进行签名，生成服务器签名然后发送给客户端，同时发送这个服务端DH参数。\r\n* 第三次握手：浏览器会先验证数字证书和服务器签名，通过后将客户端的DH参数传递给服务器。接着客户端通过ECDHE算法，利用客户端DH参数和服务端DH参数计算出预主密钥，有了预主密钥、客户端随机数和服务端随机数，客户端利用这三个计算出对称加密的主密钥。\r\n* 第四次握手：服务端也使用ECDHE算法生成预主密钥，然后用相同的方法生成主密钥。当双方都验证通过之后，握手正式结束，后面开始正常收发加密的HTTP请求和响应了。\r\n\r\n>RSA和ECDHE握手过程的区别\r\n\r\n* RSA密钥协商算法不支持前向保密，ECDHE密钥协商算法不支持前向保密。\r\n* 使用了RSA密钥协商的算法，TLS完成四次握手之后，才能进行应用数据的传输，而对于ECDHE算法，客户端可以不用等服务端的最后一次TLS握手，就可以提前发出加密的HTTP数据，节省了一个消息的往返时间。\r\n\r\n## 八、综合性面试题\r\n### HTTPS为什么既有对称加密也有非对称加密？\r\n>对称加密的加解密使用的是用一个密钥，由于交易双方使用的是相同的密钥，无法避免密钥的传输，密钥在传输的过程中可能会被截获，但是对称加密的计算量较小，加密速度快，加密效率高。非对称加密采用的是公私钥的方式，私钥不在网络中传输，但是计算量比较大，效率不高。所以HTTPS利用这两者的优势，将两种方式结合起来，在交换密钥阶段使用非对称加密的方式，之后建立通信后，使用对称加密的方式。\r\n\r\n### 客户端如何验证证书的有效性？\r\n>一个数字证书通常包含了公钥、持有者信息、证书认证机构CA的信息、CA对这份文件的数字签名和使用的算法以及证书的有效期。数字证书的作用就是用来认证公钥持有者的身份，以防止第三方进行冒充，这个则行数是由CA证书认证机构签名的，这个CA证书认证机构是网络世界的认证中心，具有极高的可信度，所以由他签发的证书是可靠的。之所以要签名是为例防止中间人对证书进行篡改。\r\n\r\n#### CA签发证书的过程\r\n* 首先CA会把持有者的公钥、用途、颁发者、有效时间等进行一个打包，然后进行Hash计算，得到一个Hash值。\r\n* 然后CA会使用自己的私钥将该Hash值进行加密，生成一个证书签名。\r\n* 将证书签名添加到文件证书上，形成数字证书。\r\n\r\n#### 客户端验证服务端数字证书的过程\r\n* 客户端使用相同的哈希算法获取该证书的哈希值。\r\n* 一般情况下，用户的浏览器和操作系统中集成了CA的公钥信息，浏览器收到证书之后可以使用CA的公钥解密数字签名得到另一个哈希值。\r\n* 浏览器比较两个哈希值，如果值相同，则认为这个证书是可信的，反之认定证书不可信。\r\n\r\n#### HTTPS如何防止中间人攻击？\r\n>关于HTTPS防止中间人攻击的方法，我们只需要从上文中的客户端如何验证证书的有效性来回答即可。\r\n\r\n## 参考文献\r\n>特别感谢以下博主的文章支持！\r\n\r\n* [HTTPS 详解一：附带最精美详尽的 HTTPS 原理图](https://segmentfault.com/a/1190000021494676)\r\n\r\n* [图解 HTTPS：RSA 握手过程](https://zhuanlan.zhihu.com/p/344086342)\r\n\r\n* [图解 ECDHE 密钥交换算法](https://www.cnblogs.com/xiaolincoding/p/14318338.html)"
    },
    {
      "id": "/Egg.js中间件的核心用法",
      "metadata": {
        "permalink": "/blog/Egg.js中间件的核心用法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Egg.js中间件的核心用法.md",
        "source": "@site/blog\\Egg.js中间件的核心用法.md",
        "title": "Egg.js中间件的核心用法",
        "description": "一、在应用中使用中间件",
        "date": "2021-10-30T00:00:00.000Z",
        "formattedDate": "2021年10月30日",
        "tags": [
          {
            "label": "Egg.js",
            "permalink": "/blog/tags/egg-js"
          }
        ],
        "readingTime": 4.24,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Egg.js中间件的核心用法",
          "date": "2021-10-30T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Egg.js",
          "tags": [
            "Egg.js"
          ]
        },
        "prevItem": {
          "title": "（最系统、最全面）这一次，彻底搞懂HTTP面试",
          "permalink": "/blog/（最系统、最全面）这一次，彻底搞懂HTTP面试"
        },
        "nextItem": {
          "title": "Egg.js中使用extend、Cookie、Session的基本方式",
          "permalink": "/blog/Egg.js中使用extend、Cookie、Session的基本方式"
        }
      },
      "content": "## 一、在应用中使用中间件\r\n1. 在app/middleware文件夹下新建一个auth2.js\r\n\r\n```js\r\nmodule.exports = (option,app) => {\r\n\r\n  return async function auth2(ctx,next) {\r\n\r\n    console.log(new Date);\r\n\r\n    // 下面的这个语句很重要，如果没有下面这个语句，线程执行到这里就要终止了\r\n    await next();\r\n  }\r\n}\r\n```\r\n\r\n2. 注册中间件\r\n\r\n>在config.default.js中进行注册。\r\n\r\n```js\r\nconfig.middleware = ['auth2'];\r\n```\r\n\r\n3. 给中间件传参\r\n\r\n```js\r\nconfig.middleware = ['auth2'];\r\n```\r\n\r\n4. 中间件读取传过来的参数\r\n\r\n```js\r\nreturn async function auth2(ctx,next) {\r\n    console.log(option);\r\n\r\n    console.log(new Date);\r\n\r\n    // 下面的这个语句很重要，如果没有下面这个语句，线程执行到这里就要终止了\r\n    await next();\r\n  }\r\n```\r\n\r\n## 二、在router.js中使用中间件\r\n>本节的目标是给指定路由配置中间件。下面的这种方式，不需要再config.default.js中注册路由了。\r\n\r\n1. 定义中间件的方式和上文的定义方式一致。\r\n2. 在router.js中获取中间件，并指定哪些路由能够触发。\r\n\r\n```js\r\nmodule.exports = app => {\r\n  const { router, controller } = app;\r\n  const auth = app.middleware.auth();\r\n  router.get('/',auth, controller.home.setSession);\r\n  router.get('/news', controller.news.index);\r\n  router.get('/deletecookie',controller.home.deletecookie)\r\n};\r\n```\r\n\r\n## 三、Egg.js中使用KOA的中间件\r\n>下文我们以egg中使用koa-jsonp这个中间件为例进行系统性阐述。\r\n\r\n1. 安装koa-jsonp\r\n\r\n```shell\r\nnpm install koa-jsonp\r\n```\r\n\r\n2. 在app/middleware中新建一个jsonp.js\r\n\r\n```js\r\n// 配置KOA的中间件\r\n\r\nconst jsonp = require('koa-jsonp');\r\n\r\nmodule.exports = jsonp;\r\n```\r\n\r\n3. 注册中间件(在config.default.js)\r\n\r\n```js\r\nconfig.middleware = ['jsonp'];\r\n```\r\n\r\n4. 请求指定路径\r\n\r\n```js\r\nhttp://127.0.0.1:7001/shop?callback=666\r\n```\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/825fdeccb69c8329c5a327bae582a113.png)\r\n\r\n>下文继续讲一个koa-compress的中间件，这个中间件能够开启服务器Gzip压缩的功能。\r\n\r\n1. 安装koa-compress\r\n\r\n```\r\nnpm install koa-compress\r\n```\r\n\r\n2. 在app/middleware下新建一个compress.js\r\n\r\n```js\r\nmodule.exports = require('koa-compress');\r\n```\r\n\r\n3. 注册中间件\r\n\r\n```js\r\nconfig.middleware = ['jsonp','compress'];\r\n```\r\n\r\n4. 配置中间件的参数\r\n\r\n```js\r\nconfig.compress = {\r\n    threshold: 1024   // 设置压缩门限值\r\n}\r\n```\r\n\r\n>此时访问指定页面的文件都是经过压缩的文件了。\r\n\r\n>如果是非标准的中间件，中间件的定义方式如下所示：\r\n\r\n```js\r\n// 下面演示非标准中间件的使用\r\n\r\nconst middleWare = require('xxx');\r\n\r\nmodule.exports = (option,app) => {\r\n  return middleWare(options1,options2)\r\n}\r\n```\r\n\r\n## 四、中间件的通用配置\r\n>无论是引用层加载的中间件还是框架再带的中间件，都支持下面三个通用的配置项。\r\n\r\n1. enable：控制中间件是否开启。\r\n2. match：设置只有符合某些规则的请求才会经过这个中间件。\r\n3. ignore：设置符合某些规则的请求不经过这个中间件。\r\n\r\n* 禁用某个中间件\r\n\r\n```js\r\nconfig.compress = {\r\n    enable: false,\r\n    threshold: 10   // 设置压缩门限值\r\n  }\r\n```\r\n\r\n* 设置让某个路由能匹配中间件\r\n\r\n```js\r\nconfig.auth = {\r\n    match: '/news',\r\n    title: 'auth 你好'\r\n  }\r\n```\r\n\r\n>如果想忽略某个路由，可以使用下面的写法\r\n\r\n```js\r\nconfig.auth = {\r\n    ignore: '/news',\r\n    title: 'auth 你好'\r\n  }\r\n```\r\n\r\n>如果要处理的路由情况比较复杂，我们还可以使用下面的match方法\r\n\r\n```js\r\nconfig.auth = {\r\n    match(ctx) {\r\n      if (ctx.request.url === '/shop' || ctx.request.url === \"/news\") {\r\n        return true;\r\n      }\r\n      return false\r\n    },\r\n    title: 'auth 你好'\r\n  }\r\n```\r\n\r\n## 五、设置未经授权的用户无法访问指定页面\r\n1. 在app/middleware/ 下创建指定中间件\r\n\r\n```js\r\nmodule.exports = (option,app) => {\r\n  return async function auth(ctx,next) {\r\n    if (ctx.session && ctx.session.userinfo) {\r\n      await next()\r\n    } else {\r\n      if (ctx.request.url === '/') {\r\n        await next();\r\n      } else {\r\n        ctx.redirect('/');\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n2. 注册中间件\r\n\r\n```js\r\n  config.middleware = ['auth','compress','adminAuth'];\r\n```\r\n3. 让指定路径的路由触发中间件\r\n\r\n```js\r\n  config.adminAuth = {\r\n    match: '/admin/user'\r\n  }\r\n```"
    },
    {
      "id": "/Egg.js中使用extend、Cookie、Session的基本方式",
      "metadata": {
        "permalink": "/blog/Egg.js中使用extend、Cookie、Session的基本方式",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Egg.js中使用extend、Cookie、Session的基本方式.md",
        "source": "@site/blog\\Egg.js中使用extend、Cookie、Session的基本方式.md",
        "title": "Egg.js中使用extend、Cookie、Session的基本方式",
        "description": "一、初始化",
        "date": "2021-10-29T00:00:00.000Z",
        "formattedDate": "2021年10月29日",
        "tags": [
          {
            "label": "Egg.js",
            "permalink": "/blog/tags/egg-js"
          }
        ],
        "readingTime": 6.845,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Egg.js中使用extend、Cookie、Session的基本方式",
          "date": "2021-10-29T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Egg.js",
          "tags": [
            "Egg.js"
          ]
        },
        "prevItem": {
          "title": "Egg.js中间件的核心用法",
          "permalink": "/blog/Egg.js中间件的核心用法"
        },
        "nextItem": {
          "title": "LeetCode——二叉树的层序遍历（递归与非递归）",
          "permalink": "/blog/LeetCode——二叉树的层序遍历（递归与非递归）"
        }
      },
      "content": "## 一、初始化\r\n1. 项目初始化\r\n\r\n```js\r\negg-init spider --type=simple\r\n```\r\n\r\n2. 安装依赖\r\n\r\n```js\r\nnpm i\r\n```\r\n\r\n3. 运行测试项目\r\n\r\n```shell\r\nnpm run dev\r\n```\r\n\r\n4. 配置模板引擎\r\n\r\n```shell\r\nnpm i egg-view-ejs \r\n```\r\n\r\n5. 找到app/config/plugin.js\r\n\r\n```js\r\nexports.ejs = {\r\n    enable: true,\r\n    package: 'egg-view-ejs'\r\n};\r\n```\r\n\r\n6. 找到app/config/config.default.js\r\n\r\n```js\r\nconfig.view = {\r\n    mapping: {\r\n        '.html': 'ejs'\r\n    }\r\n}\r\n```\r\n\r\n7. 配置公共的URL地址（config/config.default.js）\r\n\r\n```js\r\nconfig.api = \"http://www.phonegap100.com/\"\r\n```\r\n\r\n## 二、抓取新闻接口实现新闻列表与详情\r\n1. 定义新闻列表和新闻详情路由\r\n\r\n```js\r\nrouter.get('/news', controller.news.index);\r\nrouter.get('/newscontent', controller.news.content);\r\n```\r\n\r\n2. 在service中获取新闻列表的数据和新闻详情的数据\r\n\r\n```js\r\nasync index() {\r\n    let list = await this.service.news.getNewsList();\r\n    await this.ctx.render('news',{\r\n      list\r\n    })\r\n  }\r\nasync content() {\r\n    const aid = this.ctx.query.aid;\r\n    console.log(aid);\r\n\r\n    const detail = await this.service.news.getNewsContent(aid);\r\n\r\n    await this.ctx.render('newscontent',{\r\n      detail:detail[0]\r\n    })\r\n  }\r\n```\r\n\r\n>记住：渲染的时候，一定要使用await，因为这是异步渲染，不然可能会报404错误。\r\n\r\n3. 在view视图层中定义模板引擎\r\n\r\n```html\r\n  <h2>新闻列表</h2>\r\n  <ul>\r\n    <%for (let i = 0; i < list.length; i++) {%>\r\n      <li><a href=\"/newscontent?aid=<%=list[i].aid%>\"><%=list[i].title%></a></li>\r\n    <%}%>\r\n  </ul>\r\n```\r\n\r\n## 三、Egg.js框架拓展extend\r\n### 通过Application\r\n1. 在app文件夹下新建文件夹extend\r\n2. 在extend文件夹下面创建一个application.js，在这个文件中暴露的函数，均可以通过this.app.xxx来进行调用,但是在application.js内部this就是app。\r\n\r\n```js\r\nmodule.exports = {\r\n  foo(param) {\r\n    // this 就是 app 对象，在其中可以调用 app 上的其他方法，或访问属性\r\n    console.log(this);\r\n  },\r\n};\r\n```\r\n\r\n### 通过Context\r\n1. 在extend文件夹下创建context.js\r\n2. 在context.js中定义想要拓展的函数\r\n\r\n```js\r\nmodule.exports = {\r\n  getHost(param) {\r\n    // this 就是 ctx 对象，在其中可以调用 ctx 上的其他方法，或访问属性\r\n    return this.request.header.host; \r\n  },\r\n};\r\n```\r\n\r\n3. 调用拓展的函数\r\n\r\n```js\r\nconsole.log(this.ctx.getHost());\r\n```\r\n\r\n>更多其他的拓展方式请访问官网：[Egg拓展](https://eggjs.org/zh-cn/basics/extend.html#context)\r\n\r\n### 通过拓展的形式将时间戳转换为时间字符串\r\n1. 安装相关模块并引入\r\n\r\n```js\r\nconst sd = require('silly-datetime')\r\n\r\nmodule.exports = {\r\n  formatTime (param) {\r\n    // this 是 helper 对象，在其中可以调用其他 helper 方法\r\n    // this.ctx => context 对象\r\n    // this.app => application 对象\r\n    return sd.format(new Date(param*1000),'YYYY-MM-DD HH:mm')\r\n  },\r\n};\r\n```\r\n\r\n2. 在模板引擎中使用\r\n\r\n```js\r\n<%=helper.formatTime(list[i].dateline)%>\r\n```\r\n\r\n3. 在控制器中使用\r\n\r\n>通过this.ctx.helper.xxx()\r\n\r\n```js\r\nconsole.log(this.ctx.helper.sendHello());\r\n```\r\n\r\n### 通过Request\r\n1. 在extend文件夹下面创建request.js\r\n\r\n```js\r\nmodule.exports = {\r\n  foo() {\r\n    return this.header.host\r\n  },\r\n};\r\n```\r\n\r\n2. 在控制器中调用\r\n\r\n```js\r\nconsole.log(this.ctx.request.foo());\r\n```\r\n\r\n## 四、禁止指定IP的访问\r\n### Egg调用中间件的时机\r\n>匹配路由前或匹配路由完成时。\r\n\r\n### 中间件的定义与配置、传值\r\n1. 在app文件夹下新建一个文件夹middleware文件夹，并在下面新建一个printdate.js\r\n\r\n```js\r\nmodule.exports = (options,app) => {\r\n\r\n  console.log(options);\r\n  // 返回一个异步的方法\r\n  return async function printDate(ctx,next) {\r\n    console.log(new Date());\r\n    await next();\r\n  }\r\n}\r\n```\r\n\r\n2. 在config/config.default.js\r\n\r\n```js\r\n  config.middleware = ['printdate'];\r\n\r\n  config.printdate = {\r\n    aaa: '123'\r\n  }\r\n```\r\n\r\n### 禁止指定ip访问\r\n1. 在app/middleware中新建一个forbidip.js\r\n\r\n```js\r\nmodule.exports = (options,app) => {\r\n  // 返回一个异步的方法\r\n  return async function printDate(ctx,next) {\r\n    // 要屏蔽的IP\r\n    const forbidIp = \"127.0.0.1\";\r\n    // 获取客户端的ip\r\n    if (ctx.request.ip === forbidIp) {\r\n      ctx.status = 403;\r\n      ctx.body = \"您的IP已经被屏蔽\"\r\n    } else {\r\n      await next();\r\n    }\r\n\r\n  }\r\n}\r\n```\r\n\r\n2. 在config/config.default.js中注册这个中间件\r\n\r\n```js\r\nconfig.middleware = ['printdate','forbidip'];\r\n```\r\n\r\n## 五、POST提交数据并通过中间件配置CSRF\r\n1. 模板引擎中定义好csrf\r\n\r\n```js\r\n  <form action=\"/add?_csrf=<%=csrf%>\" method=\"post\">\r\n    用户名：<input type=\"text\" name=\"username\"><br><br>\r\n    密码：<input type=\"password\" name=\"password\"><br><br>\r\n    <button type=\"submit\">提交</button>\r\n  </form>\r\n```\r\n\r\n2. 在app/middleware下创建一个auth.js\r\n\r\n```js\r\nmodule.exports = (option,app) => {\r\n  return async function auth(ctx,next) {\r\n    \r\n    // 设置模板全局变量，之所以要这样做，是为了让模板引擎能够直接获取到csrf，而不用每次都传递csrf\r\n    ctx.state.csrf = ctx.csrf;\r\n    await next();\r\n  }\r\n}\r\n```\r\n\r\n## 六、Egg.js中使用Cookie\r\n1. 设置cookie的方法\r\n\r\n```js\r\nthis.ctx.cookies.set('name','zhangsan');\r\n```\r\n\r\n2. 获取cookie的方法\r\n\r\n```js\r\nthis.ctx.cookies.get('name');\r\n```\r\n\r\n>下面介绍下，如何在一个控制器中设置cookie，在另一个控制器中获取cookie\r\n\r\n* 设置cookie的控制器\r\n\r\n```js\r\nasync index() {\r\n    const { ctx } = this;\r\n    // 设置cookie\r\n    const username = this.ctx.cookies.set('username','zhangsan');\r\n    // this.ctx.csrf : 用户访问这个页面的时候，生成一个密钥\r\n    await ctx.render('home')\r\n  }\r\n```\r\n\r\n* 获取cookie的控制器\r\n\r\n```js\r\nasync index() {\r\n    const username = this.ctx.cookies.get('username')\r\n    await this.ctx.render('news', {\r\n      username\r\n    })\r\n  }\r\n```\r\n\r\n3. 设置cookie的缓存有效时长\r\n\r\n```js\r\nconst username = this.ctx.cookies.set('username','zhangsan',{\r\n      maxAge: 1000*3600*24\r\n    });\r\n```\r\n\r\n4. 设置参数\r\n\r\n```js\r\nconst username = this.ctx.cookies.set('username','zhangsan',{\r\n  maxAge: 1000*3600*24,\r\n  httpOnly: true,\r\n  signed: true,     //对cookie进行签名，防止用户修改cookie\r\n  encrypt: true,         // 如果对cookie进行加密，获取的时候需要解密\r\n});\r\n```\r\n5. 清除cookie\r\n\r\n```js\r\nthis.ctx.cookies.set('username',null)\r\n```\r\n\r\n## Egg.js中使用Seesion\r\n>cookie是保存在客户端的浏览器上，而Session则是保存在服务器上。当浏览器访问服务器并发送第一次请求的时候，服务端会创建一个session对象，生成一个类似与key,value的键值对，然后将key(cookie)返回到浏览器，浏览器下次再访问的时候，携带key(cookie)，找到对应的session(value)。浏览器首次访问目标服务器的时候，目标服务器的响应头中会包含一个set-cookie字段，浏览器第二次访问将携带cookie进行访问。\r\n\r\n\r\n1. 在控制器中设置session\r\n\r\n```js\r\nasync setSession() {\r\n    this.ctx.session.username = \"余波\";\r\n  }\r\n```\r\n\r\n2. 在控制器中获取session\r\n\r\n```js\r\nasync index() {\r\n    // 拿到session，并渲染到news页面中\r\n    const username = this.ctx.session.username;\r\n    await this.ctx.render('news', {\r\n      username\r\n    })\r\n  }\r\n```\r\n\r\n3. 设置session的过期时间（也可以在config中配置session）\r\n\r\n```js\r\nthis.ctx.session.maxAge = 5000;\r\n```\r\n\r\n4. 在config.default.js中配置session\r\n\r\n```js\r\nconfig.session = {\r\n    maxAge: 1000*5\r\n}\r\n```"
    },
    {
      "id": "/LeetCode——二叉树的层序遍历（递归与非递归）",
      "metadata": {
        "permalink": "/blog/LeetCode——二叉树的层序遍历（递归与非递归）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——二叉树的层序遍历（递归与非递归）.md",
        "source": "@site/blog\\LeetCode——二叉树的层序遍历（递归与非递归）.md",
        "title": "LeetCode——二叉树的层序遍历（递归与非递归）",
        "description": "题目描述",
        "date": "2021-10-27T00:00:00.000Z",
        "formattedDate": "2021年10月27日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 2.58,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——二叉树的层序遍历（递归与非递归）",
          "date": "2021-10-27T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "Egg.js中使用extend、Cookie、Session的基本方式",
          "permalink": "/blog/Egg.js中使用extend、Cookie、Session的基本方式"
        },
        "nextItem": {
          "title": "一篇文章掌握Egg.js的核心用法",
          "permalink": "/blog/一篇文章掌握Egg.js的核心用法"
        }
      },
      "content": "## 题目描述\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/529dbcc0afd64c348aa3db92f4bfbc46.png)\r\n\r\n## 递归实现\r\n>递归实现主要是在函数内部定义一个新的函数，这个函数接收两个参数，一个是当前节点，一个是层次，如果当前节点为空的话，则返回空，如果当前节点不为空，判断二维数组的指定位置是否为空，如果存在则push进当前节点的val值，如果不存在则设置为空数组，然后递归遍历左子树，层次+1，递归遍历右子树的时候层次还是+1。\r\n\r\n```js\r\nvar levelOrder = function(root) {\r\n  // 定义最终的返回结果\r\n  const res = [];\r\n  function levelOrder(root,level) {\r\n    if (!root) return null;\r\n    res[level] = res[level] || [];\r\n    res[level].push(root.val);\r\n    levelOrder(root.left,level + 1);\r\n    levelOrder(root.right,level + 1);\r\n  };\r\n  levelOrder(root,0);\r\n  return res;\r\n};\r\n```\r\n\r\n## 非递归实现\r\n>非递归实现主要是借助队列来实现，首先获取队列中对应二叉树的一层的元素，然后取出队头元素插入指定二维数组中，如果左子树存在的话，让左子树入队列，如果右子树存在，则让右子树入队列，循环完一层队列的层次+1。\r\n\r\n```js\r\nvar levelOrder = function(root) {\r\n  if (!root) return []\r\n  // 定义最终的返回结果\r\n  const res = [];\r\n  // 定义队列\r\n  const queue = [root];\r\n  // 定义层次\r\n  let level = 0;\r\n  // 只要队列中有元素，便进入循环\r\n  while (queue.length) {\r\n    res.push([]);\r\n    let len = queue.length;\r\n    for (let i = 0; i < len; i++) {\r\n      // 取出对头元素\r\n      let node = queue.shift();\r\n      res[level].push(node.val);\r\n      // 左子树存在的话，让左子树入队列\r\n      node.left && queue.push(node.left);\r\n      // 右子树存在的话，让右子树入队列\r\n      node.right && queue.push(node.right);\r\n    }\r\n    level++;\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\n## 题目反思\r\n>二叉树的层序遍历是一种非常重要的遍历方式，是我们必须掌握的，本题中值得我们学习的思路有以下几点。\r\n\r\n1. 使用递归的层序遍历和使用迭代的层序遍历都需要借助层数level这个变量。\r\n2. 递归的思想和队列的思想值得我们学习。"
    },
    {
      "id": "/一篇文章掌握Egg.js的核心用法",
      "metadata": {
        "permalink": "/blog/一篇文章掌握Egg.js的核心用法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/一篇文章掌握Egg.js的核心用法.md",
        "source": "@site/blog\\一篇文章掌握Egg.js的核心用法.md",
        "title": "一篇文章掌握Egg.js的核心用法",
        "description": "快速创建一个egg项目",
        "date": "2021-10-26T00:00:00.000Z",
        "formattedDate": "2021年10月26日",
        "tags": [
          {
            "label": "Egg.js",
            "permalink": "/blog/tags/egg-js"
          }
        ],
        "readingTime": 5.03,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "一篇文章掌握Egg.js的核心用法",
          "date": "2021-10-26T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Egg.js",
          "tags": [
            "Egg.js"
          ]
        },
        "prevItem": {
          "title": "LeetCode——二叉树的层序遍历（递归与非递归）",
          "permalink": "/blog/LeetCode——二叉树的层序遍历（递归与非递归）"
        },
        "nextItem": {
          "title": "腾讯云Severless核心用法",
          "permalink": "/blog/腾讯云Severless核心用法"
        }
      },
      "content": "## 快速创建一个egg项目\r\n1. 创建一个文件夹并进行自定义命名\r\n```shell\r\nmkdir 自定义名字\r\n```\r\n2. 进入上述文件夹，并初始化egg\r\n```shell\r\nnpm init egg --type=simple\r\n```\r\n3. 安装依赖\r\n```shell\r\nnpm install\r\n```\r\n4. 运行项目\r\n```shell\r\nnpm run dev\r\n```\r\n## 推荐使用下面的方式创建项目\r\n1. 首先全局安装egg-init\r\n2. 使用egg-init创建项目\r\n3. 进入项目\r\n4. 安装依赖\r\n5. 运行\r\n\r\n```js\r\nnpm i egg-init -g\r\negg-init eggname --type=simple\r\ncd eggname\r\nnpm i\r\nnpm run dev\r\n```\r\n\r\n## Egg的目录结构\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/3527084bad42607855874313f2515370.png)\r\n\r\n### 1. app文件夹\r\n>app文件夹是我们的主要项目文件夹。\r\n\r\n### 2. config文件夹\r\n>config文件夹是我们的主要配置文件和插件配置的位置。\r\n\r\n### 3. logs文件夹\r\n>logs文件夹是我们的日志文件夹，一般不适用。\r\n\r\n### 4. node_modules文件夹\r\n>这个文件夹是我们的模块安装的文件夹。\r\n\r\n### 5. package.json文件\r\n>当前项目所下载的依赖，以及启动设置等。\r\n\r\n## Egg的约定规范\r\n### 路由写在哪里？\r\n>路由写在app下的router.js\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/c6ac8dc5d501b96a6d24ac7df1fe2680.png)\r\n\r\n### 模板写在哪里？\r\n>模板写在app文件夹下面的view文件夹中\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/c28243451d880ecbe23e342e0cdda88d.png)\r\n\r\n### 查询数据，获取数据写在哪里？\r\n>写在app文件夹下面的service文件夹中。\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/3b3126dd38199d734b217eb34a94326f.png)\r\n\r\n### 业务逻辑写在哪里？\r\n>Controller负责处理业务逻辑。\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/4e6ad931685c19fb2e0deb9af1683777.png)\r\n\r\n### 判断权限写在哪里？\r\n>写在app文件夹下的middleware文件夹中。\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/a9b139d000dd254d5cd99fa641e3abfe.png)\r\n\r\n### 静态文件放在哪里？\r\n>静态文件放在app文件夹下的public文件夹中。\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/fc741928037aa10230bfc7446ebc057d.png)\r\n\r\n### 拓展功能写在哪里？\r\n>app文件夹下的extend文件夹中。\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/a16bb4351a9a033415bba366df64ffa5.png)\r\n\r\n## 配置Egg的代码提示\r\n1. 安装eggjs插件\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/f78f13ba8c92261f808c1aacff0d6399.png)\r\n\r\n2. 如果没有提示找到下面的文件，并修改为下面的内容\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/1daed3103db8fb025edb7ce9574bddfb.png)\r\n```json\r\n{\r\n    \"egg-controller\": {\r\n            \"scope\": \"javascript,typescript\",\r\n            \"prefix\": \"egg controller\",\r\n            \"body\": [\r\n                    \"'use strict';\",\r\n                    \"const Controller = require('egg').Controller;\",\r\n                    \"class $1Controller extends Controller {\",\r\n                            \"    async index() {\",\r\n                                    \"        const { ctx } = this;\",\r\n                                    \"        ctx.body = '$2';\",\r\n                                    \"    }\",\r\n                            \"}\",\r\n                            \"module.exports = $1Controller;\",\r\n            ],\r\n            \"description\": \"egg 控制器的代码提示\"\r\n    },\r\n\r\n    \"egg-service\": {\r\n            \"scope\": \"javascript,typescript\",\r\n            \"prefix\": \"egg service\",\r\n            \"body\": [\r\n                    \"const Service = require('egg').Service;\",\r\n                    \"class $1Service extends Service {\",\r\n                            \"    async find(uid) {\",\r\n                                    \"        const sql = ``;\",\r\n                                    \"        const data = await this.app.mysql.query(sql);\",\r\n                                    \"        return data;\",\r\n                                    \"    }\",\r\n                            \"}\",\r\n                            \"module.exports = $1Service;\",\r\n            ],\r\n            \"description\": \"egg 控制器的代码提示\"\r\n    },\r\n\r\n    \"myjuqery\": {\r\n            \"prefix\": \"myjuqery\",\r\n            \"body\": [\r\n                    \"<script src='http://code.jquery.com/jquery-3.4.1.min.js'></script>\"\r\n            ],\r\n            \"description\": \"导入juqery工具包\"\r\n    },\r\n\r\n    \"myaxios\": {\r\n            \"prefix\": \"myaxios\",\r\n            \"body\": [\r\n                    \"<script src='https://unpkg.com/axios/dist/axios.min.js'></script>\"\r\n            ],\r\n            \"description\": \"导入axios工具包\"\r\n    },\r\n    \"react-class\": {\r\n            \"scope\": \"javascript,typescript\",\r\n            \"prefix\": \"reactclass\",\r\n            \"body\": [\r\n                    \"import React from 'react';\",\r\n                    \"import '../css/$1.css'\",\r\n                    \"\",\r\n                    \"class $1 extends React.Component {\",\r\n                    \"    render() {\",\r\n                    \"        return (\",\r\n                    \"\",\r\n                    \"        );\",\r\n                    \"    }\",\r\n                    \"}\",\r\n                    \"export default $1;\",\r\n            ],\r\n            \"description\": \"react 类组件的代码提示\"\r\n    },\r\n    \"react-function\": {\r\n            \"scope\": \"javascript,typescript\",\r\n            \"prefix\": \"reactfunction\",\r\n            \"body\": [\r\n                    \"import React from 'react';\",\r\n                    \"\",\r\n                    \"function $1() {\",\r\n                    \"     return (\",\r\n                    \"\",\r\n                    \"     );\",\r\n                    \"}\",\r\n                    \"\",\r\n                    \"export default $1;\",\r\n            ],\r\n            \"description\": \"react 函数组件的代码提示\"\r\n    }\r\n}\r\n```\r\n\r\n## Egg如何获取数据处理数据？\r\n### Egg给客户端响应数据。\r\n```js\r\nthis.ctx.body = 'xxx'\r\n```\r\n### Egg获取客户端的请求参数\r\n```js\r\nthis.ctx.query\r\n```\r\n### 配置动态路由并获取参数\r\n1. 动态路由配置\r\n```js\r\nrouter.get('/newslist/:id',controller.news.newslist);\r\n```\r\n2. 获取参数\r\n```js\r\nthis.ctx.params\r\n```\r\n>注意：配置完动态路由之后，如果访问的路由不带参数返回的是404.\r\n\r\n## 配置模板引擎\r\n1. 安装插件\r\n```js\r\nnpm i egg-view-ejs --save\r\n```\r\n2. 进行项目配置\r\n* plugin.js\r\n```js\r\nexports.ejs = {\r\n    enable: true,\r\n    package: 'egg-view-ejs',\r\n};\r\n```\r\n* config.default.js\r\n```js\r\n// 配置模板引擎\r\nconfig.view = {\r\n    mapping: {\r\n        '.html': 'ejs',\r\n    },\r\n};\r\n```\r\n3. 异步调用render\r\n```js\r\nawait ctx.render('index.html')\r\n```\r\n>egg会自动向view文件夹中寻找index.html文件的。下面介绍一个index.html实例。\r\n\r\n```html\r\n<h1>新闻页面</h1>\r\n<%=msg%>\r\n<h2>下面是一个for循环</h2>\r\n<%\r\n    for(let i = 0; i < list.length; i++) { %>\r\n        <li><%=list[i]%></li>\r\n    <%}\r\n%>\r\n```\r\n\r\n## 访问Egg项目中的静态资源\r\n>在路径中带上public即可。\r\n```html\r\n<img src=\"/public/images/CSS.png\" alt=\"\">\r\n```\r\n\r\n## 控制器获取service提供数据的方法\r\n* Controller/news.js\r\n```js\r\nconst list = await this.service.news.getNewsList();\r\nawait ctx.render('index.html',{\r\n    msg,\r\n    list\r\n})\r\n```\r\n* service/news.js\r\n```js\r\nasync getNewsList () {\r\n    const list = [1,2,3,4]\r\n    return list;\r\n}\r\n```\r\n>注意：不只是控制器可以调用服务的数据，一个服务也可以调用另一个服务的数据。"
    },
    {
      "id": "/腾讯云Severless核心用法",
      "metadata": {
        "permalink": "/blog/腾讯云Severless核心用法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/腾讯云Severless核心用法.md",
        "source": "@site/blog\\腾讯云Severless核心用法.md",
        "title": "腾讯云Severless核心用法",
        "description": "什么是Serverless？",
        "date": "2021-10-25T00:00:00.000Z",
        "formattedDate": "2021年10月25日",
        "tags": [
          {
            "label": "Serverless",
            "permalink": "/blog/tags/serverless"
          }
        ],
        "readingTime": 8.38,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "腾讯云Severless核心用法",
          "date": "2021-10-25T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Serverless",
          "tags": [
            "Serverless"
          ]
        },
        "prevItem": {
          "title": "一篇文章掌握Egg.js的核心用法",
          "permalink": "/blog/一篇文章掌握Egg.js的核心用法"
        },
        "nextItem": {
          "title": "Express_02--处理表单的POST请求",
          "permalink": "/blog/Express_02--处理表单的POST请求"
        }
      },
      "content": "## 什么是Serverless？\r\n>Serverless又名无服务器，所谓无服务器并非是不需要依赖和依靠服务器等资源，而是开发者再也不用过多考虑服务器的问题，可以更专注在产品代码上，狭义的Serverless是由Faas和Baas组成的。\r\n\r\n### 传统的高并发架构\r\n>在传统的高并发架构下，我们需要配置很多东西，首先，我们需要采购服务器，然后对服务器进行配置，还要将这些服务器分为web服务器和数据库服务器，配置负载均衡，配置主从数据库，配置静态服务器等等，然后是部署程序，部署之后还需要不断的进行维护，这就是传统的高并发架构。\r\n\r\n### Serverless下的高并发架构\r\n>在Serverless下使用者不用关心需要购买几台服务器，也不需要关心哪些作为web服务器，哪些作为数据库服务器，也不需要关心搭建环境、部署项目。开发者只需要将项目部署到serverless服务器上即可。并且，Serverless向用户提供了日志服务、监控服务、以及高并发等。\r\n\r\n## Egg.js项目结构图\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/54d060e461988526ddbafa6c7edba1de.png)\r\n\r\n## 腾讯云Severless\r\n1. 安装serverless\r\n\r\n```shell\r\nnpm install -g serverless\r\n```\r\n\r\n2. 查看版本\r\n\r\n```shell\r\nserverless -v\r\n```\r\n\r\n### 快速生成一个项目\r\n1. 在空文件夹下执行serverless命令\r\n\r\n```shell\r\nserverless\r\n```\r\n\r\n2. 选择express模板\r\n\r\n3. 选择部署在云端\r\n\r\n\r\n### 部署到云上\r\n```shell\r\nserverless deploy\r\n```\r\n\r\n### 创建云函数\r\n>选择自定义创建，环境选择Node12,然后点击完成即可。\r\n\r\n* 在浏览器地址栏中访问我们的云函数\r\n\r\n>配置触发管理，创建触发器，触发方式选择API网关触发，选择新建API服务，请求类型选择Any,发布，免鉴权，取消集成响应。如果没有取消集成响应是不能够直接返回字符串的。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/eb821f876233145e4d9d9c8b0afc2a74.png)\r\n\r\n>通过下面的访问路径即可实现访问。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/d474b1460e0436655a8ff44254486581.png)\r\n\r\n>修改云函数并点击部署后，即可重新访问目标URL。\r\n\r\n>云函数中的层管理有什么用？云函数中的层管理可以上传我们的node_modules，然后配置云函数选择这个环境。\r\n\r\n>云函数要想要修改自定义域名可以通过触发管理中的API服务名中的自定义域名进行配置。\r\n\r\n### WebCli中通过应用模板创建云函数\r\n1. 点击云产品，进入Serverless应用中心\r\n2. 新建应用\r\n3. 选择express框架模板\r\n\r\n### Vscode中使用插件创建编写云函数\r\n>安装下面的插件\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/3caaab9e1c219b75a22d28299742b328.png)\r\n\r\n>初次登陆的时候，可以按照插件说明上的网址访问id和key.\r\n\r\n### Serverless Cli创建编写应用\r\n>安装方法请看上文的 ## 腾讯云Severless\r\n\r\n>安装完成之后，在项目中使用下面的代码即可使用serverless\r\n\r\n```shell\r\nserverless\r\n```\r\n\r\n>当我们更新完代码之后，可以通过下面的代码将本地代码同步到云端。\r\n\r\n```shell\r\nserverless deploy\r\n```\r\n\r\n>本地进行调试可以通过下面的方式\r\n\r\n```shell\r\nnodemon app.js\r\n```\r\n\r\n>可以在配置中设置不上传node_modules这个文件夹，但是需要在云函数中开启自动安装依赖功能。\r\n\r\n### 配置静态资源\r\n```js\r\napp.use(express.static(__dirname  + \"/public\"))\r\n```\r\n\r\n>可以参考这篇文章的经验[因缺少绝对路径引发的部署血案](https://juejin.cn/post/7009109979403649038)\r\n\r\n## 使用Serverless部署KOA项目\r\n>在KOA中我们如果希望部署后直接开启API网关触发器，需要将下面的这行代码给注释掉。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/27081f7dc7a1532a1c8dfd0d8ae6c2c2.png)\r\n\r\n\r\n### 配置静态资源服务\r\n1. 安装相关依赖\r\n\r\n```shell \r\nnpm install koa-static\r\n```\r\n\r\n2. 引入工具包\r\n\r\n```js\r\nconst static = require('koa-static')\r\n```\r\n\r\n3. 配置中间件\r\n\r\n```js\r\napp.use(static(path.join(__dirname,'public')))\r\n```\r\n\r\n## 使用Serverless部署Egg.js\r\n>基本部署方法和上述方式一致，下文不再进行赘述。\r\n>本地测试egg\r\n\r\n```shell\r\nnpm run dev\r\n```\r\n\r\n## 使用Serverless部署Vue.js\r\n>通过Serverless模板创建的Vue项目默认使用的是Vue2的项目，如果想要使用Vue3的项目，只需要在已有项目中添加serverless.yml配置文件，然后执行下面的操作即可。\r\n\r\n```shell\r\nnpm i\r\nnpm run serve\r\nnpm run build\r\nserverless deploy\r\n```\r\n\r\n>腾讯云serverless会将静态文件存放在COS上，下面是对应的COS名称。存储桶中的代码也就是我们dist文件夹中的代码。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/c91fcfa96fb18ae7ea5c7d5f56a2e65c.png)\r\n\r\n\r\n## Serverless中使用Node操作Mysql、Mongodb数据库\r\n### 腾讯云Mysql与云函数构建私有网络\r\n>首先Mysql和云函数应该在同一个区域，比如都在上海六区，然后在同一个私有网络下面，才可以实现局域网访问，否则只能实现公网访问。\r\n\r\n### Serverless中操作Mongodb数据库\r\n>方法和上文提到的操作Mysql类似，本文不再进行赘述。\r\n\r\n## Serverless将本地文件上传到腾讯云COS上。\r\n\r\n>把本地资源同步到服务器。\r\n\r\n1. 根据下面的文档进行安装依赖。\r\n\r\n* [对象存储SDK指南](https://cloud.tencent.com/document/product/436/8629)\r\n\r\n2. 在腾讯云上创建一个存储桶，设置为共有读私有写。\r\n\r\n>本地代码如下所示。\r\n\r\n```js\r\nconst fs = require('fs');\r\n\r\n// SECRETID 和 SECRETKEY请登录 https://console.cloud.tencent.com/cam/capi 进行查看和管理\r\nvar COS = require('cos-nodejs-sdk-v5');\r\nvar cos = new COS({\r\n  SecretId: 'xxx',\r\n  SecretKey: 'xxx'\r\n});\r\n\r\n// 上传对象\r\ncos.putObject({\r\n  Bucket: 'serverless1test-1301559367', /* 必须 */\r\n  Region: 'ap-beijing',    /* 必须 */\r\n  Key: 'test.png',              /* 必须 */\r\n  StorageClass: 'STANDARD',\r\n  Body: fs.createReadStream('./python.png'), // 上传文件对象\r\n  onProgress: function(progressData) {\r\n      console.log(JSON.stringify(progressData));\r\n  }\r\n}, function(err, data) {\r\n  console.log(err || data);\r\n});\r\n```\r\n\r\n## Express在Serverless中实现图片上传到COS中\r\n1. 在app.js中配置body-parser中间件\r\n\r\n* [body-parser中间件](https://github.com/expressjs/body-parser)\r\n\r\n```js\r\nvar bodyParser = require('body-parser')\r\napp.use(bodyParser.urlencoded({ extended: false }))\r\napp.use(bodyParser.json())\r\n```\r\n\r\n2. 在app.js中配置multer中间件\r\n```js\r\nconst multer = require('multer');\r\nvar storage = multer.memoryStorage()\r\nvar upload = multer({ storage: storage })\r\n```\r\n\r\n3. 配置路由上传到指定的存储桶中实现图片上传功能\r\n```js\r\napp.post(`/doUpload`, upload.single(\"img\"), (req, res) => {\r\n  var cos = new COS({\r\n    SecretId: 'AKID4xbz6wWNyIM8droUt0qQjkUyBCwPbW9V',\r\n    SecretKey: 'xxx'\r\n  });\r\n  // 上传对象\r\n  cos.putObject({\r\n    Bucket: 'serverless1test-1301559367', /* 必须 */\r\n    Region: 'ap-beijing',    /* 必须 */\r\n    Key: req.file.originalname,              /* 必须 */\r\n    StorageClass: 'STANDARD',\r\n    Body: req.file.buffer, // 上传文件对象\r\n    onProgress: function (progressData) {\r\n      console.log(JSON.stringify(progressData));\r\n      res.send(req.body)\r\n    }\r\n  }, function (err, data) {\r\n    console.log(err || data);\r\n  });\r\n})\r\n```\r\n\r\n## Serverless中配置域名访问\r\n1. 找到对应的serverless应用。\r\n2. 找到api网关，点击服务id，点击自定义域名。\r\n3. 进行自定义域名时，域名要指向指定的地址。\r\n4. 配置路径映射\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/9f2dc3fea857b53c8e16cab82751ee86.png)\r\n\r\n## Serverless中配置HTTPS访问\r\n>给Serverless对应的应用配置HTTPS访问，只需添加相应的安全证书即可。\r\n\r\n## 配置COS自定义域名\r\n>只需通过对应存储桶的自定义域名设置即可。"
    },
    {
      "id": "/Express_02--处理表单的POST请求",
      "metadata": {
        "permalink": "/blog/Express_02--处理表单的POST请求",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Express_02--处理表单的POST请求.md",
        "source": "@site/blog\\Express_02--处理表单的POST请求.md",
        "title": "Express_02--处理表单的POST请求",
        "description": "express处理表单的post请求",
        "date": "2021-10-24T00:00:00.000Z",
        "formattedDate": "2021年10月24日",
        "tags": [
          {
            "label": "Express",
            "permalink": "/blog/tags/express"
          }
        ],
        "readingTime": 1.615,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Express_02--处理表单的POST请求",
          "date": "2021-10-24T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Express",
          "tags": [
            "Express"
          ]
        },
        "prevItem": {
          "title": "腾讯云Severless核心用法",
          "permalink": "/blog/腾讯云Severless核心用法"
        },
        "nextItem": {
          "title": "迭代法实现对二叉树的前中后序遍历",
          "permalink": "/blog/迭代法实现对二叉树的前中后序遍历"
        }
      },
      "content": "## express处理表单的post请求\r\n>需要我们注意的是express内置了获取get请求体的API(req.query)，但是并没有内置获取post请求体的API，所以需要我们手动的去配置中间件。\r\n\r\n### 配置body-parser中间件\r\n#### 1. 安装\r\n```shell\r\nnpm install body-parser\r\n```\r\n#### 2. 导入并配置\r\n```js\r\nconst bodyParser = require('body-parser')\r\napp.use(bodyParser.urlencoded({ extended: false }))\r\napp.use(bodyParser.json())\r\n```\r\n#### 3. 此时即可成功获取req.body(客户端post的内容)\r\n```js\r\napp.post('/post',(req,res) => {\r\n    console.log(req.body);\r\n})\r\n```\r\n```\r\n[Object: null prototype] { name: 'faithpassi', message: 'dsddfgfgdf' }\r\n```\r\n\r\n## 将读取到的字符串转为JSON\r\n```js\r\nfs.readFile('./db.json','utf8', (err, data) => {\r\n    if (!err) {\r\n        res.render('index.html', {\r\n            students: JSON.parse(data).students\r\n        });\r\n    }\r\n})\r\n```\r\n\r\n## 将所有的路由结构提取到一个文件中，并进行暴露\r\n### 方式一：自己封装函数\r\n```js\r\nconst fs = require('fs');\r\nmodule.exports = function (app) {\r\n    app.get('/students', (req, res) => {\r\n        fs.readFile('./db.json', 'utf8', (err, data) => {\r\n            if (!err) {\r\n                res.render('index.html', {\r\n                    students: JSON.parse(data).students\r\n                });\r\n            }\r\n        })\r\n    })\r\n}\r\n```\r\n### 方式二：使用Express自带的路由容器\r\n#### 1.在路由文件中创建路由容器，并进行暴露\r\n```js\r\nconst express = require('express');\r\n// 创建一个路由容器\r\nconst router = express.Router();\r\n\r\nrouter.get('/students', (req, res) => {\r\n    fs.readFile('./db.json', 'utf8', (err, data) => {\r\n        if (!err) {\r\n            res.render('index.html', {\r\n                students: JSON.parse(data).students\r\n            });\r\n        }\r\n    })\r\n})\r\nmodule.exports = router;\r\n```\r\n#### 2. 将路由容器挂载到app上\r\n```js\r\n// 把路由器挂载到 app上\r\napp.use(router)\r\n```"
    },
    {
      "id": "/迭代法实现对二叉树的前中后序遍历",
      "metadata": {
        "permalink": "/blog/迭代法实现对二叉树的前中后序遍历",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/迭代法实现对二叉树的前中后序遍历.md",
        "source": "@site/blog\\迭代法实现对二叉树的前中后序遍历.md",
        "title": "迭代法实现对二叉树的前中后序遍历",
        "description": "题目描述",
        "date": "2021-10-23T00:00:00.000Z",
        "formattedDate": "2021年10月23日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 3.26,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "迭代法实现对二叉树的前中后序遍历",
          "date": "2021-10-23T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "Express_02--处理表单的POST请求",
          "permalink": "/blog/Express_02--处理表单的POST请求"
        },
        "nextItem": {
          "title": "（千字长文）Vue核心基础解析",
          "permalink": "/blog/（千字长文）Vue核心基础解析"
        }
      },
      "content": "## 题目描述\r\n>对二叉树的遍历是面试中常出现的题目，二叉树的前中后序遍历可以通过递归实现，也可以通过迭代实现，递归的方式在实际使用时，可能会面临内存溢出的风险，所以掌握迭代法的遍历方式，对我们也是很关键的，让我们来一起学会如何通过迭代法来遍历二叉树吧！\r\n\r\n## 前序遍历\r\n>首先，将根节点入栈，然后出栈的时候记录其值，同时判断其是否存在右子树和左子树，其中先判断右子树，再判断左子树，存在的话则将其压入栈中，然后循环遍历栈，直到栈为空。\r\n\r\n```js\r\nvar preorderTraversal = function (root) {\r\n\r\n  if (!root) return [];\r\n  // 定义最终返回的结果\r\n  let result = [];\r\n  // 定义栈\r\n  const stack = [root];\r\n\r\n  // 只要栈中有元素则进入循环\r\n  while (stack.length) {\r\n    let node = stack.pop();\r\n    result.push(node.val);\r\n    // 如果右孩子存在的话\r\n    node.right && stack.push(node.right);\r\n    node.left && stack.push(node.left);\r\n  }\r\n  return result;\r\n\r\n};\r\n```\r\n\r\n## 中序遍历\r\n>中序遍历的迭代法核心思想在于先遍历完左子树，然后遍历根节点，然后遍历右子树，先使用while循环，遇到左子节点，就让左子节点入栈，如果出栈元素有右子树，就让当前节点指向这颗右子树。\r\n\r\n```js\r\nvar inorderTraversal = function(root) {\r\n  // 如果节点为空的情况\r\n  if (!root) return [];\r\n  // 定义最终返回的结果\r\n  const result = [];\r\n  // 当前处理节点\r\n  let cur = root;\r\n  // 定义辅助栈\r\n  let stack = [];\r\n  // 核心循环\r\n  while (stack.length || cur) {\r\n    // 首先遍历左子树\r\n    while (cur) {\r\n      stack.push(cur);\r\n      cur = cur.left;\r\n    }\r\n    // 出栈，存储\r\n    let node = stack.pop();\r\n    result.push(node.val);\r\n    if (node.right) {\r\n      cur = node.right\r\n    }\r\n  }\r\n  return result;\r\n};\r\n```\r\n\r\n## 后序遍历\r\n>后序遍历的迭代法核心思路在于，将当前节点的值优先插入栈首，然后左孩子存在将左孩子入栈，右孩子存在将右孩子入栈。\r\n\r\n```js\r\nvar postorderTraversal = function(root) {\r\n  if (!root) return []\r\n  // 定义最终返回的结果\r\n  let result = [];\r\n  // 定义辅助栈\r\n  let stack = [root];\r\n  // 只要栈不为空就循环\r\n  while (stack.length) {\r\n    let node = stack.pop();\r\n    result.unshift(node.val);\r\n    // 记住，此处是先左后右\r\n    node.left && stack.push(node.left);\r\n    node.right && stack.push(node.right);\r\n  }\r\n  return result\r\n};\r\n```\r\n\r\n## 总结\r\n>二叉树前中后序遍历的迭代法是非常重要的思路，主要是借助辅助栈来帮助我们遍历，无论是在工作中还是在面试中，这些思路都会帮助我们写出更加精致的代码。"
    },
    {
      "id": "/（千字长文）Vue核心基础解析",
      "metadata": {
        "permalink": "/blog/（千字长文）Vue核心基础解析",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/（千字长文）Vue核心基础解析.md",
        "source": "@site/blog\\（千字长文）Vue核心基础解析.md",
        "title": "（千字长文）Vue核心基础解析",
        "description": "什么是Vue?",
        "date": "2021-10-22T00:00:00.000Z",
        "formattedDate": "2021年10月22日",
        "tags": [
          {
            "label": "Vue",
            "permalink": "/blog/tags/vue"
          }
        ],
        "readingTime": 24.595,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "（千字长文）Vue核心基础解析",
          "date": "2021-10-22T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Vue",
          "tags": [
            "Vue"
          ]
        },
        "prevItem": {
          "title": "迭代法实现对二叉树的前中后序遍历",
          "permalink": "/blog/迭代法实现对二叉树的前中后序遍历"
        },
        "nextItem": {
          "title": "递归模板解决二叉树的前中后序遍历问题",
          "permalink": "/blog/递归模板解决二叉树的前中后序遍历问题"
        }
      },
      "content": "## 什么是Vue?\r\n>Vue是一个渐进式的框架，渐进式指的是可以将Vue作为应用的一部分嵌入其中，带来更丰富的交互体验，比如一个项目是使用Jquery构建的，此时就可以通过Vue对部分网页进行重构，而不必重构全部的网页。\r\n\r\n## 通过Vue.js文件使用Vue\r\n```js\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n</head>\r\n<body>\r\n    \r\n    <div id=\"app\">{{message}}</div>\r\n\r\n    <script src=\"./vue.js\"></script>\r\n    <script>\r\n        const app = new Vue({\r\n            el: '#app',\r\n            data: {\r\n                message: \"Hello Vue\"\r\n            }\r\n        });\r\n    </script>\r\n</body>\r\n</html>\r\n```\r\n>el属性决定了这个Vue对象挂载到哪一个元素上。data属性会存储一些和绑定对象上相关联的数据。\r\n\r\n\r\n## 全局安装脚手架\r\n```shell\r\nnpm install -g @vue/cli\r\n```\r\n\r\n## 通过Vue脚手架创建项目\r\n```shell\r\nvue create demo\r\n```\r\n\r\n## 运行项目\r\n```shell\r\nnpm run serve\r\n```\r\n\r\n## 使用Vite构建Vue项目\r\n```\r\nnpm init vite@latest <project-name> -- --template vue\r\n```\r\n\r\n## src下面的目录解析\r\n* assets文件夹\r\n\r\n>上述文件夹下面主要存放静态文件。\r\n\r\n* components文件夹\r\n\r\n>这个文件夹主要存放自定义组件\r\n\r\n* App.vue\r\n\r\n>这个文件是我们的根组件。\r\n\r\n* main.js\r\n\r\n>上述文件是我们的入口文件。\r\n\r\n## 绑定数据与绑定HTML(v-html)的方法\r\n```js\r\n<template>\r\n    <div>\r\n        <h1>{{msg}}</h1>\r\n        <p>绑定对象：{{userInfo.username}}---{{userInfo.userage}}</p>\r\n        <p>\r\n            {{h2}}\r\n        </p>\r\n        <p>绑定HTML：<span v-html=\"h2\"></span></p>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\n    export default {\r\n        data() {\r\n            return {\r\n                msg: \"你好Vue\",\r\n                userInfo: {\r\n                    username: \"张三\",\r\n                    userage: \"24\"\r\n                },\r\n                h2: \"<h2>这是一个H2标题</h2>\"\r\n            }\r\n        }\r\n    }\r\n</script>\r\n\r\n<style>\r\n    h1 {\r\n        text-align: center;\r\n        color: red\r\n    }\r\n</style>\r\n```\r\n\r\n## 绑定属性\r\n### 绑定图片属性src\r\n>方式1\r\n\r\n```js\r\n<img v-bind:src=\"imgSrc\">\r\n```\r\n\r\n>方式2\r\n\r\n```js\r\n<img :src=\"imgSrc\">\r\n```\r\n\r\n### 绑定自定义属性\r\n>方式1\r\n\r\n```js\r\n<div v-bind:title=\"title\">鼠标放上去就知道了</div>\r\n```\r\n\r\n>方式2\r\n\r\n```js\r\n<div :title=\"title\">鼠标放上去就知道了</div>\r\n```\r\n\r\n### 绑定静态值需要加单引号\r\n>下面是一个动态属性名的例子，其中的值是静态的。\r\n\r\n```js\r\n<a v-bind:[myHref]=\"'http://www.baidu.com'\">跳转到百度</a>\r\n<script>\r\n    export default {\r\n        data() {\r\n            return {\r\n                msg: \"你好Vue\",\r\n                myHref: \"href\"\r\n            }\r\n        }\r\n    }\r\n</script>\r\n```\r\n\r\n## 循环遍历\r\n>下面的循环遍历是以v-for为基础进行的。\r\n\r\n```js\r\n<ul>\r\n    <li v-for=\"(item,index) in list1\" :key=\"index\">\r\n        {{item}} -- {{index}}\r\n    </li>\r\n</ul>\r\n```\r\n\r\n>下面是需要二次遍历的情况\r\n\r\n```js\r\n<li v-for=\"(item,index) in list3\" :key=\"index\">\r\n    {{item.title}}\r\n    <ol>\r\n        <li v-for=\"(j,key) in item.double\" :key=\"key\">\r\n            {{j.color}}\r\n        </li>\r\n    </ol>\r\n</li>\r\n```\r\n\r\n>下面是循环遍历对象的情况\r\n\r\n```js\r\n<li v-for=\"(value,key,index) in myobj\" :key=\"index\">\r\n    {{value}} -- {{key}} -- {{index}}\r\n</li>\r\n```\r\n\r\n## 事件方法\r\n>下面是事件方法的基本用法。\r\n\r\n```js\r\n<template>\r\n    <div>\r\n        <h1>{{msg}}</h1>\r\n        <button @click=\"setMsg()\">点我改变信息</button>\r\n        <button @click=\"getMsg()\">点击弹出消息</button>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\n    export default {\r\n        data() {\r\n            return {\r\n                msg: \"你好\"\r\n            }\r\n        },\r\n        methods: {\r\n            setMsg() {\r\n                this.msg = \"这是改变后的msg\"\r\n            },\r\n            getMsg() {\r\n                alert(this.msg)\r\n            }\r\n        }\r\n    }\r\n</script>\r\n```\r\n\r\n## class绑定多个动态属性\r\n```js\r\n<template>\r\n    <div>\r\n        <div :class=\"{'active': isActive,'red': isRed}\">这是动态类</div>\r\n        <div class=\"test\" :class=\"{'active': isActive}\"></div>\r\n        <div :class=\"[colorClass,baseClass]\"></div>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\n    export default {\r\n        data() {\r\n            return {\r\n                msg: \"你好\",\r\n                myClass: \"red\",\r\n                isActive: true,\r\n                isRed: false,\r\n                colorClass: 'color',\r\n                baseClass: 'base'\r\n            }\r\n        },\r\n    }\r\n</script>\r\n\r\n<style>\r\n    .red {\r\n        background-color: red;\r\n        width: 100px;\r\n        height: 100px;\r\n    }\r\n    .test {\r\n        background: pink;\r\n        width: 100px;\r\n        height: 100px;\r\n    }\r\n    .active {\r\n        display: block;\r\n        font-size: 30px;\r\n        color: aqua;\r\n    }\r\n    .color {\r\n        background-color: blue;\r\n    }\r\n    .base {\r\n        width: 500px;\r\n        height: 500px;\r\n    }\r\n</style>\r\n```\r\n\r\n## 数组语法结合三目运算\r\n```js\r\n<div :class=\"[flag ? colorClass:baseClass]\">111</div>\r\n```\r\n\r\n## 循环遍历数组并指定类和样式\r\n```js\r\n<template>\r\n    <div>\r\n        <ul>\r\n            <li v-for=\"(item,index) in list\" :key=index :class=\"{'red': index===0,'blue': index===1}\">\r\n                {{item}}\r\n            </li>\r\n            <li v-for=\"(item,index) in list\" :key=index :style=\"[index===0?styleRed:null,index===1?styleBlue:null]\">\r\n                {{item}}\r\n            </li>\r\n        </ul>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\n    export default {\r\n        data() {\r\n            return {\r\n                list: ['赵','钱','孙','李'],\r\n                styleRed: {\r\n                    color: 'red'\r\n                },\r\n                styleBlue: {\r\n                    color: 'blue'\r\n                }\r\n            }\r\n        },\r\n    }\r\n</script>\r\n\r\n<style>\r\n    .red {\r\n        background-color: red;\r\n        width: 100px;\r\n        height: 100px;\r\n    }\r\n    .blue {\r\n        background-color: blue;\r\n        width: 100px;\r\n        height: 100px;\r\n    }\r\n</style>\r\n```\r\n### @是v-on的缩写\r\n>下面的这种写法也是可以的。\r\n\r\n```js\r\n<button v-on:click=\"setmsg()\">点我修改为李四</button>\r\n```\r\n\r\n### 一个方法调用另一个方法\r\n```js\r\n<button @click=\"run()\">一个方法调用另一个方法</button>\r\nexport default {\r\n    data() {\r\n        return {\r\n            list: ['赵','钱','孙','李'],\r\n            styleRed: {\r\n                color: 'red'\r\n            },\r\n            styleBlue: {\r\n                color: 'blue'\r\n            },\r\n            msg: \"张三\"\r\n        }\r\n    },\r\n    methods: {\r\n        getmsg() {\r\n            alert(this.msg)\r\n        },\r\n        setmsg() {\r\n            this.msg = \"李四\";\r\n        },\r\n        run() {\r\n            this.getmsg()\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 获取事件对象\r\n>核心就是传递给目标函数一个$event。\r\n\r\n```js\r\n<button  data-aid=\"123\" @click=\"eventFn($event)\">点我获取事件对象</button>\r\n```\r\n\r\n>需要传入多个参数的情况，将$event放在最后。\r\n\r\n```js\r\n<button  data-title2=\"666\" data-aid=\"123\" @click=\"eventFn(111,$event)\">点我获取事件对象</button>\r\n```\r\n\r\n### 获取事件对象的自定义属性\r\n>下面是html结构\r\n\r\n```js\r\n<button  data-title2=\"666\" data-aid=\"123\" @click=\"eventFn($event)\">点我获取事件对象</button>\r\n```\r\n\r\n>下面是获取方法：通过e.srcElement.dataset.xxx;\r\n\r\n```js\r\nalert(e.srcElement.dataset.aid)\r\nalert(e.srcElement.dataset.title2)\r\n```\r\n\r\n### 一次触发多个函数\r\n```js\r\n<button @click=\"one(),two()\">点我一次触发两个</button>\r\none() {\r\n    console.log(\"这是one\");\r\n},\r\ntwo() {\r\n    console.log(\"这是two\");\r\n}\r\n```\r\n\r\n### 阻止事件的默认行为\r\n#### 方式一：通过preventDefault。\r\n```js\r\n<a href=\"http://www.baidu.com\" target=\"_blank\" @click=\"stopEvent($event)\">点我跳转到百度</a>\r\nstopEvent(e) {\r\n    e.preventDefault()\r\n}\r\n```\r\n\r\n#### 方式二：通过事件修饰符来阻止\r\n```js\r\n<a href=\"http://www.baidu.com\" target=\"_blank\" @click.prevent=\"stopFn2\">点我跳转到百度</a>\r\nstopFn2() {\r\n\r\n}\r\n```\r\n\r\n### 按键修饰符\r\n>按键修饰符主要是检测用户按了什么键，主要是通过@keyup实现。\r\n\r\n```js\r\n<input type=\"text\" @keyup=\"doSearch($event)\">\r\ndoSearch(e) {\r\n    if (e.keyCode === 13) {\r\n        alert('检测到用户按了回车键')\r\n    }\r\n}\r\n```\r\n\r\n>实现输入的时候，不做操作，只有按回车的时候才执行函数。\r\n\r\n```js\r\n<input type=\"text\" @keyup.enter=\"doSearch($event)\">\r\n```\r\n\r\n### 获取元素对象\r\n* 原生JS获取DOM对象\r\n\r\n```js\r\nconst usernameObj = document.querySelector('#username');\r\nalert(usernameObj.value)\r\n```\r\n\r\n* 通过this.$refs\r\n\r\n```js\r\n<li>年龄：<input type=\"text\" ref=\"age\"></li>\r\nalert(this.$refs.age.value)\r\n```\r\n\r\n### 双向数据绑定MVVM\r\n>MVVM就是我们常说的双向数据绑定，Vue就是一个MVVM框架，M表示model,V表示View，在MVVM框架中model改变会影响view，view视图改变反过来会影响model。\r\n\r\n* 获取双向数据绑定的值（直接从this中拿即可）\r\n\r\n```js\r\nalert(this.username)\r\n```\r\n\r\n* 对radio单选框进行双向数据绑定\r\n\r\n```js\r\n<input type=\"radio\" name=\"sex\" id=\"sex1\" value=\"男\" v-model=\"userinfo.sex\"> <label for=\"sex1\">男</label>\r\n<input type=\"radio\" name=\"sex\" id=\"sex2\" value=\"女\" v-model=\"userinfo.sex\"> <label for=\"sex2\">女</label>\r\n```\r\n\r\n* 对select选择框进行双向数据绑定\r\n\r\n```js\r\n<select v-model=\"userinfo.city\">\r\n    <option v-for=\"(item,index) in userinfo.cityList\" :key=\"index\" :value=\"item\">{{item}}</option>\r\n</select>\r\n```\r\n\r\n* 对checkbox进行双向数据绑定\r\n\r\n```js\r\n<span v-for=\"(item,index) in userinfo.hobbies\" :key=\"index\">\r\n    <input type=\"checkbox\" :id=\"'ch' + index\" v-model=\"item.checked\" />\r\n    <label :for=\"'ch'+index\">{{item.title}}</label>\r\n</span>\r\nhobbies: [\r\n    {\r\n        title: \"吃饭\",\r\n        checked: false\r\n    },\r\n    {\r\n        title: \"睡觉\",\r\n        checked: true\r\n    },\r\n    {\r\n        title: \"写代码\",\r\n        checked: false\r\n    },\r\n]\r\n```\r\n\r\n* 对textarea进行双向数据绑定\r\n\r\n```js\r\n<textarea cols=\"30\" rows=\"10\" v-model=\"userinfo.mark\"></textarea>\r\nmark: \"\"\r\n```\r\n\r\n## Vue的生命周期\r\n\r\n## Vue的template\r\n\r\n### 插值操作\r\n>所谓的插值操作，可以理解为双大括号语法。\r\n\r\n```js\r\n<h2>当前求和为：{{count}}</h2>\r\n```\r\n\r\n### v-once\r\n>v-once存在的意义是数据只渲染一次，当数据发生变化的时候，渲染的数据不随着变化。\r\n\r\n```js\r\n<h2 v-once>当前求和为：{{count}}</h2>\r\n```\r\n\r\n### v-html\r\n>v-html存在的意义是将字符串形式的html文本渲染为真正的HTML。\r\n\r\n```js\r\n<div id=\"root\">\r\n  <h2 v-html=\"url\"></h2>\r\n</div>\r\n<script src=\"../vue.js\"></script>\r\n\r\n<script>\r\n  const app = new Vue({\r\n    el: \"#root\",\r\n    data: {\r\n      count: 0,\r\n      url: '<a href=\"http://www.baidu.com\">百度一下</a>'\r\n    }\r\n  });\r\n</script>\r\n```\r\n\r\n### v-text\r\n>v-text能够实现类似双大括号插值的方法，但是这个指令不够灵活，一般不推荐使用。\r\n\r\n```js\r\n<h2 v-text=\"count\"></h2>\r\n```\r\n\r\n### v-pre\r\n>v-pre指令存在的意义是显示原生的内容，指的是不从vue中提取数据，双大括号显示的还是双大括号。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/8381c69a2a4df712f9250096214f81f0.png)\r\n\r\n### v-cloak\r\n>v-cloak指令存在的意义是控制JS解析引擎还未解析到双大括号语法或卡顿的时候，显示的内容。这个指令需要结合css语法。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/7088c535b1ec5a5ac96f805e95e1a011.png)\r\n\r\n### v-bind\r\n>v-bind可以使用冒号进行缩写。\r\n\r\n```js\r\n<img :src=\"imgUrl\" alt=\"\">\r\ndata: {\r\n  count: 0,\r\n  imgUrl: 'https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20211012134540.png'\r\n}\r\n```\r\n\r\n>v-bind动态绑定class。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/493beb07f8233f838db4a89833a19b22.png)\r\n\r\n* 也可以通过下面的语法\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/2376c26c1fe88550c9f881fdbb1aad5f.png)\r\n\r\n* 对象语法\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/77a815269cf97ad8c4fd8faafbcd5d26.png)\r\n\r\n* 数组语法\r\n\r\n1. 加单引号的情况\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/87cdd7c292da15d68f9f1fbd5715ba6f.png)\r\n\r\n2. 不加单引号的情况\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/3e3cd4837a17e788d7fca58b506420a5.png)\r\n\r\n>v-bind动态绑定style。\r\n\r\n1. 加单引号的情况。\r\n\r\n```js\r\n<h2 :style=\"{fontSize: '50px'}\">当前求和为：{{count}}</h2>\r\n```\r\n\r\n>此时的50px代表的是字面量并不是变量，但是如果不加单引号，此时的50px指的是一个变量，Vue会从data中寻找这个变量。\r\n\r\n2. 不加单引号的情况\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/2170c74d73f85fcee0118a763f4da033.png)\r\n\r\n\r\n## 计算属性\r\n### 计算属性的基本使用\r\n>调用计算属性的时候，后面不用加括号。\r\n```js\r\n<h2>{{fullName}}</h2>\r\ncomputed: {\r\n  fullName() {\r\n    return this.firstName + this.lastName\r\n  }\r\n}\r\n```\r\n\r\n### 计算属性的复杂操作\r\n>下面是使用计算属性的一个例子。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/0d11b0dee7c3f07182eebe56648ea9e9.png)\r\n\r\n### 计算属性的setter和getter\r\n>一般情况下，我们不适用计算属性的set方法，请看下面的例子。\r\n\r\n```js\r\n<div id=\"root\">\r\n  <h2>当前姓名为：{{fullName}}</h2>\r\n</div>\r\n<script src=\"../vue.js\"></script>\r\n\r\n<script>\r\n  const app = new Vue({\r\n    el: \"#root\",\r\n    data: {\r\n      count: 0,\r\n      firstName: '张',\r\n      lastName: '三'\r\n    },\r\n    computed: {\r\n      fullName: {\r\n        set(value) {\r\n          const [value1,value2] = value.split('') \r\n          this.firstName = value1;\r\n          this.lastName = value2;\r\n        },\r\n        get() {\r\n          return this.firstName + this.lastName;\r\n        }\r\n      }\r\n    }\r\n  });\r\n</script>\r\n```\r\n\r\n### 计算属性和methods的对比\r\n>计算属性是有缓存机制的，以下面的例子为例，如果是methods，调用多少次，函数就需要执行多少次，但是如果是计算属性，调用多次，函数只执行了一次，极大的提高了性能。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/2015c2a146bfda2ea99e9ae3e5743969.png)\r\n\r\n\r\n## v-on\r\n>v-on的语法糖是@\r\n\r\n### v-on的参数传递问题\r\n>v-on在调用的时候，是否加括号是一个指的我们探讨的问题。\r\n\r\n1. 加不加都行的情况\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/cd66a5ee5c0376fe203a58090f7303af.png)\r\n\r\n2. 假如函数需要接受一个参数的情况，如果加括号传入的是undefined，不加则传入的是事件对象。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/d1daeba2945e660eb75436134ab20f4d.png)\r\n\r\n3. 既需要event对象又需要自定义参数的情况\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/dd39002746af8a38a17517025bb2f97d.png)\r\n\r\n### v-on的修饰符\r\n>有些时候，我们拿到event的目的可能是进行一些事件处理，vue提供的这些修饰符就是来帮助我们方便的处理一些事件。\r\n\r\n* .stop -阻止事件冒泡，调用event.stopPropagation()\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/9f7505ebbbd2929a7d8e3fddc588ec9d.png)\r\n\r\n* .prevent - 调用event.preventDefault() 阻止默认事件的触发\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/78f3cba45afde4b57fa77f83868e4ad1.png)\r\n\r\n* keyup：键盘弹起触发事件\r\n\r\n```js\r\n<input type=\"text\" @keyup=\"key()\">\r\n```\r\n\r\n* keyup.enter：输入回车才会触发事件\r\n\r\n```js\r\n<input type=\"text\" @keyup.enter=\"key()\">\r\n```\r\n\r\n* .once点击回调只会触发一次\r\n\r\n```js\r\n<button @click.once=\"oncefn\">这个按钮只能被按一次</button>\r\n```\r\n\r\n## v-if、v-else-if、v-else的基本用法\r\n>v-if后面的条件为false的时候，对应的元素及其子元素不会渲染，v-else后面不用加条件。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/a668e4a50f796f416cd76161acae19ed.png)\r\n\r\n### 解决input复用问题\r\n>所谓的input复用问题就是切换input后，用户原本输入的值还在。解决方案就是给每一个input添加key属性。\r\n\r\n```js\r\n<input type=\"text\" id=\"username\" placeholder=\"使用账户登录\" key=\"username\">\r\n```\r\n\r\n## v-show和v-if的区别\r\n1. 不渲染时是否在DOM中\r\n    * v-if如果条件为false时，对应的元素就不会存在与DOM中。\r\n    * v-show如果条件为false的时候，仅仅是将元素的diplay属性置为none。\r\n\r\n2. 如何选择\r\n    * 如果需要频繁的进行显示和隐藏，使用v-show。\r\n    * 如果只有一次切换的情况，使用v-if。\r\n    \r\n## 响应式改变数组的方法\r\n1. push\r\n2. pop\r\n3. shift\r\n4. unshift\r\n5. splice\r\n6. sort\r\n7. reverse\r\n\r\n## 不能够响应式的操作\r\n1. 通过下标修改元素。\r\n\r\n## 过滤器的使用\r\n```js\r\n<td>{{item.price | showPrice}}</td>\r\nfilters: {\r\n  showPrice(price) {\r\n    return '￥' + price.toFixed(2);\r\n  }\r\n}\r\n```\r\n\r\n## v-model\r\n>v-model主要用来实现双向数据绑定。\r\n\r\n### 基本案例\r\n```js\r\n<div id=\"root\">\r\n    <h2>当前message：{{message}}</h2>\r\n    <input type=\"text\" v-model=\"message\">\r\n    </div>\r\n    <script src=\"../vue.js\"></script>\r\n\r\n    <script>\r\n    const app = new Vue({\r\n      el: \"#root\",\r\n      data: {\r\n        count: 0,\r\n        message: ''\r\n      }\r\n    });\r\n</script>\r\n```\r\n\r\n### 原理分析\r\n>v-model其实是一个语法糖，背后的本质包含了两个操作。\r\n\r\n1. v-bind绑定一个value属性。\r\n2. v-on指令给当前元素绑定input事件。\r\n\r\n### v-model结合radio类型使用\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/0607b3b8862108ca54281f01d814a083.png)\r\n\r\n### v-model结合checkbox使用\r\n>单个checkbox\r\n\r\n```js\r\n<label for=\"license\">\r\n  <input type=\"checkbox\" id=\"license\" v-model=\"isAgree\">同意协议\r\n</label>\r\n<h2>用户选择的是：{{isAgree}}</h2>\r\n```\r\n\r\n>多个checkbox的情况\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/3c1f2bb5e2294595b859f332448bed7b.png)\r\n\r\n### v-model结合select使用\r\n>只能选择一个的情况。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/64cd633f7756771025bf41d6c7db5580.png)\r\n\r\n>可以选择多个的情况。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/01f50091f1820b8309509ffd4875ee8d.png)\r\n\r\n### v-model修饰符的使用\r\n1. lazy修饰符\r\n\r\n>lazy修饰符可以让数据在失去焦点或者回车时才会更新。\r\n\r\n```js\r\n<input type=\"text\" v-model.lazy=\"message\">\r\n```\r\n\r\n2. number修饰符\r\n\r\n>number修饰符可以让输入框汇中的内容自动转换为数字类型。\r\n\r\n```js\r\n<input type=\"text\" v-model.number=\"message\">\r\n```\r\n\r\n3. trim修饰符\r\n\r\n>trim修饰符可以过滤内容两边左右的空格。\r\n\r\n```js\r\n<input type=\"text\" v-model.trim=\"message\">\r\n```\r\n\r\n## 组件化\r\n### 组件化的基本使用过程\r\n1. 创建组件构造器\r\n\r\n```js\r\nconst myComponent = Vue.extend({\r\n  template: `\r\n    <div>\r\n      <h2>模板标题</h2>\r\n      <p>模板内容</p>\r\n    </div>\r\n  `\r\n});\r\n```\r\n\r\n2. 注册组件\r\n\r\n```js\r\nVue.component('mycpn',myComponent);\r\n```\r\n\r\n3. 使用组件\r\n\r\n```js\r\n<mycpn></mycpn>\r\n```\r\n\r\n### vue组件命名的规范\r\n>如果使用驼峰命名法注册组件的时候，在使用组件的时候需要使用分割线进行分割，否则会报错。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/eb2b77fb9a1bcba84d5d1e436e8d7998.png)\r\n\r\n### 全局组件和局部组件\r\n* 全局组件：意味着可以在多个Vue实例下面使用\r\n* 局部组件：只能在某个Vue实例中使用\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/181bb1ec9845a79ef793268c48e77cab.png)\r\n\r\n### 父组件和子组件的案例\r\n```js\r\n    <div id=\"root\">\r\n    <Father></Father>\r\n    </div>\r\n    <script src=\"../vue.js\"></script>\r\n\r\n    <script>\r\n    // 创建子组件的构造器\r\n    const Son = Vue.extend({\r\n      template: `\r\n        <div>\r\n          <h2>这是子组件</h2>\r\n          <p>子组件的内容是：呵呵呵<p/> \r\n        </div>\r\n      `\r\n    })\r\n\r\n    // 创建父组件构造器\r\n    const Father = Vue.extend({\r\n      template: `\r\n        <div>\r\n          <h2>这是父组件</h2>\r\n          <p>父组件的内容是：哈哈哈</p>\r\n          <Son></Son>\r\n        </div>\r\n      `,\r\n      components: {\r\n        Son: Son\r\n      }\r\n    })\r\n\r\n    const root = new Vue({\r\n      el: '#root',\r\n      data: {\r\n\r\n      },\r\n      components: {\r\n        Father: Father\r\n      }\r\n    });\r\n    </script>\r\n```\r\n\r\n### 注册组件的语法糖写法\r\n* 注册全局组件的语法糖写法\r\n\r\n```js\r\n    Vue.component('cpn',{\r\n      template: `\r\n        <div>\r\n          <h2>这是模板</h2>  \r\n        </div>\r\n      `\r\n    });\r\n```\r\n\r\n* 注册局部组件的语法糖写法\r\n\r\n```js\r\n    const root = new Vue({\r\n      el: \"#root\",\r\n      components: {\r\n        cpn2: {\r\n          template: `\r\n        <div>\r\n          <h2>这是模板</h2>  \r\n        </div>\r\n      `\r\n        }\r\n      }\r\n    });\r\n```\r\n\r\n### 组件模板抽离的写法\r\n1. 通过script标签\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/267247b49cdeabac2f3ad1dd5a6b5c8d.png)\r\n\r\n2. 通过template标签\r\n\r\n```js\r\n  <template  id=\"tpl\">\r\n    <div>\r\n      <h2>这是模板标题</h2>\r\n      <p>这是模板文本</p>\r\n    </div>\r\n  </template>\r\n```\r\n\r\n## 组件不能访问Vue实例中的数据\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/658ea43508f972661e29d2f943e7d983.png)\r\n\r\n>组件中的data需要是一个函数通过return的形式返回。\r\n\r\n```js\r\ncomponents: {\r\n    cpn2: {\r\n      template: '#tpl',\r\n      data() {\r\n        return {\r\n          title: '这是一级标题'\r\n        }\r\n      }\r\n    }\r\n}\r\n```\r\n\r\n## 为什么组件data必须是函数？\r\n>组件data必须是函数主要是为了防止不同函数实例操作相同的数据，组件复用希望复用的是功能，而不是数据复用。\r\n\r\n## 组件通信\r\n### 父组件向子组件传递数据\r\n1. 通过props\r\n\r\n* 数组形式\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/c4ccae98170b1ea0453acb2fb0806358.png)\r\n\r\n* 对象形式（可以指定传入的类型，或指定默认值）\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/698eedcd9e5d4004ce49c73527a36e9e.png)\r\n\r\n>调用默认值的时机就是调用组件的时候没有传参，但是模板中却使用了这个参数，此时就会使用默认参数。如果默认参数是数组或者函数，default必须是一个函数的形式。\r\n\r\n### props中的驼峰标识\r\n>下面的写法是不支持的\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/e59d1afdddc98401586d0aa0d3bbe7f6.png)\r\n\r\n>但是支持下面的写法\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/383bbb7178167b7a0b5aceab1db9800a.png)\r\n\r\n>比如props想使用的参数名是ChildMyMessage，在组件调用进行v-bind绑定的时候需要写成:child-my-message\r\n\r\n### 子组件向父组件传递数据\r\n>主要是通过子组件中调用$emit方法将事件传递给父组件，父组件通过v-on监听这个事件并调用自己的函数。\r\n\r\n```js\r\n  <div id=\"root\">\r\n    <cpn @item-click=\"cpnClick\"></cpn>\r\n  </div>\r\n  <template id=\"tpl\">\r\n    <div>\r\n      <h2>这是子组件</h2>\r\n      <button v-for=\"item in categories\" @click=\"btnClick(item)\">\r\n        {{item.name}}\r\n      </button>\r\n    </div>\r\n  </template>\r\n  <script src=\"../vue.js\"></script>\r\n\r\n  <script>\r\n    // 这是子组件\r\n    const cpn = {\r\n      template: \"#tpl\",\r\n      data() {\r\n        return {\r\n          categories: [\r\n            { id: 'aaa', name: '热门推荐' },\r\n            { id: 'bbb', name: '手机数码' }\r\n          ]\r\n        }\r\n      },\r\n      methods: {\r\n        btnClick(item) {\r\n          this.$emit('item-click',item)\r\n        }\r\n      }\r\n    }\r\n    // 这是父组件\r\n    const app = new Vue({\r\n      el: \"#root\",\r\n      data: {\r\n        count: 0\r\n      },\r\n      components: {\r\n        cpn\r\n      },\r\n      methods: {\r\n        cpnClick(item) {\r\n          console.log(item);\r\n        }\r\n      }\r\n    });\r\n  </script>\r\n```\r\n\r\n## 父组件访问子组件\r\n* 父组件访问子组件\r\n\r\n>通过$children\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/20cc4e282547a5b1e6818a644b1b7a7b.png)\r\n\r\n>通过$refs\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/6e19a078bb2b0b7787fc13db3fce3bb8.png)\r\n\r\n* 子组件访问父组件\r\n\r\n>使用$parent\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/cecbf31d3c6e59460b055310cf890255.png)\r\n\r\n* 任意组件访问根组件\r\n\r\n>通过$root\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/26145a5abef9f805f3b9afe1e84723bd.png)\r\n\r\n## slot插槽的使用\r\n>在Vue中最好的封装方式就是将共性抽取到组件中，将不同暴露为插槽，一旦预留了插槽，就可以让使用者根据自己的需求来决定插槽中插入的什么内容。\r\n\r\n>插槽的基本用法\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/40c7931d020290dde1cfdf63776b1016.png)\r\n\r\n>插槽的默认值：在调用组件的时候，如果不指定插槽内容的时候显示的结果\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/e3645e36f15ca32d4e14497dbbaf6d66.png)\r\n\r\n>具名插槽slot的使用\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/60ca27462661d664704066f468364634.png)\r\n\r\n## 编译作用域\r\n>vue中查找变量是往上查找。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/c553cc838e6f72254dd47875b1e808fd.png)\r\n\r\n## 作用域插槽\r\n>主要是让父组件获取到子组件插槽对应的数据。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/1b29b0241b0305cc810801c68a9cb283.png)\r\n\r\n\r\n ## 通过watch监听数据的变化\r\n >所谓的watch监听指的就是监听一个属性是否发生变化，如果发生变化则触发响应的函数。\r\n \r\n![image.png](https://img-blog.csdnimg.cn/img_convert/3514e6f6dda52f251beb5b09bd1c8887.png)\r\n\r\n## Vue3中集成Sass\r\n1. 安装插件\r\n\r\n```js\r\nnpm  install sass-loader  node-sass --save-dev\r\n```\r\n\r\n2. 修改标签\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/681278d8ab804fe9d585fe476f6a909d.png)\r\n\r\n## Vue3中使用localStorage\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/c294b5e3b92417abbb2b5001ce63519a.png)\r\n\r\n## mounted生命周期函数\r\n>这个生命周期函数是在页面加载的时候运行的。\r\n\r\n## scoped关键字\r\n>scoped关键字可以让css样式只适用于局部vue组件。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/69b5267ce00ace06dacc69e1294cc045.png)\r\n\r\n\r\n## 将父组件传递给子组件\r\n>主要是通过传递this。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/10281df2f88a920e807a1693f1edbf86.png)\r\n\r\n## props验证\r\n>所谓的props验证指的是对传入的props进行校验。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/c3984ea9848e6e3ff91193da06a2bdb0.png)\r\n\r\n## 单向数据流\r\n>所有的prop都使得其父子prop之间形成了一个单向下行绑定：父级prop的更新会向下流动到子组件中，但是反过来则不行，这样会防止子组件意外变更父组件的状态，从而导致你的应用的数据流向难以理解。另外，每次父级组件发生变更的时候，子组件中所有的prop都将会更新为最新的值，这意味着不应该在一个子组件内部改变prop,如果这样做了，Vue会在浏览器的控制台发出警告。\r\n\r\n## 父组件主动获取子组件的数据和执行子组件中的方法\r\n1. 调用子组件的时候传入一个ref属性。\r\n\r\n2. 通过this.$refs.xxx.属性 获取数据。\r\n\r\n3. 通过this.$refs.header.方法执行子组件中的方法。\r\n\r\n## 子组件主动获取父组件中的数据和执行父组件中的方法\r\n1. 子组件通过this.$parent.数据 获取父组件的数据。\r\n\r\n2. 子组件通过 this.$parent.方法 主动执行父组件中的方法。\r\n\r\n## 子组件执行父组件自定义事件\r\n\r\n>实例分析\r\n\r\n1. 父组件中的自定义事件是fatherEvent，父组件中的方法是hello。\r\n\r\n```js\r\n<Header @fatherEvent=\"hello\" />\r\n```\r\n\r\n2. 子组件通过$emit触发并进行传参。\r\n\r\n```js\r\nthis.$emit('fatherEvent',this.msg)\r\n```\r\n\r\n\r\n## 通过emits属性对输入的参数进行检验\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/ec6bab0e532bef8cc6bde7af05cc0f56.png)\r\n\r\n## 使用mitt插件实现非父子组件之间的传值\r\n1. 首先安装emitt插件\r\n\r\n```shell\r\nnpm install emitt\r\n```\r\n\r\n2. 定义函数并暴露对象\r\n\r\n```js\r\nimport mitt from 'mitt'\r\nconst event = mitt();\r\n\r\nexport default event;\r\n```\r\n\r\n3. 需要发送数据的组件，广播事件\r\n```js\r\nsendLogin() {\r\n  // 向外发射一个事件，名叫toLogin，数据是this.msg\r\n  event.emit('toLogin',this.msg)\r\n}\r\n```\r\n\r\n4. 需要接收数据的组件，监听事件\r\n```js\r\n// 监听事件toLogin \r\nevent.on('toLogin',(data) => {\r\n  console.log(data)\r\n})\r\n```\r\n\r\n## 自定义组件使用v-model进行双向数据绑定\r\n>首先明确下组件之间的结构，Home组件中包含Input组件，Input组件时Home组件的子组件。keyword是Home组件中的数据。\r\n\r\n* Home组件\r\n\r\n```js\r\n<Input v-model:keyword=\"keyword\" />\r\n```\r\n\r\n* Input组件\r\n\r\n```js\r\n<input type=\"text\" :value=\"keyword\" @input=\"$emit('update:keyword',$event.target.value)\" placeholder=\"请输入内容\">\r\n```\r\n\r\n## 非Prop的Attribute属性继承\r\n>所谓的非prop的Attribute属性继承指的是，如果传入的一个属性，在子组件中并未声明接收，这个属性将被子组件的根标签继承，让我们一起来看下下面的例子。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/2b2843127cdb2d12369589f4f288d80b.png)\r\n\r\n## 自定义Attribute继承\r\n>自定义Attribute继承，可以禁用默认继承，并指定哪些元素可以继承。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/5b6c7c5569f84ed3c7beb7b8a89e502e.png)"
    },
    {
      "id": "/递归模板解决二叉树的前中后序遍历问题",
      "metadata": {
        "permalink": "/blog/递归模板解决二叉树的前中后序遍历问题",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/递归模板解决二叉树的前中后序遍历问题.md",
        "source": "@site/blog\\递归模板解决二叉树的前中后序遍历问题.md",
        "title": "递归模板解决二叉树的前中后序遍历问题",
        "description": "题目描述",
        "date": "2021-10-21T00:00:00.000Z",
        "formattedDate": "2021年10月21日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 1.72,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "递归模板解决二叉树的前中后序遍历问题",
          "date": "2021-10-21T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "（千字长文）Vue核心基础解析",
          "permalink": "/blog/（千字长文）Vue核心基础解析"
        },
        "nextItem": {
          "title": "TypeScript之初识interface",
          "permalink": "/blog/TypeScript之初识interface"
        }
      },
      "content": "## 题目描述\r\n>二叉树的前中后序遍历，是面试中的常考题目也是解决二叉树问题的核心基础，本次我们来介绍下如何通过递归的方式，求解这类问题，解决这类问题的思路包括使用递归或者迭代，本次我们主要介绍如何使用递归模板来解决这类问题，通过使用模板这三种遍历只需进行细微的改动，即可得到最终的结果。\r\n\r\n## 前中后相对的是谁？\r\n>二叉树的前中后序遍历，指的是根节点所在的位置。\r\n\r\n* 前序遍历\r\n\r\n根 -> 左 -> 右\r\n\r\n* 中序遍历\r\n\r\n左 -> 根 -> 右\r\n\r\n* 后序遍历\r\n\r\n左 -> 右 -> 根\r\n\r\n## 解题模板\r\n>前序遍历，只需要将处理函数放到1号位置，中序遍历只需要将处理函数放到2号位置，后序遍历只需要将处理函数放到3号位置上即可。\r\n\r\n```js\r\nvar postorderTraversal = function(root) {\r\n  const result = [];\r\n  function lastOrder(node) {\r\n    if (!node) return \r\n    // 1号位置\r\n    lastOrder(node.left);\r\n    // 2号位置\r\n    lastOrder(node.right);\r\n    // 3号位置\r\n    result.push(node.val);\r\n  }\r\n  lastOrder(root);\r\n  return result;\r\n};\r\n```\r\n\r\n## 题目反思\r\n>二叉树的前中后序遍历的递归解法，可以通过在函数中嵌套函数的方式来解决，所谓的前中后序遍历主要是处理函数放置的位置不同。"
    },
    {
      "id": "/TypeScript之初识interface",
      "metadata": {
        "permalink": "/blog/TypeScript之初识interface",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/TypeScript之初识interface.md",
        "source": "@site/blog\\TypeScript之初识interface.md",
        "title": "TypeScript之初识interface",
        "description": "interface的作用",
        "date": "2021-10-20T00:00:00.000Z",
        "formattedDate": "2021年10月20日",
        "tags": [
          {
            "label": "TypeScript",
            "permalink": "/blog/tags/type-script"
          }
        ],
        "readingTime": 1.335,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "TypeScript之初识interface",
          "date": "2021-10-20T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "TypeScript",
          "tags": [
            "TypeScript"
          ]
        },
        "prevItem": {
          "title": "递归模板解决二叉树的前中后序遍历问题",
          "permalink": "/blog/递归模板解决二叉树的前中后序遍历问题"
        },
        "nextItem": {
          "title": "前端经久不衰的面试题--数组乱序",
          "permalink": "/blog/前端经久不衰的面试题--数组乱序"
        }
      },
      "content": "## interface的作用\r\n1. 描述对象的形状\r\n2. 对类的一部分行为进行抽象\r\n>下面的文章主要围绕着上面的两部分进行讲解。\r\n\r\n## 一、描述对象的形状\r\n>注意：下面的interface之间的元素是通过分号进行分割的。interface 后面跟的名字大小写都可以。\r\n\r\n```ts\r\ninterface person {\r\n    name: string;\r\n    music: string;\r\n}\r\nlet person: person = {\r\n    name: 'justin',\r\n    music: 'test'\r\n}\r\n```\r\n* 通过interface定义的对象，属性的个数不可多页不可少，如果非要少的话，可以采取下面的这种形式。**可选属性**\r\n```ts\r\ninterface person {\r\n    name: string;\r\n    music?: string;\r\n}\r\nlet person: person = {\r\n    name: 'justin',\r\n}\r\n```\r\n* 通过**interface**定义的对象，如果想出现**自由属性**，可以通过下面的这种方式。\r\n```ts\r\ninterface person {\r\n    name: string;\r\n    music?: string;\r\n    [propName: string]: any;\r\n}\r\nlet person: person = {\r\n    name: 'justin',\r\n    sex: 'fox'\r\n}\r\n```\r\n* 通过**readonly**定义**只读属性**\r\n```ts\r\ninterface person {\r\n    readonly id: number;\r\n    name: string;\r\n    music?: string;\r\n    [propName: string]: any;\r\n}\r\nlet person: person = {\r\n    id: 123456,\r\n    name: 'justin',\r\n    sex: 'fox'\r\n}\r\n\r\nperson.id = 666;  // 此处会报错\r\n```"
    },
    {
      "id": "/前端经久不衰的面试题--数组乱序",
      "metadata": {
        "permalink": "/blog/前端经久不衰的面试题--数组乱序",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端经久不衰的面试题--数组乱序.md",
        "source": "@site/blog\\前端经久不衰的面试题--数组乱序.md",
        "title": "前端经久不衰的面试题--数组乱序",
        "description": "题目描述",
        "date": "2021-10-19T00:00:00.000Z",
        "formattedDate": "2021年10月19日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 1.92,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "前端经久不衰的面试题--数组乱序",
          "date": "2021-10-19T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "TypeScript之初识interface",
          "permalink": "/blog/TypeScript之初识interface"
        },
        "nextItem": {
          "title": "有大用途的useRef",
          "permalink": "/blog/有大用途的useRef"
        }
      },
      "content": "## 题目描述\r\n>给定一个未排序的数组，从中取出指定个数的随机元素，并以数组的形式进行返回，这道题目经常出现在前端各大厂的面试官手中，因此值得我们进行探讨和学习。\r\n\r\n* 测试实例\r\n\r\n>给定数组[1, 3, 5, 6, 8, 9, 5]，要求输出一个随机数组，数组的个数是3，输出可以是[1,3,5]、[6,8,9].....等只要是随机的三个数字，并且取自给定数组即可。\r\n\r\n## 实现思路\r\n>这道题目主要是考查我们对数组乱序算法的了解，直接使用random函数是肯定不行的，因为计算机内部的random函数并不是真正的随机函数，因此，我们可以考虑使用经典算法Fisher-Yates Shuffle算法。\r\n\r\n1. 从数组中随机选一个为混排的元素。\r\n2. 将第一步的元素与序列p的最后一个元素进行交换。\r\n3. 指向最后一个元素的指针前移并继续重复前两步。\r\n\r\n## 实现代码\r\n```js\r\n// 手撕数组乱序\r\nfunction getRandomArr(arr,count) {\r\n  // 定义分割点\r\n  let point = arr.length - count;\r\n  // 数组的长度\r\n  let len = arr.length;\r\n  \r\n  while (len > point) {\r\n    // 以len下标为基准：index表示的是len下标前面的任意一个元素下标\r\n    let index = Math.floor((len--) * Math.random())\r\n    // 如果index和len不同，则交换\r\n    if (index != len) {\r\n      let temp = arr[index];\r\n      arr[index] = arr[len];\r\n      arr[len] = temp;\r\n    }\r\n  }\r\n  return arr.slice(point);\r\n}\r\nconsole.log(getRandomArr([1, 3, 5, 6, 8, 9, 5], 3));\r\n```"
    },
    {
      "id": "/有大用途的useRef",
      "metadata": {
        "permalink": "/blog/有大用途的useRef",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/有大用途的useRef.md",
        "source": "@site/blog\\有大用途的useRef.md",
        "title": "有大用途的useRef",
        "description": "使用useRef获取DOM元素",
        "date": "2021-10-18T00:00:00.000Z",
        "formattedDate": "2021年10月18日",
        "tags": [
          {
            "label": "Hooks",
            "permalink": "/blog/tags/hooks"
          }
        ],
        "readingTime": 1.325,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "有大用途的useRef",
          "date": "2021-10-18T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Hooks",
          "tags": [
            "Hooks"
          ]
        },
        "prevItem": {
          "title": "前端经久不衰的面试题--数组乱序",
          "permalink": "/blog/前端经久不衰的面试题--数组乱序"
        },
        "nextItem": {
          "title": "二刷--无重复字符的最长子串",
          "permalink": "/blog/二刷--无重复字符的最长子串"
        }
      },
      "content": "## 使用useRef获取DOM元素\r\n>使用useRef获取DOM元素是目前useRef最常用的用法。\r\n\r\n### 基本用法\r\n```js\r\nfunction App() {\r\n    const box = useRef();\r\n\r\n    return (\r\n        <div ref={box}>\r\n            <button onClick={() => console.log(box)}>点击获取div</button>\r\n        </div>\r\n    )\r\n}\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/690a1254e0f8fa452719c4f1ad1a82a0.png)\r\n\r\n## 使用useRef跨组件周期保存数据\r\n>即使组件重新渲染，保存的数据仍然还在，保存的数据被更改不会触发组件重新渲染。\r\n\r\n### 基本用法\r\n```js\r\n/**\r\n * @description: 组件挂载完成之后开启一个循环定时器，使用useRef的保存数据功能\r\n *               不会随着组件的更新而丢失数据\r\n * @param {*}\r\n * @return {*}\r\n */\r\nfunction App() {\r\n    const [count,setCount] = useState(0)\r\n    const timeId = useRef;\r\n    useEffect(() => {\r\n        timeId.current = setInterval(() => {\r\n            setCount(count => count + 1);\r\n        },1000)\r\n    }, []);\r\n    const handleSetInterval = () => {\r\n        clearInterval(timeId.current)\r\n    }\r\n    return (\r\n        <div>\r\n            <h1>当前求和为{count}</h1>\r\n            <button onClick={handleSetInterval}>点我清除定时器</button>\r\n        </div>\r\n    )\r\n}\r\n```\r\n>这里我们需要注意的是数据并不是直接保存在useRef返回的这个对象中的，而是保存在这个对象的current属性上的。"
    },
    {
      "id": "/二刷--无重复字符的最长子串",
      "metadata": {
        "permalink": "/blog/二刷--无重复字符的最长子串",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/二刷--无重复字符的最长子串.md",
        "source": "@site/blog\\二刷--无重复字符的最长子串.md",
        "title": "二刷--无重复字符的最长子串",
        "description": "题目描述",
        "date": "2021-10-17T00:00:00.000Z",
        "formattedDate": "2021年10月17日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.745,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "二刷--无重复字符的最长子串",
          "date": "2021-10-17T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "有大用途的useRef",
          "permalink": "/blog/有大用途的useRef"
        },
        "nextItem": {
          "title": "从原理上解读useState钩子函数",
          "permalink": "/blog/从原理上解读useState钩子函数"
        }
      },
      "content": "## 题目描述\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/2242857d297dc77e899718001bceee1a.png)\r\n\r\n## 解题思路\r\n> 本题主要采用滑动窗口结合哈希表的思想，涉及到滑动窗口就必然涉及到左右指针，当右指针遍历到某一个元素的时候，我们首先判断哈希表中是否有该元素，无论有无，我们都首先记录下这个元素出现的次数，然后使用while循环，判断右指针指向的元素如果出现重复的情况，则更新左指针，最后更新极值。\r\n\r\n## AC代码\r\n```js\r\nvar lengthOfLongestSubstring = function (s) {\r\n  // 定义左指针\r\n  let left = 0;\r\n  // 定义右指针\r\n  let right = 0;\r\n  // 定义哈希表窗口\r\n  let window = new Map();\r\n  // 定义最终返回的最大值\r\n  let res = 0;\r\n  // 只要右指针没有到终点即开始循环\r\n  while (right < s.length) {\r\n    // 判断窗口中是否有右指针指向的元素\r\n    if (window.has(s[right])) {\r\n      window.set(s[right], window.get(s[right]) + 1)\r\n    } else {\r\n      window.set(s[right], 1);\r\n    };\r\n    // 右指针的元素出现重复的情况\r\n    while (window.get(s[right]) > 1) {\r\n      // 左指针对应的数量减一之后再让左指针右移\r\n      window.set(s[left], window.get(s[left]) - 1);\r\n      left++;\r\n    }\r\n    right++;\r\n    res = Math.max(res, right - left);\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\n## 题目反思\r\n* 学会使用哈希表作为滑动窗口的载体。\r\n* 只要是涉及到窗口的长度，一定要考虑到左右指针之间的关系。"
    },
    {
      "id": "/从原理上解读useState钩子函数",
      "metadata": {
        "permalink": "/blog/从原理上解读useState钩子函数",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/从原理上解读useState钩子函数.md",
        "source": "@site/blog\\从原理上解读useState钩子函数.md",
        "title": "从原理上解读useState钩子函数",
        "description": "原生useState具有的几个特点",
        "date": "2021-10-16T00:00:00.000Z",
        "formattedDate": "2021年10月16日",
        "tags": [
          {
            "label": "Hooks",
            "permalink": "/blog/tags/hooks"
          }
        ],
        "readingTime": 2.575,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "从原理上解读useState钩子函数",
          "date": "2021-10-16T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Hooks",
          "tags": [
            "Hooks"
          ]
        },
        "prevItem": {
          "title": "二刷--无重复字符的最长子串",
          "permalink": "/blog/二刷--无重复字符的最长子串"
        },
        "nextItem": {
          "title": "LeetCode——有效的括号（借助栈）",
          "permalink": "/blog/LeetCode——有效的括号（借助栈）"
        }
      },
      "content": "## 原生useState具有的几个特点\r\n1. 返回一个数组，数组的第一个参数值是状态值，第二个参数值是设置状态的方法。\r\n2. useState会判断传入的state是初始值还是已存在的值。\r\n3. useState可能被多次调用\r\n4. 调用设置状态的方法后需要重新渲染组件。\r\n\r\n## 手写useState\r\n### 第一步：用不同的数组来分别存放状态值和设置状态的方法\r\n```js\r\nlet states = [];\r\nlet setters = [];\r\nlet stateId = 0;\r\n```\r\n### 第二步：判断useState传入的初始状态值是否已经存在\r\n>存在用以前的，不存在则使用初始状态值\r\n```js\r\nstates[stateId] = states[stateId] ? states[stateId] : initialState;\r\n```\r\n\r\n### 第三步：通过状态的id来返回设置状态的方法，然后加入到设置方法的数组中\r\n>注意：自定义的渲染函数必须能够操作全局的状态id.\r\n```js\r\nsetters.push(createSetter(stateId));\r\nfunction createSetter(stateId) {\r\n    return function (newState) {\r\n        states[stateId] = newState;\r\n        myRender();\r\n    }\r\n}\r\nfunction myRender() {\r\n    stateId = 0;\r\n    ReactDOM.render(<App />, document.querySelector('#root'));\r\n}\r\n```\r\n\r\n### 第四步：返回第i个状态值和操作状态的方法，并对stateId+1\r\n```js\r\nlet value = states[stateId];\r\nlet setter = setters[stateId];\r\nstateId++;\r\nreturn [value, setter]\r\n```\r\n\r\n## 完整代码\r\n```js\r\nimport React from 'react'\r\nimport ReactDOM from 'react-dom'\r\n\r\n// 自定义Hook\r\n\r\n/**\r\n * @description: 手写useState\r\n * @param {*}\r\n * @return {*}\r\n */\r\nlet states = [];\r\nlet setters = [];\r\nlet stateId = 0;\r\nfunction createSetter(stateId) {\r\n    return function (newState) {\r\n        states[stateId] = newState;\r\n        myRender();\r\n    }\r\n}\r\nfunction myRender() {\r\n    stateId = 0;\r\n    ReactDOM.render(<App />, document.querySelector('#root'));\r\n}\r\nfunction myUseState(initialState) {\r\n    // 判断state是否存在，存在则使用以前的，不存在则使用初始值\r\n    states[stateId] = states[stateId] ? states[stateId] : initialState;\r\n    setters.push(createSetter(stateId));\r\n    let value = states[stateId];\r\n    let setter = setters[stateId];\r\n    stateId++;\r\n    return [value, setter]\r\n}\r\nfunction App() {\r\n    const [count, setCount] = myUseState(0);\r\n    const [name, setName] = myUseState('张三');\r\n    return (\r\n        <div>\r\n            <h1>当前求和为：{count}</h1>\r\n            <button onClick={() => setCount(count + 1)}>点我+1</button>\r\n            <h1>当前姓名为：{name}</h1>\r\n            <button onClick={() => setName('李四')}>点我切换姓名</button>\r\n        </div>\r\n    )\r\n}\r\n\r\nReactDOM.render(<App />, document.querySelector('#root'));\r\n```\r\n\r\n## CodeSandBox在线实现地址\r\n* [在线实现](https://codesandbox.io/s/shou-xie-usestate-62gkc?file=/src/index.js)\r\n\r\n## 参考资料\r\n* [官方文档：useState](https://zh-hans.reactjs.org/docs/hooks-reference.html#usestate)\r\n\r\n* [从源码剖析useState的执行过程](https://juejin.cn/post/6844903833764642830)"
    },
    {
      "id": "/LeetCode——有效的括号（借助栈）",
      "metadata": {
        "permalink": "/blog/LeetCode——有效的括号（借助栈）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——有效的括号（借助栈）.md",
        "source": "@site/blog\\LeetCode——有效的括号（借助栈）.md",
        "title": "LeetCode——有效的括号（借助栈）",
        "description": "题目描述",
        "date": "2021-10-15T00:00:00.000Z",
        "formattedDate": "2021年10月15日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 2.115,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——有效的括号（借助栈）",
          "date": "2021-10-15T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "从原理上解读useState钩子函数",
          "permalink": "/blog/从原理上解读useState钩子函数"
        },
        "nextItem": {
          "title": "彻底搞懂自定义Hook函数和路由钩子函数",
          "permalink": "/blog/彻底搞懂自定义Hook函数和路由钩子函数"
        }
      },
      "content": "## 题目描述\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/3dae1e003683aebeddb9ab52e8326d10.png)\r\n\r\n## 解题思路\r\n>本题的核心解题思路在于借助栈。\r\n\r\n1. 首先，定义一个栈。\r\n2. 遍历字符串中的每一个元素，如果该元素是左括号，不管是哪一种类型的左括号都直接入栈。\r\n3. 如果遇到的是右括号，首先判断栈中是否有元素，如果没有元素则直接返回false，如果有元素，则判断是否是一对有效的括号，如果无效则返回false。\r\n4. 循环完成之后，判断栈中是否还有元素，如果没有则返回true,反之返回false。\r\n\r\n## AC代码\r\n```js\r\nvar isValid = function(s) {\r\n  // 本题使用栈的思想进行求解，思路较为简单\r\n  // 首先定义一个栈\r\n  let stack = [];\r\n  // 遍历s的每一个元素\r\n  for (let i = 0;i < s.length; i++) {\r\n    // 如果是左括号，则直接入栈\r\n    if (s[i] === '(' || s[i] === '{' || s[i] === '[') {\r\n      stack.push(s[i]);\r\n    } else {\r\n      // 能够走到这里说明不是左括号\r\n      // 如果遇到一个右括号并且此时栈为空，说明这个不是有效的括号，可以直接返回false \r\n      if (stack.length === 0) return false;\r\n      // 如果栈不为空\r\n      // 获取栈顶元素\r\n      let stackTop = stack[stack.length-1];\r\n      if ((stackTop === '(' && s[i] === ')') || (stackTop === '[' && s[i] === ']') || (stackTop === '{' && s[i] === '}')) {\r\n        stack.pop();\r\n      } else {\r\n        return false\r\n      }\r\n    }\r\n  }\r\n  // 遍历完成后，如果最后栈为空说明是有效的阔含，反之说明不是有效的括号\r\n  if (stack.length === 0) {\r\n    return true \r\n  } else {\r\n    return false\r\n  }\r\n};\r\n```\r\n\r\n## 题目反思\r\n* 学会使用栈来解决有效的括号这类问题。"
    },
    {
      "id": "/彻底搞懂自定义Hook函数和路由钩子函数",
      "metadata": {
        "permalink": "/blog/彻底搞懂自定义Hook函数和路由钩子函数",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/彻底搞懂自定义Hook函数和路由钩子函数.md",
        "source": "@site/blog\\彻底搞懂自定义Hook函数和路由钩子函数.md",
        "title": "彻底搞懂自定义Hook函数和路由钩子函数",
        "description": "什么是自定义Hook?",
        "date": "2021-10-14T00:00:00.000Z",
        "formattedDate": "2021年10月14日",
        "tags": [
          {
            "label": "Hooks",
            "permalink": "/blog/tags/hooks"
          }
        ],
        "readingTime": 2.82,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "彻底搞懂自定义Hook函数和路由钩子函数",
          "date": "2021-10-14T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Hooks",
          "tags": [
            "Hooks"
          ]
        },
        "prevItem": {
          "title": "LeetCode——有效的括号（借助栈）",
          "permalink": "/blog/LeetCode——有效的括号（借助栈）"
        },
        "nextItem": {
          "title": "LeetCode——最小路径和（动态规划）",
          "permalink": "/blog/LeetCode——最小路径和（动态规划）"
        }
      },
      "content": "## 什么是自定义Hook?\r\n* 自定义Hook是标准的封装和共享逻辑的方式。\r\n* 自定义Hook是一个函数，其名称以use开头。\r\n* 自定义Hook其实就是逻辑和内置的Hook的组合。\r\n\r\n>通俗的说，自定义Hook就是对组件间共用逻辑的封装，其名称以use开头。\r\n\r\n### 实例一：封装共有请求\r\n>假设我们在组件挂载完成之后，需要对远程服务器发送一个GET请求，获取到文章数据，然后显示在页面中，我们可以通过下面的写法来完成，将获取数据折翼共有操作进行封装。\r\n```js\r\nfunction useGetPost() {\r\n    const [post,setPost] = useState({});\r\n    useEffect(() => {\r\n        axios.get('https://jsonplaceholder.typicode.com/posts/1')\r\n            .then(res => setPost(res.data));\r\n    },[])\r\n    return [post,setPost];\r\n}\r\nfunction App() {\r\n\r\n    const [post] = useGetPost();\r\n    return (\r\n        <div>\r\n            <h1>{post.title}</h1>\r\n            <div>{post.body}</div>\r\n        </div>\r\n    )\r\n}\r\n```\r\n\r\n### 实例二：封装输入框的value和onChange属性\r\n>在Form表单中输入框的value和onChange属性是十分重要的，也是使用非常频繁的，如果针对每一个输入框都单独写onChange函数是非常臃肿的，通过自定义Hook进行封装则极大提高了便利性。\r\n\r\n```js\r\n// 定义自定义Hook：获取input的value和onChange\r\nfunction useUpdateInput(initialValue) {\r\n    const [value,setValue] = useState(initialValue);\r\n    return {\r\n        value,\r\n        onChange: e => setValue(e.target.value)\r\n    }\r\n}\r\n\r\nfunction App() {\r\n    const usernameInput = useUpdateInput('');\r\n    const passwordInput = useUpdateInput('')\r\n    const submitForm = (event) => {\r\n        event.preventDefault();\r\n        console.log(usernameInput.value);\r\n        console.log(passwordInput.value);\r\n    }\r\n    return (\r\n        <form onSubmit={submitForm}>\r\n            <input type=\"text\" name=\"username\" {...usernameInput}/>\r\n            <input type=\"password\" name=\"password\" {...passwordInput} />\r\n            <input type=\"submit\" />\r\n        </form>\r\n    )\r\n}\r\n```\r\n\r\n## 什么是路由钩子函数？\r\n>React路由钩子函数是react-router-dom这个库提供的，主要提供了以下四个钩子函数：\r\n\r\n* useHistory\r\n* useLocation\r\n* useRouteMatch\r\n* useParams\r\n\r\n>**注意：Link和Route必须在同一个路由器上，这个路由器可以是HashRouter也可以是BrowserRouter，Link to指示路由跳转到哪个组件，Route path 指示component**\r\n\r\n### 路由组件获取History、Location、Match与Params\r\n>这里要想获取到Params需要使用动态路由。\r\n\r\n* App组件\r\n```js\r\nfunction App() {\r\n    return (\r\n        <div>\r\n            <div>\r\n                <Link to='/home/xiaoming'>首页</Link>\r\n                <Link to='/list'>列表页</Link>\r\n            </div>\r\n            <div>\r\n                <Route path='/home/:name' component={Home}/>\r\n                <Route path='/list' component={List}/>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nReactDOM.render(<Router>\r\n    <App />\r\n</Router>, document.querySelector('#root'));\r\n```\r\n* Home组件（路由组件）\r\n```js\r\nimport {useHistory,useLocation,useRouteMatch,useParams} from 'react-router-dom'\r\nimport React from 'react';\r\n\r\nconst Home = (props) => {\r\n    console.log(useHistory());\r\n    console.log(useLocation());\r\n    console.log(useRouteMatch());\r\n    console.log(useParams());\r\n    return (\r\n        <div>\r\n            这是Home组件\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Home;\r\n```"
    },
    {
      "id": "/LeetCode——最小路径和（动态规划）",
      "metadata": {
        "permalink": "/blog/LeetCode——最小路径和（动态规划）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——最小路径和（动态规划）.md",
        "source": "@site/blog\\LeetCode——最小路径和（动态规划）.md",
        "title": "LeetCode——最小路径和（动态规划）",
        "description": "题目描述",
        "date": "2021-10-13T00:00:00.000Z",
        "formattedDate": "2021年10月13日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 2.39,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——最小路径和（动态规划）",
          "date": "2021-10-13T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "彻底搞懂自定义Hook函数和路由钩子函数",
          "permalink": "/blog/彻底搞懂自定义Hook函数和路由钩子函数"
        },
        "nextItem": {
          "title": "VsCode通过snippet generator快速生成自定义代码片段",
          "permalink": "/blog/VsCode通过snippet generator快速生成自定义代码片段"
        }
      },
      "content": "## 题目描述\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/994343286d7ef4f4e4cd00e81f0c0e58.png)\r\n\r\n## 解题思路\r\n>本题是动态规划的经典例题，是一道必须掌握的习题。\r\n\r\n1. 核心的DP方程\r\n$dp[i][j] = dp[i][j] + Math.min(dp[i-1][j],dp[i][j-1]) + dp[i][j]$\r\n\r\n2. 处理边界条件\r\n>题目中明确说了，移动的时候，只能向右或者向下移动，其他的移动方式是不被允许的，所以对第一行来说，元素只能从左往右移动，对第一列来说，元素只能从上往下移动。\r\n\r\n* 第一行的处理方法\r\n\r\n```js\r\nfor (let j = 1; j < grid[0].length; j++) {\r\n    grid[0][j] = grid[0][j] + grid[0][j - 1];\r\n}\r\n```\r\n\r\n* 第一列的处理方法\r\n\r\n```js\r\nfor (let i = 1; i < grid.length; i++) {\r\n    grid[i][0] = grid[i][0] + grid[i - 1][0];\r\n}\r\n```\r\n\r\n3. 处理一般情况\r\n>一般情况就是使用我们第一步的核心DP方程来进行求解。\r\n\r\n## AC代码\r\n```js\r\nvar minPathSum = function (grid) {\r\n  // 本题堪称是动态规划的经典例题，必须背会\r\n  // 本题最核心的动态方程为：dp[i][j] = Math.min(dp[i-1][j],dp[i][j-1]) + dp[i][j]\r\n  // 首先处理边界条件，题目明确指出每次移动只能向右或者向下移动，所以不能向左或者其他方向进行移动。\r\n  // 处理第一行的元素：第一行的元素没有上项，从第一行的第二个元素开始进行处理\r\n  for (let j = 1; j < grid[0].length; j++) {\r\n    grid[0][j] = grid[0][j] + grid[0][j - 1];\r\n  }\r\n  // 处理第一列的元素，道理和处理第一行的元素类似\r\n  for (let i = 1; i < grid.length; i++) {\r\n    grid[i][0] = grid[i][0] + grid[i - 1][0];\r\n  }\r\n  // 处理一般情况\r\n  for (let i = 1; i < grid.length; i++) {\r\n    for (let j = 1; j < grid[0].length; j++) {\r\n      grid[i][j] = Math.min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j];\r\n    }\r\n  }\r\n  return grid[grid.length - 1][grid[0].length - 1]\r\n};\r\n```\r\n\r\n## 题目反思\r\n* 学会使用动态规划来求解路径问题。\r\n* 在动态规划中处理好边界条件是很重要的。"
    },
    {
      "id": "/VsCode通过snippet generator快速生成自定义代码片段",
      "metadata": {
        "permalink": "/blog/VsCode通过snippet generator快速生成自定义代码片段",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/VsCode通过snippet generator快速生成自定义代码片段.md",
        "source": "@site/blog\\VsCode通过snippet generator快速生成自定义代码片段.md",
        "title": "VsCode通过snippet generator快速生成自定义代码片段",
        "description": "一、首先在snippet creator上生成代码片段模板",
        "date": "2021-10-12T00:00:00.000Z",
        "formattedDate": "2021年10月12日",
        "tags": [
          {
            "label": "VSCode",
            "permalink": "/blog/tags/vs-code"
          }
        ],
        "readingTime": 0.535,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "VsCode通过snippet generator快速生成自定义代码片段",
          "date": "2021-10-12T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "VSCode",
          "tags": [
            "VSCode"
          ]
        },
        "prevItem": {
          "title": "LeetCode——最小路径和（动态规划）",
          "permalink": "/blog/LeetCode——最小路径和（动态规划）"
        },
        "nextItem": {
          "title": "LeetCode——最大子序和（贪心算法）",
          "permalink": "/blog/LeetCode——最大子序和（贪心算法）"
        }
      },
      "content": "## 一、首先在snippet creator上生成代码片段模板\r\n>[在线snippet creator](https://snippet-generator.app/)\r\n\r\n1. 首先复制我们需要快速生成的代码模板。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/66d59867f751b8c8682c46ab8898910e.png)\r\n\r\n2. 复制到下面的区域中。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/41cb89727aef965d1ccda99709fb14e3.png)\r\n\r\n3. 输入触发片段的快捷代码\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/33a01dfce160e41db71dbe320cc43649.png)\r\n\r\n4. 将生成的代码复制到VsCode的用户代码片段中\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/6e594b14172781427a08014cf9405d83.png)\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/8c684034d71b7639fae0fa3e2efd4735.png)\r\n\r\n5. 注意选择文件后缀，如果想要选择html中使用，就选择html。"
    },
    {
      "id": "/LeetCode——最大子序和（贪心算法）",
      "metadata": {
        "permalink": "/blog/LeetCode——最大子序和（贪心算法）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——最大子序和（贪心算法）.md",
        "source": "@site/blog\\LeetCode——最大子序和（贪心算法）.md",
        "title": "LeetCode——最大子序和（贪心算法）",
        "description": "题目描述",
        "date": "2021-10-11T00:00:00.000Z",
        "formattedDate": "2021年10月11日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.175,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——最大子序和（贪心算法）",
          "date": "2021-10-11T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "VsCode通过snippet generator快速生成自定义代码片段",
          "permalink": "/blog/VsCode通过snippet generator快速生成自定义代码片段"
        },
        "nextItem": {
          "title": "LeetCode——最长回文子串（中心拓展法）",
          "permalink": "/blog/LeetCode——最长回文子串（中心拓展法）"
        }
      },
      "content": "## 题目描述\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/18bd13013327765e68ccf030ae6f9af3.png)\r\n\r\n## 解题思路\r\n>主要是判断窗口内的和是正数还是负数，遍历nums中的每一个元素，判断窗口内的和sum是正数还是负数，正数则加上当前的值，负数则将当前的值赋值给sum。每一轮循环都比较sum和全局max的值。\r\n\r\n## AC代码\r\n```js\r\nvar maxSubArray = function (nums) {\r\n    // 首先定义临时最大值\r\n    let max = nums[0];\r\n    // 定义 连续和\r\n    let sum = 0;\r\n    // 遍历每一个元素\r\n    for (let v of nums) {\r\n        // 如果sum是正数，则加当前元素，反之不加\r\n        if (sum > 0) {\r\n            sum = sum + v;\r\n        } else {\r\n            sum = v;\r\n        }\r\n        max = Math.max(sum,max);\r\n    }\r\n    return max\r\n};\r\n```\r\n\r\n## 题目反思\r\n* 此题使用贪心算法，解题代码看似很简单，但是思想确实很难理解的，所以需要我们多练，多思考，准确理解每一个变量的含义。"
    },
    {
      "id": "/LeetCode——最长回文子串（中心拓展法）",
      "metadata": {
        "permalink": "/blog/LeetCode——最长回文子串（中心拓展法）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——最长回文子串（中心拓展法）.md",
        "source": "@site/blog\\LeetCode——最长回文子串（中心拓展法）.md",
        "title": "LeetCode——最长回文子串（中心拓展法）",
        "description": "题目描述",
        "date": "2021-10-10T00:00:00.000Z",
        "formattedDate": "2021年10月10日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.46,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——最长回文子串（中心拓展法）",
          "date": "2021-10-10T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "LeetCode——最大子序和（贪心算法）",
          "permalink": "/blog/LeetCode——最大子序和（贪心算法）"
        },
        "nextItem": {
          "title": "LeetCode——最长公共前缀（数组API-every方法）",
          "permalink": "/blog/LeetCode——最长公共前缀（数组API-every方法）"
        }
      },
      "content": "## 题目描述\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/dec02e3ae24282d9d4945b6febefced1.png)\r\n\r\n## 解题思路\r\n1. 将字符串的长度分为奇数和偶数的情况。\r\n2. 奇数的情况，传入的是两个相同的下标，偶数的情况传入的是i和i+1。\r\n3. 如果m大于等于0，n小于len，并且这两个字符是相等的，则一个左移，一个右移。\r\n4. 移动完毕之后，判断是否更新最终的结果，只要比最终结果长，就更新最终结果。\r\n\r\n## AC代码\r\n```js\r\nvar longestPalindrome = function(s) {\r\n    // 获取字符串的长度\r\n    let len = s.length;\r\n    // 定义最终返回的结果\r\n    let result = '';\r\n\r\n    // 循环遍历每一个字符并更新最终的结果\r\n    for (let i = 0; i < len; i++) {\r\n        // 奇数的情况\r\n        getResult(i,i);\r\n        // 偶数的情况\r\n        getResult(i,i+1);\r\n    }\r\n    function getResult(m,n) {\r\n        while(m >= 0 && n < len && s[m] === s[n]) {\r\n            m--;\r\n            n++;\r\n        }\r\n        // 判断是否更新最终的结果，只要比最终结果长，就更新为最终结果\r\n        if (n - m -1 > result.length) {\r\n            result = s.slice(m+1,n);\r\n        }\r\n    }\r\n    return result;\r\n};\r\n```\r\n\r\n## 题目反思\r\n* 学会中心拓展法这个思路。\r\n* 熟练记忆slice这个API的用法。"
    },
    {
      "id": "/LeetCode——最长公共前缀（数组API-every方法）",
      "metadata": {
        "permalink": "/blog/LeetCode——最长公共前缀（数组API-every方法）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——最长公共前缀（数组API-every方法）.md",
        "source": "@site/blog\\LeetCode——最长公共前缀（数组API-every方法）.md",
        "title": "LeetCode——最长公共前缀（数组API-every方法）",
        "description": "题目描述",
        "date": "2021-10-09T00:00:00.000Z",
        "formattedDate": "2021年10月9日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.525,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——最长公共前缀（数组API-every方法）",
          "date": "2021-10-9",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "LeetCode——最长回文子串（中心拓展法）",
          "permalink": "/blog/LeetCode——最长回文子串（中心拓展法）"
        },
        "nextItem": {
          "title": "React使用TS模板脚手架报错：声明了“ React”，但从未读取其值",
          "permalink": "/blog/React使用TS模板脚手架报错：声明了“ React”，但从未读取其值"
        }
      },
      "content": "## 题目描述\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/01b46a4d66ca2f70b52bae1915b4ced7.png)\r\n\r\n## 解题思路\r\n1. 首先获取数组的第一个字符串，以这个字符串为标准进行后续的判断。\r\n2. 定义需要返回的最终字符串，初始值为空串。\r\n3. 使用循环比例第一个字符串，每次遍历的时候，都利用数组的every这个API，判断数组的每一个字符串的第i个字符，是否和子一个字符串的第i个字符一致，一致则返回true，并进行结果字符串的拼接，如果不是则直接返回result。\r\n4. 如果最终没有匹配到，则返回空串result。\r\n\r\n## AC代码\r\n```js\r\nvar longestCommonPrefix = function(strs) {\r\n    // 考虑使用every API 来和第一个字符串进行比较\r\n    let firstStr = strs[0];\r\n    let result = ''\r\n    for (let i = 0; i < firstStr.length; i++) {\r\n        let flag = strs.every(item => item[i] === firstStr[i]);\r\n\r\n        if (flag) {\r\n            result = result + firstStr[i]\r\n        } else {\r\n            return result;\r\n        }\r\n    }\r\n    return result\r\n};\r\n```\r\n\r\n## 题目反思\r\n* 学会利用数组的常用api,例如这个every。\r\n* 本题并不困难，即使是使用最常用的暴力双循环，也是可以做出来的，最重要的是能否快速简洁的做出来。"
    },
    {
      "id": "/React使用TS模板脚手架报错：声明了“ React”，但从未读取其值",
      "metadata": {
        "permalink": "/blog/React使用TS模板脚手架报错：声明了“ React”，但从未读取其值",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React使用TS模板脚手架报错：声明了“ React”，但从未读取其值.md",
        "source": "@site/blog\\React使用TS模板脚手架报错：声明了“ React”，但从未读取其值.md",
        "title": "React使用TS模板脚手架报错：声明了“ React”，但从未读取其值",
        "description": "报错提示",
        "date": "2021-10-08T00:00:00.000Z",
        "formattedDate": "2021年10月8日",
        "tags": [
          {
            "label": "debug",
            "permalink": "/blog/tags/debug"
          }
        ],
        "readingTime": 0.335,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "React使用TS模板脚手架报错：声明了“ React”，但从未读取其值",
          "date": "2021-10-8",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "debug",
          "tags": [
            "debug"
          ]
        },
        "prevItem": {
          "title": "LeetCode——最长公共前缀（数组API-every方法）",
          "permalink": "/blog/LeetCode——最长公共前缀（数组API-every方法）"
        },
        "nextItem": {
          "title": "LeetCode——全排列（DFS）",
          "permalink": "/blog/LeetCode——全排列（DFS）"
        }
      },
      "content": "## 报错提示\r\n>声明了“ React”，但从未读取其值。\r\n\r\n## 错误原因\r\n>因为是使用的基于TS的react模板脚手架，因此在安装依赖的时候，必须安装带有@types/xxx的文件。\r\n\r\n## 解决办法\r\n```shell\r\nnpm install -D @types/react\r\n```"
    },
    {
      "id": "/LeetCode——全排列（DFS）",
      "metadata": {
        "permalink": "/blog/LeetCode——全排列（DFS）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——全排列（DFS）.md",
        "source": "@site/blog\\LeetCode——全排列（DFS）.md",
        "title": "LeetCode——全排列（DFS）",
        "description": "全排列是DFS的经典应用，无论是在平时的工作中还是在面试中，都是经常被问到的考点，接下来让我们一起来探究这个问题吧。",
        "date": "2021-10-07T00:00:00.000Z",
        "formattedDate": "2021年10月7日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.255,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——全排列（DFS）",
          "date": "2021-10-7",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "React使用TS模板脚手架报错：声明了“ React”，但从未读取其值",
          "permalink": "/blog/React使用TS模板脚手架报错：声明了“ React”，但从未读取其值"
        },
        "nextItem": {
          "title": "面试官让你使用CSS画一个圆，你会吗？",
          "permalink": "/blog/面试官让你使用CSS画一个圆，你会吗？"
        }
      },
      "content": ">全排列是DFS的经典应用，无论是在平时的工作中还是在面试中，都是经常被问到的考点，接下来让我们一起来探究这个问题吧。\r\n\r\n## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/adec1fb58b1dd57795bdcbb351eff742.png)\r\n\r\n## 解题思路\r\n>本题的核心解题思路就是使用DFS(深度优先遍历),遍历完一条路径然后再去遍历另一条路径，通过使用一个used对象来记录目标元素是否被遍历过，来实现DFS。\r\n\r\n```js\r\nvar permute = function(nums) {\r\n    const result = [];\r\n    const used = {};\r\n    \r\n    function dfs(paths) {\r\n        if (paths.length === nums.length) {\r\n            result.push(paths.slice());\r\n            return;\r\n        }\r\n        for (let i = 0; i < nums.length; i++) {\r\n            if (used[i]) {\r\n                continue;\r\n            }\r\n            paths.push(nums[i]);\r\n            paths\r\n            used[i] = true;\r\n            dfs(paths);\r\n            paths.pop();\r\n            used[i] = false;\r\n        }\r\n    }\r\n    \r\n    dfs([])\r\n    return result;\r\n};\r\n```\r\n\r\n## 题目反思\r\n* DFS实现的核心在于使用一个对象来记录目标元素是否遍历过。\r\n* dfs遍历完一条路径之后，需要将路径数组中去掉栈顶元素，然后将该元素置未遍历状态。"
    },
    {
      "id": "/面试官让你使用CSS画一个圆，你会吗？",
      "metadata": {
        "permalink": "/blog/面试官让你使用CSS画一个圆，你会吗？",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/面试官让你使用CSS画一个圆，你会吗？.md",
        "source": "@site/blog\\面试官让你使用CSS画一个圆，你会吗？.md",
        "title": "面试官让你使用CSS画一个圆，你会吗？",
        "description": "最近看到一道比较基础的前端面试题，和大家分享下。面试官问：请使用CSS绘制一个圆。",
        "date": "2021-10-07T00:00:00.000Z",
        "formattedDate": "2021年10月7日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 0.445,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "面试官让你使用CSS画一个圆，你会吗？",
          "date": "2021-10-7",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "LeetCode——全排列（DFS）",
          "permalink": "/blog/LeetCode——全排列（DFS）"
        },
        "nextItem": {
          "title": "一篇文章，彻底搞懂浏览器的缓存机制",
          "permalink": "/blog/一篇文章，彻底搞懂浏览器的缓存机制"
        }
      },
      "content": ">最近看到一道比较基础的前端面试题，和大家分享下。面试官问：请使用CSS绘制一个圆。\r\n\r\n## 方法：使用border-radius\r\n>我们只需要将border-radius设置为50%即可。\r\n\r\n### HTML部分\r\n```html\r\n<div class=\"circle\">\r\n</div>\r\n```\r\n\r\n### CSS部分\r\n```css\r\n .circle {\r\n\twidth: 80px;\r\n\theight: 80px;\r\n\tbackground-color: pink;\r\n\tmargin: 10px auto;\r\n\tborder-radius: 50%;\r\n }\r\n```\r\n\r\n### 实现效果\r\n![](https://img-blog.csdnimg.cn/img_convert/c67be70c08308c258dce8a347b2ab46e.png)"
    },
    {
      "id": "/一篇文章，彻底搞懂浏览器的缓存机制",
      "metadata": {
        "permalink": "/blog/一篇文章，彻底搞懂浏览器的缓存机制",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/一篇文章，彻底搞懂浏览器的缓存机制.md",
        "source": "@site/blog\\一篇文章，彻底搞懂浏览器的缓存机制.md",
        "title": "一篇文章，彻底搞懂浏览器的缓存机制",
        "description": "无论在工作中还是平时的学习面试过程中，HTTP缓存几乎都是我们绕不开的话题，面对这些常见的知识点，我们不应该选择逃避，而是勇于面对，去搞懂它们。",
        "date": "2021-10-06T00:00:00.000Z",
        "formattedDate": "2021年10月6日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 23.63,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "一篇文章，彻底搞懂浏览器的缓存机制",
          "date": "2021-10-6",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "面试官让你使用CSS画一个圆，你会吗？",
          "permalink": "/blog/面试官让你使用CSS画一个圆，你会吗？"
        },
        "nextItem": {
          "title": "一道考查面试者CSS功底的面试题—实现CSS九宫格",
          "permalink": "/blog/一道考查面试者CSS功底的面试题—实现CSS九宫格"
        }
      },
      "content": ">无论在工作中还是平时的学习面试过程中，HTTP缓存几乎都是我们绕不开的话题，面对这些常见的知识点，我们不应该选择逃避，而是勇于面对，去搞懂它们。\r\n\r\n## 为什么需要缓存？\r\n>在任何一个前端项目中，访问服务器获取数据都是很常见的事情，如果相同的数据被重复请求了不止一次，那么多余的请求必然会浪费网络带宽，以及延迟浏览器渲染所要处理的内容，从而影响用户的使用体验。如果用户使用的是按量计费的方式访问网络，多余的请求还会隐形的增加用户的网络流量资费。因此考虑使用缓存技术对已经获取的资源进行重用，是一种提升网站性能与用户体验的有效策略。\r\n\r\n## 缓存的原理\r\n>缓存的原理是在首次请求后保存一份请求资源的响应副本，当用户再次发起相同请求后，如果判断缓存命中则拦截请求，将之前存储的响应副本返回给用户，从而避免了重新向服务器发起资源请求。\r\n\r\n## HTTP缓存\r\n>HTTP缓存应该算是前端开发中最常接触的缓存之一，它又可以细分为强制缓存和协商缓存，二者最大的区别在于判断缓存命中时，浏览器是否需要向服务器端进行询问以协商缓存的相关信息，进而判断是否需要就响应内容进行重新请求，下面让我们来看看HTTP缓存的具体机制及缓存的决策策略。\r\n\r\n### 强制缓存\r\n>对于强制缓存而言，如果浏览器判断所请求的目标资源有效命中，则直接从强制缓存中返回请求响应，无须与服务器进行任何通信。\r\n\r\n>其中与强制缓存相关的两个字段是expires和cache-control，expires是在HTTP1.0协议中声明的用来控制缓存失效日期时间戳的字段，它由服务器端指定后通过响应头告知浏览器，浏览器在接收到带有该字段的响应体后进行缓存。\r\n\r\n>若之后浏览器再次发起相同的资源请求，便会对比expires与本地当前的时间戳，如果当前请求的本地时间戳小于expires的值，则说明浏览器缓存的响应还未过期，可以直接使用而无须向服务器端再次发起请求。只有当本地时间戳大于expires值，发生缓存过期时，才允许重新向服务器发起请求。\r\n\r\n>从上述强制缓存的是否过期的判断机制中不难看出，这个方式存在一个很大的漏洞，即对本地时间戳过分依赖，如果客户端本地的时间与服务器端的时间不同步，或者对客户端的时间进行主动修改，那么对于缓存过期的判断可能就无法和预期相符。\r\n\r\n>为了解决expires判断的局限性，从HTTP1.1协议开始新增了cache-control字段来对expires的功能进行拓展和完善。从上述代码中可见cache-control设置了maxage=31536000的属性值来控制响应资源的有效期，它是一个以秒为单位的时间长度，表示该资源在被请求到后的31536000秒内有效，如此便可避免服务器端和客户端时间戳不同步而造成的问题。\r\n\r\n>注意：如果Cache-Control的max-age和expires同时存在，则以max-age为准。\r\n\r\n### Cache-Control的其他参数\r\n* no-cache\r\n\r\n>设置no-cache并非不适用缓存，而是表示强制进行协商缓存，即对于每次发起的请求都不会再去判断强制缓存是否过期，而是直接与服务器写撒谎给你来验证缓存的有效性，若缓存未过期，则会使用本地缓存。\r\n\r\n* no-store\r\n\r\n>设置no-store则表示禁止使用任何缓存，客户端的每次请求都需要服务器端给予全新的响应。no-cache与no-store是两个互斥的属性值，不能同时设置。\r\n\r\n* public\r\n\r\n>若资源响应头中的cache-control字段设置了public属性值，则表示响应资源既可以被浏览器缓存，又可以被代理服务器缓存。\r\n\r\n* private \r\n\r\n>private则限制了响应资源只能被浏览器缓存，如果没有显示指定则默认值是private。\r\n\r\n* max-age\r\n\r\n>表示服务器端告知客户端浏览器响应资源的过期时长。\r\n\r\n* s-maxage\r\n\r\n>对于大型架构的项目通常会涉及使用各种代理服务器的情况，这就需要考虑缓存在代理服务器上的有效性问题，这边是s-maxage存在的意义，它表示缓存在代理服务器中的过期时长，且仅当设置了public属性值时才是有效的。\r\n\r\n>由此可见，cache-control能够作为expires的完全替代方案，并且拥有其所不具备的一些缓存控制特性，在项目实践中使用它就足够了，目前expires还存在的唯一理由就是向下兼容。\r\n\r\n\r\n\r\n### 协商缓存\r\n>顾名思义，协商缓存就是在使用本地缓存之前，需要向服务器发起一次GET请求，与之协商当前浏览器保存的本地缓存是否已经过期。通常是采用所请求资源的最近一次的修改时间戳来判断的。\r\n\r\n* 实例\r\n\r\n> 假设客户端需要向服务器请求一个manifest.js的JS文件，为了让该资源被再次请求时能够通过协商缓存的机制使用本地缓存，那么首次返回该图片资源的响应头中应包含一个名为last-modified的字段，该字段的属性值为该JS文件最近一次修改的时间戳。\r\n\r\n> 当我们刷新网页时，由于该JS文件使用的是协商缓存，客户端浏览器无法确定本地缓存是否过期，所以需要向服务器发送一次GET请求，进行缓存有效性的协商，此次GET请求的请求头中需要包含一个ifmodified-since字段，其值正是上次响应头中last-modified的字段值。\r\n\r\n> 当服务器收到该请求后便会对比请求资源当前的修改时间戳与if-modified-since字段的值，如果二者相同则说明缓存未过期，可继续使用本地缓存，否则服务器重新返回全新的文件资源。\r\n\r\n#### 基于Last-Modified的协商缓存（服务器端代码）\r\n```js\r\n const data = fs.readFileSync('./imgs/CSS.png');\r\n const { mtime } = fs.statSync('./imgs/CSS.png');\r\n const ifModifiedSince = req.headers['if-modified-since'];\r\n if (ifModifiedSince === mtime.toUTCString()) {\r\n \tres.statusCode = 304;\r\n \tres.end();\r\n \treturn\r\n }\r\n res.setHeader('last-modified',mtime.toUTCString())\r\n res.setHeader('Cache-Control','no-cache');\r\n res.end(data);\r\n ```\r\n \r\n #### Last-Modified协商缓存流程\r\n >客户端第一次请求目标资源的时，服务器返回的响应标头包含last-modified和该资源的最后一次修改的时间戳，以及cache-control：no-cache，当客户端再次请求该资源的时候，会携带一个ifmodifiedsince字段，如果这个字段对应的时间与目标资源的时间戳进行对比，如果没有变化则返回一个304状态码。\r\n\r\n>需要注意的是：协商缓存判断缓存有效的响应状态码是304，但是如果是强制缓存判断有效的话，响应状态码是200。\r\n\r\n\r\n#### last-modified的不足\r\n1. last-modified是根据请求资源的最后修改时间戳进行判断的，虽然请求的文件资源进行了编辑，但是内容并没有发生任何变化，时间戳也会更新，从而导致协商缓存时关于有效性的判断验证为失效，需要重新进行完整的资源请求。这无疑会造成网络带宽资源的浪费，以及延长用户获取到目标资源的时间。\r\n2. 标识文件资源修改的时间戳单位是秒，如果文件修改的速度非常快，假设在几百毫秒内完成，那么通过时间戳的方式来验证缓存的有效性，是无法识别出该次文件资源的更新的。\r\n\r\n> 其实造成上述两种缺陷的原因相同，就是服务器无法根据资源修改的时间戳识别出真正的更新，进而导致重新发起了请求，该重新请求却使用了缓存的Bug场景。\r\n\r\n#### 基于Etag的协商缓存（服务端代码）\r\n![](https://img-blog.csdnimg.cn/img_convert/03ccddbca7c68a55afdae8519ddd665d.png)\r\n\r\n>为了弥补通过时间戳判断的不足，从HTTP1.1规范开始新增了一个Etag的头信息，即实体标签。\r\n>其内容主要是服务器为不同的资源进行哈希计算所生成的一个字符串，该字符串类似于文件指纹，只要文件内容编码存在差异，对应的Etag对文件资源进行更精准的变化感知。\r\n\r\n#### Etag协商缓存的流程\r\n\r\n1. 首先，服务端将要返回给客户端的数据通过etag模块进行哈希计算生成一个字符串，这个字符串类似于文件指纹。\r\n2. 检测客户端的请求标头中的ifNoneMatch字段的值和第一步计算的值是否一致，一致则返回304。\r\n3. 如果不一致则返回etag标头和Cache-Control：no-cache。\r\n\r\n#### Etag的不足\r\n\r\n>不像强制缓存中cache-control可以完全替代expires的功能，在协商缓存中，Etag并非last-modified的替代方案而是一种补充方案，因为依旧存在一些弊端。\r\n\r\n1. 服务器对于生成文件资源的Etag需要付出额外的计算开销，如果资源的尺寸比较大，数量较多且修改频繁，那么生成的Etag的过程就会影响服务器的性能。\r\n2. Etag字段值的生成分为强验证和弱验证，强验证根据资源内容进行生成，能够保证每个字节都相同，弱验证则根据资源的部分属性来生成，生成速度快但无法确保每个字节都相同，并且在服务器集群场景下，也会因为准确不够而降低协商缓存有效性的成功率，所以恰当的方式是根据具体的资源使用场景选择恰当的缓存校验方式。\r\n\r\n\r\n## 缓存决策及其注意事项\r\n### 缓存决策\r\n>假设在不考虑客户端缓存容量与服务器算力的理想情况下，我们当然希望客户端浏览器上的缓存触发率尽可能高，留存时间尽可能长，同时还要Etag实现当资源更新时进行高效的重新验证。但实际情况往往是容量与算力都有限，因此就需要制定合适的缓存策略，来利用有限的资源达到最优的性能效果，明确能力的边界，力求在边界内做到最好。\r\n\r\n### 缓存决策树\r\n>在面对一个具体的缓存需求时，我们可以参照如下的缓存决策树来逐步确定对一个资源具体的缓存策略。\r\n\r\n* 是否使用缓存\r\n\t* 否：no-store\r\n\t* 是：\r\n\t\t* 是否进行协商缓存\r\n\t\t\t* 是：no-cache\r\n\t\t\t* 否\r\n\t\t\t\t* 是否会被代理服务器缓存\r\n\t\t\t\t\t* 是：public\r\n\t\t\t\t\t* 否：private\r\n\t\t\t\t\t\t* 配置强制缓存过期时间\r\n\t\t\t\t\t\t\t* 配置协商缓存的Etag或last-modified。\r\n\r\n## CDN缓存\r\n\r\n### 什么是CDN？\r\n>CDN全称是内容分发网络，它是构建在现有网络基础上的虚拟智能网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、调度及内容分发等功能模块，使用户在请求所需访问的内容时能够就近获取，以此来降低网络拥塞，提高资源对用户的响应速度。\r\n\r\n### 不使用CDN的通信流程\r\n1. 向传统的DNS服务器请求域名解析。\r\n2. DNS服务器返回域名对应的服务器IP。\r\n3. 根据服务器IP请求服务器内容。\r\n4. 服务器返回响应资源。\r\n\r\n### 使用CDN的通信流程\r\n1. 客户端向传统的DNS服务器请求域名解析。\r\n2. 传统的DNS服务器将域名解析权交给了CNAME指向的专用DNS服务器，所以对用户输入域名的解析最终是在CDN专用的DNS服务器上完成的。\r\n3. CDN专用的DNS服务器将CDN负载均衡器的IP发给客户端。\r\n4. 浏览器会重新向CDN负载均衡器发起请求，经过对用户IP地址的距离、所请求资源内容的位置等的综合计算，返回给用户确定的缓存服务器IP地址。\r\n5. 浏览器最后对缓存服务器进行请求资源。\r\n\r\n### 静态资源适合使用CDN\r\n>静态资源指的是不需要网站业务服务器参与计算即可得到的资源，包括第三方库的JavaScript脚本文件、样式表文件以及图片等，这些文件的特点是访问频率高、承载流量大、但更新频次低，且不与业务有太多耦合。\r\n\r\n>如果是动态资源文件，比如依赖服务器端渲染得到的HTML页面，它需要借助服务器端的数据进行计算才能得到，所以这样的资源不适合存放在CDN缓存服务器上。\r\n\r\n### CDN的性能优化\r\n>下面仅介绍一个CDN优化点：域名设置。\r\n\r\n>在淘宝的主页上，主站请求的域名为 www.taobao.com ，而静态资源请求CDN服务器的域名有g.alicdn.com和img.alicdn.com两种，这样做的原因有以下两点：\r\n\r\n1. 避免对静态资源的请求携带不必要的cookie信息。\r\n2. 考虑浏览器对同一域名下并发请求的限制。\r\n\r\n\r\n\r\n\r\n## 面试常见问题\r\n\r\n### 问题1：强缓存涉及到哪些请求头？\r\n>答：涉及到expires和cache-control两个字段，expires是HTTP1.0协议中的，cache-control是HTTP/1.1协议的。\r\n\r\n### 问题2：为什么现在不用expries用cache control？\r\n>答：因为基于expires的强制缓存对本地时间戳过于依赖，如果客户端本地的时间与服务器端的时间不同步，那么对缓存过期的判断可能就会出错。cache-control通过maxage=xxx秒的形式来控制响应资源的有效期，如此可以避免服务器端和客户端时间戳不同步的问题。\r\n\r\n### 问题3：强缓存public private no-store no-catch区别？（Cache-Control有哪些属性?分别表示什么意思？）\r\n>public：表示响应资源既可以被客户端缓存也可以被代理服务器缓存。\r\n>private：表示响应资源只能被浏览器缓存，如果没有显式指定则默认是private\r\n>no-store：表示禁止使用任何缓存，每次请求都需要服务器给与全新的响应。\r\n>no-cache：表示使用协商缓存。每次请求不再去判断强制缓存是否过期，而是直接向服务器发送请求来验证缓存的有效性。\r\n>max-age：表示服务器端告知客户端浏览器响应资源的过期时长。\r\n>s-maxage：表示缓存在代理服务器中的过期时长，且仅当设置了public属性值时才是有效的。\r\n\r\n### 问题4：协商缓存的校验是在客户端还是服务器端？协商缓存怎么验证是否命中？\r\n>答：服务器端，服务器端会对比文件最后的修改时间和客户端请求携带的时间是否一致，一致则判断命中缓存。协商缓存存在两种形式，一种是基于last-modified，客户端第一次请求目标资源的时候，服务器返回的响应标头中包含last-modified和该资源的最后一次修改的时间戳，以及cache-control：no-cache，当客户端再次请求该资源的时候，会携带一个ifmodifiedsince字段，如果这个字段对应的时间和目标资源的时间戳进行对比，没有变化则返回304状态码。另一种是基于Etag的协商缓存，手下服务端将要返回给客户端的数据通过etag模块进行哈希计算生成一个字符串，这个字符串类似于文件指纹，检测客户端的请求标头中的ifNoneMatch字段的值和第一步计算的值是否一致，一致则返回304，不一致则返回最新的数据以及etag标头和Cache-Control：no-cache。\r\n\r\n### 问题5：协商缓存出于什么原因有Last-Modified,Etag?\r\n>答：之所以有last-modified还有etag，是因为这二者均有自己的不足，last-modified是根据请求资源的最后修改时间戳来进行判断的，有可能只是对文件名进行了编辑，但是文件内容并未修改，这样时间戳也会更新，从而导致协商缓存判断失效，请求了已经存在的完整资源，这对网络带宽是一种浪费，也有可能是文件修改的速度是毫秒级别的，但是last-modified的单位是秒，可能无法识别出资源的修改。etag并非last-modified的完全替代方案，只能是一种补充方案，etag存在的问题是，服务器需要对文件资源进行etag计算，需要付出额外的计算开销，如果资源的尺寸比较大，生成Etag的过程可能会影响服务器的性能，所以这也就是为什么协商缓存既有last-modified又有etag的原因了。\r\n\r\n### 问题6：协商缓存和强缓存的区别？\r\n#### 相同点\r\n>都是从客户端缓存中读取资源。\r\n\r\n#### 不同点\r\n1. 如果浏览器命中的是强缓存，则不需要给服务器发请求，而协商缓存最终由服务器来决定是否使用缓存，即客户端与服务器之间存在一次通信。\r\n2. 在chrome中命中缓存，返回的状态码是200，而如果是协商缓存，返回的是状态码304。\r\n\r\n\r\n### 问题7：expires 和 cache-control 哪个优先级高? 不缓存怎么设置？\r\n>答：expires是HTTP/1.0的产物，Cache-Control则是HTTP/1.1的产物，二者如果同时存在的话，Cache-Control优先级比Expires高。不缓存则是通过Cache-Control：no-store设置。\r\n\r\n### 问题8：LastModified 对应有个请求头是什么？\r\n>last-modified-since.\r\n\r\n### 问题9：缓存的优先级顺序？\r\n>答：Cache-Control > Expires > Etag > Last-Modified。"
    },
    {
      "id": "/一道考查面试者CSS功底的面试题—实现CSS九宫格",
      "metadata": {
        "permalink": "/blog/一道考查面试者CSS功底的面试题—实现CSS九宫格",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/一道考查面试者CSS功底的面试题—实现CSS九宫格.md",
        "source": "@site/blog\\一道考查面试者CSS功底的面试题—实现CSS九宫格.md",
        "title": "一道考查面试者CSS功底的面试题—实现CSS九宫格",
        "description": "通过CSS实现九宫格可以很好的考查候选人的CSS基本功，所以在当今的前端面试中，无论是大厂还是小厂，这个面试题经常出现在候选人面前，这道题目看似简单，但是最终能够做出来的人也是凤毛麟角，让我们来一探究竟吧。",
        "date": "2021-10-05T00:00:00.000Z",
        "formattedDate": "2021年10月5日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 1.54,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "一道考查面试者CSS功底的面试题—实现CSS九宫格",
          "date": "2021-10-5",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "一篇文章，彻底搞懂浏览器的缓存机制",
          "permalink": "/blog/一篇文章，彻底搞懂浏览器的缓存机制"
        },
        "nextItem": {
          "title": "LeetCode——爬楼梯（动态规划）",
          "permalink": "/blog/LeetCode——爬楼梯（动态规划）"
        }
      },
      "content": ">通过CSS实现九宫格可以很好的考查候选人的CSS基本功，所以在当今的前端面试中，无论是大厂还是小厂，这个面试题经常出现在候选人面前，这道题目看似简单，但是最终能够做出来的人也是凤毛麟角，让我们来一探究竟吧。\r\n\r\n## 方法一：使用table\r\n>table布局能够实现的原因在于table的tr和td能够将元素形成行列显示。table布局中有一个是否合并边框的样式border-collapse: collapse;值得我们注意。\r\n\r\n### HTML部分\r\n```html\r\n<table>\r\n    <tr>\r\n        <td>1</td>\r\n        <td>2</td>\r\n        <td>3</td>\r\n    </tr>\r\n    <tr>\r\n        <td>4</td>\r\n        <td>5</td>\r\n        <td>6</td>\r\n    </tr>\r\n    <tr>\r\n        <td>7</td>\r\n        <td>8</td>\r\n        <td>9</td>\r\n    </tr>\r\n</table>\r\n```\r\n### CSS部分\r\n```css\r\n* {\r\n    margin: 0;\r\n    padding: 0;\r\n}\r\ntable {\r\n    border-collapse: collapse;\r\n    margin: 0 auto;\r\n}\r\ntable td {\r\n    width: 60px;\r\n    height: 60px;\r\n    background-color: blue;\r\n    border: 1px solid #000;\r\n    text-align: center;\r\n    line-height: 60px;;\r\n}\r\n```\r\n\r\n## 方法二：使用flex布局\r\n>使用flex布局的核心在于flex-wrap: wrap。\r\n\r\n### HTML部分\r\n```html\r\n<ul>\r\n    <li>1</li>\r\n    <li>2</li>\r\n    <li>3</li>\r\n    <li>4</li>\r\n    <li>5</li>\r\n    <li>6</li>\r\n    <li>7</li>\r\n    <li>8</li>\r\n    <li>9</li>\r\n</ul>\r\n```\r\n\r\n### CSS部分\r\n```css\r\n* {\r\n    margin: 0;\r\n    padding: 0;\r\n    box-sizing: border-box;\r\n}\r\nli {\r\n    list-style: none;\r\n}\r\nul {\r\n    display: flex;\r\n    flex-wrap: wrap;\r\n    width: 180px;\r\n    height: 180px;\r\n}\r\nul > li {\r\n    background-color: blue;\r\n    width: calc(100% / 3);\r\n    height: 60px;\r\n    line-height: 60px;\r\n    border: 1px solid #000;\r\n    text-align: center;\r\n}\r\n```\r\n\r\n## 实现效果\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/136dde832b618a8935fdb21b35f3b727.png)"
    },
    {
      "id": "/LeetCode——爬楼梯（动态规划）",
      "metadata": {
        "permalink": "/blog/LeetCode——爬楼梯（动态规划）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——爬楼梯（动态规划）.md",
        "source": "@site/blog\\LeetCode——爬楼梯（动态规划）.md",
        "title": "LeetCode——爬楼梯（动态规划）",
        "description": "这道题目和剑指offer中的青蛙跳台阶是一个问题。",
        "date": "2021-10-04T00:00:00.000Z",
        "formattedDate": "2021年10月4日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.955,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——爬楼梯（动态规划）",
          "date": "2021-10-4",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "一道考查面试者CSS功底的面试题—实现CSS九宫格",
          "permalink": "/blog/一道考查面试者CSS功底的面试题—实现CSS九宫格"
        },
        "nextItem": {
          "title": "压缩HTTP请求和响应数据的方法",
          "permalink": "/blog/压缩HTTP请求和响应数据的方法"
        }
      },
      "content": ">这道题目和剑指offer中的青蛙跳台阶是一个问题。\r\n\r\n## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/e2f3505bfbef61565f1a82974d5aca71.png)\r\n\r\n## 解题思路：动态规划\r\n>动态规划的核心思路在于：要想爬到第i个台阶就必须爬到第i-1个台阶和第i-2个台阶，所有的可能性就是这两种情况的和。\r\n\r\n```js\r\nvar climbStairs = function (n) {\r\n    let dp = [];\r\n    dp[0] = 0;\r\n    dp[1] = 1;\r\n    dp[2] = 2;\r\n    for (let i = 3; i <= n; i++) {\r\n        dp[i] = dp[i - 1] + dp[i - 2];\r\n    }\r\n    return dp[n]\r\n};\r\n```\r\n\r\n## 题目反思\r\n>本题如果直接采用递归的方法，肯定是要超时的，动态规划是解决这类问题的好方法。\r\n>动态规划的关键在于准确的列出动态规划的方程。"
    },
    {
      "id": "/压缩HTTP请求和响应数据的方法",
      "metadata": {
        "permalink": "/blog/压缩HTTP请求和响应数据的方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/压缩HTTP请求和响应数据的方法.md",
        "source": "@site/blog\\压缩HTTP请求和响应数据的方法.md",
        "title": "压缩HTTP请求和响应数据的方法",
        "description": "在客户端和浏览器进行信息交互的时候，如果直接传输文件，可能会消耗太多的流量，通过压缩技术可以为我们节省很多流量，下面来介绍下HTTP响应数据是如何进行压缩的。",
        "date": "2021-10-03T00:00:00.000Z",
        "formattedDate": "2021年10月3日",
        "tags": [
          {
            "label": "HTTP",
            "permalink": "/blog/tags/http"
          }
        ],
        "readingTime": 3.165,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "压缩HTTP请求和响应数据的方法",
          "date": "2021-10-3",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "HTTP",
          "tags": [
            "HTTP"
          ]
        },
        "prevItem": {
          "title": "LeetCode——爬楼梯（动态规划）",
          "permalink": "/blog/LeetCode——爬楼梯（动态规划）"
        },
        "nextItem": {
          "title": "LeetCode——买卖股票的最佳时机（动态规划+更新极值）",
          "permalink": "/blog/LeetCode——买卖股票的最佳时机（动态规划+更新极值）"
        }
      },
      "content": ">在客户端和浏览器进行信息交互的时候，如果直接传输文件，可能会消耗太多的流量，通过压缩技术可以为我们节省很多流量，下面来介绍下HTTP响应数据是如何进行压缩的。\r\n\r\n## HTTP响应数据压缩\r\n### 使用Gzip压缩文本\r\n\r\n>浏览器和服务器之间会使用主动协商机制，浏览器向服务器发送请求的时候，其请求标头中会含有Accept-Encoding字段，其中包含了客户端支持的压缩算法，以及各自的优先级，服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送Content-Encoding首部来告知浏览器它选择了哪一种压缩算法。\r\n\r\n* 客户端请求标头实例\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/170f3bab09835a36465cccc4a2089783.png)\r\n\r\n* 服务器端响应标头实例\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/8a8f9edf06e23314e9486b64dd89d342.png)\r\n\r\n## HTTP请求数据的压缩\r\n\r\n### 头部数据压缩\r\n>HTTP协议是不支持头信息压缩的，但是HTTP2引入了头信息压缩机制，一方面，头信息可以使用gzip或compress压缩后再发送，另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号。\r\n\r\n### 请求体数据压缩\r\n>上文中，我们提到了HTTP协议中的Accept-Encoding/Content-Encoding机制，这套机制可以很好地用于文本类响应正文地压缩，可以大幅度地减少网络传输，从而一直被广泛使用，但HTTP请求地发起方，无法事先知晓要访问地服务端是否支持解压，所以现阶段地浏览器没有压缩请求正文。\r\n\r\n>有一些通讯协议基于HTTP做了拓展，他们地客户端和服务端是专用地，可以放心大胆地压缩请求正文，例如WebDAV客户端就是这样地。\r\n\r\n>实际地Web项目中，会存在请求正文非常大的场景，例如发表长篇博客，上报用于调试的网络数据等待，这些数据如果能在本地压缩后再提交，就可以节省网络流量、减少传输时间。下面将介绍如何对HTTP请求正文进行压缩，包含如何再服务端解压、如何在客户端压缩两部分。\r\n\r\n>下面是三种常见的文本压缩方式\r\n\r\n1. DEFLATE\r\n2. ZLIB\r\n3. GZIP"
    },
    {
      "id": "/LeetCode——买卖股票的最佳时机（动态规划+更新极值）",
      "metadata": {
        "permalink": "/blog/LeetCode——买卖股票的最佳时机（动态规划+更新极值）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——买卖股票的最佳时机（动态规划+更新极值）.md",
        "source": "@site/blog\\LeetCode——买卖股票的最佳时机（动态规划+更新极值）.md",
        "title": "LeetCode——买卖股票的最佳时机（动态规划+更新极值）",
        "description": "题目描述",
        "date": "2021-10-02T00:00:00.000Z",
        "formattedDate": "2021年10月2日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 3.065,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——买卖股票的最佳时机（动态规划+更新极值）",
          "date": "2021-10-2",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "压缩HTTP请求和响应数据的方法",
          "permalink": "/blog/压缩HTTP请求和响应数据的方法"
        },
        "nextItem": {
          "title": "这一次，彻底搞懂React的diff算法",
          "permalink": "/blog/这一次，彻底搞懂React的diff算法"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/6d8fd51e0a18bc7b9327f6850374e5f9.png)\r\n\r\n## 思路一：更新最大值和最小值\r\n* 首先，假设第一个元素是价格最小的值minPrice。\r\n* 定义一个价格最大差maxPriceDiff，并设置值为0。\r\n* 从数组的第二个元素开始更新价格最大差和最小值。\r\n* 最小值是在第i个元素和前面的最小值minPrice之间进行比较。\r\n* 最大价格差则是在前面的最大价格差和（第i天的股票价值-前面的最小值)之间进行比较。\r\n* 最后返回最大价格差。\r\n\r\n### AC代码\r\n```js\r\nvar maxProfit = function (prices) {\r\n    // 通过不断更新最大值和最小值的方法来求解\r\n    let maxPriceDiff = 0;\r\n    let minPrice = prices[0];\r\n    for (let i = 1; i < prices.length; i++) {\r\n        minPrice = Math.min(prices[i], minPrice);\r\n        let tempMax = Math.max(prices[i] - minPrice);\r\n        maxPriceDiff = Math.max(maxPriceDiff, tempMax);\r\n    }\r\n    return maxPriceDiff;\r\n};\r\n```\r\n\r\n## 思路二：动态规划\r\n>详细的思路请看代码中的注释。\r\n>需要我们注意的是：本题中只能进行一次交易，例如如果你今天买入那么你手上的现金就是-prices[i]。\r\n\r\n### dp数组以及下标的含义\r\n* dp[i][0]：表示第i天，手里不持有股票的现金数\r\n* dp[i][1]：表示第i天，手里持有股票的现金数\r\n\r\n### AC代码\r\n\r\n```js\r\nvar maxProfit = function (prices) {\r\n    // 通过动态规划的方法\r\n    const dp = new Array(prices.length).fill([0, 0]);\r\n    // 设置动态规划的初始值\r\n    // 第0天不持股的情况下，手上的现金数\r\n    dp[0][0] = 0;\r\n    // 第1天持股的情况下，手上的现金数是当日价格的负数\r\n    dp[0][1] = -prices[0];\r\n    // 从第二天开始进行遍历\r\n    for (let i = 1; i < prices.length; i++) {\r\n        // 第i天手上不持股的情况：前一天不持股，或者前一天持股但是今天卖掉了\r\n        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);\r\n        // 第i天手上持股的情况：前一天不持股，今天买入，或者前一天持股今天没卖\r\n        dp[i][1] = Math.max(- prices[i], dp[i - 1][1]);\r\n    }\r\n    // 最终返回的就是最后一天不持股手上的最大现金数\r\n    return dp[prices.length - 1][0]\r\n};\r\n```\r\n\r\n## 题目反思\r\n* 学会使用动态规划来求解买卖股票的问题\r\n* 学会通过不断更新最大值和最小值的方法来求解这个问题。\r\n* 动态规划最重要的是理解dp数组及其下标的含义并准确列出动态规划的方程。"
    },
    {
      "id": "/这一次，彻底搞懂React的diff算法",
      "metadata": {
        "permalink": "/blog/这一次，彻底搞懂React的diff算法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/这一次，彻底搞懂React的diff算法.md",
        "source": "@site/blog\\这一次，彻底搞懂React的diff算法.md",
        "title": "这一次，彻底搞懂React的diff算法",
        "description": "在前端面试中，只要涉及到React框架，diff算法便是我们绕不开的话题，这次让我们来系统性的梳理diff算法，不再被这个知识点所困扰。",
        "date": "2021-10-01T00:00:00.000Z",
        "formattedDate": "2021年10月1日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 4.085,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "这一次，彻底搞懂React的diff算法",
          "date": "2021-10-1",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "LeetCode——买卖股票的最佳时机（动态规划+更新极值）",
          "permalink": "/blog/LeetCode——买卖股票的最佳时机（动态规划+更新极值）"
        },
        "nextItem": {
          "title": "这一次，彻底搞定伪类和伪元素的区别",
          "permalink": "/blog/这一次，彻底搞定伪类和伪元素的区别"
        }
      },
      "content": "> 在前端面试中，只要涉及到React框架，diff算法便是我们绕不开的话题，这次让我们来系统性的梳理diff算法，不再被这个知识点所困扰。\r\n\r\n## 什么是diff算法？\r\n\r\n> 在了解diff算法之前，我们要直到diff算法并非React独家首创，但是React针对diff算法做了自己的优化，使得diff算法可以帮助我们计算出Virtual Dom中真正变化的部分，并只针对该部分进行实际的DOM操作，而非渲染整个页面，从而保证了每次操作后页面的高效渲染。\r\n\r\n## 传统diff算法\r\n\r\n> 要想了解React的diff算法，我们首先要知道传统的diff算法是如何设计并实现的。\r\n\r\n### 传统diff算法的时间复杂度\r\n\r\n> 传统diff算法的时间复杂度是O(N^3),其中N是树中节点的总数，这样的时间复杂度意味着如果要展示1000个节点，就要执行多达十亿次的比较，这种指数型的性能消耗对于前段渲染场景来说代价太高了。\r\n\r\n> React只有将diff算法进行改进，才有可能满足前端渲染所要求的的性能。\r\n\r\n> 之所以传统diff算法的时间复杂度是O(N^3)是因为两个二叉树的每一个节点进行两两对比的时间复杂度是O(N^2)，此时如果继续进行树的编辑操作（修改、删除）等还需要O(N)的时间复杂度，所以总的时间复杂度是O（N^3）。\r\n\r\n## React优化后的diff算法\r\n\r\n> React通过自己的优化，将O（N^3）的时间复杂度降到了O（N）。\r\n\r\n### React diff的三个前提策略\r\n\r\n1.  Web UI中DOM节点跨层级的移动操作特别少，可以忽略不计。\r\n\r\n2.  拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。\r\n\r\n3.  对于同一层级的一组子节点，它们可以通过唯一id进行区分。\r\n\r\n> React进行tree diff、component diff和element diff进行算法优化是基于上面三个前提策略。事实证明上面的三个前提策略是非常有效的。\r\n\r\n### 核心策略1：tree diff（树策略）\r\n\r\n> 对树进行分层比较，两棵树只会对同一层次的节点进行比较。\r\n\r\n### 核心策略2：component diff（组件策略）\r\n\r\n> React是基于组件构建应用的，对于组件间的比较采用下面的方式：\r\n\r\n*   如果是同一类型的组件，按照原策略继续比较虚拟DOM树，对于同一类型的组件，有可能其虚拟DOM树并没有任何变化，如果能够在比较之前准确的知道这一点，可以节省大量的运算时间，所以React向用户提供了shouldComponentUpdate()来判断该组件是否需要进行diff。\r\n\r\n*   如果不是同一类型的组件，则将该组件判断为dirty component，从而替换掉整个组件下面的所有子节点。\r\n\r\n### 核心策略3：element diff（元素策略）\r\n\r\n> 对于同一层级的一组子节点，通过唯一id进行区分。"
    },
    {
      "id": "/这一次，彻底搞定伪类和伪元素的区别",
      "metadata": {
        "permalink": "/blog/这一次，彻底搞定伪类和伪元素的区别",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/这一次，彻底搞定伪类和伪元素的区别.md",
        "source": "@site/blog\\这一次，彻底搞定伪类和伪元素的区别.md",
        "title": "这一次，彻底搞定伪类和伪元素的区别",
        "description": "很多人经常对CSS中的伪类和伪元素分不清楚，或者将这两者混为一谈，今天让我们来了解下这两者都有哪些区别。在CSS3之前是没有伪元素与伪类的区别的，直到CSS3才将这二者区分开来。",
        "date": "2021-09-30T00:00:00.000Z",
        "formattedDate": "2021年9月30日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 2.765,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "这一次，彻底搞定伪类和伪元素的区别",
          "date": "2021-9-30",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "这一次，彻底搞懂React的diff算法",
          "permalink": "/blog/这一次，彻底搞懂React的diff算法"
        },
        "nextItem": {
          "title": "一道考频较高的面试题：数组和链表的区别",
          "permalink": "/blog/一道考频较高的面试题：数组和链表的区别"
        }
      },
      "content": ">很多人经常对CSS中的伪类和伪元素分不清楚，或者将这两者混为一谈，今天让我们来了解下这两者都有哪些区别。在CSS3之前是没有伪元素与伪类的区别的，直到CSS3才将这二者区分开来。\r\n\r\n## 为什么要引入伪类和伪元素？\r\n>CSS之所以要引入伪类和伪元素是为了格式化文档树之外的信息，也就是说，伪类和伪元素是用来修饰不在文档树的部分，比如第一句话中的第一个字母或列表中的第一个元素。\r\n\r\n## 什么是伪类？\r\n> 伪类表示的是被选择元素的某种状态,例如hover。\r\n\r\n## 伪类的分类\r\n\r\n### 状态性伪类\r\n>状态性伪类是根据元素当前的状态进行选择的，当元素进入某种状态时呈现一种样式，进入另一种状态时呈现另一种样式。\r\n\r\n>典型的状态性伪类有：\r\n\r\n* :link 应用与未被访问过的链接。\r\n* :hover 应用于鼠标悬停到的元素。\r\n* :active 应用于被激活的元素。\r\n* :visited 应用于被访问过的链接，与:link互斥。\r\n* :focus 应用于拥有键盘输入焦点的元素。\r\n\r\n### 结构性伪类\r\n>CSS3新增选择器，利用DOM树进行元素过滤，通过文档结构的互相关系来匹配元素，能够减少class和id属性的定义，使得文档结构更加简洁。\r\n\r\n>典型的结构性伪类有下面的例子：\r\n\r\n* div:first-child 选择属于其父元素的第一个子元素的每个div元素。\r\n* div:last-child 选择属于其父元素最后一个子元素的每个div元素。\r\n* div:nth-child(n) 选择属于其父元素的第n个子元素的每个div元素。\r\n\r\n## 什么是伪元素？\r\n>伪元素表示的是被选择元素的某个部分，这个部分看起来像一个独立的元素，例如::before和::after。\r\n\r\n## 伪类和伪元素的区别\r\n>伪类是操作文档中已有的元素，而伪元素则是创建了一个不在文档树中的元素，并为其添加样式。"
    },
    {
      "id": "/一道考频较高的面试题：数组和链表的区别",
      "metadata": {
        "permalink": "/blog/一道考频较高的面试题：数组和链表的区别",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/一道考频较高的面试题：数组和链表的区别.md",
        "source": "@site/blog\\一道考频较高的面试题：数组和链表的区别.md",
        "title": "一道考频较高的面试题：数组和链表的区别",
        "description": "数组和链表虽然看似很基础，但却也经常被面试官问到，所以我们还是需要熟练掌握的。",
        "date": "2021-09-29T00:00:00.000Z",
        "formattedDate": "2021年9月29日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 1.04,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "一道考频较高的面试题：数组和链表的区别",
          "date": "2021-9-29",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "这一次，彻底搞定伪类和伪元素的区别",
          "permalink": "/blog/这一次，彻底搞定伪类和伪元素的区别"
        },
        "nextItem": {
          "title": "你了解HTTP长连接吗？",
          "permalink": "/blog/你了解HTTP长连接吗？"
        }
      },
      "content": ">数组和链表虽然看似很基础，但却也经常被面试官问到，所以我们还是需要熟练掌握的。\r\n\r\n## 区别1：内存上是否连续\r\n* 数组在内存上是连续的\r\n* 链表在内存上不是连续的,链表是通过指针指向下一个元素。\r\n\r\n## 区别2：存放位置不同\r\n* 数组存放在栈中\r\n* 链表存放在堆中\r\n\r\n## 区别3：查询时间复杂度不同\r\n* 数组查询时间复杂度是O(1)\r\n* 链表查询时间复杂度是O(N)\r\n\r\n## 区别4：插入或删除的时间复杂度不同\r\n* 数组的时间复杂度是O(N)\r\n* 链表的时间复杂度是O(1)\r\n\r\n## 区别5：内存分配方式不同\r\n* 数组是静态分配内存\r\n* 链表是动态分配内存"
    },
    {
      "id": "/你了解HTTP长连接吗？",
      "metadata": {
        "permalink": "/blog/你了解HTTP长连接吗？",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/你了解HTTP长连接吗？.md",
        "source": "@site/blog\\你了解HTTP长连接吗？.md",
        "title": "你了解HTTP长连接吗？",
        "description": "长连接出现的前夜",
        "date": "2021-09-28T00:00:00.000Z",
        "formattedDate": "2021年9月28日",
        "tags": [
          {
            "label": "HTTP",
            "permalink": "/blog/tags/http"
          }
        ],
        "readingTime": 6.87,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "你了解HTTP长连接吗？",
          "date": "2021-9-28",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "HTTP",
          "tags": [
            "HTTP"
          ]
        },
        "prevItem": {
          "title": "一道考频较高的面试题：数组和链表的区别",
          "permalink": "/blog/一道考频较高的面试题：数组和链表的区别"
        },
        "nextItem": {
          "title": "DNS解析优化的主要方法",
          "permalink": "/blog/DNS解析优化的主要方法"
        }
      },
      "content": "## 长连接出现的前夜\r\n>在了解长连接之前，我们先看看与之对应的短连接是什么？在HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。\r\n\r\n>早前的通信情况来看，因为都是些容量很小的文本传输，所以没有太大的问题，但是随着HTTP传输文档中包含大量的富文本，比如使用浏览器浏览一个包含多张图片的HTML页面的时候，在发送请求访问HTML页面资源的同时，也会请求该HTML页面包含的其他资源，因此，每次的请求都会造成无谓的TCP连接的建立和断开，增大了开销。\r\n\r\n## keep-alive字段\r\n>为了解决上面的问题，有些浏览器在请求的时候，使用了一个非标准的Connection字段。\r\n\r\n```shell\r\nConnection: keep-alive\r\n```\r\n\r\n>上面的字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。\r\n\r\n```shell\r\nConnection: keep-alive\r\n```\r\n\r\n>这样一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接，但是这不是标准的字段，不同实现的行为可能不一致，因此不是根本的解决办法。\r\n\r\n## 长连接出现了\r\n>1997年1月，HTTP/1.1版本发布了，它进一步完善了HTTP协议，直到现在还是最流行的版本。\r\n\r\n>HTTP/1.1版的最大变化就是引入了持久连接（HTTP Persistent Connections），即TCP默认连接不关闭，可以被多个请求复用，不用声明keep-alive字段。\r\n\r\n### 持久连接的好处\r\n* 减少了TCP连接的重复建立和断开造成的额外开销，减轻了服务器端的负载。\r\n* 使得HTTP请求和响应能够更早的结束，这样web页面的显示速度也就对应的提高了。\r\n\r\n>客户端和服务器端发现对方一段时间内没有活动，就可以主动关闭连接。不过规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。\r\n\r\n```shell\r\nConnection: close\r\n```\r\n\r\n>目前，对同一个域名，大多数浏览器允许同时建立6个持久连接。\r\n\r\n\r\n## 管道机制\r\n>注意：管道机制是基于持久连接的\r\n\r\n>HTTP/1.1版还引入了管道机制，即在同一个TCP连接里面，客户端可以同时发送多个请求，这样就进一步改进了HTTP协议的效率，以前发送请求后需要等待并接收响应，才能发送下一个请求。管线化技术出现后，不用等待响应即可直接发送下一个请求，这样就能够做到同时并行发送多个请求，而不需要一个接一个的等待响应了，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术则比持久连接要快的多，请求数越多，时间差就越明显。\r\n\r\n### 案例\r\n>假如一个客户端需要请求两个资源，以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出相应，收到后再发出B请求，管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求再回应B请求。\r\n\r\n\r\n## Content-Length字段\r\n>一个TCP连接可以传回多个响应，势必就要有一种机制，区分数据包是属于哪一个响应的，这就是Content-Length字段的作用，声明本次回应的数据长度。\r\n\r\n```shell\r\nContent-Length: 3495\r\n```\r\n\r\n>上面的代码告诉浏览器，本次响应的长度是3495个字节，后面的字节就属于下一个回应了。在1.0版本中,Content-Length字段不是必须的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。\r\n\r\n## 分块传输编码\r\n>使用Content-Length字段的前提条件是，服务器发送响应之前，必须知道响应的数据长度，对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，这样的效率不行，更好的处理方法是，产生一块数据，就发送一块，采用流模式代替缓存模式。\r\n\r\n>因此，1.1版本规定可以不使用Content-Length字段，而是使用分块传输编码，只要请求或响应的头信息中有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。\r\n\r\n```shell\r\nTransfer-Encoding: chunked\r\n```\r\n\r\n>每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度，最后是一个大小为0的块，就表示本次回应的数据发送完了。\r\n\r\n## 长连接带来的问题\r\n>虽然HTTP1.1版本允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按照次序进行的，所以服务器只有处理完一个响应，才会进行下一个响应，如果前面的响应特别慢，后面就会有许多请求排队等待着，这就称之为队头阻塞。\r\n\r\n### 如何避免？\r\n1. 减少请求数。\r\n2. 同时多开持久连接。"
    },
    {
      "id": "/DNS解析优化的主要方法",
      "metadata": {
        "permalink": "/blog/DNS解析优化的主要方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/DNS解析优化的主要方法.md",
        "source": "@site/blog\\DNS解析优化的主要方法.md",
        "title": "DNS解析优化的主要方法",
        "description": "如何清除DNS缓存？",
        "date": "2021-09-27T00:00:00.000Z",
        "formattedDate": "2021年9月27日",
        "tags": [
          {
            "label": "前端优化",
            "permalink": "/blog/tags/前端优化"
          }
        ],
        "readingTime": 5.235,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "DNS解析优化的主要方法",
          "date": "2021-9-27",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "前端优化",
          "tags": [
            "前端优化"
          ]
        },
        "prevItem": {
          "title": "你了解HTTP长连接吗？",
          "permalink": "/blog/你了解HTTP长连接吗？"
        },
        "nextItem": {
          "title": "LeetCode——路径总和（DFS）",
          "permalink": "/blog/LeetCode——路径总和（DFS）"
        }
      },
      "content": "## 如何清除DNS缓存？\r\n>在浏览器中输入下面的地址：\r\n\r\n`chrome://net-internals/#dns`\r\n\r\n>同时需要清空socket池\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/32d28fc3e1bd4eb6ff532b189ce705ae.png)\r\n\r\n>清除系统的DNS缓存\r\n\r\n1. 查看Windows系统中的缓存\r\n\r\n```shell\r\nipconfig /displaydns\r\n```\r\n\r\n2. 在windows中清除DNS缓存记录\r\n\r\n```shell\r\nipconfig /flushdns\r\n```\r\n\r\n3. 在macOS中清除DNS缓存记录\r\n\r\n```shell\r\nsudo killall -HUP mDNSResponder\r\n```\r\n\r\n## 如何清空缓存并进行硬刷新？\r\n>在F12的情况下，右键刷新按钮即可选择。\r\n\r\n## 什么是TTL？\r\n>当我们进行域名解析设置的时候，平台总会让我们设置一个TTL时间，这个TTL时间指的就是域名对应的DNS解析记录的缓存的过期时间。如果经常更换域名指向的IP地址，可以将这个时间设置短一些，但是如果不经常更换IP地址的话，可以将这个时间设置的长一些。\r\n\r\n## DNS解析优化的主要方法\r\n\r\n>一般来说，在前端优化中与DNS有关的有两点：\r\n\r\n* 减少DNS的请求次数\r\n* 进行DNS预获取：DNS Prefetch\r\n\r\n### 1. 减少DNS查找\r\n>域名系统DNS将主机名映射到IP地址，就像电话簿将人们的姓名映射到他们的电话号码中，在浏览器中输入 www.taobao.com 时，浏览器联系的DNS解析器将返回该服务器的IP地址，DNS有成本，DNS通常需要20-120毫秒来查找给定主机名的IP地址，在DNS查找完成之前，浏览器无法从该主机名下载任何内容。\r\n\r\n>缓存DNS查找以提高性能，这种缓存可以由用户的ISP或局域网维护的特殊缓存服务器上进行，但是在个别用户的计算机上也会发生缓存，DNS信息保留在操作系统的DNS缓存中，大多数浏览器都有自己的缓存，与操作系统的缓存分开，只要浏览器将DNS记录保留在自己的缓存中，它就不会对操作系统的记录请求进行干扰。\r\n\r\n>默认情况下Chrome会缓存1分钟的DNS查找。\r\n\r\n>当客户端中的DNS缓存为空时（浏览器和操作系统都为空），DNS查找的次数和页面中主机名的数量相同。这其中包括页面中URL、图片、脚本文件、样式表、Flash对象等包含的主机名。减少主机名的数量可以减少DNS查找次数。\r\n\r\n>减少主机名的数量还可以减少页面中并行下载的数量，减少DNS查找次数可以节省响应时间，但是减少并行下载却会增加响应时间。\r\n\r\n### 2. DNS预获取\r\n>DNS-prefetch（DNS预获取）是尝试在请求资源之前解析域名，这可能是后面要加载的文件，也可能是用户尝试打开的链接目标。域名解析和内容载入时串行的网络操作，所以这个方式能减少用户的等待时间，提升用户体验。\r\n\r\n>DNS-prefetch可以帮助开发人员掩盖DNS解析延迟。HTML的link元素通过dns-prefetch的rel属性值提供此功能，然后再href属性中指要跨域的域名。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/9ab6c26121ab5a9c3a9dd0d99d78b36b.png)\r\n\r\n>每当站点引用跨域资源的时候，都应在head元素中放置dns-prefetch提示，但是要记住下面的注意事项。\r\n\r\n1. DNS-prefetch仅对跨域的DNS查找有效。\r\n2. dns-prefetch要谨慎使用，多页面重复DNS预解析会增加DNS查询次数。\r\n3. 默认情况下浏览器会对页面中和当前域名不在同一个域的域名进行预获取，并且缓存结果，这就是隐式的DNS Prefetch。如果想对页面中没有出现的域进行获取，那么就要使用显示的DNS Prefetch了。\r\n4. 虽然使用DNS Prefetch能够加快页面的解析速度，但是也不能滥用，因为有开发者指出禁用DNS预获取能节省每月100亿的DNS查询。\r\n\r\n### 3. 延长DNS缓存时间\r\n\r\n### 4. 尽可能使用A记录代替CNAME\r\n\r\n### 5. 使用CDN加速域名"
    },
    {
      "id": "/LeetCode——路径总和（DFS）",
      "metadata": {
        "permalink": "/blog/LeetCode——路径总和（DFS）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——路径总和（DFS）.md",
        "source": "@site/blog\\LeetCode——路径总和（DFS）.md",
        "title": "LeetCode——路径总和（DFS）",
        "description": "题目描述",
        "date": "2021-09-26T00:00:00.000Z",
        "formattedDate": "2021年9月26日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.71,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——路径总和（DFS）",
          "date": "2021-9-26",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "DNS解析优化的主要方法",
          "permalink": "/blog/DNS解析优化的主要方法"
        },
        "nextItem": {
          "title": "二刷--用两个栈实现队列",
          "permalink": "/blog/二刷--用两个栈实现队列"
        }
      },
      "content": "## 题目描述\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/3280f107030b2a8e6f5c3f30be334022.png)\r\n\r\n## 解题思路\r\n\r\n>本题的核心解题思路是使用DFS，每次遍历完一条路径，走到叶子节点之后看是否这条路径的和与targetsum一致，一致则返回true，反之则返回false。\r\n\r\n## AC代码\r\n\r\n```js\r\nvar hasPathSum = function (root, targetSum) {\r\n    \r\n    if (!root) return false;\r\n\r\n    if (root.left === null && root.right === null) {\r\n        if (targetSum - root.val === 0) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    return hasPathSum(root.left,targetSum-root.val) || hasPathSum(root.right,targetSum-root.val);\r\n\r\n};\r\n```\r\n\r\n## 题目反思\r\n* 学会DFS来遍历二叉树。\r\n* 学会使用递减归零的思想来判断和的问题。"
    },
    {
      "id": "/二刷--用两个栈实现队列",
      "metadata": {
        "permalink": "/blog/二刷--用两个栈实现队列",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/二刷--用两个栈实现队列.md",
        "source": "@site/blog\\二刷--用两个栈实现队列.md",
        "title": "二刷--用两个栈实现队列",
        "description": "题目描述",
        "date": "2021-09-25T00:00:00.000Z",
        "formattedDate": "2021年9月25日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 2.515,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "二刷--用两个栈实现队列",
          "date": "2021-9-25",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "LeetCode——路径总和（DFS）",
          "permalink": "/blog/LeetCode——路径总和（DFS）"
        },
        "nextItem": {
          "title": "如何控制Promise的串行执行？",
          "permalink": "/blog/如何控制Promise的串行执行？"
        }
      },
      "content": "## 题目描述\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/eddac7a0db55bb90ddf65620730d2595.png)\r\n\r\n## 解题思路\r\n1. 一个栈用来模拟入队操作。\r\n2. 另一个栈用来模拟出队操作。\r\n3. 在构造函数的原型对象上添加增加队尾元素函数和删除队头元素函数，注意，这两个函数都不要使用箭头函数，因为涉及到this。\r\n4. 增加队尾元素只需直接在入队栈中入队即可。\r\n5. 删除队头元素则需进行如下判断\r\n    * 出队栈中是否有元素，有则直接出栈\r\n    * 入队栈中是否有元素\r\n        * 有：将入队栈中的所有元素倒序加入到出队栈中，然后返回出队栈的栈顶元素。\r\n        * 没有：返回-1.\r\n\r\n\r\n## AC代码\r\n```js\r\nfunction CQueue() {\r\n    // 模拟入队栈\r\n    this.stackA = [];\r\n    // 模拟出队栈\r\n    this.stackB = []; \r\n}\r\n\r\n/**\r\n * @description: 在队尾中添加元素\r\n * @param {*}\r\n * @return {*}\r\n */\r\nCQueue.prototype.appendTail = function (value) {\r\n    // 直接在入队栈中入队即可\r\n    this.stackA.push(value);\r\n}\r\n\r\nCQueue.prototype.deleteHead = function() {\r\n    // 首先判断出队栈中是否有元素，有则出栈\r\n    if (this.stackB.length !== 0) {\r\n        return this.stackB.pop();\r\n    } \r\n    // 走到这里说明出队栈中没有元素，我们判断入队栈中是否有元素\r\n    if (this.stackA.length !== 0) {\r\n        // 把入队栈中的元素倒序加入出队栈  这是本题的解题核心\r\n        while(this.stackA.length !== 0) {\r\n            this.stackB.push(this.stackA.pop());\r\n        }\r\n        return this.stackB.pop();\r\n\r\n    } else {\r\n        return -1\r\n    }\r\n}\r\n```\r\n\r\n## 题目反思\r\n>本次遇到这个题目属于二刷了，这个题目是剑指offer的一道题目，第二次遇到也没有很顺利的做出来，本题的思路并不难，遇到的困难主要是我想使用箭头函数，但是因为本题涉及到了this指向的问题，箭头函数的this指向是看运行时的上下文环境的，所以导致报错，所以希望在以后的学习和工作中一旦涉及到this指向的问题，一定要考虑清楚箭头函数的问题。"
    },
    {
      "id": "/如何控制Promise的串行执行？",
      "metadata": {
        "permalink": "/blog/如何控制Promise的串行执行？",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/如何控制Promise的串行执行？.md",
        "source": "@site/blog\\如何控制Promise的串行执行？.md",
        "title": "如何控制Promise的串行执行？",
        "description": "Promise是如何执行的？",
        "date": "2021-09-24T00:00:00.000Z",
        "formattedDate": "2021年9月24日",
        "tags": [
          {
            "label": "Promise",
            "permalink": "/blog/tags/promise"
          }
        ],
        "readingTime": 2.65,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "如何控制Promise的串行执行？",
          "date": "2021-9-24",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Promise",
          "tags": [
            "Promise"
          ]
        },
        "prevItem": {
          "title": "二刷--用两个栈实现队列",
          "permalink": "/blog/二刷--用两个栈实现队列"
        },
        "nextItem": {
          "title": "TypeScript核心基础",
          "permalink": "/blog/TypeScript核心基础"
        }
      },
      "content": "## Promise是如何执行的？\r\n>让我们来一起看看这个例子，下面的这个例子是一个数组，数组中的每一个元素都是一个函数，函数会返回一个Promise对象，但是每个Promise对象都被定时器控制着执行时间，熟系JS事件循环机制的同学都知道，Promise属于微任务，在执行的时候会加入到微任务队列中，所以执行顺序是2 -> 1 -> 3\r\n\r\n```js\r\nconst funcArr = [\r\n    () =>\r\n        new Promise((resolve) => {\r\n            setTimeout(() => resolve(1), 2000);\r\n        }),\r\n    () =>\r\n        new Promise((resolve) => {\r\n            setTimeout(() => resolve(2), 1000);\r\n        }),\r\n    () =>\r\n        new Promise((resolve) => {\r\n            setTimeout(() => resolve(3), 3000);\r\n        }),\r\n];\r\nfor (let v of funcArr) {\r\n    v().then(res => console.log(res))\r\n}\r\n```\r\n## 核心思想\r\n>实现Promise的核心思想是借助reduce,reduce这个API可以将不同的Promise串联起来。\r\n\r\n## 实现步骤\r\n### 第一步：定义一个接收不同Promise执行结果的数组\r\n```js\r\nconst res = []\r\n```\r\n\r\n### 第二步：返回一个Promise对象\r\n```js\r\nreturn new Promise((resolve,reject) => {     \r\n})\r\n```\r\n\r\n### 第三步：通过reduce将不同的Promise进行串联执行\r\n```js\r\narr.reduce((pre,cur) => {\r\n    return pre.then(cur).then(data => res.push(data))\r\n},Promise.resolve()).then(() => resolve(res))\r\n```\r\n\r\n## 完整代码\r\n```js\r\nconst funcArr = [\r\n    () =>\r\n        new Promise((resolve) => {\r\n            setTimeout(() => resolve(1), 2000);\r\n        }),\r\n    () =>\r\n        new Promise((resolve) => {\r\n            setTimeout(() => resolve(2), 1000);\r\n        }),\r\n    () =>\r\n        new Promise((resolve) => {\r\n            setTimeout(() => resolve(3), 3000);\r\n        }),\r\n];\r\n/**\r\n * @description: 实现Promise的串行\r\n * @param {*}: 接收一个包含多个返回Promise对象的函数的数组\r\n * @return {*}: 返回一个Promise对象\r\n */\r\nfunction inOrder(arr) {\r\n    const res = []\r\n    return new Promise((resolve,reject) => {\r\n        arr.reduce((pre,cur) => {\r\n            return pre.then(cur).then(data => res.push(data))\r\n        },Promise.resolve()).then(() => resolve(res))       \r\n    })\r\n}\r\n\r\ninOrder(funcArr).then(data => console.log(data))\r\n```\r\n\r\n## 反思\r\n* reduce函数如果使用大括号的情况下，别忘了使用return.\r\n* then中包裹的是一个函数，这也就是为什么funcArr中每一个元素都是一个Promise对象。\r\n* resolve后其实还是一个Promise对象，只有这个Promise对象then之后才会变为其他类型的值。\r\n* reduce的第二个参数，在本次实例中其实是一个Promise对象，这一点指的我们借鉴。\r\n\r\n## 参考资料\r\n* [[清代八股文]Promise如何实现串行执行](https://www.cnblogs.com/zhangnan35/p/14584035.html)"
    },
    {
      "id": "/TypeScript核心基础",
      "metadata": {
        "permalink": "/blog/TypeScript核心基础",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/TypeScript核心基础.md",
        "source": "@site/blog\\TypeScript核心基础.md",
        "title": "TypeScript核心基础",
        "description": "配置VScode自动生成TS文件",
        "date": "2021-09-23T00:00:00.000Z",
        "formattedDate": "2021年9月23日",
        "tags": [
          {
            "label": "TypeScript",
            "permalink": "/blog/tags/type-script"
          }
        ],
        "readingTime": 15.21,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "TypeScript核心基础",
          "date": "2021-9-23",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "TypeScript",
          "tags": [
            "TypeScript"
          ]
        },
        "prevItem": {
          "title": "如何控制Promise的串行执行？",
          "permalink": "/blog/如何控制Promise的串行执行？"
        },
        "nextItem": {
          "title": "优化HTTP请求和响应的方法",
          "permalink": "/blog/优化HTTP请求和响应的方法"
        }
      },
      "content": "## 配置VScode自动生成TS文件\r\n* 生成ts配置文件\r\n```js\r\ntsc --init\r\n```\r\n\r\n* 激活输出路径\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/632424ce8189318838bd1cb1ebd6b645.png)\r\n\r\n* 配置保存即输出到指定路径\r\n\r\n1. 点击终端下的运行任务\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/55bca9ada4d0197bdc290b8d129676bd.png)\r\n2. 点击typescript\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/1772984e91806ed69a505940da85dcdd.png)\r\n3. 点击tsc监视\r\n\r\n## TS中的基本数据类型\r\n### boolean类型\r\n```js\r\nlet flag: boolean = true;\r\nflag = false;\r\n```\r\n\r\n### number类型\r\n```js\r\nlet num: number = 666;\r\nnum = 777;\r\n```\r\n\r\n### string类型\r\n```js\r\nlet str: string = '666';\r\nstr = '777';\r\n```\r\n\r\n### array类型\r\n```js\r\n// 方式1\r\nlet arr: number[] = [1,2,3];\r\n// 方式2\r\nlet arr2: Array<number> = [6,7,8];\r\n```\r\n\r\n### 元组类型(tuple)\r\n```js\r\n// 元组类型\r\nlet arr: [number,string,boolean] = [1,'60',true];\r\n```\r\n\r\n### 枚举类型\r\n```js\r\n// 枚举类型\r\nenum Flag{color1 = 'blue',color2 = 'pink'};\r\n\r\nlet flag: Flag = Flag.color2;\r\n\r\nconsole.log(flag);\r\n```\r\n\r\n### 任意类型any\r\n```js\r\n// 任意类型\r\nlet num: any = 666;\r\nnum = 'test';\r\nnum = true;\r\n```\r\n\r\n### undefined类型\r\n```js\r\n// undefined类型\r\nlet num: undefined;\r\nconsole.log(num);\r\n```\r\n\r\n### null类型\r\n```js\r\nlet num: null;\r\nnum = null;\r\n```\r\n\r\n### void类型\r\n* 表示方法没有任何返回类型\r\n```js\r\nfunction run(): void{\r\n    console.log('run');\r\n}\r\n```\r\n\r\n### never类型\r\n>表示无法到达终点的函数，例如死循环或者抛出异常。\r\n```js\r\nfunction test(): never {\r\n    throw new Error('错误');\r\n}\r\n```\r\n\r\n## TS的函数类型\r\n### 基本形式\r\n```js\r\nfunction test(name: string,age: number): string{\r\n    return `${name} ---- ${age}`\r\n}\r\ntest('nihao',666);\r\n```\r\n\r\n### 可选参数\r\n>在JS中，函数定义的参数可传也可不传，但是在TS中是必须传递的，如果不传需要配置可选参数。\r\n```js\r\nfunction test(name: string,age?: number): string{\r\n    return `${name} ---- ${age}`\r\n}\r\ntest('nihao');\r\n```\r\n\r\n### 默认参数\r\n>下面的例子中的number是默认参数。\r\n```js\r\nfunction test(name: string,age: number=20): string{\r\n    return `${name} ---- ${age}`\r\n}\r\ntest('nihao');\r\n```\r\n\r\n### 剩余参数\r\n```js\r\nfunction sum(...arg: number[]): number{\r\n    return arg.reduce((pre,cur) => pre + cur,0)\r\n}\r\nsum(1,2,3,4)\r\n```\r\n\r\n### 函数重载\r\n>在JS中一旦出现同名方法在同一作用域的情况下，下面的会覆盖上面的，但是在TS中则存在重载的情况。\r\n* 注意：下面的any并不是说可以传递任意类型。\r\n```js\r\nfunction test(name: string): string;\r\n\r\nfunction test(age: number): string;\r\n// 这里的any其实并不是真正的any，必须传递上面的两种类型之一，反之报错\r\nfunction test(str: any): string{\r\n    if (typeof str === 'string') {\r\n        return '姓名' + str;\r\n    } else {\r\n        return '年龄' + str;\r\n    }\r\n}\r\ntest('里斯');\r\n```\r\n\r\n## TS中的类\r\n### 类中属性和方法的定义\r\n```ts\r\nclass Person{\r\n    name: string;\r\n    constructor(n: string) {\r\n        this.name = n;\r\n    }   \r\n    run() :void {\r\n        console.log(this.name);\r\n    }\r\n}\r\n\r\nconst p = new Person('张三');\r\np.run();\r\n```\r\n\r\n### TS中实现继承\r\n>TS中实现继承主要用到了extends和super两个关键字。\r\n```js\r\nclass Person{\r\n    name: string;\r\n\r\n    constructor(name: string) {\r\n        this.name = name;\r\n    }\r\n    run(): string {\r\n        return `${this.name}在学习`\r\n    }\r\n}\r\n\r\nclass child extends Person{\r\n    constructor(name: string) {\r\n        super(name);\r\n    }\r\n}\r\n\r\nconst c = new child('小明');\r\nconsole.log(c.run());\r\n```\r\n\r\n### 类中的修饰符\r\n* public: 自身可以调用，子类可以调用，实例可以调用\r\n```js\r\nclass Person{\r\n    public name: string;\r\n\r\n    constructor(name: string) {\r\n        this.name = name;\r\n    }\r\n    run(): string {\r\n        return `${this.name}在学习`\r\n    }\r\n}\r\n\r\nconst p = new Person('张三');\r\nconsole.log(p.name);\r\n```\r\n* protected: 自身可以调用，子类可以调用\r\n```js\r\nclass Person{\r\n    protected name: string;\r\n\r\n    constructor(name: string) {\r\n        this.name = name;\r\n    }\r\n    run(): string {\r\n        return `${this.name}在学习`\r\n    }\r\n}\r\n\r\nclass Child extends Person{\r\n    \r\n    constructor(name: string) {\r\n        super(name)\r\n    }\r\n    run2(): void{\r\n        console.log(this.name);\r\n    }\r\n}\r\n\r\nconst c = new Child('666');\r\nconsole.log(c.run());\r\n```\r\n* private：只有自身能够访问\r\n```js\r\nclass Person{\r\n    private name: string;\r\n\r\n    constructor(name: string) {\r\n        this.name = name;\r\n    }\r\n    run(): string {\r\n        return `${this.name}在学习`\r\n    }\r\n}\r\n\r\nconst p = new Person('张三');\r\np.name   // 报错\r\n```\r\n>注意：如果不写类成员修饰符默认是public.\r\n\r\n### 静态属性和静态方法\r\n* 通过static关键词定义静态属性\r\n```ts\r\nclass Person{\r\n    name: string;\r\n    constructor(name: string){\r\n        this.name = name;\r\n    }\r\n\r\n    run() {\r\n        console.log(this.name);\r\n    }\r\n    static work() {\r\n        console.log('这是类的静态方法');\r\n    }\r\n}\r\n\r\nconst p = new Person('张三');\r\n\r\n// p.work()  // 报错\r\nPerson.work();\r\n```\r\n* 静态方法只能调用静态属性不能调用实例属性\r\n```ts\r\nclass Person{\r\n    name: string;\r\n    static age: number = 18;\r\n    constructor(name: string){\r\n        this.name = name;\r\n    }\r\n\r\n    run() {\r\n        console.log(this.name);\r\n    }\r\n    static work() {\r\n        console.log('这是类的静态方法');\r\n        console.log('年龄是：',Person.age);        \r\n    }\r\n}\r\n\r\nconst p = new Person('张三');\r\n\r\nPerson.age;\r\nPerson.work();\r\n```\r\n\r\n### 多态\r\n>多态指的是父类定义一个方法不去实现，让子类去实现，每一个子类有不同的表现。\r\n\r\n```ts\r\nclass Animal {\r\n    name: string;\r\n    constructor(name: string) {\r\n        this.name = name;\r\n    }\r\n    eat(): void {\r\n        console.log('这是父类的eat');\r\n    }\r\n}\r\n\r\nclass Cat extends Animal {\r\n    name: string;\r\n    constructor(name: string) {\r\n        super(name)\r\n        this.name = name;\r\n    }\r\n    eat(): void {\r\n        console.log('这是子类的多态：',this.name);\r\n        \r\n    }\r\n}\r\nconst c = new Cat('小猫');\r\nc.eat();\r\n```\r\n\r\n### 抽象类\r\n>用abstract关键字定义抽象类和抽象方法，抽象类中的抽象方法不包含具体的实现且必须在派生类中实现。抽象方法只能放在抽象类中。\r\n\r\n1. 抽象类无法进行具体的实例化\r\n```ts\r\nabstract class Animal{\r\n    abstract eat(): void;\r\n}\r\nconst a = new Animal()   // 直接报错\r\n```\r\n\r\n2. 抽象类的子类必须实现抽象类中的抽象方法\r\n```ts\r\nabstract class Animal {\r\n    abstract eat(): void;\r\n}\r\nclass cat extends Animal {\r\n    eat(): void {\r\n        console.log(666);\r\n    }\r\n}\r\nconst c = new cat();\r\nc.eat()\r\n```\r\n\r\n## TS中的接口\r\n>接口的存在也是为了定义标准。\r\n\r\n### 属性接口\r\n```ts\r\ninterface fullname {\r\n    firstName: string;\r\n    secondName: string;\r\n}\r\nfunction getName (name: fullname) {\r\n    console.log(`${name.firstName} + '---' + ${name.secondName}`);\r\n}\r\nconst obj = {\r\n    firstName: '小',\r\n    secondName: '明'\r\n}\r\ngetName(obj);\r\n```\r\n\r\n### 接口的可选属性\r\n```ts\r\ninterface fullname {\r\n    firstName: string;\r\n    secondName?: string;\r\n}\r\nfunction getName (name: fullname) {\r\n    console.log(`${name.firstName} + '---' + ${name.secondName}`);\r\n}\r\nconst obj = {\r\n    firstName: '小',\r\n    // secondName: '明'\r\n}\r\ngetName(obj);\r\n```\r\n\r\n### 函数类型的接口\r\n```ts\r\ninterface encrypht {\r\n    (key: string,value: string): string;\r\n}\r\nconst md5: encrypht = function md5(key: string, value: string): string {\r\n    return key + value;\r\n}\r\nconsole.log(md5('1','2'));\r\n```\r\n\r\n### 可索引接口\r\n>这个接口主要是对数组和对象的约束。\r\n\r\n* 对数组的约束\r\n```ts\r\ninterface useArr {\r\n    [index: number]: string;\r\n}\r\n\r\nconst arr: useArr = ['1','2']\r\n```\r\n* 对对象的约束\r\n```ts\r\ninterface useObj {\r\n    [index: string]: string;\r\n}\r\nconst obj: useObj = {\r\n    name: '张三',\r\n    age: '666'\r\n}\r\n```\r\n\r\n### 类类型接口\r\n>类类型接口存在的意义主要是对类进行约束。\r\n\r\n```ts\r\ninterface Animal {\r\n    name: string;\r\n    eat(str: string): void;\r\n}\r\nclass Cat implements Animal {\r\n    name: string;\r\n    constructor(name: string) {\r\n        this.name = name;\r\n    }\r\n    eat(str: string): void {\r\n        console.log(this.name + str);\r\n    }\r\n}\r\nconst cat = new Cat('小猫咪');\r\nconsole.log(cat.eat('玉米'));\r\n```\r\n\r\n### 接口拓展\r\n>接口拓展指的是接口可以继承另一个接口。\r\n\r\n```ts\r\ninterface Animal {\r\n    eat(): void;\r\n}\r\ninterface Person extends Animal {\r\n    work(): void;\r\n}\r\nclass people implements Person {\r\n    name: string;\r\n    constructor(name: string) {\r\n        this.name = name;\r\n    }\r\n    eat() {\r\n        console.log('eat');\r\n    }\r\n    work() {\r\n        console.log('work');\r\n    }\r\n}\r\nconst p = new people('小张');\r\np.eat()\r\np.work()\r\n```\r\n\r\n### 继承+实现\r\n```ts\r\ninterface Animal {\r\n    eat(): void;\r\n}\r\ninterface Person extends Animal {\r\n    work(): void;\r\n}\r\nclass Programer {\r\n    name: string;\r\n    constructor(name: string) {\r\n        this.name = name;\r\n    }\r\n    coding(): void {\r\n        console.log(this.name + '在写代码');\r\n    }\r\n}\r\nclass people extends Programer implements Person {\r\n    name: string;\r\n    constructor(name: string) {\r\n        super(name);\r\n        this.name = name;\r\n    }\r\n    eat() {\r\n        console.log('eat');\r\n    }\r\n    work() {\r\n        console.log('work');\r\n    }\r\n}\r\nconst p = new people('小张');\r\np.coding();\r\n```\r\n\r\n## TS中的泛型\r\n>泛型可以支持不特定的类型。\r\n\r\n### 泛型定义\r\n```ts\r\nfunction getData<T>(value: T): T {\r\n    return value;\r\n}\r\n\r\nconsole.log(getData<string>('123'));\r\nconsole.log(getData<number>(123));\r\n```\r\n\r\n### 类的泛型\r\n```ts\r\nclass MinClass<T> {\r\n    list: T[] = [];\r\n\r\n    add(num: T) {\r\n        this.list.push(num);\r\n    }\r\n\r\n    min(): T {\r\n        let minNum = this.list[0];\r\n        for (let v of this.list) {\r\n            if (v < minNum) {\r\n                minNum = v;\r\n            }\r\n        }\r\n        return minNum;\r\n    }\r\n}\r\nconst m = new MinClass<number>();\r\n```\r\n\r\n### 泛型接口\r\n* 写法1\r\n```ts\r\ninterface configFn {\r\n    <T>(value: T): T;\r\n}\r\n\r\nconst fn: configFn = function<T>(value: T): T {\r\n\r\n    return value;\r\n}\r\n\r\nconsole.log(fn<string>('666'));\r\n```\r\n* 写法2\r\n```ts\r\ninterface configFn<T> {\r\n    (value: T): T;\r\n}\r\n\r\nfunction getData<T>(value: T): T {\r\n    return value;\r\n}\r\n\r\nconst myGetData: configFn<string> = getData;\r\n\r\nmyGetData('20')\r\n```\r\n\r\n### 泛型类实现泛型接口（用于逻辑复用）\r\n>泛型类快速实现泛型接口的方法\r\n\r\n1. 定义好初始结构\r\n```ts\r\nclass MongoDb<T> implements DBI<T> {\r\n    \r\n}\r\n```\r\n2. 光标悬浮然后点击快速修复\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/0efd3feec3b2d71e6cd0158406fd6fbf.png)\r\n\r\n3. 点击实现接口\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/64fdad63cff639b1f9b18fa95c8a8e08.png)\r\n\r\n* 经典实例\r\n```ts\r\ninterface DBI<T> {\r\n    add(info: T): boolean;\r\n    update(info: T): boolean;\r\n    delete(id: number): boolean;\r\n    get(id: number): any[];\r\n}\r\n\r\n/**\r\n * @description: 要实现泛型接口的类也必须是泛型类\r\n * @param {*}\r\n * @return {*}\r\n */\r\nclass MysqlDb<T> implements DBI<T> {\r\n    add(info: T): boolean {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n    update(info: T): boolean {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n    delete(id: number): boolean {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n    get(id: number): any[] {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n}\r\n\r\nclass MongoDb<T> implements DBI<T> {\r\n    add(info: T): boolean {\r\n        console.log(info);\r\n        return true;\r\n        \r\n    }\r\n    update(info: T): boolean {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n    delete(id: number): boolean {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n    get(id: number): any[] {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n    \r\n}\r\n\r\nclass User {\r\n    username: string | undefined;\r\n    password: string | undefined;   \r\n}\r\n\r\nconst u = new User();\r\nu.username = '张三';\r\nu.password = '123';\r\n\r\nconst m = new MongoDb();\r\nm.add(u);\r\n```\r\n\r\n\r\n## 命名空间\r\n* 命名空间和模块的区别\r\n>命名空间：内部模块，主要用于组织代码，避免命名冲突。\r\n>模块：TS的外部模块的简称，侧重代码的复用，一个模块里可能会有多个命名空间。\r\n\r\n```ts\r\nnamespace A {\r\n    export class Animal {\r\n        name: string | undefined;\r\n        age: number | undefined;\r\n    }\r\n}\r\nnamespace B {\r\n    export class Animal {\r\n        name: string | undefined;\r\n        age: number | undefined;\r\n    }\r\n}\r\nconst cat = new A.Animal()\r\nconst dog = new B.Animal()\r\n```\r\n\r\n## TS装饰器\r\n### 装饰器有什么用？\r\n>装饰器是一种特殊类型的声明，它能够被附加到类声明，方法，属性或参数上，可以修改类的行为。通俗的讲装饰器就是一个方法，可以注入到类、方法、属性参数上来拓展类、属性、方法，参数的功能。\r\n\r\n### 类装饰器\r\n>注意：类装饰器功能的实现需要在tsconfig.json文件中配置如下代码。\r\n\r\n```ts\r\n\"experimentalDecorators\": true\r\n```\r\n\r\n1. 普通装饰器（无法传参）\r\n\r\n```ts\r\nfunction logClass(params: any) {\r\n    // 这里的params指的就是被装饰器下面的函数\r\n    console.log(params);\r\n    // 下面就是我们动态拓展的属性\r\n    params.prototype.apiUrl = 'http://www.baidu.com'\r\n}\r\n\r\n// \r\n@logClass\r\nclass HttpClient {\r\n    constructor() {\r\n\r\n    }\r\n    getData() {\r\n\r\n    }\r\n}\r\n\r\nconst h: any = new HttpClient();\r\nconsole.log(h.apiUrl);\r\n```\r\n\r\n2. 装饰器工厂（可以传参）\r\n\r\n```ts\r\n// 装饰器工厂\r\nfunction logClass(params: any) {\r\n    // params：是装饰器传过来的参数\r\n    // 下面的target才是指的类本身\r\n    return function(target: any) {\r\n        console.log('这是target：',target);\r\n        console.log('这是params：',params);\r\n        target.prototype.apiUrl = params;\r\n    }\r\n}\r\n\r\n// \r\n@logClass('666')\r\nclass HttpClient {\r\n    constructor() {\r\n\r\n    }\r\n    getData() {\r\n\r\n    }\r\n}\r\nconst h: any = new HttpClient();\r\nconsole.log(h.apiUrl);  //666\r\n```\r\n\r\n### 类装饰器重载\r\n```ts\r\nfunction logClass(target: any) {\r\n    return class extends target {\r\n        apiUrl: string = '这个是修改后的url';\r\n        getData() {\r\n            this.apiUrl = '这个是修改后的url---'\r\n            console.log(this.apiUrl);\r\n            \r\n        }\r\n    }\r\n}\r\n@logClass\r\nclass HttpClient {\r\n    apiUrl: string | undefined;\r\n    constructor() {\r\n        this.apiUrl = '这是构造函数中的URL'\r\n    }\r\n    getData() {\r\n        console.log(this.apiUrl);\r\n    }\r\n}\r\nconst h = new HttpClient();\r\nh.getData();\r\n```\r\n\r\n### 属性装饰器\r\n>属性装饰器表达式会在运行时当做函数被调用，传入下列两个参数\r\n1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。\r\n2. 成员的名字。\r\n\r\n```ts\r\n// 属性装饰器\r\nfunction logProperty(params: any) {\r\n    return function(target: any,attr: any) {\r\n        // 这里的target指的就是类的原型对象\r\n        // 这里的attr指的是类的属性\r\n        console.log(target);\r\n        console.log(attr);\r\n        target[attr] = params;\r\n    }\r\n}\r\nclass HttpClient {\r\n    @logProperty('http://www.baidu.com')\r\n    url: string | undefined;\r\n    constructor() {\r\n\r\n    }\r\n    getData() {\r\n        console.log(this.url);\r\n    }\r\n}\r\nconst h = new HttpClient();\r\nh.getData()\r\n```\r\n\r\n### 方法装饰器\r\n>在方法装饰器中可以修改方法装饰器对应的方法或属性。\r\n\r\n```ts\r\n/**\r\n * @description: 方法装饰器\r\n * @param {any} params\r\n * @return {*}\r\n */\r\nfunction logFun(params: any) {\r\n    /**\r\n     * @description: \r\n     * @param {any} target：原型对象\r\n     * @param {any} methodName：方法名\r\n     * @param {any} desc：方法的属性描述\r\n     * @return {*}\r\n     */\r\n    return function(target: any,methodName: any,desc: any) {\r\n        console.log(target);\r\n        console.log(methodName);\r\n        console.log(desc.value);\r\n\r\n        const oldMethod = desc.value;\r\n        desc.value = function(...args: any[]) {\r\n            args = args.map(item => {\r\n                return String(item)\r\n            })\r\n            oldMethod.apply(this,args)\r\n        }\r\n    }\r\n}\r\nclass HttpClient {\r\n    url: string | undefined;\r\n    constructor() {\r\n    }\r\n    @logFun('你好')\r\n    getData(...args: any[]) {\r\n        console.log(args);  // ['123','666']\r\n        console.log('这是getData中的方法');\r\n    }\r\n}\r\nconst h = new HttpClient();\r\nh.getData(123,'666')\r\n```\r\n\r\n### 方法参数装饰器\r\n```ts\r\n/**\r\n * @description: 方法参数装饰器\r\n * @param {any} params\r\n * @return {*}\r\n */\r\nfunction logParams(params: any) {\r\n    /**\r\n     * @description: \r\n     * @param {any} target：类的原型对象\r\n     * @param {any} methodName：参数对应的方法名\r\n     * @param {any} paramsIndex：参数对应的索引\r\n     * @return {*}\r\n     */\r\n    return function(target: any,methodName: any,paramsIndex: any) {\r\n        console.log(params);\r\n        console.log(target);\r\n        console.log(methodName);\r\n        console.log(paramsIndex);\r\n        // 增加一个属性\r\n        target.apiUrl = params;\r\n    }\r\n}\r\nclass HttpClient {\r\n    url: string | undefined;\r\n    constructor() {\r\n    }\r\n    getData(@logParams('你好') uuid: any) {\r\n        console.log(uuid);\r\n    }\r\n}\r\nconst h: any = new HttpClient();\r\nh.getData(123);\r\nconsole.log(h.apiUrl);   //你好\r\n```\r\n\r\n### 装饰器的执行顺序\r\n>首先看下面的代码\r\n\r\n```ts\r\nfunction logClass1(params: any) {\r\n    return function(target: any) {\r\n        console.log('类装饰器1');\r\n    }\r\n}\r\nfunction logClass2(params: any) {\r\n    return function(target: any) {\r\n        console.log('类装饰器2');\r\n    }\r\n}\r\nfunction logAttribute() {\r\n    return function(target: any,attr: any) {\r\n        console.log('属性装饰器');\r\n    }\r\n}\r\nfunction logMethod() {\r\n    return function(target: any,methodName: any,desc: any) {\r\n        console.log('方法装饰器');\r\n    }\r\n}\r\nfunction logParams1() {\r\n    return function (target: any,methodName: any,paramsIndex: any) {\r\n        console.log('方法参数装饰器1'); \r\n    }\r\n}\r\nfunction logParams2() {\r\n    return function (target: any,methodName: any,paramsIndex: any) {\r\n        console.log('方法参数装饰器2'); \r\n    }\r\n}\r\n\r\n@logClass1('111')\r\n@logClass2('2222')\r\nclass HttpClient {\r\n    @logAttribute()\r\n    url: string | undefined;\r\n    constructor() {\r\n    }\r\n    @logMethod()\r\n    getData() {\r\n        return true\r\n    }\r\n    setDate(@logParams1() attr1: any,@logParams2() attr2: any) {\r\n        return true;\r\n    }\r\n}\r\n```\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/ed7a97c9040340387ad196ded9624c6c.png)\r\n\r\n>注意：在class内部执行顺序是按照代码顺序来的。"
    },
    {
      "id": "/优化HTTP请求和响应的方法",
      "metadata": {
        "permalink": "/blog/优化HTTP请求和响应的方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/优化HTTP请求和响应的方法.md",
        "source": "@site/blog\\优化HTTP请求和响应的方法.md",
        "title": "优化HTTP请求和响应的方法",
        "description": "为什么要进行请求和响应的优化？",
        "date": "2021-09-22T00:00:00.000Z",
        "formattedDate": "2021年9月22日",
        "tags": [
          {
            "label": "HTTP",
            "permalink": "/blog/tags/http"
          }
        ],
        "readingTime": 2.865,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "优化HTTP请求和响应的方法",
          "date": "2021-9-22",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "HTTP",
          "tags": [
            "HTTP"
          ]
        },
        "prevItem": {
          "title": "TypeScript核心基础",
          "permalink": "/blog/TypeScript核心基础"
        },
        "nextItem": {
          "title": "一篇文章搞定几乎所有TCP/UDP面试题",
          "permalink": "/blog/一篇文章搞定几乎所有TCPUDP面试题"
        }
      },
      "content": "## 为什么要进行请求和响应的优化？\r\n>核心目的：更快的获取到内容。\r\n\r\n## 核心思路\r\n1. 更好的连接传输效率。\r\n2. 更少的请求数量。\r\n3. 更小的资源大小。\r\n4. 合适的缓存策略。\r\n\r\n## 最佳实践\r\n1. **减少DNS查找**：每次主机名的解析都需要一次网络往返，从而增加了请求的延迟时间，同时还会阻塞后续的请求。\r\n2. **重用TCP连接**：尽可能的使用持久连接，以消除因TCP握手和慢启动导致的延迟。\r\n3. **减少HTTP重定向**：HTTP重定向需要额外的DNS查询，TCP握手等非常耗时，最佳的重定向次数为0。\r\n4. **压缩传输的资源**：比如Gzip、图片缓存。\r\n5. **使用缓存**：比如HTTP缓存、CDN缓存、Service Worker缓存。\r\n6. **使用CDN内容分发网络**：把数据放在里用户地理位置更近的地方，可以明显减少每次TCP连接的网络延迟，增大吞吐量。\r\n7. **删除没有必要请求的资源**。\r\n8. **在客户端缓存资源**：缓存必要的应用资源，避免每次都重复请求相同的内容，例如多图片下载可以考虑使用缓存。\r\n9. **内容在传输前先压缩**：传输数据之前应该先压缩应用资源，把要传输的字节减少到最小，在压缩的时候确保对每种不同的资源采用最好的压缩手段。\r\n10. **消除不必要的请求开销**：减少请求的HTTP首部数据（比如HTTP Cooki）\r\n11. **并行处理请求和响应**：请求和响应的排队都会导致延迟，可以尝试并行的处理请求和响应（利用多个HTTP1.1连接实现并行下载，在可能的情况下使用HTTP管道计数）。\r\n12. **针对协议版本采取优化措施**：例如升级到HTTP2.0。\r\n13. **根据需要采用服务端渲染方式**：这种方式可以解决SPA应用首屏渲染慢的问题。\r\n14. **采用预渲染的方式加速静态页面**：页面渲染的极致性能，比较适合静态页面。"
    },
    {
      "id": "/一篇文章搞定几乎所有TCPUDP面试题",
      "metadata": {
        "permalink": "/blog/一篇文章搞定几乎所有TCPUDP面试题",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/一篇文章搞定几乎所有TCPUDP面试题.md",
        "source": "@site/blog\\一篇文章搞定几乎所有TCPUDP面试题.md",
        "title": "一篇文章搞定几乎所有TCP/UDP面试题",
        "description": "无论是大厂面试还是小厂面试，以及平时工作学习中TCP/UDP协议都是我们绕不开的话题，本文的行文顺序为什么会是这样的？这是按照真实出现的面试题目来进行分章节的，也就是说每一个小标题都是一道面试题。本次让我们一起下定决心将这个问题彻底解决，加油！",
        "date": "2021-09-21T00:00:00.000Z",
        "formattedDate": "2021年9月21日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 28.315,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "一篇文章搞定几乎所有TCP/UDP面试题",
          "date": "2021-9-21",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "优化HTTP请求和响应的方法",
          "permalink": "/blog/优化HTTP请求和响应的方法"
        },
        "nextItem": {
          "title": "二刷--两数相加",
          "permalink": "/blog/二刷--两数相加"
        }
      },
      "content": ">无论是大厂面试还是小厂面试，以及平时工作学习中TCP/UDP协议都是我们绕不开的话题，本文的行文顺序为什么会是这样的？这是按照真实出现的面试题目来进行分章节的，也就是说每一个小标题都是一道面试题。本次让我们一起下定决心将这个问题彻底解决，加油！\r\n\r\n## 一、TCP和UDP的区别\r\n>关于TCP和UDP的区别，我们可以考虑从以下六个维度出发进行阐述。\r\n\r\n1. 是否连接\r\n    * TCP是面向连接的，UDP是面向无连接的\r\n2. 是否可靠\r\n    * TCP是可靠的，UDP是不可靠的\r\n3. 连接对象的个数\r\n    * TCP只支持一对一通信，而UDP支持一对一、一对多、多对一、多对多通信。\r\n4. 传输方式\r\n    * TCP是面向字节流的，UDP是面向报文的。\r\n5. 首部开销\r\n    * TCP首部开销大，最小20字节，但是UDP首部仅8字节。\r\n6. 应用场景\r\n    * TCP适用于可靠传输的场景比如支付场景，UDP适合实时应用，例如视频会议直播。\r\n\r\n## 二、TCP为什么是可靠的？\r\n>TCP主要靠以下六种机制来保证传输的可靠性。\r\n\r\n### 1. TCP校验和\r\n>TCP校验和是一个端对端的校验和，由发送端计算，然后由接收端进行验证，其目的是为了发现TCP首部和数据在发送端到接收端之间发生的任何改动，如果接收方检测到校验和有差错，则TCP段会被直接丢弃。\r\n\r\n### 2. 确认应答和序列号\r\n>`确认应答`指的是发送端每次发送数据后都会收到接收端的确认应答ACK，发送端只有接收到确认应答ACK之后才会继续发送数据，假如在特定时间内没有收到接收端的确认应答ACK，发送端会重新发送数据。`序列号`机制的存在是为了防止在有网络延迟的情况下发送端不断发送相同数据的情况发生。每当发送端发送数据时，会将序列号放入TCP的首部，然后接收端在序列号的基础上+1生成新的序列号，然后通过ACK传回给发送端，发送端会根据这个序列号来判断是否重新发送之前的数据。\r\n\r\n### 3. 超时重传\r\n>超时重传就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的ACK确认应答报文，就会重发该数据。\r\n\r\n### 4. 连接管理\r\n>连接管理主要是指的三次握手和四次挥手，详细的情况请看本文的第四部分。\r\n\r\n### 5. 流量控制\r\n>流量控制的目的是控制发送端的发送速度，使其按照接收端的数据处理速度来发送数据，避免接收端处理不过来，产生丢包或网络拥塞，TCP实现流量控制的关键是滑动窗口，发送端和接收端均有一个滑动窗口对应一个缓冲区，记录当前发送或接收到的数据，接收端会在返回的ACK报文中包含自己可用于接收数据的缓冲区的大小，在TCP的报文首部里用window表示，发送端发送的数据不会超过window的大小。\r\n\r\n\r\n### 6. 拥塞控制\r\n#### 问题1：为什么要有拥塞控制？\r\n>如果网络出现拥堵，此时TCP还在继续重传数据，就会加重网络的负担，会导致更大的延迟以及更多的丢包。所以TCP为了避免这一现现象就设计了拥塞控制，目的就是避免发送方的数据填满整个网络。\r\n\r\n#### 问题2：什么是拥塞窗口？\r\n>上文我们提到了拥塞控制是为了避免发送发的数据填满整个网络，所以我们需要调节发送方发送的数据量，定义了一个叫做拥塞窗口的概念。\r\n\r\n>概念：拥塞窗口cwnd是发送方维护的一个状态量，它会根据网络的拥塞程度动态变化，有了拥塞窗口之后意味着发送窗口只能是拥塞窗口和接收窗口之间的最小值。\r\n\r\n* 拥塞窗口cwnd的变化规则：\r\n\r\n1. 只要网络中没有出现拥塞，cwnd就会增大。\r\n2. 一旦网络中出现拥塞，cwnd就会减少。\r\n\r\n>只要发送方没有在对丁的时间内接收到ACK确认应答报文就认为网络中出现了拥塞。\r\n\r\n#### 问题3：拥塞控制的主要算法都有哪些？\r\n\r\n1. 慢启动\r\n\r\n>慢启动指的是发送方每收到一个ACK，拥塞窗口cwnd的大小就会+1.当拥塞窗口大于等于慢启动门限的时候就会启动拥塞避免算法。慢启动的增长速率为指数增长。\r\n\r\n2. 拥塞避免\r\n* 拥塞避免的规则\r\n\r\n> 每收到一个ACK确认，cwnd增加1/cwnd。\r\n\r\n* 例子\r\n\r\n>假如慢启动门限的值为16，当收到16个ACK确认的时候，cwnd才增加1。\r\n\r\n* 拥塞避免算法的意义\r\n\r\n>将原本慢启动算法的指数增长变为了线性增长，降低了增长速度。但是这样增长着还是会进入拥塞状态，此时就会进行重传，然后进入拥塞发生的情况。\r\n\r\n3. 拥塞发生\r\n>当网络发生拥塞的时候会启动重传机制，重传机制包括超时重传和快速重传，针对这两种重传方式有两种不同的拥塞发生算法。\r\n\r\n* 针对超时重传的拥塞发生算法\r\n\r\n>慢启动门限ssthresh变为cwnd/2,然后将cwnd置为1。然后重新开始慢启动，这种方式会突然减少数据流，造成网络卡顿。\r\n\r\n* 针对快速重传的拥塞发生算法\r\n\r\n>当接收方发现丢了一个包的时候，会发送三次前一个包的ACK，当发送端收到这三个ACK的时候，就会启动快速重传，不必等待超时重传。此时cwnd变为原来的一半，然后慢启动门限也等于这个cwnd,然后开始快速恢复算法。\r\n\r\n* 快速恢复算法的规则\r\n\r\n>拥塞窗口cwnd = 慢启动门限ssthresh + 3(之所以加3是因为发送端收到三个ACK确认报文，表明网络中少了三个报文，所以拥塞窗口可以+3),然后重传丢失的数据包，如果收到重复的ACK，cwnd+1,如果收到新的ACK，将cwnd置为原本的慢启动门限值，表明丢失的报文都已经收到，恢复过程已经结束，可以再次进入拥塞避免状态了。\r\n\r\n\r\n#### 拥塞控制的实例图\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/af9fdb6043138f5e0fc39883c1726a88.png)\r\n\r\n\r\n## 三、什么是滑动窗口？\r\n### 1. 为什么要有滑动窗口？\r\n>当发送方一次性发送过多的数据给接收端，接收端是接收不过来的，所以发送端发送数据时必须限定在一定的容量内，这就是为什么要设置滑动窗口的原因（滑动窗口是一种流量控制策略，接收端告诉发送端一次最多可以发送多少数据）。\r\n\r\n### 2. 滑动窗口中的四个基本概念\r\n* 发送方发送缓冲区内的数据可以被分为下面的四类：\r\n1. 已发送并收到ACK确认的数据。\r\n2. 已发送但未收到ACK确认的数据。\r\n3. 允许发送当尚未发送的数据。\r\n4. 发送窗口外发送缓存区内暂时不允许发送的数据。\r\n\r\n### 3. 窗口滑动的移动规则\r\n* 接收端在未接收到接收窗口最左边的数据时是不会发送ACK确认包的,直到最左边接收到数据才会发送ACK确认包并向右移动。\r\n* 发送端在未收到发送窗口最左边的数据的ACK确认包时也是不会向右移动的。发送端根据自己收到的最大的ACK序号向右移动。\r\n\r\n### 4. 发送方的发送窗口和接收方的接收窗口总是一样大的吗？\r\n>在同一时刻并不是，因为发送方可能根据当时的网络情况适当改变自己的发送窗口的尺寸，并且网络传送窗口值有一定的时延。\r\n\r\n### 5. 窗口边沿的三种移动方式\r\n* 窗口合拢：指的是窗口左边沿向右边沿靠近，这种现象代表左边的数据被发送并确认。\r\n* 窗口收缩：指的是窗口右边沿向左移动，这种现象可能代表的是接收端通知发送端窗口变小。\r\n* 窗口张开：指的是窗口右边沿向右移动，这种现象代表了接收方读取了缓冲区里的数据。\r\n\r\n## 四、TCP的三次握手与四次挥手\r\n### 问题1. 为什么要进行三次握手？\r\n>因为TCP是面向连接的协议，所以使用TCP前必须先建立连接，而建立连接是通过三次握手来进行的。\r\n\r\n### 问题2：三次握手的流程和状态变迁\r\n* 刚开始时，客户端和服务端都处于closed状态，先是服务端主动监听某个端口，处于listen状态。\r\n\r\n* 第一次握手：发送SYN报文。客户端会随机初始化一个序号x，然后将此序号置于TCP首部的序号字段中，然后把SYN标志置为1，然后把这个SYN报文发送给服务端，表示向服务端发起连接，该报文不包含应用层的数据，之后客户端处于SYN-SENT状态。\r\n\r\n* 第二次握手：发送SYN+ACK报文。服务端收到客户端的SYN报文后，服务端也会随机初始化一个序号y，这个y也是放入TCP首部的序号字段中，然后把TCP首部的确认应答号(ack)字段填入x+1，接着把SYN和ACK标志置为1，最后把该报文发送给客户端，该报文也不包含应用层数据。之后服务端处于SYN-RCVD状态。\r\n\r\n* 第三次握手：发送ACK报文。客户端收到服务端报文后，会将TCP首部的ACK标志位置为1，确认应答号ack置为y+1,序号置为x+1，然后把这个报文发送给服务端。这次报文可以携带应用层的数据，之后客户端处于established状态，服务器收到这个报文后也会进入established状态。\r\n\r\n>下图是博主绘制的TCP三次握手的流程图和状态变迁图，值得背诵。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/9ffb8e813b8c7643258cc12c5db3bfbc.png)\r\n\r\n### 问题3：为什么是三次握手而不是二次或者四次？\r\n* 常见不完整解释：三次握手可以确保通信的双方都具有收发数据的能力。\r\n\r\n>仅仅通过上面的解释1来回答面试官的问题是远远不够的，我们还需要给出下面的解释。\r\n* 正确解释：(三次握手可以避免以下问题)\r\n1. 三次握手可以避免历史连接。如果客户端发出连接请求，但是这个请求在传输中丢失了，客户端又重发了一遍，这一次收到了确认并建立了连接，数据传输完毕之后，关闭了这个连接，但是之前丢失的这个连接请求因为网络延迟的原因再次到达服务器端，服务器端以为是一个新的连接，于是向客户端发送确认报文段，同意连接。如果是二次握手，此时就已经建立了连接，但是客户端会忽略服务端发来的确认报文段，也不发送数据，但是服务器端却在一直等待来自客户端的数据，这样会造成数据浪费。如果是三次握手的话，当客户端收到历史连接的时候会发出终止的报文来终止连接。\r\n2. 三次握手可以同步双方初始序列号。TCP通信的双方都要确保初始序列号能被可靠的同步。这个序列号可以标识发送出去的数据包中哪些是已经被对方收到的。如果是二次握手的话只能保证一方的序列号被正确的接收，难以保证同步。\r\n\r\n### 问题4：四次挥手的过程和状态改变\r\n* 断开连接之前，双方都处于连接状态也就是establised状态。\r\n* 第一次挥手：客户端发送一个FIN位置为1，序号seq为x的FIN报文，然后客户端进入FIN_WAIT_1状态。\r\n* 第二次挥手：服务端收到客户端的FIN报文后，会给客户端发送一个ACK报文，表示已经收到了，然后进入CLOSED_WAIT状态。客户端收到这个报文后进入FIN_WAIT2状态。\r\n* 第三次挥手：等到服务端处理完数据之后，也会向客户端发送一个FIN报文，然后服务端进入LAST_ACK状态。\r\n* 第四次挥手：客户端收到服务端发送过来的FIN报文，会向服务端发送一个ACK报文，表示自己收到了，然后客户端进入TIME_WAIT状态，服务端收到这个ACK报文之后就会进入CLOSED状态。至此服务器端关闭结束，经过2MSL之后客户端进入CLOSED状态，也关闭了。\r\n\r\n>下图是博主绘制的四次挥手的流程图和状态改变。\r\n\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/274365a670199dfd24a842682524a17d.png)\r\n\r\n### 问题5：为什么是四次挥手而不是三次？\r\n>原因：服务端收到客户端发送的FIN包后，可能还有没有发送完的数据，所以先回复一个ACK确认包，表示已经收到了FIN包，等服务端将剩余数据发送完毕之后再发送一个FIN包给客户端表示已经没有要发送的数据了，可以结束了连接了。所以是四次挥手而不是三次。\r\n\r\n### 问题6：如果客户端没有收到服务端返回的FIN包，客户端会一直等待吗？\r\n>答：并不会，因为如果没有收到服务器端的FIN包，会让客户端一直处于FIN_WAIT2状态，FIN_WAIT2没有时间限制，如果本端进入FIN_WAIT2如果，对端失去响应，本端也不会一直卡在FIN_WAIT2状态，因为还可以使用TCP keepalive计时器避免此问题。\r\n\r\n### 问题7：什么是2MSL？TIME_WAIT状态为什么要设置2MSL？\r\n* 1MSL表示报文的最大生存时间，超过这个时间的报文将被丢弃。\r\n>之所以TIME_WAIT要设置为2MSL是因为第四次挥手的这个ACK确认包，服务器端未必能收到，如果收不到这个包进行重传的话，一来一回最多2MSL的时间，如果在这个时间都没有收到服务端的重传说明服务端已经收到了这个包，此时客户端就可以正常关闭了。\r\n\r\n## 五、TCP/IP的四层网络模型\r\n>关于TCP/IP的四层网络模型主要包括以下的四个方面。\r\n\r\n* 应用层\r\n* 传输层\r\n* 网络层\r\n* 网络接口层\r\n\r\n## 六、TCP的拆包与粘包问题\r\n### 问题1：TCP为什么要进行拆包？（TCP是如何进行拆包的？）\r\n1. 要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。\r\n2. 待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。\r\n\r\n### 问题2：什么是粘包？\r\n>TCP是面向字节流的协议，不会发送数据包，这个数据包是网络层的概念，应用程序交付给TCP的是结构化的数据，TCP会对这个结构化的数据做流式传输，流式传输最大的问题就是没有边界，没有边界就会造成数据粘在一起，这种粘在一起就是粘包，具体的概念可以理解为发送方发送的若干个数据包到接收方接收时粘在一起，从接收缓冲区看后一包数据的头紧接着前一包数据的尾。\r\n\r\n### 问题3：什么情况下会发生粘包？\r\n1. 要发送的数据小于TCP发送缓冲区大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。\r\n2. 接收数据的应用层没有及时读取接收缓冲区中的数据，将发生粘包。\r\n3. 由于TCP是有连接复用机制的，多个进程使用一个TCP连接，多种不同结构的数据进入TCP的流式传输也可能造成粘包现象。\r\n4. Nagle算法可能导致粘包，因为Nagle算法会将多个分组拼装为一个数据段发送出去，如果没有处理好边界，也可能会发生粘包问题。\r\n\r\n### 问题4：如何解决粘包问题？\r\n1. 发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首都的长度字段，便知道每一个数据包的实际长度了。\r\n2. 发送端将每个数据包封装为固定长度，这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。\r\n3. 在数据包之间设置边界，如添加特殊符号。\r\n\r\n\r\n\r\n## 七、TCP与HTTP的区别\r\n1. TCP是传输层协议，定义的是数据传输和连接方式的规范，HTTP是应用层协议，定义的是传输数据的内容的规范。\r\n2. HTTP是无状态的短连接，TCP是有状态的长链接。\r\n3. HTTP协议是在TCP协议之上建立的，HTTP在发起请求时通过TCP协议建立起连接服务器的通道。\r\n\r\n>注意：从HTTP/1.1版本起，默认开启了Keep-Alive，保持连接性，当一个网页打开后，客户端和服务器端之间用于传输HTTP数据的TCP连接不会被关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立好的Keep-Alive，但是这个Keep-Alive会有一个保持的时间。\r\n\r\n## 八、流量控制和拥塞控制的区别？\r\n>流量控制是由接收端控制的，拥塞控制是由发送端控制的，最终都是控制发送端的发送速率。\r\n\r\n\r\n## 九、TCP/UDP的报文格式\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/672f3ac62903f8ef8e2e6768a494287c.png)\r\n\r\n>下面对UDP报文格式字段进行解释\r\n\r\n* 源端口：这个字段是UDP报文头的前16位，代表的是发送这个数据报的应用程序所使用的UDP端口，这个字段是可选的，接收端根据这个字段发送响应。\r\n* 目的端口：接收端计算机上UDP应用程序使用的端口。\r\n* 长度：该字段也占据16位，表示的是UDP数据包的长度，包含UDP报文头和UDP数据长度。\r\n* UDP校验和：可以检验数据在传输中是否被损坏。\r\n\r\n## 十、UDP应该如何解决可靠性的问题？\r\n>UDP不可靠的原因在于传输层无法保证数据的可靠传输，所以我们可以通过应用层来实现可靠传输，例如在应用层实现超时重传，提供确认序列号，滑动窗口等。\r\n\r\n\r\n## 十一、Nagle算法与延迟确认机制\r\n### 问题1：什么是Nagle算法？为什么要设置Nagle算法？\r\n>TCP总是希望尽可能的发送足够大的数据，Nagle算法就是为了实现尽可能的发送大块数据，避免网络中充斥着许多小数据块。Nagle算法的基本定义是任意时刻，最多只能有一个未被确认的小段，这个小段指的是小于MSS尺寸的数据块，所谓未被确认是指一个数据块发送出去之后没有收到对方的ACK确认。\r\n\r\n### 问题2：Nagle算法的规则\r\n1. 如果数据报的长度达到了MSS，则允许发送。\r\n2. 如果数据包中包含有FIN，则允许发送。\r\n3. 如果设置了TCP_NODELAY选项，则允许发送。\r\n4. 如果没有设置TCP_CORK选项，且所有发出去的小数据包都被确认了，则允许发送。\r\n5. 如果上述四个条件都没有得到满足，但是发生了超时则立即发送。\r\n\r\n### 问题3：什么是延迟确认机制？\r\n>TCP的接收端在收到报文后，不会立即发送ACK，而是等待一段时间发送ack，以便将ack和要发送的数据一起发送给发送端，同时这样做可以合并ACK，比如连续收到了两个TCP包，只要回复最终的ACK即可。但是这个延迟不会无限延长，在何时发送ACK时有如下规定：\r\n\r\n* 当有响应数据要发送时，ack会随着数据一块发送。\r\n* 如果此时没有响应数据要发送，会有一个延迟时间范围，如果在这个延迟时间范围内有响应数据要发送则随着这个数据一起发送，超过了这个时间范围则直接发送。\r\n* 如果在延迟期间内，新的数据到了，则直接发送ACK。\r\n\r\n\r\n\r\n## 参考资料\r\n* [TCP是如何实现可靠连接的？](https://segmentfault.com/a/1190000018592072)\r\n* [30张图解： TCP 重传、滑动窗口、流量控制、拥塞控制](https://www.cnblogs.com/xiaolincoding/p/12732052.html))\r\n* [蚂蚁金服面试 TCP中的滑动窗口 | 掘金技术征文](https://juejin.cn/post/6844904105211592712)\r\n* [没有比这篇讲得更详细了：TCP协议面试10连问，总会用得到，建议收藏](https://github.com/Obsession-kai/Indoor_Positioning_Algorithm.eg.landmarc/issues/2)\r\n* [强烈推荐：35 张图解：被问千百遍的 TCP 三次握手和四次挥手面试题](https://www.cnblogs.com/xiaolincoding/p/12638546.html)\r\n* [计算机网络第35讲-TCP的拥塞控制（计算机网络简明教程及仿真实验）](https://www.bilibili.com/video/BV1L4411a7RN?from=search&seid=896317388929706020)\r\n* [一文走进 HTTP 与 TCP 协议，它们的区别与联系](https://github.com/sisterAn/blog/issues/96)\r\n* [【计算机网络】TCP 的流量控制与拥塞控制](https://imageslr.com/2020/tcp-flow-control-congestion.html)"
    },
    {
      "id": "/二刷--两数相加",
      "metadata": {
        "permalink": "/blog/二刷--两数相加",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/二刷--两数相加.md",
        "source": "@site/blog\\二刷--两数相加.md",
        "title": "二刷--两数相加",
        "description": "题目描述",
        "date": "2021-09-20T00:00:00.000Z",
        "formattedDate": "2021年9月20日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.455,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "二刷--两数相加",
          "date": "2021-9-20",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "一篇文章搞定几乎所有TCP/UDP面试题",
          "permalink": "/blog/一篇文章搞定几乎所有TCPUDP面试题"
        },
        "nextItem": {
          "title": "因缺少绝对路径引发的部署血案",
          "permalink": "/blog/因缺少绝对路径引发的部署血案"
        }
      },
      "content": "## 题目描述\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/87338ab025eba27b658c03eca30e6d11.png)\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/694510a3a4d96337b6c41412c9f65dd2.png)\r\n\r\n## 解题思路\r\n1. 定义一个结果链表，用于存储最终的结果。\r\n2. 定义一个临时节点保存结果链表的头结点。\r\n3. 定义进位。\r\n4. 只要进位或者l1或者l2，只要任意一个不为空都进入循环。\r\n5. 循环中：将对应位的值和进位加一起，如果进位大于10，进位变为1，反之变为0。\r\n\r\n## 完整代码\r\n```js\r\nvar addTwoNumbers = function (l1, l2) {\r\n    // 创建一个结果链表\r\n    let result = new ListNode('-');\r\n    // 用一个临时变量保存链表的头结点\r\n    let temp = result;\r\n    // 定义进位\r\n    let addten = 0;\r\n\r\n    // 只要l1 或者 l2 或者 进位任意一个不为空 都要进入循环\r\n    while (l1 || l2 || addten) {\r\n        let a = l1 ? l1.val : 0;\r\n        let b = l2 ? l2.val : 0;\r\n        let sum = a + b + addten;\r\n        addten = sum >= 10 ? 1 : 0; \r\n        result.next = new ListNode((sum % 10));\r\n        result = result.next;\r\n        if (l1) l1 = l1.next;\r\n        if (l2) l2 = l2.next;\r\n    }\r\n    return temp.next\r\n};\r\n```\r\n\r\n## 题目反思\r\n>本题属于常规的链表类型的题，只需要注意进位这一问题即可，多刷多练。"
    },
    {
      "id": "/因缺少绝对路径引发的部署血案",
      "metadata": {
        "permalink": "/blog/因缺少绝对路径引发的部署血案",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/因缺少绝对路径引发的部署血案.md",
        "source": "@site/blog\\因缺少绝对路径引发的部署血案.md",
        "title": "因缺少绝对路径引发的部署血案",
        "description": "问题描述",
        "date": "2021-09-19T00:00:00.000Z",
        "formattedDate": "2021年9月19日",
        "tags": [
          {
            "label": "debug",
            "permalink": "/blog/tags/debug"
          }
        ],
        "readingTime": 2.555,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "因缺少绝对路径引发的部署血案",
          "date": "2021-9-19",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "debug",
          "tags": [
            "debug"
          ]
        },
        "prevItem": {
          "title": "二刷--两数相加",
          "permalink": "/blog/二刷--两数相加"
        },
        "nextItem": {
          "title": "Next.js下配置babel以支持Css-In-Js",
          "permalink": "/blog/Next.js下配置babel以支持Css-In-Js"
        }
      },
      "content": "## 问题描述\r\n>博主在学习Next应用的时候，使用express作为后台，部署在本地一切正常，但是部署在字节的轻服务上便出现如下错误。\r\n\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/bced536b66077d107c212e64d746d08d.png)\r\n\r\n## 解决过程\r\n\r\n### 尝试1：尝试是否是跨域问题\r\n>刚开始遇到这个错误，我判断可能是跨域问题，后来经排查不是，因为如果是跨域问题，自定义的路由不可能被访问成功，但是我通过postman访问自定义路由是能够成功的，说明不是跨域的问题，而且我已经配置了下面的语句。\r\n\r\n```js\r\napp.use(cors());  // 解决跨域\r\n```\r\n\r\n### 尝试2：修改静态资源的路径\r\n>因为只有静态资源无法访问，说明可能是配置静态资源的中间件出来问题，所以我刚开始在网上找到了这样的一个解决方案，即下面的语句。\r\n\r\n```js\r\napp.use(express.static(path.join(__dirname, 'build', 'public')));\r\n```\r\n\r\n>上面的解决也是无效，后来我咨询了字节轻服务的相关工程师，原来是因为path.join会拼接字符串，但是我的路径中并没有build这个文件夹，所以报错，我原本还以为这两个文件夹是并列关系，原来是拼接关系。\r\n\r\n### 尝试3：修改为绝对路径（最终解决方案）\r\n>在字节轻服务工程师的帮助下，我才用了绝对路径的方式来公开静态资源，这一次成功了~感谢字节轻服务的工程师。\r\n\r\n```js\r\napp.use(express.static(path.join(__dirname, 'public')));\r\n```\r\n\r\n## 问题原因\r\n>在express公开静态资源的时候，如果不加入绝对路径，会按照云平台中的node执行的位置去找，自然会出现找不到的情况，自然会出现404的错误，但是我们如果加上了绝对路径dirname则会避免这个问题，直接找到这个资源的绝对路径。\r\n\r\n## 参考资料\r\n* [在 Express 中提供静态文件](https://expressjs.com/zh-cn/starter/static-files.html)\r\n* [Node.js 中 __dirname 和 ./ 的区别](https://blog.csdn.net/zsensei/article/details/79094714)"
    },
    {
      "id": "/Next.js下配置babel以支持Css-In-Js",
      "metadata": {
        "permalink": "/blog/Next.js下配置babel以支持Css-In-Js",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Next.js下配置babel以支持Css-In-Js.md",
        "source": "@site/blog\\Next.js下配置babel以支持Css-In-Js.md",
        "title": "Next.js下配置babel以支持Css-In-Js",
        "description": "由于Next.js和Emotion.js的升级，以往的babel配置不再适用于最新版本，如果还使用以前的babel配置则会报下面的错误",
        "date": "2021-09-18T00:00:00.000Z",
        "formattedDate": "2021年9月18日",
        "tags": [
          {
            "label": "Next",
            "permalink": "/blog/tags/next"
          }
        ],
        "readingTime": 0.87,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Next.js下配置babel以支持Css-In-Js",
          "date": "2021-9-18",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Next",
          "tags": [
            "Next"
          ]
        },
        "prevItem": {
          "title": "因缺少绝对路径引发的部署血案",
          "permalink": "/blog/因缺少绝对路径引发的部署血案"
        },
        "nextItem": {
          "title": "二刷--斐波那契数列",
          "permalink": "/blog/二刷--斐波那契数列"
        }
      },
      "content": ">由于Next.js和Emotion.js的升级，以往的babel配置不再适用于最新版本，如果还使用以前的babel配置则会报下面的错误\r\n\r\n## 错误提示\r\n* React is not defined.\r\n\r\n>出现上面的错误，并不是没有引入react，而是在项目代码中想要使用emotion等css-in-js库，但是没有进行正确的配置，导致的错误，这个错误很难排查，主要是官方也没有给出解决方案。\r\n\r\n## 解决方案\r\n* 在项目的跟目录下创建.babelrc，并写入下面的代码。\r\n\r\n```shell\r\n{\r\n    \"presets\": [\r\n        [\r\n            \"next/babel\",\r\n            {\r\n                \"preset-react\": {\r\n                    \"runtime\": \"automatic\",\r\n                    \"importSource\": \"@emotion/react\"\r\n                }\r\n            }\r\n        ]\r\n    ],\r\n    \"plugins\": [\r\n        \"@emotion/babel-plugin\"\r\n    ]\r\n}\r\n```\r\n\r\n\r\n## 参考链接\r\n* [Github issue](https://github.com/nrwl/nx/issues/6778)"
    },
    {
      "id": "/二刷--斐波那契数列",
      "metadata": {
        "permalink": "/blog/二刷--斐波那契数列",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/二刷--斐波那契数列.md",
        "source": "@site/blog\\二刷--斐波那契数列.md",
        "title": "二刷--斐波那契数列",
        "description": "这是博主第二次刷这个题目，经典题目的经典算法，斐波那契数列可以采用递归来进行求解，但是如果要求的数字比较大的情况下，会出现重复计算的问题，复杂度比较高，所以我们本次采用的是非递归的方法，极大的降低了时间和空间复杂度。",
        "date": "2021-09-17T00:00:00.000Z",
        "formattedDate": "2021年9月17日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 1.44,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "二刷--斐波那契数列",
          "date": "2021-9-17",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "Next.js下配置babel以支持Css-In-Js",
          "permalink": "/blog/Next.js下配置babel以支持Css-In-Js"
        },
        "nextItem": {
          "title": "一篇文章掌握Next.js的核心要点",
          "permalink": "/blog/一篇文章掌握Next.js的核心要点"
        }
      },
      "content": ">这是博主第二次刷这个题目，经典题目的经典算法，斐波那契数列可以采用递归来进行求解，但是如果要求的数字比较大的情况下，会出现重复计算的问题，复杂度比较高，所以我们本次采用的是非递归的方法，极大的降低了时间和空间复杂度。\r\n\r\n## 题目描述\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/9d778307073545fbacfb514ebbc3cdf7.png)\r\n\r\n## 解题思路\r\n* 如果目标值小于等于1，则直接返回。\r\n* 如果目标值大于等于1，则定义两个临时变量保存前两个数字。\r\n* 通过循环的方法不断更新这两个值，即可求出最终的解。\r\n\r\n## AC代码\r\n>由于leetcode上需要进行取余计算，我们只需要给结果去个余即可。\r\n\r\n```js\r\nvar fib = function (n) {\r\n    if (n <= 1) return n;\r\n\r\n    let prev1 = 1;\r\n    let prev2 = 0;\r\n    let result = 0;\r\n\r\n    for (let i = 2; i <= n; i++) {\r\n        result = (prev1 + prev2) % 1000000007;\r\n        prev2 = prev1;\r\n        prev1 = result;\r\n    }\r\n    return result;\r\n};\r\n```\r\n\r\n## 题目反思\r\n* 学会使用非递归的方法求解斐波那契数列来降低算法的复杂度。"
    },
    {
      "id": "/一篇文章掌握Next.js的核心要点",
      "metadata": {
        "permalink": "/blog/一篇文章掌握Next.js的核心要点",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/一篇文章掌握Next.js的核心要点.md",
        "source": "@site/blog\\一篇文章掌握Next.js的核心要点.md",
        "title": "一篇文章掌握Next.js的核心要点",
        "description": "Next.js整体介绍",
        "date": "2021-09-16T00:00:00.000Z",
        "formattedDate": "2021年9月16日",
        "tags": [
          {
            "label": "Next",
            "permalink": "/blog/tags/next"
          }
        ],
        "readingTime": 11.825,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "一篇文章掌握Next.js的核心要点",
          "date": "2021-9-16",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Next",
          "tags": [
            "Next"
          ]
        },
        "prevItem": {
          "title": "二刷--斐波那契数列",
          "permalink": "/blog/二刷--斐波那契数列"
        },
        "nextItem": {
          "title": "LeetCode——长度最小的子数组（滑动窗口）",
          "permalink": "/blog/LeetCode——长度最小的子数组（滑动窗口）"
        }
      },
      "content": "## Next.js整体介绍\r\n>Next.js是React服务端渲染应用框架，用于构建SEO友好的SPA应用。\r\n\r\n1. 支持两种渲染方式，静态生成和服务器端渲染。\r\n2. 基于页面的路由系统，路由零配置。\r\n3. 自动代码拆分，优化页面加载速度。\r\n4. 支持静态导出，可将应用导出为静态网站。\r\n5. 内置CSS-in-JS库styled-jsx\r\n6. 方案成熟，可用于生产环境，世界许多公司都在使用。\r\n7. 应用部署简单，拥有专属部署环境vercel，也可以部署在其他环境。\r\n\r\n## 创建Next.js项目\r\n\r\n* 创建\r\n```shell\r\nnpm init next-app mynext\r\n```\r\n\r\n* 运行\r\n```shell\r\nnpm run dev\r\n```\r\n\r\n* 访问\r\n```shell\r\nlocalhost:3000\r\n```\r\n\r\n>出现下面的页面表示项目初始化成功。\r\n\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/81e395da6d55d73ce527f644ae4132fc.png)\r\n\r\n\r\n## 基于页面的路由系统\r\n### 创建页面\r\n\r\n* 在Next.js中，页面是被放置在pages文件夹中的React组件。\r\n* 组件需要被默认导出\r\n* 组件文件中不需要引入react\r\n* 页面地址与文件地址是对应的关系\r\n\r\n>创建一个list页面\r\n\r\n1. 在pages文件夹下创建一个list.js\r\n```js\r\nexport default function List() {\r\n    return (\r\n        <div>\r\n            <h1>Hello,Next!</h1>\r\n        </div>\r\n    )\r\n}\r\n```\r\n\r\n2. 在路由下访问下面的地址即可\r\n```shell\r\nhttp://localhost:3000/list\r\n```\r\n\r\n\r\n### 页面跳转\r\n>注意事项\r\n\r\n* Link组件默认使用JavaScript进行页面跳转，即SPA形式的跳转。\r\n* 如果浏览器中JavaScript被禁用，则使用链接跳转\r\n* Link组件中不应添加除href属性以外的属性，其余属性添加到a标签上\r\n* Link组件通过预取功能自动优化应用程序以获得最佳性能。\r\n\r\n>从主页跳转到list页面的代码(默认去pages文件夹下找list)\r\n\r\n```js\r\nimport Link from 'next/link'\r\nexport default function Home() {\r\n    return (\r\n        <div >\r\n            <Link href=\"/list\"><a>List Page</a></Link>\r\n        </div>\r\n    )\r\n}\r\n```\r\n\r\n## Next.js应用中的静态访问\r\n>应用程序根目录中的public文件夹用于提供静态资源，可以通过以下形式进行访问：（下面的/就代表了public这个文件夹）\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/9ca8bf2aaed1eb6b85bf8f46248d3acc.png)\r\n\r\n>下面的代码将访问public文件夹下的CSS.png这个图片\r\n\r\n```js\r\n<img src=\"/images/CSS.png\" alt=\"\" />\r\n```\r\n\r\n## 修改页面中的元数据\r\n>通过Head组件修改元数据。Head组件的主要作用是将html的标签添加到页面的head中。\r\n\r\n* Home.js\r\n```js\r\nimport Link from 'next/link'\r\nimport Head from 'next/head'\r\nexport default function Home() {\r\n    return (\r\n        <div >\r\n            <Head>\r\n                <title>My Next</title>\r\n            </Head>\r\n            <Link href=\"/list\"><a>List Page</a></Link>\r\n            <img src=\"/images/CSS.png\" alt=\"\" />\r\n        </div>\r\n    )\r\n}\r\n```\r\n\r\n* list.js\r\n```js\r\nimport Head from 'next/head'\r\nexport default function List() {\r\n    return (\r\n        <div>\r\n            <Head>\r\n                <title>List Page</title>\r\n            </Head>\r\n            <h1>Hello,Next!</h1>\r\n        </div>\r\n    )\r\n}\r\n```\r\n## 添加样式的方式\r\n### styled-jsx\r\n\r\n>在next中内置了styled-jsx,它是一个CSS-in-JS库，允许在React组件中编写CSS，CSS仅作用于组件内部。\r\n\r\n* 修改跳转到list页面的链接样式\r\n```js\r\nimport Link from 'next/link'\r\nimport Head from 'next/head'\r\nexport default function Home() {\r\n    return (\r\n        <div >\r\n            <Head>\r\n                <title>My Next</title>\r\n            </Head>\r\n            <Link href=\"/list\"><a className=\"demo\" >List Page</a></Link>\r\n            <style jsx>\r\n                {`\r\n                    .demo {\r\n                        color: red;\r\n                    }\r\n                `}\r\n            </style>\r\n        </div>\r\n    )\r\n}\r\n```\r\n\r\n### CSS样式\r\n#### CSS模块\r\n\r\n>通过使用CSS模块功能，允许将组件的CSS样式编写在单独的CSS文件中，CSS模块约定样式文件的名称必须`组件文件名称.module.css`\r\n\r\n```js\r\n# list.js\r\nimport Head from 'next/head'\r\nimport styles from './list.module.css';\r\nexport default function List() {\r\n    return (\r\n        <div>\r\n            <Head>\r\n                <title>List Page</title>\r\n            </Head>\r\n            <h1 className={styles.demo}>Hello,Next!</h1>\r\n        </div>\r\n    )\r\n}\r\n\r\n# list.module.css\r\n.demo {\r\n    color: blueviolet;\r\n}\r\n```\r\n\r\n#### 添加全局样式\r\n1. 在pages文件夹下新建_app.js文件并加入如下代码。\r\n2. 在项目根目录下创建styles文件夹，并在其中创建global.css\r\n3. 在_app.js中通过import引入global.css\r\n4. 重新启动开发服务器\r\n\r\n>注意：在_app.js中需要加入下面的固定代码\r\n\r\n```js\r\nexport default function App({ Component, pageProps }) {\r\n    return <Component {...pageProps} />\r\n}\r\n```\r\n\r\n## 预渲染\r\n>什么是预渲染？\r\n\r\n* 预渲染是指数据和HTML的拼接在服务器端提前完成\r\n* 预渲染可以使SEO更加友好\r\n* 预渲染会带来更好的用户体验，可以无需运行JS即可查看应用程序UI\r\n\r\n>预渲染的两种形式\r\n\r\n* 在Next.js中支持两种形式的预渲染：静态生成和服务器端渲染。\r\n* 静态生成和服务器端渲染是生成HTML树的时机不同。\r\n* 静态生成：静态生成是在构建时生成HTML，以后的每个请求都共用构建时生成好的HTML。\r\n* 服务器端渲染：服务器端渲染是在请求时生成HTML，每个请求都会重新生成HTML。\r\n\r\n>两种预渲染方式的选择\r\n\r\n* Next.js允许开发者为每个页面选择不同的预渲染方式，不同的预渲染方式拥有不同的特点，应根据场景进行渲染。\r\n* 大多数页面建议静态生成。\r\n* 静态生成一次构建，反复使用，访问速度快，因为页面都是事先生成好的。适用场景：营销页面、博客文章、电子商务产品列表、帮助和文档。\r\n* 服务器端渲染访问速度不如静态生成，但是由于每次请求都会重新渲染，适用于数据频繁更新的页面或页面内容随请求变化而变化的页面。\r\n\r\n## 实现静态生成\r\n>无数据和有数据的静态生成。\r\n\r\n* 如果组件不需要再其他地方获取数据，直接进行静态生成。\r\n* 如果组件需要在其他地方获取数据，在构建时next.js会预先获取组件需要的数据，然后再对组件进行静态生成。\r\n\r\n### 无数据的静态生成\r\n\r\n1. 先把.next文件夹删掉\r\n\r\n2. 运行build命令\r\n```shell\r\nnpm run build\r\n```\r\n\r\n### 有数据的静态生成\r\n>通过getStaticProps方法获取组件静态生成时需要的数据，并通过props的方式将数据传递给组件，该方法是一个异步函数，需要在组件内部进行导出，在开发模式下，getStaticProps改为在每个请求上运行。\r\n\r\n```js\r\nimport Head from 'next/head'\r\nimport styles from './list.module.css';\r\nimport { readFile } from 'fs';\r\nimport { promisify } from 'util';\r\nimport { join } from 'path'\r\n\r\nconst read = promisify(readFile);\r\nexport default function List({data}) {\r\n    return (\r\n        <div>\r\n            <Head>\r\n                <title>List Page</title>\r\n            </Head>\r\n            <h1 className={styles.demo}>Hello,Next!</h1>\r\n            <h2>控制台打印的是{data}</h2>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport async function getStaticProps () {\r\n    let data = await read(join(process.cwd(),'pages','_app.js'),'utf-8');\r\n    console.log(data)\r\n    return {\r\n        props: {\r\n            data\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### npm start和npm run dev的区别\r\n* start启动的是生产环境中的代码\r\n* dev启动的是开发环境中的代码\r\n\r\n\r\n### 实现基于动态路由的静态生成\r\n>基于参数为页面组件生成HTML页面，有多少参数就生产多少HTML页面，在构建应用时，先获取用户可以访问的所有路由参数，再根据路由参数获取具体的数据，然后根据数据生成静态HTML。\r\n\r\n1. 创建基于动态路由的页面组件文件，命名时在文件名称外面加上[]，比如[id].js\r\n\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/806d009b5b3aed3d19f93784f8b94e38.png)\r\n\r\n2. 导出异步函数getStaticPaths，用于获取所有用户可以访问的路由参数。\r\n\r\n3. 导出异步函数getStaticProps，用户根据路由参数获取具体的数据。\r\n\r\n>注意：getStaticProps和getStaticPaths只运行在服务器端，永远不会运行在客户端，甚至不会被打包到客户端JavaScript中，意味着这里可以随意些服务端代码，比如查询数据库。\r\n\r\n>[id].js\r\n\r\n```js\r\nexport default function Post({data}) {\r\n    return (\r\n        <div>\r\n            <span>{data.id}</span>\r\n            <span>{data.title}</span>\r\n        </div>\r\n    )\r\n}\r\n\r\n// 返回用户能够访问到的所有的路由参数\r\nexport async function getStaticPaths() {\r\n    return {\r\n        paths: [{params: {id: '1'}},{params: {id: '2'}}],\r\n        fallback: false\r\n    }\r\n}\r\n\r\n// 返回路由参数对应的具体数据\r\nexport async function getStaticProps({params}) {\r\n    const id = params.id;\r\n    let data;\r\n    switch (id) {\r\n        case '1':\r\n            data = {id: \"1\",title: 'Hello'};\r\n            break;\r\n        case '2':\r\n            data = {id: \"2\", title: 'World'};\r\n            break;\r\n        default:\r\n            data = {};\r\n    }\r\n    return {\r\n        props: {\r\n            data\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### fallback选项的作用\r\n>fallback设置为false表示如果用户请求的参数，不在指定参数范围内，则返回404页面，如果这个值是true,表示获取用户请求的数据并生成对应的静态页面。\r\n\r\n>下面是fallback为true时[id].js的代码\r\n\r\n```js\r\nimport { useRouter } from 'next/router'\r\nexport default function Post({data}) {\r\n    const router = useRouter();\r\n    if (router.isFallback) return <div style={{color: 'red'}}>Loading...</div>\r\n    return (\r\n        <div>\r\n            <span>{data.id}</span>\r\n            <span>{data.title}</span>\r\n        </div>\r\n    )\r\n}\r\n\r\n// 返回用户能够访问到的所有的路由参数\r\nexport async function getStaticPaths() {\r\n    return {\r\n        paths: [{params: {id: '1'}},{params: {id: '2'}}],\r\n        fallback: true\r\n    }\r\n}\r\n\r\n// 返回路由参数对应的具体数据\r\nexport async function getStaticProps({params}) {\r\n    const id = params.id;\r\n    let data;\r\n    switch (id) {\r\n        case '1':\r\n            data = {id: \"1\",title: 'Hello'};\r\n            break;\r\n        case '2':\r\n            data = {id: \"2\", title: 'World'};\r\n            break;\r\n        case '3':\r\n            data = {id: '3',title: 'Hello World'};\r\n            break;\r\n        default:\r\n            data = {};\r\n    }\r\n    return {\r\n        props: {\r\n            data\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 自定义404页面\r\n>要创建自定义404页面，需要在pages文件夹中创建404.js文件。\r\n\r\n```js\r\nexport default function Custom404() {\r\n    return (\r\n        <h1>404 Not Found</h1>\r\n    )\r\n}\r\n```\r\n\r\n## API Routers\r\n>API Routers可以理解为接口，客户端向服务端发送请求获取数据的接口，Next.js应用允许React开发者编写服务器端代码创建数据接口。\r\n\r\n### 实现API Routers\r\n1. 在pages/api文件夹中创建API Routes文件，比如user.js\r\n2. 在文件中默认导出请求处理函数，函数有两个参数，req为请求对象，res为响应对象。\r\n3. 访问API Routes: localhost:3000/api/user\r\n\r\n>注意：不要在getStaticProps或getStaticPaths函数中访问API Routers，因为这两个函数就是在服务器端运行的，可以直接写服务器端代码。\r\n\r\n>下面是/pages/api/user.js\r\n\r\n```js\r\nexport default (req, res) => {\r\n    res.send({ name: 'hello' })\r\n}\r\n```"
    },
    {
      "id": "/LeetCode——长度最小的子数组（滑动窗口）",
      "metadata": {
        "permalink": "/blog/LeetCode——长度最小的子数组（滑动窗口）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——长度最小的子数组（滑动窗口）.md",
        "source": "@site/blog\\LeetCode——长度最小的子数组（滑动窗口）.md",
        "title": "LeetCode——长度最小的子数组（滑动窗口）",
        "description": "题目描述",
        "date": "2021-09-15T00:00:00.000Z",
        "formattedDate": "2021年9月15日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 2.685,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——长度最小的子数组（滑动窗口）",
          "date": "2021-9-15",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "一篇文章掌握Next.js的核心要点",
          "permalink": "/blog/一篇文章掌握Next.js的核心要点"
        },
        "nextItem": {
          "title": "搭建next前台开发环境并引入antd",
          "permalink": "/blog/搭建next前台开发环境并引入antd"
        }
      },
      "content": "## 题目描述\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/2d32692e1808cda349a3b753db2a15bd.png)\r\n\r\n## 解题思路\r\n>注意：题目让我们求的是大于等于target的长度最小的子数组，而不是等于。\r\n\r\n>思路：通过滑动窗口的思想，不断更新窗口的最小值。\r\n\r\n### 1：初始化滑动窗口\r\n>主要定义滑动窗口的左边界、右边界、初始最小值、窗口内的和。\r\n\r\n```js\r\n// 定义初始最小值\r\nlet minLen = Infinity;\r\n// 定义滑动窗口的左边界\r\nlet left = 0;\r\n// 定义滑动窗口的右边界\r\nlet right = 0;\r\n// 定义窗口内的和\r\nlet sum = 0;\r\n```\r\n\r\n### 2：核心循环体\r\n>只要右边界没有走到最后就继续循环，首先计算窗口内的和，如果大于等于target，则更新最小长度，然后左移左边界，循环结束再移动右边界。\r\n\r\n```js\r\n// 只要右边界没有走到最后就不终止循环\r\nwhile (right < nums.length) {\r\n\r\n    sum = sum + nums[right];\r\n    // 如果窗口内的和 ≥ target\r\n    while (sum >= target) {\r\n        // 更新窗口的最小长度\r\n        minLen = Math.min(minLen,right-left+1);\r\n        // 更新和\r\n        sum = sum - nums[left];\r\n        left++\r\n    }\r\n    right++;\r\n}\r\n```\r\n\r\n### 3：判断返回\r\n>如果最小长度是无限大，则返回0，反之返回最小长度。\r\n\r\n```js\r\nminLen = minLen === Infinity ? 0 : minLen\r\nreturn minLen\r\n```\r\n\r\n## 完整代码\r\n```js\r\nvar minSubArrayLen = function (target, nums) {\r\n    // 定义初始最小值\r\n    let minLen = Infinity;\r\n    // 定义滑动窗口的左边界\r\n    let left = 0;\r\n    // 定义滑动窗口的右边界\r\n    let right = 0;\r\n    // 定义窗口内的和\r\n    let sum = 0;\r\n\r\n    // 只要右边界没有走到最后就不终止循环\r\n    while (right < nums.length) {\r\n\r\n        sum = sum + nums[right];\r\n        // 如果窗口内的和 ≥ target\r\n        while (sum >= target) {\r\n            // 更新窗口的最小长度\r\n            minLen = Math.min(minLen,right-left+1);\r\n            // 更新和\r\n            sum = sum - nums[left];\r\n            left++\r\n        }\r\n        right++;\r\n    }\r\n    minLen = minLen === Infinity ? 0 : minLen\r\n    return minLen\r\n};\r\n\r\nminSubArrayLen(7,[2,3,1,2,4,3])\r\n```\r\n\r\n## 题目反思\r\n>遇到题目中带有连续的字样，可以优先考虑使用滑动窗口来解决问题，这道题目并不难，和其他的滑动窗口类型的题目解题方法几乎一致。"
    },
    {
      "id": "/搭建next前台开发环境并引入antd",
      "metadata": {
        "permalink": "/blog/搭建next前台开发环境并引入antd",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/搭建next前台开发环境并引入antd.md",
        "source": "@site/blog\\搭建next前台开发环境并引入antd.md",
        "title": "搭建next前台开发环境并引入antd",
        "description": "参考文档：https://jspang.com/detailed?id=52",
        "date": "2021-09-14T00:00:00.000Z",
        "formattedDate": "2021年9月14日",
        "tags": [
          {
            "label": "Next",
            "permalink": "/blog/tags/next"
          }
        ],
        "readingTime": 0.87,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "搭建next前台开发环境并引入antd",
          "date": "2021-9-14",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Next",
          "tags": [
            "Next"
          ]
        },
        "prevItem": {
          "title": "LeetCode——长度最小的子数组（滑动窗口）",
          "permalink": "/blog/LeetCode——长度最小的子数组（滑动窗口）"
        },
        "nextItem": {
          "title": "【青训营】- 走进Web多媒体笔记",
          "permalink": "/blog/【青训营】- 走进Web多媒体笔记"
        }
      },
      "content": ">参考文档：https://jspang.com/detailed?id=52\r\n\r\n## 1：搭建next开发环境\r\n\r\n```shell\r\nnpx create-next-app blog\r\n```\r\n\r\n## 2：进入blog目录\r\n```shell\r\ncd blog\r\n```\r\n\r\n## 3：使用yarn测试\r\n```js\r\nyarn dev\r\n```\r\n\r\n>如果能够进入到下面的界面，说明前三步已经成功了！\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/396d0b0e355a0a878ba143907967e35f.png)\r\n\r\n## 4：加载antd\r\n```shell\r\nyarn add antd \r\n```\r\n\r\n## 5：在pages目录下建立_app.js文件，并写入下列内容\r\n```js\r\nimport App from 'next/app'\r\n\r\nimport 'antd/dist/antd.css'\r\n\r\nexport default App\r\n```\r\n\r\n## 6：引入Button组件\r\n```js\r\nimport React from 'react'\r\nimport Head from 'next/head'\r\nimport {Button} from 'antd'\r\nconst Home = () => (\r\n  <>\r\n    <Head>\r\n      <title>Home</title>\r\n    </Head>\r\n    <div><Button>我是按钮</Button></div>\r\n </>\r\n)\r\n\r\nexport default Home\r\n```\r\n\r\n## 7：测试实现效果\r\n>出现下面的效果，表示前台环境搭建成功！\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/57aed284eea2d3ffa6c8e9ddda31c625.png)"
    },
    {
      "id": "/【青训营】- 走进Web多媒体笔记",
      "metadata": {
        "permalink": "/blog/【青训营】- 走进Web多媒体笔记",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/【青训营】- 走进Web多媒体笔记.md",
        "source": "@site/blog\\【青训营】- 走进Web多媒体笔记.md",
        "title": "【青训营】- 走进Web多媒体笔记",
        "description": "什么是web多媒体技术？",
        "date": "2021-09-13T00:00:00.000Z",
        "formattedDate": "2021年9月13日",
        "tags": [],
        "readingTime": 2.525,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "【青训营】- 走进Web多媒体笔记",
          "date": "2021-9-13",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "字节青训营 - 字节青训营"
        },
        "prevItem": {
          "title": "搭建next前台开发环境并引入antd",
          "permalink": "/blog/搭建next前台开发环境并引入antd"
        },
        "nextItem": {
          "title": "【青训营】- 小程序开发笔记",
          "permalink": "/blog/【青训营】- 小程序开发笔记"
        }
      },
      "content": "## 什么是web多媒体技术？\r\n>下面摘录下w3school的官方定义：多媒体是我们可以看到和听到的一切：文本、书籍、图片、音乐、声音、CD、视频、DVD、档案、电影等。多媒体以多种方式存在，在因特网上会发现很多被嵌入网页中的元素。\r\n\r\n* 点播\r\n* 直播\r\n* 图片\r\n* 实时通信\r\n* 云游戏\r\n* 视频编辑\r\n\r\n## 音视频基础知识\r\n>假设8bit表示一个子像素，清晰度为1280*720，频率25fps,时长60s,未压缩视频大小=8bit*3*1280*720*25*60=3.9GB,经过H264压缩后视频大小为11MB。\r\n\r\n## 编码格式发展\r\n* 1999：MPEG-4\r\n* 2003：H.264\r\n* 2010：VP8\r\n* 2013：H.265,VP9\r\n* 2015：VP10\r\n* 2018：AV1\r\n\r\n## 浏览器提供的原生多媒体能力\r\n>video和audio元素 方法\r\n\r\n* play()：开始播放音频/视频\r\n* paused()：暂停当前播放\r\n* load()：重新加载当前元素\r\n* canPlayType()：检测浏览器是否能播放指定的类型\r\n* addTextTrack()：向目标文件添加新的文本轨道\r\n* autoplay()：设置或返回是否在加载完成后随即播放音频\r\n* controls()：设置或返回是否显示控件\r\n\r\n\r\n>video和audio元素的缺陷\r\n\r\n* 不支持直接播放hls、flv等视频格式\r\n* 视频资源的请求和加载无法通过代码控制\r\n\r\n>MediaSource\r\n\r\n* 拓展浏览器视频播放能力，支持视频分段加载，替代flash播放器\r\n* 支持播放mp4、hls、flv等。\r\n* 可实现视频分段加载、清晰度无缝切换、自适应码率、精确预加载等。\r\n\r\n## Web多媒体技术的发展和突破\r\n* 加密音视频播放\r\n* 自适应码率\r\n* 弹幕：无碰撞、交互弹幕、防挡人像。\r\n* 网页推流\r\n* 网页解码\r\n* 云游戏原理和特点：无需安装、对硬件要求第、低延迟、强兼容性要求。\r\n\r\n## 总结与展望\r\n>字节跳动Web多媒体技术发展:\r\n\r\n* 自主研发视频播放器\r\n* xgplayer开源\r\n* flv\r\n* hls\r\n* webrtc\r\n* 视频编辑\r\n* web heif\r\n* 加密视频\r\n* h265与防劫持\r\n* 交互视频\r\n* 云游戏"
    },
    {
      "id": "/【青训营】- 小程序开发笔记",
      "metadata": {
        "permalink": "/blog/【青训营】- 小程序开发笔记",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/【青训营】- 小程序开发笔记.md",
        "source": "@site/blog\\【青训营】- 小程序开发笔记.md",
        "title": "【青训营】- 小程序开发笔记",
        "description": "了解小程序技术，认识小程序的基本开发方式，为小程序技术学习打下良好的基础。",
        "date": "2021-09-12T00:00:00.000Z",
        "formattedDate": "2021年9月12日",
        "tags": [],
        "readingTime": 2.57,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "【青训营】- 小程序开发笔记",
          "date": "2021-9-12",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "字节青训营 - 字节青训营"
        },
        "prevItem": {
          "title": "【青训营】- 走进Web多媒体笔记",
          "permalink": "/blog/【青训营】- 走进Web多媒体笔记"
        },
        "nextItem": {
          "title": "面试官让我手写Promise.all",
          "permalink": "/blog/面试官让我手写Promise.all"
        }
      },
      "content": ">了解小程序技术，认识小程序的基本开发方式，为小程序技术学习打下良好的基础。\r\n\r\n## 小程序与Web区别\r\n### 为什么有小程序？\r\n* 以社交流量为载体\r\n* 以信息传播流量为载体\r\n* 以交易属性为载体。\r\n\r\n### 小程序特点\r\n* 触手可及，用完即走：小程序是一种无需下载安装即可使用的应用，能以最低成本抵达用户，极大程度上降低了使用门槛。\r\n* 流量互导，功能补充：小程序依托各平台生态，有线下扫码，分享，搜索等各种入口，帮助各平台做功能上的补充，同时也为平台带来更多的流量。\r\n* 提升体验，媲美原生：小程序采用逻辑和渲染分离的模式，同时部分组件使用native进行渲染，并通过资源管理等方式帮助小程序加载更快，使用起来更加流畅。\r\n\r\n### 小程序与Web在技术上的区别\r\n1. 小程序部分组件直接通过原生实现camera等。\r\n2. 小程序会在端上做资源的缓存、销毁等，控制小程序的周期，让小程序能够更快更快速的加载。\r\n3. 小程序在架构将将逻辑和渲染进行了分离，而web是在同一个进程中。\r\n\r\n### 小程序与WEB在生态上的区别\r\n1. 小程序各方面限制更加严格，将渲染和逻辑分开，这样做的直接后果就是之前很多在WEB中的东西直接不能用了，必须在平台给定的规则下进行开发，方便了平台进行监控。\r\n2. 各端提供官方入口，包括扫码，我的小程序，文章内嵌等等。\r\n3. 发布被各平台管控，有着统一的应用版本管理。\r\n\r\n## 如何提升开发效率\r\n>Taro是一个开放式的跨端框架解决方案，taro课编译成不同的小程序，甚至web和RN。"
    },
    {
      "id": "/面试官让我手写Promise.all",
      "metadata": {
        "permalink": "/blog/面试官让我手写Promise.all",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/面试官让我手写Promise.all.md",
        "source": "@site/blog\\面试官让我手写Promise.all.md",
        "title": "面试官让我手写Promise.all",
        "description": "原生的Promise.all有什么特点？",
        "date": "2021-09-11T00:00:00.000Z",
        "formattedDate": "2021年9月11日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 2.635,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "面试官让我手写Promise.all",
          "date": "2021-9-11",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "【青训营】- 小程序开发笔记",
          "permalink": "/blog/【青训营】- 小程序开发笔记"
        },
        "nextItem": {
          "title": "前端面试不会直接挂掉的题目--冒泡排序",
          "permalink": "/blog/前端面试不会直接挂掉的题目--冒泡排序"
        }
      },
      "content": "## 原生的Promise.all有什么特点？\r\n1. 特点1：接收一个可迭代对象\r\n2. 特点2：传入的数据中可以是普通数据，也可以是Promise对象\r\n3. 特点3：可迭代对象的promise是并行执行的\r\n4. 特点4：保持输入数组的顺序和输出数组的顺序一致\r\n5. 特点5：传入数组中只要有一个reject，立即返回reject\r\n6. 特点6：所有数据resolve之后返回结果\r\n\r\n## 实现Promise.all\r\n### 1：函数返回的是一个Promise对象\r\n```js\r\nfunction myPromiseAll(iterable) {\r\n    return new Promise((resolve,reject) => {\r\n    })\r\n}\r\n```\r\n### 2：将可迭代对象转换为一个数组\r\n```js\r\nconst promises = Array.from(iterable);\r\n```\r\n### 3：并发执行每一个Promise\r\n```js\r\n// 定义一个计数器用来判断是否所有的promise执行完毕\r\nlet count = 0;\r\n// 并发执行每一个promise\r\nfor (let i = 0; i < promises.length; i++) {\r\n    Promise.resolve(promises[i]).then(res => {\r\n        result[i] = res;\r\n        count++;\r\n        if (count === promises.length) {\r\n            resolve(result);\r\n        }\r\n    }).catch(err => reject(err))\r\n}\r\n```\r\n>第三步是实现Promise.all的核心，有几点需要我们注意：\r\n\r\n1. 并不是push进result数组的，而是通过下标的方式进行存储，这是因为我们为了保证输出的顺序，因为Promise对象执行的时间可能不同，push的话会破坏顺序。\r\n2. 通过计数标志来判断是否所有的promise对象都执行完毕了，因为在then中表示该promise对象已经执行完毕。\r\n\r\n## 完整实现\r\n```js\r\nfunction myPromiseAll(iterable) {\r\n    return new Promise((resolve,reject) => {\r\n        const promises = Array.from(iterable);\r\n        // 定义Promise对象resolve的数组\r\n        const result = [];\r\n        // 定义一个计数器用来判断是否所有的promise执行完毕\r\n        let count = 0;\r\n        // 并发执行每一个promise\r\n        for (let i = 0; i < promises.length; i++) {\r\n            Promise.resolve(promises[i]).then(res => {\r\n                result[i] = res;\r\n                count++;\r\n                if (count === promises.length) {\r\n                    resolve(result);\r\n                }\r\n            }).catch(err => reject(err))\r\n        }\r\n    })\r\n}\r\n```\r\n\r\n## Promise.all的实现给我们什么启示\r\n* Promise.all返回的是一个Promise对象\r\n* Promise.all接收的可迭代对象数组需要通过Array.from转换为数组\r\n* Promise.all是并发执行的。\r\n* Promise.all中一个reject直接返回reject的结果。"
    },
    {
      "id": "/前端面试不会直接挂掉的题目--冒泡排序",
      "metadata": {
        "permalink": "/blog/前端面试不会直接挂掉的题目--冒泡排序",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端面试不会直接挂掉的题目--冒泡排序.md",
        "source": "@site/blog\\前端面试不会直接挂掉的题目--冒泡排序.md",
        "title": "前端面试不会直接挂掉的题目--冒泡排序",
        "description": "在准备面试的过程中，我们往往容易陷入到很多难度比较高的题目中不能自拔，却忽略了比较基础的题目，面试官在不了解我们的情况下，刚开始可能会问我们一道比较基础的算法题，比如数据结构，请问你能手写下冒泡排序吗？如果此时不会的话，可能直接结束面试了。哈哈~，让我们今天来一起学习下这个比较简单的排序算法吧~",
        "date": "2021-09-10T00:00:00.000Z",
        "formattedDate": "2021年9月10日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 3.04,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "前端面试不会直接挂掉的题目--冒泡排序",
          "date": "2021-9-10",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "面试官让我手写Promise.all",
          "permalink": "/blog/面试官让我手写Promise.all"
        },
        "nextItem": {
          "title": "LeetCode——LRU 缓存机制（借助Map）",
          "permalink": "/blog/LeetCode——LRU 缓存机制（借助Map）"
        }
      },
      "content": ">在准备面试的过程中，我们往往容易陷入到很多难度比较高的题目中不能自拔，却忽略了比较基础的题目，面试官在不了解我们的情况下，刚开始可能会问我们一道比较基础的算法题，比如数据结构，请问你能手写下冒泡排序吗？如果此时不会的话，可能直接结束面试了。哈哈~，让我们今天来一起学习下这个比较简单的排序算法吧~\r\n\r\n## 什么是冒泡排序？\r\n>冒泡排序指的是一种排序的思想，假如我们拿到一个数组，数组中是一堆无序的数字，冒泡排序就可以让这堆无序的数字变得有序，之所以叫做冒泡排序而不是其他的XX排序，是因为冒泡排序的每一轮排序中都将最大的值置为了最后的位置上，就像冒泡一样，所以取名为冒泡排序。\r\n\r\n## 冒泡排序的思想\r\n1. 排序的轮数是数组的长度-1.\r\n2. 每一轮排序都将最大的值放在最末尾。\r\n3. 下一轮排序需要比较的次数都要比上一轮少一次。\r\n\r\n## 实现冒泡排序\r\n```js\r\nfunction mySort(arr) {\r\n    let temp;\r\n    for (let i = 0; i < arr.length - 1; i++) {\r\n        for (let j = 0; j < arr.length - 1 - i; j++) {\r\n            if (arr[j] > arr[j+1]) {\r\n                temp = arr[j];\r\n                arr[j] = arr[j+1];\r\n                arr[j+1] = temp;\r\n            }\r\n        }\r\n    }\r\n    console.log(arr);\r\n    return arr;\r\n}\r\nmySort([8,9,7,3,2,6])\r\n```\r\n\r\n## 时间复杂度和空间复杂度分析\r\n* 空间复杂度\r\n>在空间上，我们只定义了一个临时变量进行交换使用，所以空间复杂度为O(1)。\r\n\r\n* 时间复杂度\r\n>我们分析最差情况下的时间复杂度，假如数组是完全逆序排列的，时间复杂度为：3n(n-1)/2，所以平均时间复杂度为O(n^2).\r\n\r\n## 冒泡排序的稳定性\r\n>在辨别冒泡排序是否是稳定排序之前，我们首先要知道什么样的算法算是一种稳定的算法。稳定的算法通俗的讲就是假如两个值是一样的，排序前A在B的前面，排序后A还在B的前面，这样的排序算法我们称之为稳定的排序算法，反之称为不稳定的排序算法，因此冒泡排序是稳定的。"
    },
    {
      "id": "/LeetCode——LRU 缓存机制（借助Map）",
      "metadata": {
        "permalink": "/blog/LeetCode——LRU 缓存机制（借助Map）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——LRU 缓存机制（借助Map）.md",
        "source": "@site/blog\\LeetCode——LRU 缓存机制（借助Map）.md",
        "title": "LeetCode——LRU 缓存机制（借助Map）",
        "description": "题目描述",
        "date": "2021-09-09T00:00:00.000Z",
        "formattedDate": "2021年9月9日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 2.355,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——LRU 缓存机制（借助Map）",
          "date": "2021-9-9",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "前端面试不会直接挂掉的题目--冒泡排序",
          "permalink": "/blog/前端面试不会直接挂掉的题目--冒泡排序"
        },
        "nextItem": {
          "title": "二刷--二叉树的最近公共祖先",
          "permalink": "/blog/二刷--二叉树的最近公共祖先"
        }
      },
      "content": "## 题目描述\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/2334001134d15ad82ee518db33291848.png)\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/e172d2644b8e67da1bb999700ebf86ff.png)\r\n\r\n## 解题思路\r\n>解决这个问题之前，我们首先要读懂题意，知道什么是LRU缓存机制，LRU缓存机制指的是优先删除那些最久未使用的缓存，在本题中，一个缓存被put或者get都算是一次使用，明白这一点，也就理解了本题的核心题意。\r\n\r\n### 1: 初始化构造函数\r\n```js\r\nvar LRUCache = function (capacity) {\r\n    this.capacity = capacity;\r\n    this.map = new Map();\r\n};\r\n```\r\n\r\n### 2：实现get方法\r\n* 判断map中是都有目标key。\r\n    * 没有则返回-1\r\n    * 有，则保存对应的值，然后删除键值对，重新存，然后返回对应的值。这里之所以要进行重新存储，是为了更新首个元素为最久未使用的元素。\r\n\r\n```js\r\nLRUCache.prototype.get = function (key) {\r\n    // 如果map中有这个key存在则返回，反之返回-1\r\n    if (this.map.has(key)) {\r\n        const value = this.map.get(key);\r\n        this.map.delete(key);\r\n        this.map.set(key,value)\r\n        return this.map.get(key);\r\n    } else {\r\n        return -1;\r\n    }\r\n};\r\n```\r\n\r\n### 3：实现put方法\r\n* 首先判断要存储的key是否存在\r\n    * 存在：删除进行重新存储\r\n    * 不存在：首先判断map的尺寸是否大于构造函数中的容量，如果大于则删除map的首元素，删除方法是`map.entries().next().value[0]`,如果不大于则直接存储。\r\n    \r\n```js\r\nLRUCache.prototype.put = function (key, value) {\r\n    // 首先判断这个key存在吗，存在则删除，重新放置 反之直接放置\r\n    if (this.map.has(key)) {\r\n        this.map.delete(key);\r\n        this.map.set(key,value);\r\n    } else {\r\n        // 判断map的大小是否比题目给定的容量大\r\n        if (this.map.size >= this.capacity) {\r\n            this.map.delete(this.map.entries().next().value[0]);\r\n            this.map.set(key,value)\r\n        } else {\r\n            this.map.set(key,value)\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n## 题目反思\r\n* 通过本题应该学会使用map的各种API，从这题可以看出，我对map的各种API还不够熟系。\r\n* map.entries()变为了一个可迭代的对象。\r\n* next()会将一个可迭代对象变为一个普通对象。"
    },
    {
      "id": "/二刷--二叉树的最近公共祖先",
      "metadata": {
        "permalink": "/blog/二刷--二叉树的最近公共祖先",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/二刷--二叉树的最近公共祖先.md",
        "source": "@site/blog\\二刷--二叉树的最近公共祖先.md",
        "title": "二刷--二叉树的最近公共祖先",
        "description": "这是第二次刷这个题目了，可见这个题目的考频有多高。这是一刷的地址剑指Offer——二叉树的最近公共祖先（JS实现）。",
        "date": "2021-09-08T00:00:00.000Z",
        "formattedDate": "2021年9月8日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.255,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "二刷--二叉树的最近公共祖先",
          "date": "2021-9-8",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "LeetCode——LRU 缓存机制（借助Map）",
          "permalink": "/blog/LeetCode——LRU 缓存机制（借助Map）"
        },
        "nextItem": {
          "title": "这一次，彻底搞懂闭包",
          "permalink": "/blog/这一次，彻底搞懂闭包"
        }
      },
      "content": ">这是第二次刷这个题目了，可见这个题目的考频有多高。这是一刷的地址[剑指Offer——二叉树的最近公共祖先（JS实现）](https://juejin.cn/post/6948663969418575886)。\r\n\r\n## 题目描述\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/29b55d2d75808d76c62479ccc955b693.png)\r\n\r\n## 解题思路\r\n* 首先判断当前节点是null还是p还是q。\r\n    * null：直接返回null\r\n    * p：直接返回p\r\n    * q：直接返回q\r\n* 递归遍历左右子树并接受返回值\r\n* 如果左右子树返回的值都不为空，则说明当前的父节点就是最近公共祖先。反之则返回当前不为空的节点为最近公共祖先。\r\n\r\n## AC代码\r\n```js\r\nvar lowestCommonAncestor = function(root, p, q) {\r\n    // 如果节点为空 返回null\r\n    if (!root ) return null;\r\n\r\n    if (root === p) return p;\r\n\r\n    if (root === q) return q;\r\n\r\n    let x = lowestCommonAncestor(root.left,p,q);\r\n    let y = lowestCommonAncestor(root.right,p,q);\r\n\r\n    if (x && y) {\r\n        return root;\r\n    } else {\r\n        return x || y;\r\n    }\r\n};\r\n```\r\n\r\n## 题目反思\r\n* 学会使用递归的方式遍历二叉树并返回目标元素。"
    },
    {
      "id": "/这一次，彻底搞懂闭包",
      "metadata": {
        "permalink": "/blog/这一次，彻底搞懂闭包",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/这一次，彻底搞懂闭包.md",
        "source": "@site/blog\\这一次，彻底搞懂闭包.md",
        "title": "这一次，彻底搞懂闭包",
        "description": "什么是闭包？",
        "date": "2021-09-07T00:00:00.000Z",
        "formattedDate": "2021年9月7日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 2.525,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "这一次，彻底搞懂闭包",
          "date": "2021-9-7",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "二刷--二叉树的最近公共祖先",
          "permalink": "/blog/二刷--二叉树的最近公共祖先"
        },
        "nextItem": {
          "title": "学会使用useMemo和useCallback对你没坏处",
          "permalink": "/blog/学会使用useMemo和useCallback对你没坏处"
        }
      },
      "content": "## 什么是闭包？\r\n>在了解闭包之前，我们首先需要搞懂什么是闭包，闭包指的是一个有权访问另一个函数作用域中变量的函数。\r\n\r\n## 为什么需要闭包？\r\n>我们知道在JS中，变量分为全局变量和局部变量，全局变量的作用域为全局作用域，局部变量的作用域为局部作用域，我们可以在函数内部访问全局变量，但是无法在全局环境中访问函数的局部变量，闭包可以帮助我们访问到这个局部变量。\r\n\r\n## 闭包的应用场景\r\n### 场景一：立即执行函数\r\n```js\r\nconst a = 666;\r\n\r\n(function getA(){\r\n    console.log(a);\r\n})()\r\n```\r\n\r\n### 场景二：模拟块级作用域\r\n```js\r\nfor(var i = 0; i < 5; i++) {\r\n    (function (j) {\r\n        setTimeout(() => {\r\n            console.log(j);\r\n        },1000)\r\n    })(i)\r\n}\r\n```\r\n\r\n### 场景三：封装私有变量\r\n```js\r\nfunction Person(name) {\r\n    this.getName = function(){\r\n        return name\r\n    }\r\n}\r\n```\r\n\r\n## 闭包解决了什么问题？（闭包的作用）\r\n1. 闭包可以缓存上级作用域，使得函数外部打破了函数作用域的束缚，可以访问函数内部的变量。\r\n2. 让变量的值始终保持在内存中。\r\n\r\n## 闭包带来了什么问题？（闭包的缺陷）\r\n闭包会导致函数的变量一直保存在内存中，过多的闭包会导致内存泄露。\r\n\r\n## 数组的哪些方法用到了闭包？\r\n* 例如forEach\r\n```js\r\nconst arr = [1,2,3];\r\n\r\narr.forEach((item,index) => {\r\n    setTimeout(() => {\r\n        console.log(item);\r\n    },1000)\r\n})\r\n```\r\n>只要是符合闭包的定义，一个有权访问另一个函数作用域中变量的函数就是闭包。权威指南中说，严格意义来说JS中的函数都是闭包。\r\n\r\n## 参考资料\r\n* [什么是闭包？闭包的作用是什么？](https://github.com/YvetteLau/Step-By-Step/issues/24)\r\n* [JS 闭包经典使用场景和含闭包必刷题](https://juejin.cn/post/6937469222251560990#heading-8)\r\n* [当面试官问你闭包时，他究竟想听到些什么？](https://zhuanlan.zhihu.com/p/29157822)\r\n* [# 谈谈你对闭包的认识？](https://juejin.cn/post/6844904120806014990#heading-3)"
    },
    {
      "id": "/学会使用useMemo和useCallback对你没坏处",
      "metadata": {
        "permalink": "/blog/学会使用useMemo和useCallback对你没坏处",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/学会使用useMemo和useCallback对你没坏处.md",
        "source": "@site/blog\\学会使用useMemo和useCallback对你没坏处.md",
        "title": "学会使用useMemo和useCallback对你没坏处",
        "description": "什么是useMemo？",
        "date": "2021-09-06T00:00:00.000Z",
        "formattedDate": "2021年9月6日",
        "tags": [
          {
            "label": "Hooks",
            "permalink": "/blog/tags/hooks"
          }
        ],
        "readingTime": 2.385,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "学会使用useMemo和useCallback对你没坏处",
          "date": "2021-9-6",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Hooks",
          "tags": [
            "Hooks"
          ]
        },
        "prevItem": {
          "title": "这一次，彻底搞懂闭包",
          "permalink": "/blog/这一次，彻底搞懂闭包"
        },
        "nextItem": {
          "title": "大厂面试必须掌握的六种继承方式，你会吗？",
          "permalink": "/blog/大厂面试必须掌握的六种继承方式，你会吗？"
        }
      },
      "content": "## 什么是useMemo？\r\n>useMemo的行为类似Vue中的计算属性，可以检测某个值的变化，根据变化值计算新值。useMemo会缓存计算结果，如果检测值没有发生变化，即使组件重新渲染，也不会重新计算，此行为可以有助于避免在每个渲染上进行昂贵的计算。不要再useMemo函数中执行与渲染无关的操作。\r\n\r\n### useMemo的基本用法\r\n```js\r\nfunction App() {\r\n\r\n    const [bool,setBool] = useState(true);\r\n    const [age,setAge] = useState('666');\r\n    \r\n    const result = useMemo(() => {\r\n        console.log('检测到age发生变化');\r\n        return age * 2; \r\n    },[age])\r\n    return (\r\n        <div>\r\n            {age}\r\n            {bool ? '真': '假'}\r\n            <button onClick={() => setBool(!bool)}>点我切换布尔值</button>\r\n            <button onClick={() => setAge(age*1 + 1)}>点我age+1</button>\r\n            result是：{result}\r\n        </div>\r\n    )\r\n}\r\n```\r\n## memo方法\r\n>memo方法可以用于性能优化，如果本组件中的数据没有发生变化，阻止组件更新，类似类组件中的PureComponent和shouldComponentUpdate.\r\n\r\n### memo方法的基本用法\r\n```js\r\nfunction App() {\r\n    const [count, setCount] = useState(0);\r\n    return (\r\n        <div>\r\n            <Foo />\r\n            <h1>当前求和为：{count}</h1>\r\n            <button onClick={() => setCount(count + 1)}>点我+1</button>\r\n        </div>\r\n    )\r\n\r\n}\r\n\r\nconst Foo = memo(function Foo() {\r\n    console.log('Foo被渲染了');\r\n    return (\r\n        <div>这是Foo组件</div>\r\n    )\r\n})\r\n```\r\n\r\n## useCallback是什么？\r\n>常用于性能优化，缓存函数，使得组件重新渲染时得到相同的函数实例。\r\n\r\n### useCallback的基本用法\r\n>在这里我们需要注意的是useCallback的第一个参数时我们需要缓存的函数，第二个参数是一个数组，数组中包含的是没有变化的目标函数。\r\n\r\n```js\r\nfunction App() {\r\n    const [count, setCount] = useState(0);\r\n    const resetCount = useCallback(() => setCount(0),[setCount]);\r\n    return (\r\n        <div>\r\n            <Foo resetCount={resetCount}/>\r\n            <h1>当前求和为：{count}</h1>\r\n            <button onClick={() => setCount(count + 1)}>点我+1</button>\r\n            \r\n        </div>\r\n    )\r\n}\r\nconst Foo = memo(function Foo(props) {\r\n    console.log('Foo被渲染了');\r\n    return (\r\n        <div>\r\n            这是Foo组件\r\n            <button onClick={props.resetCount}>点我归零</button>\r\n        </div>\r\n    )\r\n})\r\n```\r\n\r\n## 参考资料\r\n* [官方文档：useCallback](https://zh-hans.reactjs.org/docs/hooks-reference.html#usecallback)\r\n* [官方文档：useMemo](https://zh-hans.reactjs.org/docs/hooks-reference.html#usememo)"
    },
    {
      "id": "/大厂面试必须掌握的六种继承方式，你会吗？",
      "metadata": {
        "permalink": "/blog/大厂面试必须掌握的六种继承方式，你会吗？",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/大厂面试必须掌握的六种继承方式，你会吗？.md",
        "source": "@site/blog\\大厂面试必须掌握的六种继承方式，你会吗？.md",
        "title": "大厂面试必须掌握的六种继承方式，你会吗？",
        "description": "博主在阅读大量面经文章时发现无论是大厂面试还是小厂面试，无论是社招还是校招，只要考查JS基础，继承、原型、原型链都是绕不开的话题，所以本次希望和大家一起学习必须掌握的七种继承方式，博主将细致的分析每一种继承方式的原理、优缺点并给出在线的实现方式，这不仅仅对面试有帮助，还对我们理解JS的运行机制有帮助，让我们一起加油吧~顺便给个赞哦！",
        "date": "2021-09-05T00:00:00.000Z",
        "formattedDate": "2021年9月5日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 8.145,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "大厂面试必须掌握的六种继承方式，你会吗？",
          "date": "2021-9-5",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "学会使用useMemo和useCallback对你没坏处",
          "permalink": "/blog/学会使用useMemo和useCallback对你没坏处"
        },
        "nextItem": {
          "title": "【青训营】- JavaScript中的设计模式笔记",
          "permalink": "/blog/【青训营】- JavaScript中的设计模式笔记"
        }
      },
      "content": ">博主在阅读大量面经文章时发现无论是大厂面试还是小厂面试，无论是社招还是校招，只要考查JS基础，继承、原型、原型链都是绕不开的话题，所以本次希望和大家一起学习必须掌握的七种继承方式，博主将细致的分析每一种继承方式的原理、优缺点并给出在线的实现方式，这不仅仅对面试有帮助，还对我们理解JS的运行机制有帮助，让我们一起加油吧~顺便给个赞哦！\r\n\r\n## 1：原型链继承\r\n### 原理\r\n>原型链继承的原理是利用原型对象和实例之间的关系实现继承，**实现这种继承的关键在于让子类的原型对象指向新创建的父类实例。**\r\n\r\n### 实现代码\r\n```js\r\n// 1：原型链继承\r\nfunction Father() {\r\n    this.name = 'justin';\r\n}\r\nFather.prototype.getName = function () {\r\n    return this.name\r\n}\r\n\r\nfunction Child() { }\r\nChild.prototype = new Father();\r\nconst child = new Child();\r\nconsole.log(child.getName());\r\n```\r\n### 优缺点\r\n* 优点：实例可以继承的属性包括：实例的构造函数的属性，父类构造函数的属性，父类原型对象上的属性。\r\n* 缺点：一个实例修改了原型对象上的属性，另一个实例的原型属性也会被修改。新实例无法向父类构造函数传参。\r\n>下面这个例子展示了，原型链继承的缺点\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/b1a755287a8cf12b5a0c80a7d0b6a5d0.png)\r\n\r\n### 在线实现\r\n[codeSandBox](https://codesandbox.io/s/1-yuan-xing-lian-ji-cheng-30ffv)\r\n\r\n## 2. 构造函数继承\r\n### 原理\r\n>构造函数继承的核心在于：在子类构造函数中通过父类构造函数.call(this)来实现继承。\r\n\r\n### 实现代码\r\n```js\r\n// 2：构造函数继承\r\nfunction Father() {\r\n    this.name = 'justin';\r\n    this.say = {haha: 111}\r\n}\r\n\r\nfunction Child(age) {\r\n    Father.call(this);\r\n    this.age = age;\r\n}\r\n\r\nconst child1 = new Child(10);\r\nconst child2 = new Child(20);\r\n\r\nchild1.say.haha = 222;\r\n\r\nconsole.log(child1);\r\nconsole.log(child2);\r\n```\r\n### 优缺点\r\n* 优点\r\n1. 可以继承多个构造函数属性（通过多次call的调用）\r\n2. 解决了原型链继承中实例共享引用类型的问题\r\n3. 在子实例中可以向父实例中传参\r\n\r\n* 缺点\r\n1. 只继承了父类构造函数的属性，没有继承父类原型对象上的属性。\r\n2. 无法实现父类构造函数的复用，每次都要重新调用\r\n\r\n### 在线实现\r\n[codeSandBox](https://codesandbox.io/s/2-gou-zao-han-shu-ji-cheng-mpsir?file=/index.html)\r\n\r\n## 3. 组合继承（组合指的是组合了原型链和构造函数的继承方式）\r\n### 原理\r\n>结合了原型链和构造函数的继承方式，一是通过在子类构造函数中让父类构造函数调用call修改this指向，二是让子类构造函数的原型对象指向父类构造函数的实例。\r\n\r\n### 实现代码\r\n```js\r\n// 3：组合继承（组合指的是组合了原型链继承和构造函数继承）\r\nfunction Father(age) {\r\n    this.colors = ['red','pink'];\r\n    this.age = age;\r\n}\r\nFather.prototype.say = () => '你好';\r\nfunction Child(name,age) {\r\n    // 构造函数的方式\r\n    Father.call(this,age);\r\n    this.name = name;\r\n} \r\n// 原型链\r\nChild.prototype = new Father();\r\nChild.prototype.constructor = Child;\r\n\r\nconst child1 = new Child('张三',20);\r\nconst child2 = new Child('李四',25);\r\nChild.prototype\r\nchild1\r\nchild1.colors.push('black');\r\nconsole.log(child1.colors);\r\nconsole.log(child2.colors);\r\nconsole.log(child1.say());\r\n```\r\n### 优缺点\r\n* 优点\r\n1. 可以继承父类构造函数上的属性和原型对象上的属性。\r\n2. 可以传参。\r\n3. 每个新实例引入的构造函数属性是私有的。\r\n\r\n* 缺点\r\n1. 调用了两次父类构造函数。\r\n2. 子类实例上的属性，同时存在于原型链上和子例身上，造成原型链污染。\r\n\r\n### 在线实现\r\n[codeSandBox](https://codesandbox.io/s/3-zu-he-ji-cheng-jrem9)\r\n\r\n## 4: 原型式继承\r\n### 原理\r\n>利用一个空函数作为中介，让这个中介的原型对象指向需要继承的父类对象，然后返回这个函数的实例，即可完成原型式继承。\r\n\r\n### 实现代码\r\n```js\r\n// 4：原型式继承\r\nfunction createObj(o) {\r\n    function F() { };\r\n    F.prototype = o;\r\n    return new F();\r\n}\r\n\r\nconst obj = {\r\n    name: 'justin',\r\n    friends: [1, 2, 3, 4]\r\n}\r\n// 方式1\r\nconst m1 = createObj(obj);\r\nconst m2 = createObj(obj);\r\n// 方式2\r\nconst m3 = Object.create(obj);\r\n\r\nconsole.log(m1.name);  //justin\r\nconsole.log(m2.name);  //justin\r\nm1.friends.push(666);\r\n\r\nconsole.log(m1.friends);  // [1,2,3,4,666]\r\nconsole.log(m2.friends);  // [1,2,3,4,666]\r\n```\r\n### 优缺点\r\n* 优点\r\n1. 类似于复制一个对象，用函数来包装。\r\n\r\n* 缺点\r\n1. 无法向父类传参。\r\n2. 父类的引用类型被子类共享。\r\n\r\n### 在线实现\r\n[codeSandBox在线实现](https://codesandbox.io/s/4-yuan-xing-shi-ji-cheng-cp0dq)\r\n\r\n## 5：寄生式继承\r\n### 原理\r\n>寄生式继承是在原型式继承的基础上进行了一次增强，也就是通过增加一个函数，然后添加属性实现继承。\r\n\r\n### 实现代码\r\n```js\r\n// 5：寄生式继承\r\nfunction objCopy(o) {\r\n    function F() {};\r\n    F.prototype = o;\r\n    return new F();\r\n}\r\n\r\nfunction enhanceObj(o) {\r\n    const clone = objCopy(o);\r\n    clone.say = function() {\r\n        return 'hi';\r\n    }\r\n    return clone;\r\n}\r\n\r\nconst obj = {\r\n    name: 'justin',\r\n    colors: [1,2,3]\r\n}\r\n\r\nconst m1 = enhanceObj(obj);\r\nconst m2 = enhanceObj(obj);\r\n\r\nconsole.log(m1.name);  //justin\r\nconsole.log(m1.colors); //[1,2,3]\r\nconsole.log(m1.say());  //hi\r\n\r\nm1.colors.push(777)\r\nconsole.log(m2.colors); // [1,2,3,777]\r\n```\r\n### 优缺点\r\n* 优点\r\n1. 增强了原型式继承的能力。\r\n\r\n* 缺点\r\n1. 无法向父类传参。\r\n2. 父类构造函数的引用类型对象被子类实例共享。\r\n\r\n### 在线实现\r\n[codeSandBox在线实现](https://codesandbox.io/s/5-ji-sheng-shi-ji-cheng-3j7bo)\r\n\r\n## 6：寄生组合式继承\r\n### 原理\r\n>寄生组合式继承结合了构造函数继承、寄生式继承，让子类的构造函数的原型对象指向原型式继承传过来的实例，同时这个实例的构造函数也指向子类构造函数，别忘了子类构造函数中还需要父类构造函数通过call改变this指向。\r\n\r\n### 实现代码\r\n```js\r\n// 6：寄生组合式继承\r\nfunction Father(name) {\r\n    this.name = name;\r\n    this.colors = [1,2,3];\r\n}\r\nFather.prototype.say = function() {\r\n    return 'hi';\r\n}\r\n\r\nfunction Child(name,age) {\r\n    Father.call(this,name);\r\n    this.age = age;\r\n}\r\nfunction createObj(o) {\r\n    function F() {}\r\n    F.prototype = o;\r\n    return new F();\r\n}\r\n\r\nfunction inheritPrototype(Child,Father) {\r\n    // 先构造一个指向父类构造函数原型对象的对象\r\n    const prototype = createObj(Father.prototype);\r\n    // 让这个对象的构造函数指向Child\r\n    prototype.constructor = Child;\r\n    Child.prototype = prototype;\r\n}\r\ninheritPrototype(Child,Father);\r\nconst child1 = new Child('justin',666);\r\nconst child2 = new Child('心飞扬',777);\r\nconsole.log(child1.colors); //[1,2,3]\r\nconsole.log(child2.colors); //[1,2,3]\r\nchild1.colors.push(666);\r\n\r\nconsole.log(child1.colors);  // [1,2,3,666]\r\nconsole.log(child2.colors);  // [1,2,3]\r\n```\r\n### 优缺点\r\n* 优点：这是目前最优的一种继承方式。\r\n1. 子类构造函数可以向父类传参。\r\n2. 只调用一次父类构造函数。\r\n3. 父类的引用类型属性不会被子类共享。\r\n\r\n### 在线实现\r\n[codeSandBox在线实现](https://codesandbox.io/s/6-ji-sheng-zu-he-shi-ji-cheng-py9kg?file=/index.html)\r\n\r\n## 参考链接\r\n* [JS继承 原型链继承、构造函数继承、组合继承、原型继承、寄生式继承、寄生组合继承](https://juejin.cn/post/6914216540468576263)\r\n\r\n* [JavaScript常用八种继承方案](https://juejin.cn/post/6844903696111763470?utm_source=pocket_mylist)\r\n\r\n* [盘点那些高频前端面试题：JS继承的六种方式](https://www.bilibili.com/video/BV1Ki4y1L7dY)"
    },
    {
      "id": "/【青训营】- JavaScript中的设计模式笔记",
      "metadata": {
        "permalink": "/blog/【青训营】- JavaScript中的设计模式笔记",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/【青训营】- JavaScript中的设计模式笔记.md",
        "source": "@site/blog\\【青训营】- JavaScript中的设计模式笔记.md",
        "title": "【青训营】- JavaScript中的设计模式笔记",
        "description": "什么是设计模式？",
        "date": "2021-09-04T00:00:00.000Z",
        "formattedDate": "2021年9月4日",
        "tags": [
          {
            "label": "青训营",
            "permalink": "/blog/tags/青训营"
          }
        ],
        "readingTime": 3.01,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "【青训营】- JavaScript中的设计模式笔记",
          "date": "2021-9-4",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "青训营",
          "tags": [
            "青训营"
          ]
        },
        "prevItem": {
          "title": "大厂面试必须掌握的六种继承方式，你会吗？",
          "permalink": "/blog/大厂面试必须掌握的六种继承方式，你会吗？"
        },
        "nextItem": {
          "title": "这一次，彻底搞懂useEffect",
          "permalink": "/blog/这一次，彻底搞懂useEffect"
        }
      },
      "content": "## 什么是设计模式？\r\n>在软件设计过程中，针对特定问题的简洁而优雅的解决方案。从经验总结到合理运用再到解决问题。\r\n\r\n### SOLID五大设计原则\r\n1. S单一职责原则：一个程序只做好一件事。\r\n2. O开放封闭原则：对拓展开放，对修改封闭。\r\n3. L李氏置换原则：子类能覆盖父类，并能出现在父类出现的地方。\r\n4. I接口独立原则：保持接口的单一独立。\r\n5. D依赖导致原则：使用方法只关注接口而不关注集体类的实现。\r\n\r\n## 为什么需要设计模式？\r\n1. 易读性：使用设计模式能够提高代码的可读性，提升后续开发效率。\r\n2. 可拓展性：使用设计模式对代码解耦，能很好的增强代码的易修改性和拓展性。\r\n3. 复用性：使用设计模式可以重用已有的解决方案，无需再重复相同的工作。\r\n4：可靠性：使用设计模式能够增加系统的健壮性，使得代码编写真正工程化。\r\n\r\n## 常见的八种设计模式\r\n1. 单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。\r\n2. 策略模式：定义一系列的算法，把它们一个个封装起来，并且使他们可以相互替换，把看似毫无联系的代码提取封装，复用，使得其更容易被理解和拓展。\r\n3. 代理模式：为一个对象提供一个代用品，替身对象可对请求预先进行处理。\r\n4. 命令模式：常用语富文本编辑器工具栏。\r\n5. 组合模式：用小的子对象来构建更大的对象，将对象组合成树形结构。\r\n6. 装饰器模式：能够在不改变对象自身的基础上，在程序运行期间给对象动态的添加职责。\r\n7. 发布订阅模式：对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。\r\n8. 适配器模式：解决两个软件实体间的接口不兼容问题，不需要改变已有的接口，就能够使它们协同作用。"
    },
    {
      "id": "/这一次，彻底搞懂useEffect",
      "metadata": {
        "permalink": "/blog/这一次，彻底搞懂useEffect",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/这一次，彻底搞懂useEffect.md",
        "source": "@site/blog\\这一次，彻底搞懂useEffect.md",
        "title": "这一次，彻底搞懂useEffect",
        "description": "什么是useEffect?",
        "date": "2021-09-03T00:00:00.000Z",
        "formattedDate": "2021年9月3日",
        "tags": [
          {
            "label": "Hooks",
            "permalink": "/blog/tags/hooks"
          }
        ],
        "readingTime": 2.51,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "这一次，彻底搞懂useEffect",
          "date": "2021-9-3",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Hooks",
          "tags": [
            "Hooks"
          ]
        },
        "prevItem": {
          "title": "【青训营】- JavaScript中的设计模式笔记",
          "permalink": "/blog/【青训营】- JavaScript中的设计模式笔记"
        },
        "nextItem": {
          "title": "一道看似简单的阿里前端算法题",
          "permalink": "/blog/一道看似简单的阿里前端算法题"
        }
      },
      "content": "## 什么是useEffect?\r\n>让函数型组件拥有处理副作用的能力，类似生命周期函数。\r\n\r\n### 1. useEffect执行时机\r\n>可以把useEffect看做componentDidMount,componentDidUpdate,componentWillUnmount这三个函数的组合。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/f92c585c136ca03a11a8b27c36a1e890.png)\r\n\r\n* 当做componentDidMount和componentDidUpdate的时候\r\n```js\r\nfunction App() {\r\n    const [count,setCount] = useState(0);\r\n    // 组件挂载完成之后 或 组件数据更新完成之后 执行\r\n    useEffect(() => {\r\n        console.log('组件挂载完成之后 或 组件数据更新完成之后 执行');\r\n    })\r\n    return (\r\n        <div>\r\n            {count}\r\n            <button onClick={() => setCount(count + 1)}>+1</button>\r\n        </div>\r\n    )\r\n}\r\n```\r\n* 仅当做comonentDidMount的时候\r\n```js\r\nuseEffect(() => {\r\n    console.log('仅当做componentDidMount');\r\n},[])\r\n```\r\n* 当做componentWillunmount的时候(注意：这里不是仅当做componentWillunmount)\r\n```js\r\nuseEffect(() => () => {\r\n    console.log('当做componentWillUnmount');\r\n})\r\n```\r\n\r\n\r\n### 2. useEffect的使用方法示例\r\n1. 为window对象添加滚动事件。（挂载完成后绑定事件，卸载组件后解除绑定）\r\n```js\r\nfunction App() {\r\n    function onScroll() {\r\n        console.log('监听到页面发生滚动了');\r\n    }\r\n    useEffect(() => {\r\n        window.addEventListener('scroll',onScroll);\r\n        return () => {\r\n            // 卸载组件时解除对事件的绑定\r\n            window.removeEventListener('scroll',onScroll);\r\n        }\r\n    })\r\n    return (\r\n        <div>\r\n            App \r\n        </div>\r\n    )\r\n}\r\n```\r\n2. 设置定时器让count数值每隔一秒增加1。\r\n```js\r\nfunction App() {\r\n    \r\n    const [count,setCount] = useState(0);\r\n    useEffect(() => {\r\n        const timeId = setInterval(() => {\r\n           setCount(count => count + 1); \r\n        },1000)\r\n        return () => {\r\n            clearInterval(timeId);\r\n        }\r\n    },[])\r\n    return (\r\n        <div>\r\n            <h1>当前求和为：{count}</h1> \r\n        </div>\r\n    )\r\n}\r\n```\r\n\r\n### 3. useEffect解决的问题\r\n1. 将一组相干的业务逻辑归置到了同一个副作用函数中.\r\n2. 简化重复代码,使组件内部代码更加清晰.\r\n\r\n### 4：useEffect的第二个参数\r\n* 只有指定数据发生变化的时候才触发effect\r\n```js\r\nuseEffect(() => {\r\n    document.title = count;\r\n}, [count]) \r\n```\r\n\r\n### 5：useEffect结合异步函数\r\n>在useEffect中直接使用async和await是会报错的，推荐使用立即执行函数来包裹异步函数。\r\n```js\r\nfunction getData() {\r\n    return new Promise(resolve => {\r\n        resolve({msg: 'Hello'})\r\n    })\r\n}\r\nfunction App() {\r\n\r\n    useEffect(() => {\r\n        (async function () {\r\n            const result = await getData();\r\n            console.log(result);\r\n        })()\r\n    },[])\r\n    \r\n    return (\r\n        <div>\r\n            App\r\n        </div>\r\n    )\r\n}\r\n```\r\n\r\n## 参考文献\r\n* [官方文档](https://zh-hans.reactjs.org/docs/hooks-reference.html#useeffect)"
    },
    {
      "id": "/一道看似简单的阿里前端算法题",
      "metadata": {
        "permalink": "/blog/一道看似简单的阿里前端算法题",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/一道看似简单的阿里前端算法题.md",
        "source": "@site/blog\\一道看似简单的阿里前端算法题.md",
        "title": "一道看似简单的阿里前端算法题",
        "description": "博主本次介绍的题目是真实来自阿里前端CBU部门招聘实习生的一道前端算法题，这道题并不是LeetCode上的找出数组中第K大的元素这道题模，而是在这道题目的基础上进行了改编，让我们一起来探索下这道题目该如何解决。",
        "date": "2021-09-02T00:00:00.000Z",
        "formattedDate": "2021年9月2日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 5.835,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "一道看似简单的阿里前端算法题",
          "date": "2021-9-2",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "这一次，彻底搞懂useEffect",
          "permalink": "/blog/这一次，彻底搞懂useEffect"
        },
        "nextItem": {
          "title": "useState是怎么回事？",
          "permalink": "/blog/useState是怎么回事"
        }
      },
      "content": ">博主本次介绍的题目是真实来自阿里前端CBU部门招聘实习生的一道前端算法题，这道题并不是LeetCode上的**找出数组中第K大的元素**这道题模，而是在这道题目的基础上进行了改编，让我们一起来探索下这道题目该如何解决。\r\n\r\n## 题目描述\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/a5538dddf5a4b8ca8d863b90ef1166b9.png)\r\n\r\n## 题目分析\r\n>我们以下面这个数组为例，我们首先要明白题目中的第2大的元素指的是4，第3大的元素指的是3，也就是说指的是去重后的数组中的排序。我们之所以要建立一个哈希表是因为我们需要知道第k大和第m大的元素总共出现了几次，因为最后需要进行求和。\r\n```js\r\n[1, 2, 4, 4, 3, 5]\r\n```\r\n\r\n## 解题思路\r\n>本题博主采用的是哈希表 + 堆排序的方式来求解。\r\n\r\n### 第一步：构建哈希表，键为目标元素，值为目标元素出现的次数\r\n```js\r\nconst map = new Map();\r\nfor (let v of arr) {\r\n    if (!map.get(v)) {\r\n        map.set(v,1);\r\n    } else {\r\n        map.set(v,map.get(v) + 1)\r\n    }\r\n}\r\n```\r\n### 第二步：对数组去重\r\n```js\r\nconst singleNums = [...new Set(arr)]\r\n```\r\n### 第三步：构建大顶堆\r\n```js\r\n// 堆的尺寸指的是去重后的数组\r\nlet heapSize = singleNums.length;\r\nbuildMaxHeap(singleNums, heapSize);\r\nfunction buildMaxHeap(arr, heapSize) {\r\n    // 从最后一个叶子节点开始进行堆化\r\n    for (let i = Math.floor(heapSize / 2) - 1; i >= 0; i--) {\r\n        // 进行堆化\r\n        maxHeapify(arr, i, heapSize);\r\n    }\r\n}\r\nfunction maxHeapify(arr, i, heapSize) {\r\n    // 首先假定第i个是最大的\r\n    let max = i;\r\n    let leftChild = 2 * i + 1;\r\n    let rightChild = 2 * i + 2;\r\n    // 如果下标不越界，并且左孩子的比最大值大则更新最大值\r\n    if (leftChild < heapSize && arr[leftChild] > arr[max]) {\r\n        max = leftChild;\r\n    }\r\n    if (rightChild < heapSize && arr[rightChild] > arr[max]) {\r\n        max = rightChild;\r\n    }\r\n    if (max !== i) {\r\n        swap(arr, i, max);\r\n        // 上来的元素的位置往下要接着堆化\r\n        maxHeapify(arr, max, heapSize);\r\n    }\r\n}\r\n// 交换数组中两个元素\r\nfunction swap(nums, a, b) {\r\n    let temp = nums[a];\r\n    nums[a] = nums[b];\r\n    nums[b] = temp;\r\n}\r\n```\r\n### 第四步：求第k大的元素和第m大元素\r\n```js\r\nfunction target(arr, x) {\r\n    for (let i = 0; i < x - 1; i++) {\r\n        // 交换不需要进行堆化的元素\r\n        if (i === min - 1) result.push(arr[0]);\r\n        swap(arr, 0, arr.length - 1 - i);\r\n        arr\r\n        heapSize--;\r\n        maxHeapify(arr, 0, heapSize)\r\n    }\r\n}\r\ntarget(singleNums, max)\r\nresult.push(singleNums[0]);\r\n```\r\n### 第五步：根据哈希表出现的次数计算并返回结果\r\n```js\r\nreturn result.reduce((pre,cur) => pre + cur * map.get(cur),0)\r\n```\r\n\r\n## AC代码\r\n```js\r\n/*\r\n * @Date: 2021-07-09 10:06:00\r\n * @LastEditTime: 2021-08-28 11:09:30\r\n * @Description: 找出数组中第k大和第m大的数字相加之和\r\n * let arr = [1,2,4,4,3,5], k = 2, m = 4 \r\n * findTopSum(arr, k, m); // 第2大的数是4，出现2次，第4大的是2，出现1次，所以结果为10 \r\n */\r\n\r\n/**\r\n * @description: 采用堆排序求解\r\n * @param {*} arr 接收一个未排序的数组\r\n * @param {*} k 数组中第k大的元素\r\n * @param {*} m 数组中第m大的元素\r\n * @return {*}  返回数组中第k大和第m大的数字相加之和\r\n */\r\nfunction findTopSum(arr, k, m) {\r\n    \r\n\r\n    function buildMaxHeap(arr, heapSize) {\r\n        // 从最后一个叶子节点开始进行堆化\r\n        for (let i = Math.floor(heapSize / 2) - 1; i >= 0; i--) {\r\n            // 进行堆化\r\n            maxHeapify(arr, i, heapSize);\r\n        }\r\n    }\r\n    // 最大堆化函数\r\n    function maxHeapify(arr, i, heapSize) {\r\n        // 首先假定第i个是最大的\r\n        let max = i;\r\n        let leftChild = 2 * i + 1;\r\n        let rightChild = 2 * i + 2;\r\n        // 如果下标不越界，并且左孩子的比最大值大则更新最大值\r\n        if (leftChild < heapSize && arr[leftChild] > arr[max]) {\r\n            max = leftChild;\r\n        }\r\n        if (rightChild < heapSize && arr[rightChild] > arr[max]) {\r\n            max = rightChild;\r\n        }\r\n        if (max !== i) {\r\n            swap(arr, i, max);\r\n            // 上来的元素的位置往下要接着堆化\r\n            maxHeapify(arr, max, heapSize);\r\n        }\r\n    }\r\n\r\n    // 交换数组中两个元素\r\n    function swap(nums, a, b) {\r\n        let temp = nums[a];\r\n        nums[a] = nums[b];\r\n        nums[b] = temp;\r\n    }\r\n    let result = []\r\n    // k和m中较大的\r\n    let max = Math.max(k, m);\r\n    // k和m中较小的\r\n    let min = Math.min(k, m);\r\n    const map = new Map();\r\n    \r\n    for (let v of arr) {\r\n        if (!map.get(v)) {\r\n            map.set(v,1);\r\n        } else {\r\n            map.set(v,map.get(v) + 1)\r\n        }\r\n    }\r\n    // 求第x大的元素\r\n    function target(arr, x) {\r\n        for (let i = 0; i < x - 1; i++) {\r\n            // 交换不需要进行堆化的元素\r\n            if (i === min - 1) result.push(arr[0]);\r\n            swap(arr, 0, arr.length - 1 - i);\r\n            arr\r\n            heapSize--;\r\n            maxHeapify(arr, 0, heapSize)\r\n        }\r\n    }\r\n    const singleNums = [...new Set(arr)]\r\n    // 堆的大小\r\n    let heapSize = singleNums.length;\r\n    // 构建大顶堆\r\n    buildMaxHeap(singleNums, heapSize);\r\n\r\n    target(singleNums, max)\r\n    result.push(singleNums[0]);\r\n    return result.reduce((pre,cur) => pre + cur * map.get(cur),0)\r\n\r\n}\r\n\r\nfindTopSum([1, 2, 4, 4, 3, 5], 2, 4)\r\n```\r\n\r\n## 题目反思\r\n* 学会通过堆排序的方式来求解Top K问题。\r\n* 学会对数组进行去重。\r\n* 学会使用reduce Api。"
    },
    {
      "id": "/useState是怎么回事",
      "metadata": {
        "permalink": "/blog/useState是怎么回事",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/useState是怎么回事.md",
        "source": "@site/blog\\useState是怎么回事.md",
        "title": "useState是怎么回事？",
        "description": "Hooks意为钩子，React Hooks就是一堆钩子函数，React通过这些钩子函数对函数型组件进行增强，不同的钩子函数提供了不同的功能。钩子函数有一个特点，都是以use开头。",
        "date": "2021-08-31T00:00:00.000Z",
        "formattedDate": "2021年8月31日",
        "tags": [
          {
            "label": "Hooks",
            "permalink": "/blog/tags/hooks"
          }
        ],
        "readingTime": 2.66,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "useState是怎么回事？",
          "date": "2021-8-31",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Hooks",
          "tags": [
            "Hooks"
          ]
        },
        "prevItem": {
          "title": "一道看似简单的阿里前端算法题",
          "permalink": "/blog/一道看似简单的阿里前端算法题"
        },
        "nextItem": {
          "title": "LeetCode——去除重复字母（借助栈）",
          "permalink": "/blog/LeetCode——去除重复字母（借助栈）"
        }
      },
      "content": ">Hooks意为钩子，React Hooks就是一堆钩子函数，React通过这些钩子函数对函数型组件进行增强，不同的钩子函数提供了不同的功能。钩子函数有一个特点，都是以use开头。\r\n\r\n## 为函数组件提供状态\r\n>useState函数的内部是使用闭包来实现函数保存状态数据的。\r\n\r\n### useState的返回值是什么？\r\n>返回值是一个数组，数组的第一项是状态数据，第二项是设置状态数据的方法，关于这个第二项的命名，我们一般采用set+状态数据名的方法，请看下面的例子。\r\n```js\r\nconst [count,setCount] = useState(0);\r\n```\r\n\r\n## useState的细节\r\n1. 接收唯一的参数即状态初始值，初始值可以是任意数据类型。\r\n2. 返回值为数组，数组中存储状态值和更改状态值的方法，方法名称约定以set开头，后面加上状态名称。\r\n3. 方法可以被调用多次，用以保存不同的状态值。\r\n4. 参数可以是一个函数，函数返回什么，初始状态就是什么，函数只会被调用一次，用在初始值是动态值的情况。\r\n\r\n```js\r\nfunction App(props) {\r\n    const [count,setCount] = useState(() => {\r\n        return props.count || 10;\r\n    });\r\n    const [person,setPerson] = useState({name: 'justin'})\r\n    return (\r\n        <div>\r\n            <span>{count},{person.name}</span>\r\n            <br />\r\n            <button onClick={() => setCount(count + 1)}>+1</button>\r\n            <button onClick={() => setPerson({name: '国家'})}>点击切换name</button>\r\n        </div>\r\n    )\r\n}\r\n```\r\n## useState更新状态时是异步的\r\n```js\r\nfunction App(props) {\r\n    const [count,setCount] = useState(0);\r\n    const [person,setPerson] = useState({name: 'justin'})\r\n    function handleCount() {\r\n        setCount(() => {\r\n            return count + 1;\r\n        })\r\n        console.log(count);   // 打印的是0，说明是异步的\r\n    }\r\n    return (\r\n        <div>\r\n            <span>{count},{person.name}</span>\r\n            <br />\r\n            <button onClick={handleCount}>+1</button>\r\n            <button onClick={() => setPerson({name: '国家'})}>点击切换name</button>\r\n        </div>\r\n    )\r\n}\r\n```\r\n## 读取state\r\n>在class的写法中，读取state需要使用this.state，但是在hook写法中，只需要直接使用状态的变量名即可。\r\n\r\n## 为什么叫useState而不叫createState?\r\n>因为Create一词并不是很准确，因为state只在组件首次渲染的时候被创建，在下一次重新渲染的时候，useState返回给我们当前的state。"
    },
    {
      "id": "/LeetCode——去除重复字母（借助栈）",
      "metadata": {
        "permalink": "/blog/LeetCode——去除重复字母（借助栈）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——去除重复字母（借助栈）.md",
        "source": "@site/blog\\LeetCode——去除重复字母（借助栈）.md",
        "title": "LeetCode——去除重复字母（借助栈）",
        "description": "题目描述",
        "date": "2021-08-30T00:00:00.000Z",
        "formattedDate": "2021年8月30日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 2.305,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——去除重复字母（借助栈）",
          "date": "2021-8-30",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "useState是怎么回事？",
          "permalink": "/blog/useState是怎么回事"
        },
        "nextItem": {
          "title": "为什么需要React Hooks?",
          "permalink": "/blog/为什么需要React Hooks"
        }
      },
      "content": "## 题目描述\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/73aaaef9c869036d2d22c3df49109d1f.png)\r\n\r\n## 解题思路\r\n>本题我们采用栈的思路来解决这个问题,在解决问题之前,首先我们要看懂这个题目,这个题目并不是说对字母去重后直接按照字典序排列的,而是附加了一个条件即不能打乱其他字符的相对位置,如何能保证不打乱其他字符的相对位置呢?可以采用将该元素在字符串中最后一次出现时再加入栈,即使前面加入了也要pop出去.\r\n\r\n### 第一步: 如果字符出现在栈中则直接跳过\r\n```js\r\nif (stack.indexOf(char) > -1) continue;\r\n```\r\n### 第二步: 如果字符没有出现在栈中,则进行下面的判断\r\n1. 栈中是否有元素.\r\n2. 栈顶元素是否大于第i个字符.\r\n3. 第i个字符后面还有栈顶元素吗?\r\n>都满足则让栈顶元素出栈.\r\n```js\r\nwhile (stack.length > 0 && stack[stack.length -1] > char && s.indexOf(stack[stack.length - 1],i) > i) {\r\n    // 走到这里说明该元素需要跳过\r\n    stack.pop();\r\n}\r\n```\r\n### 第三步: 将第i个元素入栈\r\n```js\r\nstack.push(char);\r\n```\r\n### 第四步: 通过join方法将数组连接成字符串\r\n```js\r\nstack.join('')\r\n```\r\n\r\n## AC代码\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/fbdb1a1a49b0f30313c50b583c618805.png)\r\n\r\n## 题目反思\r\n1. 学会使用栈来解决重复字母问题.\r\n2. 学会通过join方法将数组变为字符串.\r\n3. 判断一个元素是否在数组中出现过不仅可以通过ES6中的方法,还可以通过indexof与-1的关系来进行判断.\r\n4. indexof可以接受两个参数,第一个参数代表的是哪一个字符,第二个参数代表的是从哪里开始往后查找,这个知识在解决本题的过程中,发挥了不可磨灭的作用."
    },
    {
      "id": "/为什么需要React Hooks",
      "metadata": {
        "permalink": "/blog/为什么需要React Hooks",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/为什么需要React Hooks.md",
        "source": "@site/blog\\为什么需要React Hooks.md",
        "title": "为什么需要React Hooks?",
        "description": "Hook是React16.8的新增特性，它可以让我们不使用类组件的情况下使用state以及其他的React特性。",
        "date": "2021-08-29T00:00:00.000Z",
        "formattedDate": "2021年8月29日",
        "tags": [
          {
            "label": "Hooks",
            "permalink": "/blog/tags/hooks"
          }
        ],
        "readingTime": 2.375,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "为什么需要React Hooks?",
          "date": "2021-8-29",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Hooks",
          "tags": [
            "Hooks"
          ]
        },
        "prevItem": {
          "title": "LeetCode——去除重复字母（借助栈）",
          "permalink": "/blog/LeetCode——去除重复字母（借助栈）"
        },
        "nextItem": {
          "title": "React中使用Echarts实现数据可视化的小案例（基础文章）",
          "permalink": "/blog/React中使用Echarts实现数据可视化的小案例（基础文章）"
        }
      },
      "content": ">Hook是React16.8的新增特性，它可以让我们不使用类组件的情况下使用state以及其他的React特性。\r\n\r\n## React Hooks介绍\r\n### React Hooks是用来做什么的？\r\n>对函数型组件进行增强，让函数型组件可以存储状态，可以拥有处理副作用的能力，让开发者在不使用类组件的情况下，实现相同的功能。\r\n\r\n### 什么是副作用？\r\n>上文提到了副作用这一概念，下面我们来讲解下什么是副作用，我们只需要记住只要不是把数据转换为视图的代码那么就属于副作用，例如下面的副作用例子。在类组件中，我们通常使用生命周期钩子函数来处理这些副作用，但是在函数型组件中可以使用Hooks来帮助我们处理副作用\r\n* 获取DOM元素\r\n* 为DOM元素添加事件\r\n* 设置定时器\r\n* 发送ajax请求\r\n\r\n### 类组件的不足（Hooks要解决的问题）\r\n1. 类组件缺少逻辑复用机制\r\n>类组件一般采用高阶组件来复用逻辑，为了复用逻辑增加了无实际渲染效果的组件，增加了组件层级，显示十分臃肿，增加了调试的难度以及降低了运行效率。\r\n\r\n2. 类组件有时候很复杂难以维护\r\n>有时候需要将一组相关的业务逻辑拆分到多个生命周期函数中，或者在一个生命周期函数内存在多个不相关的业务逻辑。\r\n\r\n3. 类成员方法不能保证this指向的正确性\r\n>当我们给一个元素绑定事件的时候，在事件处理函数当中如果需要更改状态，通常需要更改这个函数的this指向，否则可能指向undefined."
    },
    {
      "id": "/React中使用Echarts实现数据可视化的小案例（基础文章）",
      "metadata": {
        "permalink": "/blog/React中使用Echarts实现数据可视化的小案例（基础文章）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React中使用Echarts实现数据可视化的小案例（基础文章）.md",
        "source": "@site/blog\\React中使用Echarts实现数据可视化的小案例（基础文章）.md",
        "title": "React中使用Echarts实现数据可视化的小案例（基础文章）",
        "description": "1. 安装echarts-for-react插件(两个都要装)",
        "date": "2021-08-28T00:00:00.000Z",
        "formattedDate": "2021年8月28日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 3.165,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "React中使用Echarts实现数据可视化的小案例（基础文章）",
          "date": "2021-8-28",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "为什么需要React Hooks?",
          "permalink": "/blog/为什么需要React Hooks"
        },
        "nextItem": {
          "title": "从原理出发理解instanceof",
          "permalink": "/blog/从原理出发理解instanceof"
        }
      },
      "content": "## 1. 安装echarts-for-react插件(两个都要装)\r\n```\r\nnpm install echarts-for-react\r\nnpm install echarts\r\n```\r\n\r\n## 2. 导入ReactEcharts库\r\n```js\r\nimport ReactECharts from 'echarts-for-react';\r\n```\r\n\r\n## 3. 渲染ReactEcharts组件，并通过option导入数据\r\n```js\r\n<ReactECharts option={this.getOption(sales,stores)} />\r\n```\r\n\r\n## 4. 设置数据源option\r\n```js\r\ngetOption = (sales,stores) => {\r\n    return {\r\n        title: {\r\n            text: 'ECharts 入门示例'\r\n        },\r\n        tooltip: {},\r\n        legend: {\r\n            data: ['销量', '库存']\r\n        },\r\n        xAxis: {\r\n            data: [\"衬衫\", \"羊毛衫\", \"雪纺衫\", \"裤子\", \"高跟鞋\", \"袜子\"]\r\n        },\r\n        yAxis: {},\r\n        series: [{\r\n            name: '销量',\r\n            type: 'bar',\r\n            data: [1,2,3,4],\r\n        }, {\r\n            name: '库存',\r\n            type: 'bar',\r\n            data: [2,5,4,6]\r\n        }]\r\n\r\n    }\r\n}\r\n```\r\n\r\n## 如何将柱状图改为折线图\r\n>只需将series的对象中的type更改为line即可。\r\n```js\r\ngetOption = (sales,stores) => {\r\n    return {\r\n        title: {\r\n            text: 'ECharts 入门示例'\r\n        },\r\n        tooltip: {},\r\n        legend: {\r\n            data: ['销量', '库存']\r\n        },\r\n        xAxis: {\r\n            data: [\"衬衫\", \"羊毛衫\", \"雪纺衫\", \"裤子\", \"高跟鞋\", \"袜子\"]\r\n        },\r\n        yAxis: {},\r\n        series: [{\r\n            name: '销量',\r\n            type: 'line',\r\n            data: sales,\r\n        }, {\r\n            name: '库存',\r\n            type: 'line',\r\n            data: stores\r\n        }]\r\n\r\n    }\r\n}\r\n```\r\n>柱状图和折线图的实现效果，如下图所示\r\n\r\n![柱状图](https://img-blog.csdnimg.cn/img_convert/4dba1135680613dbcdef254fcbf1f3f8.png)\r\n![折线图](https://img-blog.csdnimg.cn/img_convert/61840f54f0ab7c31d84abd1b3386c816.png)\r\n\r\n## 如何修改柱状图的颜色\r\n>通过在option中设置color属性，既可以进行全局的样式柱状图颜色修改，也可以局部的修改某一个柱状图的颜色。更多的属性设置需要去查官方文档或者根据官方的实例进行修改。\r\n\r\n**示例代码**\r\n```js\r\noption = {\r\n    // 全局调色盘。\r\n    color: ['#c23531','#2f4554', '#61a0a8', '#d48265', '#91c7ae','#749f83',  '#ca8622', '#bda29a','#6e7074', '#546570', '#c4ccd3'],\r\n\r\n    series: [{\r\n        type: 'bar',\r\n        // 此系列自己的调色盘。\r\n        color: ['#dd6b66','#759aa0','#e69d87','#8dc1a9','#ea7e53','#eedd78','#73a373','#73b9bc','#7289ab', '#91ca8c','#f49f42'],\r\n        ...\r\n    }, {\r\n        type: 'pie',\r\n        // 此系列自己的调色盘。\r\n        color: ['#37A2DA', '#32C5E9', '#67E0E3', '#9FE6B8', '#FFDB5C','#ff9f7f', '#fb7293', '#E062AE', '#E690D1', '#e7bcf3', '#9d96f5', '#8378EA', '#96BFFF'],\r\n        ...\r\n    }]\r\n}\r\n```\r\n## Echarts的按需引入\r\n```js\r\nimport React from 'react';\r\nimport {Card} from 'antd';\r\nimport echartTheme from './../themeLight'\r\n//不是按需加载的话文件太大\r\n//import echarts from 'echarts'\r\n//下面是按需加载\r\nimport echarts from 'echarts/lib/echarts'\r\n//导入折线图\r\nimport 'echarts/lib/chart/line';  //折线图是line,饼图改为pie,柱形图改为bar\r\nimport 'echarts/lib/component/tooltip';\r\nimport 'echarts/lib/component/title';\r\nimport 'echarts/lib/component/legend';\r\nimport 'echarts/lib/component/markPoint';\r\nimport ReactEcharts from 'echarts-for-react';\r\nexport default class Line extends React.Component{\r\n  componentWillMount(){\r\n    //主题的设置要在willmounted中设置\r\n    echarts.registerTheme('Imooc',echartTheme);\r\n  }\r\n  getOption =()=> {\r\n    let option = {\r\n      title:{\r\n        text:'用户骑行订单',\r\n        x:'center'\r\n      },\r\n      tooltip:{\r\n        trigger:'axis',\r\n      },\r\n      xAxis:{\r\n        data:['周一','周二','周三','周四','周五','周六','周日']\r\n      },\r\n      yAxis:{\r\n        type:'value'\r\n      },\r\n      series:[\r\n        {\r\n          name:'OFO订单量',\r\n          type:'line',   //这块要定义type类型，柱形图是bar,饼图是pie\r\n          data:[1000,2000,1500,3000,2000,1200,800]\r\n        }\r\n      ]\r\n    }\r\n   return option\r\n  }\r\n\r\n  render(){\r\n    return(\r\n      <div>\r\n        <Card title=\"折线图表之一\">\r\n            <ReactEcharts option={this.getOption()} theme=\"Imooc\"  style={{height:'400px'}}/>\r\n        </Card>\r\n\r\n      </div>\r\n    )\r\n  }\r\n}\r\n```\r\n## 参考资料\r\n* [echarts-for-react](https://www.jianshu.com/p/f6c1c4618c22)\r\n* [ECharts for React官网](https://git.hust.cc/echarts-for-react/)\r\n* [【React】react项目引入echarts插件](https://www.jianshu.com/p/f6c1c4618c22)"
    },
    {
      "id": "/从原理出发理解instanceof",
      "metadata": {
        "permalink": "/blog/从原理出发理解instanceof",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/从原理出发理解instanceof.md",
        "source": "@site/blog\\从原理出发理解instanceof.md",
        "title": "从原理出发理解instanceof",
        "description": "有了typeof为什么还需要instanceof?",
        "date": "2021-08-27T00:00:00.000Z",
        "formattedDate": "2021年8月27日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 2.365,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "从原理出发理解instanceof",
          "date": "2021-8-27",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "React中使用Echarts实现数据可视化的小案例（基础文章）",
          "permalink": "/blog/React中使用Echarts实现数据可视化的小案例（基础文章）"
        },
        "nextItem": {
          "title": "【青训营】- TypeScript进阶笔记",
          "permalink": "/blog/【青训营】- TypeScript进阶笔记"
        }
      },
      "content": "## 有了typeof为什么还需要instanceof?\r\n>我们都知道typeof可以帮助我们判断数据类型，但是在判断object类型的时候typeof只能告诉我们是object但是不能告诉我们具体属于哪类object,请看下面的代码。instanceof的出现可以解决这个问题。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/b3b32d49759ef74b2cd9d0b2a369b96a.png)\r\n\r\n## instanceof的实现原理\r\n>在介绍instanceof的具体用法之前，我们先看下instanceof的实现原理，从原理出发可以更好的帮助我们理解它的用法。为了让读者更好的理解代码，我们需要直到下面的预备知识。\r\n\r\n* Object.prototype.\\_\\_proto\\_\\_ === null\r\n* Object.prototype是一个空对象\r\n\r\n>实现instanceof的三步走战略，请大家区分好什么是原型什么是原型对象，proto指的是原型，prototype指的是原型对象。\r\n### 第一步：获取左边表达式的原型\r\n```js\r\nlet leftProto = leftVaule.__proto__;\r\n```\r\n### 第二步：获取右边表达式的原型对象\r\n```js\r\nlet rightProtoType = rightVaule.prototype;\r\n```\r\n### 第三步：循环判断左边表达式的原型链上是否有右边的表达式\r\n```js\r\nwhile (true) {\r\n    if (leftProto === null) {\r\n        return false;\r\n    }\r\n    if (leftProto === rightProtoType) {\r\n        return true;\r\n    }\r\n    // 往左边表达式的原型链上的上一层继续查找\r\n    leftProto = leftProto.__proto__\r\n}\r\n```\r\n## 实现instanceof\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/40e9b64b951f300cc5ae23a87c7f0b6a.png)\r\n\r\n## 几个帮助理解instanceof的实例\r\n```js\r\nfunction test() {}\r\nconsole.log(test.__proto__ === Function.prototype); //true\r\nObject instanceof Object // true\r\nFunction instanceof Function // true\r\nFunction instanceof Object // true\r\ntest instanceof test // false\r\ntest instanceof Object // true\r\ntest instanceof Function // true\r\n```\r\n>要想准确理解上面的实例，必须要和上面我们讲的instanceof原理进行结合，技巧就是获取左边表达式的原型和右边表达式的原型对象，判断右边表达式的原型对象是否在左边表达式的原型链上。\r\n\r\n## 参考资料\r\n[浅谈 instanceof 和 typeof 的实现原理](https://juejin.cn/post/6844903613584654344)"
    },
    {
      "id": "/【青训营】- TypeScript进阶笔记",
      "metadata": {
        "permalink": "/blog/【青训营】- TypeScript进阶笔记",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/【青训营】- TypeScript进阶笔记.md",
        "source": "@site/blog\\【青训营】- TypeScript进阶笔记.md",
        "title": "【青训营】- TypeScript进阶笔记",
        "description": "基础知识",
        "date": "2021-08-26T00:00:00.000Z",
        "formattedDate": "2021年8月26日",
        "tags": [
          {
            "label": "字节青训营",
            "permalink": "/blog/tags/字节青训营"
          }
        ],
        "readingTime": 2.43,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "【青训营】- TypeScript进阶笔记",
          "date": "2021-8-26",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "字节青训营",
          "tags": [
            "字节青训营"
          ]
        },
        "prevItem": {
          "title": "从原理出发理解instanceof",
          "permalink": "/blog/从原理出发理解instanceof"
        },
        "nextItem": {
          "title": "【青训营】- TypeScript入门笔记",
          "permalink": "/blog/【青训营】- TypeScript入门笔记"
        }
      },
      "content": "## 基础知识\r\n### any\r\n1. any比较特殊，其实它既是Top TYPE又是Bottom Type，也就是说: any类型的常量/变量可以与任何其他类型的变量/常量相互赋值，但是any类型是不安全的，无语言服务的，所以应该尽量避免使用。\r\n2. any具有传染性: 它会使它所触及的地方变得不安全，所以TS在3.0引入了类型安全的unknown类型作为Top Type.\r\n3. any会隐藏bug\r\n4. any会隐藏代码设计细节：丢失了对数据类型的设计\r\n\r\n### unknown\r\n* unknown类型必须显示注解，TS不会把任何值推导为unknown\r\n* unknown类型只能进行等于和不等于比较\r\n* 只有类型收窄后才能进行相应运算或函数调用\r\n\r\n### boolean\r\n>布尔类型只有两个元素：true和false\r\n* let var变量会被拓宽成boolean类型，const常量就是对应字面量类型\r\n* true和false的联合类型，会被反推回boolean类型\r\n\r\n## TypeScript进阶\r\n### 类型操作keyof\r\n>keyof是在TS2.1引入的，它获取类型上所有已知、public键对应的类型联合。\r\n\r\n### 接口\r\n>接口与类型别名可以认为是同一概念的两种语法。下面介绍下接口与类型别名的区别。\r\n1. 类型别名更为通用，其右侧可以包含类型表达式，但接口右侧只能是某种结构。\r\n2. 接口间继承时TS会检查二者关系，但类型联合时TS会尽最大阻力尝试不会报错。\r\n3. 同一个作用域的多个同名接口声明会被合并。而多个同名类型别名会报错。\r\n\r\n### 类\r\n>class是ES2015引入的新特性，class本质上还是一个函数。作为构造器的函数，必须具有prototype属性，并且prototype类型和构造器返回值的类型相同。"
    },
    {
      "id": "/【青训营】- TypeScript入门笔记",
      "metadata": {
        "permalink": "/blog/【青训营】- TypeScript入门笔记",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/【青训营】- TypeScript入门笔记.md",
        "source": "@site/blog\\【青训营】- TypeScript入门笔记.md",
        "title": "【青训营】- TypeScript入门笔记",
        "description": "1. TypeScript基础",
        "date": "2021-08-25T00:00:00.000Z",
        "formattedDate": "2021年8月25日",
        "tags": [
          {
            "label": "字节青训营",
            "permalink": "/blog/tags/字节青训营"
          }
        ],
        "readingTime": 2.59,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "【青训营】- TypeScript入门笔记",
          "date": "2021-8-25",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "字节青训营",
          "tags": [
            "字节青训营"
          ]
        },
        "prevItem": {
          "title": "【青训营】- TypeScript进阶笔记",
          "permalink": "/blog/【青训营】- TypeScript进阶笔记"
        },
        "nextItem": {
          "title": "【青训营】- Node.js基础入门笔记2",
          "permalink": "/blog/【青训营】- Node.js基础入门笔记2"
        }
      },
      "content": "## 1. TypeScript基础\r\n### 1.1 开发环境\r\n1. 安装VSCode\r\n2. 安装Node.js\r\n3. 创建项目\r\n```\r\nmkdir first-ts-project && cd first-ts-project\r\nnpm init -y\r\nnpm install --save-dev typescript\r\nnpm install --save-dev typescripr@next\r\n```\r\n4. 创建tsconfig.json\r\n5. 选择TypeScript版本\r\n\r\n### 1.2 预备知识\r\n#### JS与TS的关系\r\n>TypeScript是JavaScript的超集，TS提供了所有JS的特性，并在其上层增加了TypeScript的类型系统，这个类型系统被设计为可选的，这就意味着，所有合法的JS代码都是合法的TS代码。\r\n\r\n#### TS的编译过程\r\n>TS的类型检查和生成JS是两个独立的过程，类型检查出错不影响生成JS代码！\r\n\r\n#### 类型系统\r\n* 结构类型系统：通过类型的实际结构确定两个类型是否相等或兼容\r\n* 名义类型系统：通过类型的名称确定两个类型是否相等\r\n\r\n#### 类型注解\r\n>TS放在后面。加单冒号。\r\n\r\n#### 类型拓宽、收窄\r\n* 类型拓宽：TS不用字面量类型作为该变量的类型，而是从字面量类型拓展到相应的更宽泛的类型，这个过程叫做类型拓宽。\r\n\r\n* 类型收窄：在某些情况下，TS可以更加确定变量的类型，此时它会将变量类型收窄。\r\n\r\n>TS试图在类型确定性和灵活性之前取得平衡，TS提供一系列方法来帮助收窄类型，以提高类型的确定性。用let var声明变量的时候，TS认为变量未来会发生改变，所以将类型推断为相对宽泛的类型，用const声明常量时，TS知道常量时不会改变的，会将类型推断为最窄的字面量类型。\r\n\r\n#### 值空间与类型空间\r\n* 如何判断符号是在哪个空间？\r\n1. 转译后消失的符号->类型空间\r\n2. 作为类型注解、别名的符号->类型空间\r\n3. 类型断言后的符号->类型空间\r\n4. const、let、var后面的符号->值空间\r\n5. class、enum、namespace后的符号->值空间+类型空间"
    },
    {
      "id": "/【青训营】- Node.js基础入门笔记2",
      "metadata": {
        "permalink": "/blog/【青训营】- Node.js基础入门笔记2",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/【青训营】- Node.js基础入门笔记2.md",
        "source": "@site/blog\\【青训营】- Node.js基础入门笔记2.md",
        "title": "【青训营】- Node.js基础入门笔记2",
        "description": "模块化机制",
        "date": "2021-08-24T00:00:00.000Z",
        "formattedDate": "2021年8月24日",
        "tags": [
          {
            "label": "字节青训营",
            "permalink": "/blog/tags/字节青训营"
          }
        ],
        "readingTime": 2.565,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "【青训营】- Node.js基础入门笔记2",
          "date": "2021-8-24",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "字节青训营",
          "tags": [
            "字节青训营"
          ]
        },
        "prevItem": {
          "title": "【青训营】- TypeScript入门笔记",
          "permalink": "/blog/【青训营】- TypeScript入门笔记"
        },
        "nextItem": {
          "title": "【青训营】- Node.js基础入门笔记1",
          "permalink": "/blog/【青训营】- Node.js基础入门笔记1"
        }
      },
      "content": "## 模块化机制\r\n### CommonJS规范\r\n* 加载方式\r\n1. 加载内置模块require('fs')\r\n2. 加载相对或绝对路径的文件模块require('/User/...')\r\n3. 加载npm包 require('lodash')\r\n\r\n* npm包查找原则\r\n1. 当前目录的node_modules文件夹\r\n2. 如果没有，沿着路径向上递归，直到根目录下的node_modules\r\n3. 找到之后会加载package.json 中main属性指向的文件，如果没有package.json则依次查找index.js、index.json、index.node\r\n\r\n* require.cache\r\n>require.cache中缓存着加载过的模块，缓存的原因：同步加载。\r\n1. 文件模块查找比较耗时，如果每次require都需要重新遍历查找，性能会比较差。\r\n2. 在实际开发中模块可能包含副作用代码。\r\n\r\n### 其他模块化规范\r\n* AMD是RequireJS在推广过程中规范化产出，异步加载，推崇依赖前置。\r\n* CMD是SeaJS在推广过程中规范化产出，异步加载，推崇就近依赖。\r\n* UMD规范，兼容AMD和CommonJS模式。\r\n* ES Modules,语言层面的模块化规范，与环境无关，可借助babel编译。\r\n\r\n## 包管理机制\r\n>npm是Node.js中的包管理其，提供了安装、删除等其他命令来管理包。\r\n\r\n* 常用命令\r\n```shell\r\nnpm init\r\nnpm config\r\nnpm run\r\nnpm install \r\nnpm uninstall\r\nnpm update\r\nnpm publish\r\n```\r\n\r\n## 异步编程\r\n### Promise\r\n>Promise是一个具有四个状态的有限状态机，其中三个核心状态为pending,fulfilled、rejected以及还有一个未开始的状态。\r\n\r\n## Web应用开发\r\n### HTTP模块\r\n>搭建一个最简单的HTTP服务，可以通过Node.js内置的HTTP模块。\r\n\r\n### KOA介绍\r\n>Koa是基于Node.js平台的下一代Web开发框架，Koa它仅仅提供了一个轻量优雅的函数库，使得编写Web应用变得得心应手，不在内核方法中绑定任何中间件。下面介绍下执行过程。\r\n* 服务启动\r\n    * 实例化application\r\n    * 注册中间件\r\n    * 创建服务、监听端口\r\n* 接受/处理请求\r\n    * 获取req/res对象\r\n    * 执行中间件\r\n    * 输出设置到ctx.body上的内容"
    },
    {
      "id": "/【青训营】- Node.js基础入门笔记1",
      "metadata": {
        "permalink": "/blog/【青训营】- Node.js基础入门笔记1",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/【青训营】- Node.js基础入门笔记1.md",
        "source": "@site/blog\\【青训营】- Node.js基础入门笔记1.md",
        "title": "【青训营】- Node.js基础入门笔记1",
        "description": "1. Node.js简介",
        "date": "2021-08-23T00:00:00.000Z",
        "formattedDate": "2021年8月23日",
        "tags": [
          {
            "label": "字节青训营",
            "permalink": "/blog/tags/字节青训营"
          }
        ],
        "readingTime": 2.275,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "【青训营】- Node.js基础入门笔记1",
          "date": "2021-8-23",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "字节青训营",
          "tags": [
            "字节青训营"
          ]
        },
        "prevItem": {
          "title": "【青训营】- Node.js基础入门笔记2",
          "permalink": "/blog/【青训营】- Node.js基础入门笔记2"
        },
        "nextItem": {
          "title": "【青训营】- Web标准与前端开发",
          "permalink": "/blog/【青训营】- 如何写好JS"
        }
      },
      "content": "## 1. Node.js简介\r\n>Node是一个基于Chrome V8引擎、跨平台的JS**运行环境**，注意是环境。\r\n\r\n### 版本管理\r\n载体同一个设备可以通过下面的版本管理工具来切换node的版本。\r\n* n: 一个npm全局的开源包，是依赖npm来全局安装、使用的。\r\n* fnm: 快速简单，兼容性支持\r\n* nvm: 独立的软件包。（Node Version Manager）\r\n\r\n### Node的特点\r\n#### 异步I/O\r\n> 当Node执行IO操作时，会在响应返回并恢复操作，而不是阻塞线程并浪费CPU循环等待。\r\n\r\n#### 单线程\r\n>Node保持了JS在浏览器中单线程的特点。以浏览器为例，浏览器是多进程，JS引擎是单线程。\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/5786fd57c26c03e73bb78caae42899a8.png)\r\n\r\n* 优点：\r\n>不用处处在意状态同步的问题，不会发生死锁，没有线程上下文切换带来的性能开销。\r\n\r\n* 缺点：\r\n>无法利用多核CPU，错误会引起整个应用退出，健壮性不足，大量计算占用导致CPU，无法继续执行。\r\n\r\n\r\n\r\n#### 跨平台\r\n>Node兼容了Linux和*nix平台，主要得益于在操作系统和Node上层模块系统之间构建了一层平台架构。\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/2071e55e4e11b7e0097932d21aa9c272.png)\r\n\r\n### 应用场景\r\n>Node在大部分领域都有一席之地，尤其是I/O密集型的。\r\n\r\n* Web领域：Express/Koa\r\n* 前端构建：Webpack\r\n* GUI客户端软件：VSCode/网易云音乐\r\n* 1实时通信、爬虫、CLI等...\r\n\r\n## 模块化机制\r\n1. 何为模块化？\r\n>根据功能或业务将一个大程序拆分为互相依赖的小文件，再用简单的方式拼装起来。\r\n\r\n2. 为什么模块化？\r\n>所有Script标签必须保证顺序正确，否则会依赖报错，全局变量存在命名冲突，占用内存无法被回收"
    },
    {
      "id": "/【青训营】- 如何写好JS",
      "metadata": {
        "permalink": "/blog/【青训营】- 如何写好JS",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/【青训营】- 如何写好JS.md",
        "source": "@site/blog\\【青训营】- 如何写好JS.md",
        "title": "【青训营】- Web标准与前端开发",
        "description": "写好JS的一些原则",
        "date": "2021-08-22T00:00:00.000Z",
        "formattedDate": "2021年8月22日",
        "tags": [
          {
            "label": "字节青训营",
            "permalink": "/blog/tags/字节青训营"
          }
        ],
        "readingTime": 2.52,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "【青训营】- Web标准与前端开发",
          "date": "2021-8-22",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "字节青训营",
          "tags": [
            "字节青训营"
          ]
        },
        "prevItem": {
          "title": "【青训营】- Node.js基础入门笔记1",
          "permalink": "/blog/【青训营】- Node.js基础入门笔记1"
        },
        "nextItem": {
          "title": "【青训营】- Web标准与前端开发",
          "permalink": "/blog/【青训营】- Web标准与前端开发"
        }
      },
      "content": "## 写好JS的一些原则\r\n### 各司其责\r\n* JavaScript：负责行为表现\r\n* CSS: 负责样式\r\n* HTML：负责结构\r\n\r\n### 组件封装\r\n>组件是值web页面上抽离出来的一个个包含模板、功能和样式的单元，好的组件具备封装性\r\n、正确性、拓展性、复用性。组件设计的原则：封装性、正确性、拓展性、复用性。\r\n\r\n实现组件的步骤：\r\n* 结构设计\r\n* 展现效果\r\n* 行为设计\r\n\r\n三次重构\r\n* 插件化\r\n* 模板化\r\n* 抽象化\r\n\r\n### 过程抽象\r\n* 用来处理局部细节控制的一些方法。\r\n* 函数式编程思想的基础应用。\r\n\r\n### 高阶函数\r\n* 以函数作为参数\r\n* 以函数作为返回值\r\n* 常用于作为函数装饰器\r\n\r\n>下面介绍一些常用的高阶函数\r\n* Once\r\n* Throttle\r\n* Debounce\r\n* Consumer\r\n* Iterative\r\n\r\n### 写代码最应当关注的是什么？\r\n* 风格\r\n* 效率\r\n* 约定\r\n* 使用场景\r\n* 设计\r\n\r\n>下面介绍下我个人的心得体会，关于如何写好JS\r\n\r\n### 1. 代码应该有清晰的结构\r\n>有了清晰的结构，方便我们后续的阅读和维护，假以时日再次阅读该代码也可以快速上手，如果没有清晰的结构，一旦代码量增大，则可能导致难以排查错误的情况。\r\n\r\n### 2. 指定良好的编码规范\r\n>一个良好的代码不应该有下面的问题：\r\n* 重复代码\r\n* 命名不规范\r\n* 函数过长\r\n\r\n### 3. 避免使用JS内置不合理语法\r\n>JS这门语言由于历史原因，存在一些不合理的语法（可能会造成预料之外的bug）,例如全局变量、等于判断、eval的使用等。\r\n\r\n### 4. 尽量简洁的JS代码\r\n>在实现一个功能的时候，写法往往有很多种，一万个人就有一万个哈姆雷特，但是越简洁的语法，越能激起人们阅读的兴趣，同时能够提高可读性。"
    },
    {
      "id": "/【青训营】- Web标准与前端开发",
      "metadata": {
        "permalink": "/blog/【青训营】- Web标准与前端开发",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/【青训营】- Web标准与前端开发.md",
        "source": "@site/blog\\【青训营】- Web标准与前端开发.md",
        "title": "【青训营】- Web标准与前端开发",
        "description": "1. 关于前端开发",
        "date": "2021-08-21T00:00:00.000Z",
        "formattedDate": "2021年8月21日",
        "tags": [
          {
            "label": "字节青训营",
            "permalink": "/blog/tags/字节青训营"
          }
        ],
        "readingTime": 2.58,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "【青训营】- Web标准与前端开发",
          "date": "2021-8-21",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "字节青训营",
          "tags": [
            "字节青训营"
          ]
        },
        "prevItem": {
          "title": "【青训营】- Web标准与前端开发",
          "permalink": "/blog/【青训营】- 如何写好JS"
        },
        "nextItem": {
          "title": "【青训营】- Script标签中async和defer属性总结",
          "permalink": "/blog/【青训营】- Script标签中async和defer属性总结"
        }
      },
      "content": "## 1. 关于前端开发\r\n### 前端开发的时代变迁\r\n#### 只读时代\r\n* HTML/CSS/JS\r\n* 单向发布\r\n* 静态只读\r\n* 刷新页面\r\n* 表格对齐元素\r\n* CGI\r\n\r\n#### 体验时代\r\n* Ajax/web api/Jquery\r\n* 动态交互\r\n* 社交媒体\r\n* 用户生成内容\r\n* 单页应用\r\n* jquery\r\n\r\n#### 敏捷时代\r\n* Fetch/Nodejs/Webpack\r\n* 模块化\r\n* 组件化\r\n* 转译\r\n* 打包\r\n* React\r\n* Vue\r\n\r\n### 前端开发的应用领域\r\n* Business\r\n* Customer\r\n* Developer\r\n\r\n### 前端应用领域之浏览器\r\n#### 客户端\r\n* Chrome\r\n* Edge\r\n* Firefox\r\n* Opera\r\n* Safari\r\n\r\n#### 移动端\r\n* 安卓\r\n* IOS\r\n\r\n### 前端应用领域之服务器\r\n* Nodejs\r\n* express\r\n* koa\r\n\r\n### 前端应用领域之终端和跨端\r\n#### 命令行/终端\r\n* webpack cli\r\n* babel cli\r\n* vue cli\r\n* react cli\r\n\r\n#### 桌面跨端\r\n* Electron\r\n* nw.js\r\n\r\n## 2. 关于web标准\r\n### 标准组织\r\n* W3C\r\n* Ecma\r\n* WHATWG\r\n* IETF\r\n\r\n### W3C规范制定流程\r\n1. 首次发布公开工作草案。\r\n2. 发布数份修订公开工作草案。\r\n3. 发布候选建议书。\r\n4. 发布提议建议书。\r\n5. 发布w3c建议书。\r\n5. 发布编辑建议书。\r\n\r\n### Ecma TC39规范制定流程\r\n>规范制定的主要流程图如下所示：\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/dd070bacf84c2227713d5d5a8eec3173.png)\r\n\r\n* 阶段0：在这个阶段只有TC39的成员可以提交。可以是任何的idea或者没加到提案中的新特性。\r\n* 阶段1：正式产出一个提案，找出可能的问题，提案应该包含详细的API描述以及使用例子。\r\n* 阶段2：这个阶段会产出一个初始的草案规范，并开始尝试实现，实现的形式可以是polyfill或者babel.\r\n* 阶段3：这个阶段处于候选阶段，在这个阶段会拿到具体的实验方案和用户的反馈，必须有完整的规范文档，至少要在一个浏览器中实现。\r\n* 阶段4：这个阶段属于已经准备就绪，该阶段的特性将会出现在下个版本的ECMAScript规范之中，同时需要通过两个独立的实现并通过验收测试。"
    },
    {
      "id": "/【青训营】- Script标签中async和defer属性总结",
      "metadata": {
        "permalink": "/blog/【青训营】- Script标签中async和defer属性总结",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/【青训营】- Script标签中async和defer属性总结.md",
        "source": "@site/blog\\【青训营】- Script标签中async和defer属性总结.md",
        "title": "【青训营】- Script标签中async和defer属性总结",
        "description": "为什么需要async和defer？",
        "date": "2021-08-19T00:00:00.000Z",
        "formattedDate": "2021年8月19日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 2.465,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "【青训营】- Script标签中async和defer属性总结",
          "date": "2021-8-19",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "【青训营】- Web标准与前端开发",
          "permalink": "/blog/【青训营】- Web标准与前端开发"
        },
        "nextItem": {
          "title": "LeetCode——替换后的最长重复字符（滑动窗口）",
          "permalink": "/blog/LeetCode——替换后的最长重复字符（滑动窗口）"
        }
      },
      "content": "## 为什么需要async和defer？\r\n>在进行详细介绍async和defer的区别之前，我们先讲讲为什么需要这两个属性，请看下面的例子，假如资源1需要加载很久才能完成，但是资源2很快就可以完成，此时用户需要等待很久才能看到页面，造成用户体验不好，所以我们需要一个推迟加载资源1的方法，这就是async和defer诞生的原因。\r\n```js\r\n<script src=\"资源1.js\"></script>\r\n<script src=\"资源2.js\"></script>\r\n```\r\n* 解决上述问题的方法\r\n>让第二个文件推迟执行，也就是说添加defer属性。\r\n```js\r\n<script src=\"资源1.js\" defer></script>\r\n```\r\n## async和defer的区别\r\n### 1. 不含async也不含defer\r\n>此时执行顺序是同步的，也就是按照定义的顺序，谁在上面谁先执行，执行完一个在执行下一个。这是script标签在body底部的情况，如果在head中定义则会阻塞HTML的解析，请看下图。JS脚本的加载和执行会阻塞DOM的渲染。\r\n### 2. 只含async\r\n>立即下载，不影响其他操作，等下载完成之后在暂停HTML解析然后执行脚本。(加载完成后会立即执行)\r\n### 3. 只含defer\r\n>立即下载，但是在Html解析和script加载完之后在执行defer属性标记的脚本。\r\n\r\n## async和defer的相同之处\r\n* 都是异步加载。\r\n* 都不影响DOM解析和其他资源的加载。\r\n\r\n**执行步骤图示**\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/3b2c1f2ae44146efa59678661d48d469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzQxNjk2Njg3,size_16,color_FFFFFF,t_70)\r\n\r\n\r\n>如果你想对这两个属性进行测试，可以尝试使用node创建一个服务器，然后通过延迟返回来测试输出的顺序。\r\n\r\n## 参考资料\r\n* [async和defer属性的区别-[译]](https://juejin.cn/post/6844904015956803597)\r\n\r\n* [async与defer有什么异同？](https://github.com/wsqww/devNote/issues/21)\r\n\r\n* [Script async 与 defer 有什么区别](https://segmentfault.com/a/1190000038575560)\r\n\r\n* [script标签上async 和 defer的区别](https://github.com/gwl002/gwl002.github.io/issues/7)"
    },
    {
      "id": "/LeetCode——替换后的最长重复字符（滑动窗口）",
      "metadata": {
        "permalink": "/blog/LeetCode——替换后的最长重复字符（滑动窗口）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——替换后的最长重复字符（滑动窗口）.md",
        "source": "@site/blog\\LeetCode——替换后的最长重复字符（滑动窗口）.md",
        "title": "LeetCode——替换后的最长重复字符（滑动窗口）",
        "description": "题目描述",
        "date": "2021-08-16T00:00:00.000Z",
        "formattedDate": "2021年8月16日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 3.25,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——替换后的最长重复字符（滑动窗口）",
          "date": "2021-8-16",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "【青训营】- Script标签中async和defer属性总结",
          "permalink": "/blog/【青训营】- Script标签中async和defer属性总结"
        },
        "nextItem": {
          "title": "LeetCode——最大连续1的个数 III（滑动窗口）",
          "permalink": "/blog/LeetCode——最大连续1的个数 III（滑动窗口）"
        }
      },
      "content": "## 题目描述\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/3bec257954e4e2f1372a4cff038b7868.png)\r\n\r\n## 解题思路\r\n>核心的解题思路是：滑动窗口。\r\n1. 构造一个数组，该数组拥有26个元素，下标代表的是大写字母A-Z。\r\n```js\r\nlet letterArr = new Array(26).fill(0);\r\n```\r\n2. 定义滑动窗口的左右边界和滑动窗口中出现次数最多的字母的出现次数。\r\n```js\r\n// 定义滑动窗口的左边界\r\nlet left = 0;\r\n// 定义滑动窗口的右边界\r\nlet right = 0;\r\n// 定义滑动窗口中出现次数最多的字母的次数\r\nlet max = 0;\r\n```\r\n3. 当右边界小于数组长度的时候，进入循环体，首先判断滑动窗口右边界指向的元素的是哪一个字母，然后将对应出现的次数+1，然后更新最大值，如果滑动窗口不满足条件，则更新左边界，反之更新右边界。\r\n```js\r\nwhile (right < s.length) {\r\n    // 判断滑动窗口右边界指向的字母是哪一个字母，对应的将其次数加1\r\n    let sub = s[right].charCodeAt() - 65;\r\n    letterArr[sub]++;\r\n    // 将右边界指向的字母出现的次数和最大值进行比较更新\r\n    max = Math.max(max, letterArr[sub]);\r\n    // 判断是更新左边界还是更新右边界\r\n    if (right - left + 1 > max + k) {\r\n        // 此时更新左边界\r\n        letterArr[s[left].charCodeAt() - 65]--;\r\n        left++;\r\n        letterArr[s[right].charCodeAt() - 65]--;\r\n    } else {\r\n        right++;\r\n    }\r\n}\r\n```\r\n4. 返回滑动窗口的长度\r\n```js\r\nreturn s.length - left;\r\n```\r\n\r\n## AC代码\r\n```js\r\nvar characterReplacement = function (s, k) {\r\n    // 核心思路：滑动窗口\r\n    // 构造所有大写字母的数组，下标代表元素A-Z，值代表的是在滑动窗口中出现的次数\r\n    let letterArr = new Array(26).fill(0);\r\n    // 定义滑动窗口的左边界\r\n    let left = 0;\r\n    // 定义滑动窗口的右边界\r\n    let right = 0;\r\n    // 定义滑动窗口中出现次数最多的字母的次数\r\n    let max = 0;\r\n\r\n    while (right < s.length) {\r\n        // 判断滑动窗口右边界指向的字母是哪一个字母，对应的将其次数加1\r\n        let sub = s[right].charCodeAt() - 65;\r\n        letterArr[sub]++;\r\n        // 将右边界指向的字母出现的次数和最大值进行比较更新\r\n        max = Math.max(max, letterArr[sub]);\r\n        // 判断是更新左边界还是更新右边界\r\n        if (right - left + 1 > max + k) {\r\n            // 此时更新左边界\r\n            letterArr[s[left].charCodeAt() - 65]--;\r\n            left++;\r\n            letterArr[s[right].charCodeAt() - 65]--;\r\n        } else {\r\n            right++;\r\n        }\r\n    }\r\n\r\n    return s.length - left;\r\n};\r\n```\r\n## 题目反思\r\n* 学会使用数组的下标和值表示某些元素出现的次数。\r\n* 学会使用滑动窗口解决数组中的替换问题。"
    },
    {
      "id": "/LeetCode——最大连续1的个数 III（滑动窗口）",
      "metadata": {
        "permalink": "/blog/LeetCode——最大连续1的个数 III（滑动窗口）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——最大连续1的个数 III（滑动窗口）.md",
        "source": "@site/blog\\LeetCode——最大连续1的个数 III（滑动窗口）.md",
        "title": "LeetCode——最大连续1的个数 III（滑动窗口）",
        "description": "题目描述",
        "date": "2021-08-16T00:00:00.000Z",
        "formattedDate": "2021年8月16日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 3.09,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——最大连续1的个数 III（滑动窗口）",
          "date": "2021-8-16",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "LeetCode——替换后的最长重复字符（滑动窗口）",
          "permalink": "/blog/LeetCode——替换后的最长重复字符（滑动窗口）"
        },
        "nextItem": {
          "title": "必须搞懂的跨域解决方案",
          "permalink": "/blog/必须搞懂的跨域解决方案"
        }
      },
      "content": "## 题目描述\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/70823013c0adde9a2decd49bcfb6a6fc.png)\r\n\r\n## 解题思路\r\n>本题的核心思路是滑动窗口，而滑动窗口的实现需要借助双指针，这是解决本题的核心思路。\r\n1. 定义滑动窗口的左右边界。\r\n```js\r\nlet l = 0;\r\nlet r = 0;\r\n```\r\n2. 定义滑动窗口中连续1的个数（包含K个零）\r\n```js\r\nlet max = 0;\r\n```\r\n3. 定义滑动窗口中零的个数。\r\n```js\r\nlet zeros = 0;\r\n```\r\n4. 核心循环体\r\n* 进入循环的条件是右边界越界\r\n```js\r\nwhile (r < nums.length)\r\n```\r\n* 判断滑动窗口中零的个数和K的关系\r\n    >只有两种关系，要么滑动窗口中零的个数小于等于K,要么大于K，如果小于K，说明窗口右边界还未满足条件，还需要继续扩充右边界，此时让r++,但是在右边界扩充的时候，我们要看当前右指针指向的元素是0还是1，如果是1则直接向右扩充即可，但是如果是1，则需要更新0的个数之后，继续扩充，如果零的个数大于K，则需要移动左边界，在移动左边界的时候，依然要考虑上述因素。\r\n    ```js\r\n    if (zeros <= k) {\r\n            if (nums[r] === 1) {\r\n                r++;\r\n            } else {\r\n                r++;\r\n                zeros++;\r\n            }\r\n        }\r\n        if (zeros > k) {\r\n            if (nums[l] === 0) {\r\n                zeros--;\r\n                l++;\r\n            } else {\r\n                l++;\r\n            }\r\n        }\r\n    ```\r\n* 更新最大值（因为r总是先移动后判断，所以用右边界-左边界就可以和最大值进行比较更新）\r\n```js\r\nif (r - l > max) {\r\n    max = r - l;\r\n}\r\n```\r\n\r\n## AC代码\r\n```js\r\n// 核心思路: 滑动窗口 + 更新最大值\r\nvar longestOnes = function (nums, k) {\r\n    // 定义滑动窗口的左右边界\r\n    let l = 0;\r\n    let r = 0;\r\n    // 定义滑动窗口中连续1（包含K个零）的最大值\r\n    let max = 0;\r\n    // 定义滑动窗口中0的个数\r\n    let zeros = 0;\r\n\r\n    // 进入循环的条件是：滑动窗口的右边界没有越界\r\n    while (r < nums.length) {\r\n        if (zeros <= k) {\r\n            if (nums[r] === 1) {\r\n                r++;\r\n            } else {\r\n                r++;\r\n                zeros++;\r\n            }\r\n        }\r\n        if (zeros > k) {\r\n            if (nums[l] === 0) {\r\n                zeros--;\r\n                l++;\r\n            } else {\r\n                l++;\r\n            }\r\n        }\r\n        if (r - l > max) {\r\n            max = r - l;\r\n        }\r\n    }\r\n    return max;\r\n};\r\n```\r\n## 执行结果\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/46a6893690961a7f49b57eff9e9782fc.png)\r\n\r\n## 题目反思\r\n* 学会使用滑动窗口的方式求解子区间、子数组问题。\r\n* 学会使用更新的方式获取最大值。"
    },
    {
      "id": "/必须搞懂的跨域解决方案",
      "metadata": {
        "permalink": "/blog/必须搞懂的跨域解决方案",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/必须搞懂的跨域解决方案.md",
        "source": "@site/blog\\必须搞懂的跨域解决方案.md",
        "title": "必须搞懂的跨域解决方案",
        "description": "跨域的前置知识：同源策略",
        "date": "2021-08-16T00:00:00.000Z",
        "formattedDate": "2021年8月16日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 16.865,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "必须搞懂的跨域解决方案",
          "date": "2021-8-16",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "LeetCode——最大连续1的个数 III（滑动窗口）",
          "permalink": "/blog/LeetCode——最大连续1的个数 III（滑动窗口）"
        },
        "nextItem": {
          "title": "这一次，不再为web页面生命周期烦恼",
          "permalink": "/blog/这一次，不再为web页面生命周期烦恼"
        }
      },
      "content": "## 跨域的前置知识：同源策略\r\n>关于跨域是什么，我们这里先不做介绍，我们先介绍下跨域的前置知识（同源策略）。同源策略是浏览器中非常重要的安全策略，用于限制不同源的文档或它加载的脚本，对其他文档的访问，帮助阻拦恶意文档，减少可能被攻击的媒介。\r\n\r\n## 同源的定义\r\n>判断两个URL是否同源，主要判断是协议、主机、端口号，三者是否一致，只有这三者都相同，才是同源。\r\n\r\n* 下面是判断是否同源的例子（主要与 http://store.company.com/dir/page.html 这个URL进行对比）\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/e409d606437acb4c1d014826ea9f42ae.png)\r\n\r\n* 同源的例子\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/af86aabadf98b297ea318c3e33e93938.png)\r\n\r\n* 不同源的例子\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/8ce2261a34946d80749b19f82525517e.png)\r\n\r\n## IE浏览器中同源策略的差异\r\n>IE浏览器中的同源策略和其他浏览器中的同源策略主要有以下两个差异点：\r\n\r\n1. 授信范围：IE浏览器认为如果两个URL是高度互信的域名，如公司域名，则不受同源策略的限制。\r\n2. 端口：IE浏览器未将端口号纳入到同源策略的检查中，因此即使端口号不同，只要主机和协议相同，也是属于同源的。\r\n\r\n## 跨域网络访问的类型\r\n>同源策略控制不同源之间的交互，这些交互可以分为以下三类：\r\n\r\n### 跨域写操作\r\n>跨域写操作一般是允许的，例如链接(links)、重定向以及表单提交。\r\n\r\n### 跨域读操作\r\n>一般是不被允许的，但是我们可以通过内嵌资源来巧妙地进行读取访问。\r\n\r\n### 跨域资源嵌入\r\n>这种类型一般是被允许地，主要有以下实例：\r\n\r\n* script标签\r\n* link标签\r\n* img标签\r\n* video和audio播放地多媒体资源\r\n* 通过\\<object/>\\<embed/>\\<applet/>嵌入的插件。\r\n* 通过@font-face引入的字体。\r\n* 通过\\<iframe/>载入的任何资源。\r\n\r\n\r\n\r\n## 跨域请求有没有发送到服务器端？\r\n>跨域请求实际上已经发送到了服务器，并且客户端也接收到了返回的消息，然而浏览器在接收消息后发现这个信息违反了同源策略且没有被允许跨域，所以在解析该消息的时候会报错。\r\n\r\n## 同源策略限制哪些，不限制哪些？\r\n**限制以下内容：**\r\n\r\n>一般为跨域读操作。\r\n\r\n* Ajax请求。\r\n* Cookie、LoaclStorage。\r\n* DOM对象。\r\n\r\n**不限制以下内容：**\r\n>不限制的内容主要是上文的跨域资源嵌入部分。\r\n\r\n## 跨域解决方案\r\n### 方案一：JSONP\r\n>核心思路：利用html中的script标签不受同源策略的限制来进行跨域，在客户端脚本中定义好处理的函数，然后通过请求参数传递给服务器端，服务器端进行字符串拼接后返回调用该函数。\r\n* 客户端\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/a1ef438c1dc47f83db7ffcdd5d2445a1.png)\r\n* 服务器端（express）\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/d1c4b1af0008dc60e90127b0a5df2348.png)\r\n\r\n[CodeSandBox在线演示](https://codesandbox.io/s/optimistic-murdock-ie1dc?file=/package.json)\r\n\r\n**优缺点**\r\n* 优点：兼容IE。\r\n* 缺点：仅支持get方法，且需要服务器端进行协同。由于是script标签，所以读不到ajax那么精确的状态，不知道状态码是什么，也不知道响应头是什么。\r\n\r\n#### JSONP带来的安全风险\r\n>使用JSONP跨域可能会带来JSONP劫持的问题，这个问题属于CSRF攻击范畴，当某网站通过JSONP的方式来实现跨域并传递给用户认证的敏感信息后，攻击者可以构造恶意的JSONP调用页面，诱导被攻击者访问来达到截取用户敏感信息的目的。\r\n\r\n>关于JSONP劫持漏洞攻击可以看下面的这篇文章。\r\n\r\n[JSONP 劫持原理与挖掘方法](https://www.k0rz3n.com/2019/03/07/JSONP%20%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%95/)\r\n\r\n##### JSONP漏洞利用的原理\r\n>下面以一个实例为例介绍什么是JSONP劫持。\r\n\r\n1. 假设用户已经在网站B上注册并进行了登录，网站B包含了用户的id,name，email等敏感信息。\r\n2. 此时有一个恶意网站A，用户通过浏览器向网站A发送URL请求。\r\n3. 网站A向用户返回响应界面，这个响应的页面中包含了一个JS函数和向网站B请求的script标签。（script标签中的内容如下所示）\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/ab99fc75d85f159b9f2260c91a714992.png)\r\n\r\n4. 用户收到响应后，解析JS代码，将回调函数作为参数向网站B发送请求。\r\n5. 网站B收到请求后，解析请求的URL，以JSON格式生成请求需要的数据，将封装的包含用户信息的JSON数据作为回调函数返回给浏览器。\r\n6. 网站B数据返回后，浏览器自动执行callback函数对步骤4返回的JSON格式的数据进行处理，此时就可能将数据传回给网站A的服务器，这样网站A利用网站B的JSONP漏洞便获得了用户在网站B注册的信息。\r\n\r\n\r\n\r\n### 方案二：CORS\r\n>CORS（跨域资源共享）会允许服务端来指定哪些主机可以从这个服务端加载资源。CORS通过HTTP头的形式告诉浏览器哪些不同来源的客户端可以访问本站的资源的。实现CORS跨域的关键在服务端，只要服务端设置了Access-Control-Allow-Origin就可以开启CORS，客户端发送请求时请求头加origin,服务器返回的响应头加Access-control-allow-origin,浏览器以此来判断是否允许跨域。该属性可以设置哪些域名可以访问服务器，如果设置为星号则表示所有资源都可以访问服务器资源。CORS进行跨域的时候会将请求分为简单请求和预检请求。\r\n\r\n#### 1. 简单请求\r\n> 只要同时满足下面的两个条件，就可以判断为简单请求，简单请求只需在请求时加上origin字段，响应时包含Access-Control-Allow-Origin字段，浏览器以此来判断是否允许跨域。\r\n\r\n1. 请求方法是以下三种方法之一：\r\n\r\n* HEAD\r\n* GET\r\n* POST\r\n\r\n2. HTTP的头信息Request Headers不超出以下几种字段\r\n\r\n* Accept\r\n* Accept-Language\r\n* Content-Language\r\n* Content-Type: (只限于下面的三个值)\r\n    * text/plain\r\n    * multipart/form-data\r\n    * application/x-www-form-urlencoded\r\n    \r\n\r\n#### 2. 预检请求\r\n>不满足简单请求条件的，则判断为需要进行预检请求，浏览器首先使用OPTIONS方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。预检请求的使用可以避免未获得许可的调用方，调用了有副作用的API对服务器端的数据进行修改。\r\n\r\n##### 预检请求包含的字段\r\n* OPTIONS\r\n* Origin\r\n* Access-Control-Request-Method\r\n* Access-Control-Request-Headers\r\n\r\n##### 预检请求的响应字段\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/8b14510f9e8651746d3cf548974648e3.png)\r\n\r\n>上面的字段告知服务器，实际请求将采用什么方法，将包含什么样的请求头。预检请求完成之后，将发送实际请求。\r\n\r\n#### CORS跨域的优缺点\r\n\r\n* 优点\r\n    * CORS通信与同源的AJAX通信没有差别，代码容易维护。\r\n    * 支持所有类型的HTTP请求\r\n    \r\n* 缺点\r\n    * 存在兼容性问题，特别是IE10以下的浏览器\r\n    * 第一次发送非简单请求时会多一次预检请求（第一次之后，服务器对预检请求的响应有一个有效时间）\r\n    \r\n    \r\n**CORS跨域实例**\r\n\r\n* 客户端\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/e4f295e8d0f72e10705170ee120be243.png)\r\n\r\n* 服务器端\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/d19ec8ce1259f51ec37d038cb8dc9169.png)\r\n\r\n>注意：CORS请求如果需要携带cookie信息的时候，需要将withCredentials置为true。\r\n\r\n#### JSONP和CORS比较\r\n* JSONP只支持GET请求，CORS支持所有类型的HTTP请求。\r\n* JSONP比CORS的兼容性好。\r\n\r\n### 方案三：Nginx\r\n>在介绍什么是Nginx跨域之前，我们首先来系统性的介绍下什么是反向代理。\r\n\r\n#### 反向代理和正向代理\r\n>反向代理指的是隐藏了真实的服务端，举个例子，当我们请求百度的时候，背后可能有成千上万台服务器为我们服务，但具体是哪一台，我们并不知道，我们只需要知道我们的反向代理服务器是百度即可，反向代理会帮我们把请求转发到真实的服务器那里去，Nginx就是一种反向代理服务器。顺便提一下，正向代理指的是隐藏了真实的客户端，比如我们如果想要通过代理访问谷歌，此时的代理就是正向代理，因为此时隐藏了真实的客户端。\r\n\r\n#### Nginx跨域的原理\r\n>Nginx作为反向代理服务器，就是把客户端的HTTP请求转发到另一个服务器上，代理服务器访问另一个服务器是不存在跨域问题的，nginx代理服务器获取到数据后，再转发给客户端即可实现跨域。\r\n\r\n* 浏览器角度\r\n\r\n>从浏览器的角度看，就像是访问同源服务器上的URL。\r\n\r\n* 服务器角度\r\n\r\n>从服务器角度看,并不知道这个请求是来自代理服务器的，简单来说是nginx服务器欺骗了浏览器，让浏览器认为是同源调用，又通过重写url，欺骗了真实的服务器，让他以为这个HTTP请求是直接来自用户浏览器的，这样就解决了跨域问题。\r\n\r\n\r\n### 方案四：iframe + postMessage\r\n>postMessage是HTML5新增的一项功能，该方法提供了一种受控机制来规避同源策略，可以实现跨源通信。\r\n\r\n#### 实现原理\r\n>父页面中通过iframe标签引入子页面，主页面加载完毕之后，通过postMessage方法向子页面发送消息，同时监听来自子页面的消息。子页面通过window.addEventListener方法监听来自父页面的消息，并通过top.postMessage将消息传递给父页面，从而实现跨域通信。\r\n\r\n* [codeSandBox在线实现](https://codesandbox.io/s/iframe-postmessagekua-yu-8qp1u?file=/src/server.js)\r\n\r\n>下面是实现的效果图\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/2a59b87f0df38fe0d156e33318d937cb.png)\r\n\r\n### 方案五：window.name + iframe\r\n#### 跨域原理\r\n>核心原理：在一个窗口window的生命周期内，窗口载入的所有页面共享一个window.name，每个页面对window.name都有读写权限，window.name持久存在一个窗口载入过的所有页面中。。\r\n\r\n#### 实现流程\r\n>假如A页面要跨域访问B页面，下面介绍下如何实现。\r\n\r\n1. 在页面A中创建一个iframe，将其src指向要跨域的页面B，此时页面B中的window.name中存储着数据，A页面中的iframe此时也能够拿到这个数据。\r\n2. 在A页面第一次调用onload事件的时候，将其src属性改为本地域的一个代理html,这个文件可以是一个空文件，修改src属性后，onload会被再次触发，但是此时window.name还是可以获取到的。\r\n3. 获取数据后，为了防止其他iframe获取这个数据，需要销毁这个iframe。\r\n\r\n#### 在线实现\r\n* [Github地址](https://github.com/qq1120637483/window.name-iframe-)\r\n\r\n### 方案六：WebSocket跨域\r\n>WebSocket协议是HTML5一种新的协议，实现了浏览器与服务器的全双工通信，同时允许跨域通讯，允许服务器端主动向浏览器端发送消息。WebSocket和HTTP都是应用层协议，都基于TCP协议，但是WebSocket在建立的时候需要借助HTTP协议，连接建立好之后，客户端和服务器端之间的双向通信就与HTTP无关了。\r\n\r\n#### WebSocket跨域原理\r\n>客户端可以通过new WebSocket创建一个socket实例，然后通过onopen方法中的send方法将要发送的数据传到后端，也可以利用onmessage方法来监听服务端发送过来的消息，服务端是首先引入ws模块，然后通过new WebSocket.Server来监听一个端口，然后利用message接收数据，利用send向客户端发送数据。\r\n\r\n#### 实例分析\r\n>客户端是建立在5500端口的，服务端是在5000端口的，这样可以测试能否跨域。\r\n\r\n* 客户端实现\r\n\r\n```js\r\n<script>\r\n    let socket = new WebSocket('ws://localhost:5000');\r\n    socket.onopen = function() {\r\n        socket.send('服务端你好');\r\n    }\r\n    socket.onmessage = function(e) {\r\n        console.log('服务端发过来的消息为：',e.data);\r\n    }\r\n</script>\r\n```\r\n\r\n* 服务端实现\r\n\r\n```js\r\nlet express = require('express');\r\n\r\nlet app = express();\r\n\r\nlet webSocket = require('ws');\r\n\r\nlet wss = new webSocket.Server({port:5000});\r\n\r\nwss.on('connection',function(ws) {\r\n    ws.on('message',function(data) {\r\n        console.log('客户端发过来的消息为：',data);\r\n        ws.send('客户端你好');\r\n    })\r\n})\r\n\r\nconsole.log(\"http://localhost:5000\");\r\n```\r\n\r\n### 方案七：NodeJs中间件代理跨域\r\n>node中间件实现跨域，原理大致和nginx跨域类似，都是通过一个代理服务器，实现数据的转发，类似的中间件有http-proxy-middleware。\r\n\r\n>服务端8000端口上有客户端想要获取的数据，客户端在5500端口上，代理服务器在3000端口上。\r\n\r\n* 客户端代码\r\n\r\n```js\r\n<script>\r\n    fetch('http://localhost:3000/api', {\r\n        method: 'GET'\r\n    }).then(value => { console.log(value); })\r\n</script>\r\n```\r\n\r\n* 代理服务器端代码\r\n\r\n```js\r\nconst express = require('express');\r\nconst { createProxyMiddleware } = require('http-proxy-middleware');\r\nconst app = express();\r\n\r\napp.use('/api', createProxyMiddleware({\r\n    // 客户端想要访问的跨域目标地址\r\n    target: \"http://localhost:8000\",\r\n    // 可以让参数是域名\r\n    changeOrigin: true,\r\n    pathRewrite: {\r\n        '^/api': '',\r\n    }\r\n}))\r\n\r\n// 主动监听3000端口\r\napp.listen(3000);\r\nconsole.log('代理服务器运行在：http://localhost:3000');\r\n```\r\n\r\n* 目标跨域页面代码\r\n\r\n```js\r\n<body>\r\n    <h1>这是用户目标想要跨域的页面</h1>\r\n</body>\r\n```\r\n\r\n\r\n>其余跨域方案\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/76b154ca4b9d05969639643f65277603.png)\r\n\r\n## 参考资料\r\n* [这篇文章对跨域的讲解堪称神作，简直太完美了，精辟！](https://www.jianshu.com/p/7db410081890)"
    },
    {
      "id": "/这一次，不再为web页面生命周期烦恼",
      "metadata": {
        "permalink": "/blog/这一次，不再为web页面生命周期烦恼",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/这一次，不再为web页面生命周期烦恼.md",
        "source": "@site/blog\\这一次，不再为web页面生命周期烦恼.md",
        "title": "这一次，不再为web页面生命周期烦恼",
        "description": "什么是Web页面生命周期？",
        "date": "2021-08-15T00:00:00.000Z",
        "formattedDate": "2021年8月15日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 3.985,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "这一次，不再为web页面生命周期烦恼",
          "date": "2021-8-15",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "必须搞懂的跨域解决方案",
          "permalink": "/blog/必须搞懂的跨域解决方案"
        },
        "nextItem": {
          "title": "TypeScript中的类--(TypeScript 05)",
          "permalink": "/blog/TypeScript中的类--(TypeScript 05)"
        }
      },
      "content": "## 什么是Web页面生命周期？\r\n>我们每天在浏览器中通过一个又一个的标签页来浏览相关的信息，当我们在浏览器打开很多个标签页的时候，浏览器在资源紧张的时候，并不会为每一个网页保存资源，浏览器会在标签页不活动的时候，重新分配资源。浏览器对这些页面的干预会通过页面生命周期API暴露出来。这个生命周期就是本次我们讨论的主要话题。\r\n\r\n## 页面生命周期的主要事件\r\n### 1. DOMContentLoaded\r\n>该API表示浏览器已经完全加载了HTML，并构建好了DOM树，但是css和img等外部资源尚未加载完成。注意：这里的外部资源指的是需要发送http请求获得的资源，而不是自己文件中的资源，我们看下面的例子，下面的这个例子中的img是来自cdn的资源，而不是本地资源，如果是请求的本地资源是能够获取到图片的尺寸的。\r\n\r\n```html\r\n<h1>Hello, DOMContentLoaded!</h1>\r\n<img id=\"img\" src=\"https://en.js.cx/clipart/train.gif?speed=1&cache=0\">\r\n\r\n<script>\r\n    function testReady() {\r\n        alert('DOM树已经构建完毕！')\r\n        alert(`此时图片的大小为${img.offsetWidth}*${img.offsetHeight}`)\r\n\r\n    }\r\n    document.addEventListener('DOMContentLoaded',testReady);\r\n</script>\r\n```\r\n[CodeSandBox在线演示](https://codesandbox.io/s/webye-mian-de-sheng-ming-zhou-qi-t9i8l?file=/index.html)\r\n\r\n* DOMContentLoaded会等待所有script标签执行完毕之后再执行。\r\n```js\r\n<script>\r\n    document.addEventListener(\"DOMContentLoaded\", () => {\r\n        alert(\"DOM ready!\");\r\n    });\r\n</script>\r\n\r\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js\"></script>\r\n\r\n<script>\r\n    alert(\"Library loaded, inline script executed\");\r\n</script>\r\n```\r\n>上面的代码会先输出 Library...，然后才输出DOM ready!\r\n\r\n* 如果一个样式资源后面跟着一个script标签，必须执行完样式和这个script标签才会调用DOMContentLoaded。\r\n```js\r\n<script>\r\n    document.addEventListener(\"DOMContentLoaded\", () => {\r\n        alert(\"DOM ready!\");\r\n    });\r\n</script>\r\n\r\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js\"></script>\r\n\r\n<script>\r\n    alert(\"Library loaded, inline script executed\");\r\n</script>\r\n<link href=\"https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.0.2/css/bootstrap-grid.css\" rel=\"stylesheet\">\r\n<script>\r\n  // 在样式表加载完成之前，脚本都不会执行\r\n  alert(getComputedStyle(document.body).marginTop);\r\n</script>\r\n```\r\n### 2. window.onload\r\n>这个事件表示，页面已经加载完了所有的HTML、DOM树和样式图片等资源。\r\n```js\r\n<script>\r\n    window.onload = function test() {\r\n        alert('HTML、图片、样式等资源均加载完毕');\r\n        alert(`图片的大小是${img.offsetWidth}*${img.offsetHeight}`);\r\n    }\r\n</script>\r\n\r\n<img id=\"img\" src=\"https://en.js.cx/clipart/train.gif?speed=1&cache=0\" />\r\n```\r\n[CodeSandBox在线演示](https://codesandbox.io/s/window-onloadde-shi-yong-fang-shi-zrk8k?file=/index.html)\r\n\r\n### 3. window.unload\r\n>这个事件在访问者离开页面的时候触发，在这里可以做一些不涉及延迟操作的事。\r\n```js\r\nlet analyticsData = { /* 带有收集的数据的对象 */ };\r\n\r\nwindow.addEventListener(\"unload\", function() {\r\n  navigator.sendBeacon(\"/analytics\", JSON.stringify(analyticsData));\r\n});\r\n```\r\n### 4. window.beforeunload\r\n>这个事件会在叶面即将关闭或者跳转的时候提醒用户是否确认。\r\n```js\r\n<h1>Hello, DOMContentLoaded!</h1>\r\n<a href=\"http://www.baidu.com\">点击跳转到百度</a>\r\n\r\n<script>\r\n    window.addEventListener('beforeunload', (event) => {\r\n        // Cancel the event as stated by the standard.\r\n        event.preventDefault();\r\n        // Chrome requires returnValue to be set.\r\n        event.returnValue = 'Write something clever here..';\r\n    });\r\n\r\n</script>\r\n```\r\n[CodeSandBox在线演示](https://codesandbox.io/s/onbeforeunloadde-ji-ben-yong-fa-70i63?file=/index.html)\r\n\r\n## 判断文档是否加载完毕：readyState\r\n>该API共包含以下三个状态。\r\n### 1. loading(文档正在加载)\r\n### 2. interactive(可交互，但是一些图片资源和样式仍在加载中)\r\n### 3. complete(文档全部加载完成)\r\n\r\n```js\r\nconsole.log('初始化状态是：',document.readyState);\r\n\r\nimg.onload = () => console.log('图片被加载完毕');\r\n\r\ndocument.addEventListener('DOMContentLoaded',() => console.log('DOMContentLoaded'))\r\n\r\ndocument.addEventListener('readystatechange',() => console.log('状态变为：',document.readyState))\r\n\r\nwindow.onload = () => console.log('window onload');\r\n```\r\n[CodeSandBox在线演示](https://codesandbox.io/s/readystate-utpic?file=/index.html)\r\n\r\n## 参考资料\r\n* [页面生命周期](https://www.zhouzh.tech/posts/33c2ee80-99dc-11eb-8cf4-976b62ae6e9b)\r\n\r\n* [MDN---document.readyState](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/readyState)"
    },
    {
      "id": "/TypeScript中的类--(TypeScript 05)",
      "metadata": {
        "permalink": "/blog/TypeScript中的类--(TypeScript 05)",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/TypeScript中的类--(TypeScript 05).md",
        "source": "@site/blog\\TypeScript中的类--(TypeScript 05).md",
        "title": "TypeScript中的类--(TypeScript 05)",
        "description": "类的注解方式",
        "date": "2021-08-14T00:00:00.000Z",
        "formattedDate": "2021年8月14日",
        "tags": [
          {
            "label": "TypeScript",
            "permalink": "/blog/tags/type-script"
          }
        ],
        "readingTime": 2.6,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "TypeScript中的类--(TypeScript 05)",
          "date": "2021-8-14",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "TypeScript",
          "tags": [
            "TypeScript"
          ]
        },
        "prevItem": {
          "title": "这一次，不再为web页面生命周期烦恼",
          "permalink": "/blog/这一次，不再为web页面生命周期烦恼"
        },
        "nextItem": {
          "title": "LeetCode——反转链表（双指针）",
          "permalink": "/blog/LeetCode——反转链表（双指针）"
        }
      },
      "content": "## 类的注解方式\r\n>1. 需要对实例的属性进行注解。\r\n>2. 类的方法中有参数的需要进行注解。\r\n\r\n```ts\r\nclass Greeter {\r\n    greeting: string;\r\n    constructor(message: string) {\r\n        this.greeting = message;\r\n    }\r\n    greet() {\r\n        return \"Hello, \" + this.greeting;\r\n    }\r\n}\r\n\r\nlet greeter = new Greeter(\"world\");\r\n```\r\n\r\n## 继承中的super\r\n### 1. 构造函数内部的super指的是父类的构造函数\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/fdaa62ffd8d65a6b0b53f4ad2844a33c.png)\r\n\r\n### 2. 构造函数外部的super指的是父类本身\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/4409018cf52ad939fc96f02bcbd5093b.png)\r\n\r\n```ts\r\nclass Animal {\r\n    name: string;\r\n    constructor(theName: string) { this.name = theName; }\r\n    move(distanceInMeters: number = 0) {\r\n        console.log(`${this.name} moved ${distanceInMeters}m.`);\r\n    }\r\n}\r\n\r\nclass Snake extends Animal {\r\n    constructor(name: string) { super(name); }\r\n    move(distanceInMeters = 5) {\r\n        console.log(\"Slithering...\");\r\n        super.move(distanceInMeters);\r\n    }\r\n}\r\n\r\nlet sam = new Snake(\"Sammy the Python\");\r\n\r\nsam.move();\r\n```\r\n\r\n## 类成员的修饰符\r\n### 1. public：公共的成员属性\r\n* 自身可以调用\r\n* 实例可以调用\r\n* 子类可以调用\r\n\r\n```ts\r\nclass Animal {\r\n    public name: string;\r\n    public constructor(theName: string) { this.name = theName; }\r\n    public move(distanceInMeters: number) {\r\n        console.log(`${this.name} moved ${distanceInMeters}m.`);\r\n    }\r\n}\r\n```\r\n\r\n### 2. private : 只有自身可以调用\r\n```ts\r\nclass Animal {\r\n    private name: string;\r\n    constructor(theName: string) { this.name = theName; }\r\n}\r\n\r\nnew Animal(\"Cat\").name; // 错误: 'name' 是私有的.\r\n```\r\n\r\n### 3. protected: 自身可以调用，子类也可以调用，但是实例不可以调用\r\n```ts\r\nclass Person {\r\n    protected name: string;\r\n    constructor(name: string) { this.name = name; }\r\n}\r\n\r\nclass Employee extends Person {\r\n    private department: string;\r\n\r\n    constructor(name: string, department: string) {\r\n        super(name)\r\n        this.department = department;\r\n    }\r\n\r\n    public getElevatorPitch() {\r\n        return `Hello, my name is ${this.name} and I work in ${this.department}.`;\r\n    }\r\n}\r\n\r\nlet howard = new Employee(\"Howard\", \"Sales\");\r\nconsole.log(howard.getElevatorPitch());\r\nconsole.log(howard.name); // 错误\r\n```\r\n\r\n## readonly修饰符\r\n>readobly关键字将属性设置为只读，这个属性必须在声明或者构造函数中被初始化。readonly不能对方法进行修饰。\r\n```ts\r\nclass Octopus {\r\n    readonly name: string;\r\n    readonly numberOfLegs: number = 8;\r\n    constructor (theName: string) {\r\n        this.name = theName;\r\n    }\r\n}\r\nlet dad = new Octopus(\"Man with the 8 strong legs\");\r\ndad.name = \"Man with the 3-piece suit\"; // 错误! name 是只读的.\r\n```\r\n\r\n## 参数属性\r\n>参数属性本质上就是一种简写的首发，就是将声明和赋值合并在一处。下面两种方式其实是等价的。\r\n```ts\r\n// 方式1\r\nclass Octopus {\r\n    readonly numberOfLegs: number = 8;\r\n    constructor(readonly name: string) {\r\n    }\r\n}\r\n\r\n// 方式2\r\nclass test {\r\n    readonly numerOfLegs: number = 8;\r\n    readonly name: string;\r\n    constructor(Thename: string) {\r\n        this.name = Thename;\r\n    }\r\n}\r\n```"
    },
    {
      "id": "/LeetCode——反转链表（双指针）",
      "metadata": {
        "permalink": "/blog/LeetCode——反转链表（双指针）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——反转链表（双指针）.md",
        "source": "@site/blog\\LeetCode——反转链表（双指针）.md",
        "title": "LeetCode——反转链表（双指针）",
        "description": "题目描述",
        "date": "2021-08-13T00:00:00.000Z",
        "formattedDate": "2021年8月13日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.135,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——反转链表（双指针）",
          "date": "2021-8-13",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "TypeScript中的类--(TypeScript 05)",
          "permalink": "/blog/TypeScript中的类--(TypeScript 05)"
        },
        "nextItem": {
          "title": "Express_01--Express中的基本常识和模板引擎的用法",
          "permalink": "/blog/Express_01--Express中的基本常识和模板引擎的用法"
        }
      },
      "content": "## 题目描述\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/b4dfcd4d94b3d80f8f9122807a210da2.png)\r\n\r\n## 解题思路\r\n1. 采用一个指针指向当前节点，cur节点的初始值为head.\r\n2. 采用另一个指针指向当前节点的前一个节点(pre),该节点的初始值为null.\r\n3. 每当我们修改当前指针的指向的时候，一定要保存当前指针的后一个节点.\r\n\r\n## 解题代码\r\n```js\r\nvar reverseList = function(head) {\r\n    let cur = head;\r\n    let pre = null;\r\n\r\n    while (cur) {\r\n        // 首先保存当前节点的下一个节点\r\n        let temp = cur.next;\r\n        cur.next = pre;\r\n        pre = cur;\r\n        cur = temp;\r\n    }\r\n    return pre;\r\n};\r\n```\r\n\r\n## 题目反思\r\n* 学会使用双指针来解决反转链表问题。\r\n* 本题尤其值的我们反复练习，因为本题在修改指针的指向的时候，需要保存当前指针的下一个节点，这是解决反转链表的一个很好的思路。"
    },
    {
      "id": "/Express_01--Express中的基本常识和模板引擎的用法",
      "metadata": {
        "permalink": "/blog/Express_01--Express中的基本常识和模板引擎的用法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Express_01--Express中的基本常识和模板引擎的用法.md",
        "source": "@site/blog\\Express_01--Express中的基本常识和模板引擎的用法.md",
        "title": "Express_01--Express中的基本常识和模板引擎的用法",
        "description": "1. 安装express",
        "date": "2021-08-12T00:00:00.000Z",
        "formattedDate": "2021年8月12日",
        "tags": [
          {
            "label": "Express",
            "permalink": "/blog/tags/express"
          }
        ],
        "readingTime": 2.51,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Express_01--Express中的基本常识和模板引擎的用法",
          "date": "2021-8-12",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Express",
          "tags": [
            "Express"
          ]
        },
        "prevItem": {
          "title": "LeetCode——反转链表（双指针）",
          "permalink": "/blog/LeetCode——反转链表（双指针）"
        },
        "nextItem": {
          "title": "Node报错 npm ERR! code EINVALIDTAGNAME",
          "permalink": "/blog/Node报错npm ERR code EINVALIDTAGNAME"
        }
      },
      "content": "## 1. 安装express\r\n```js\r\nnpm i express\r\n```\r\n\r\n## 2. Express的Hello,World\r\n```js\r\nconst express = require('express');\r\n\r\nconst app = express();\r\n\r\napp.get('/',(req,res) => {\r\n    res.send('Hello,Express!');\r\n})\r\n\r\napp.listen(3000,() => {\r\n    console.log('服务器启动成功！');\r\n})\r\n```\r\n\r\n## 3. 将一个文件夹下的所有文件变为可访问\r\n```js\r\napp.use('/public',express.static('./public'));\r\n```\r\n\r\n## 4. 使用nodemon来保存后自动重启\r\n```shell\r\nnpm install nodemon -g\r\n```\r\n>以后启动一个文件不再使用node + 文件名的方式，而是使用nodemon + 文件名的方式。这样可以实现热更新，即保存就更新服务器。\r\n\r\n## 基本路由\r\n```js\r\napp.get('/',(req,res) => {\r\n    res.send('Hello,Express666!');\r\n})\r\n\r\napp.get('/about',(req,res) => {\r\n    res.send('关于');\r\n})\r\n```\r\n## 暴露文件不同方式的区别\r\n### 1. 只有一个参数（URL可以直接访问文件名）\r\n```js\r\napp.use(express.static('./public'));\r\n```\r\n### 2. 两个参数（URL必须包含指向改文件的路径）\r\n```js\r\napp.use('/public',express.static('./public'));\r\n```\r\n### 3. 别名的形式\r\n```js\r\napp.use('/a',express.static('./public'));\r\n```\r\n>这里的a意思是路径中以a开头的，就可以访问public路径下的文件。\r\n\r\n## 在express中配置模板引擎art-template\r\n### 1. 安装art-template\r\n```shell\r\nnpm install --save art-template\r\nnpm install --save express-art-template\r\n```\r\n### 2. API介绍\r\n>当渲染以.art结尾的文件的时候，使用art-template模板引擎\r\n```js\r\napp.engine('art', require('express-art-template'));\r\n//或者，下面的这种方式也是可以的\r\napp.engine('html', require('express-art-template'));\r\n```\r\n>调用res.render的时候，会默认去项目的views目录中查找指定的文件，但是该文件必须以art结尾。如果engine中的第一个参数是html，则不需要进行重命名，即下面的第二种方式。\r\n```js\r\napp.get('/',(req,res) => {\r\n    res.render('404.art');\r\n})\r\n// 方式二\r\napp.get('/',(req,res) => {\r\n    res.render('404.html');\r\n})\r\n```\r\n>修改默认的views目录\r\n```js\r\napp.set('views','test');\r\n```\r\n\r\n### 一个基于express的留言本小案例\r\n```js\r\nconst express = require('express');\r\n\r\nconst app = express();\r\nlet comments = [\r\n    {\r\n        name: '黄多多',\r\n        message: '爸爸去哪了',\r\n        dateTime: '2020-5-21'\r\n    },\r\n]\r\n\r\napp.engine('html', require('express-art-template'));\r\n\r\napp.get('/', (req, res) => {\r\n    res.render('index.html',{\r\n        comments\r\n    });\r\n})\r\n\r\napp.get('/post', (req, res) => {\r\n    res.render('post.html');\r\n})\r\n\r\napp.get('/pinglun',(req,res) => {\r\n    let comment = req.query;\r\n    comment.dateTime = new Date().toLocaleString();\r\n    comments.unshift(comment);\r\n    res.redirect('/');\r\n})\r\n// 开放public目录\r\napp.use('/public', express.static('public'));\r\napp.listen(3000, () => {\r\n    console.log('服务器在3000端口启动成功......');\r\n})\r\n```"
    },
    {
      "id": "/Node报错npm ERR code EINVALIDTAGNAME",
      "metadata": {
        "permalink": "/blog/Node报错npm ERR code EINVALIDTAGNAME",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Node报错npm ERR code EINVALIDTAGNAME.md",
        "source": "@site/blog\\Node报错npm ERR code EINVALIDTAGNAME.md",
        "title": "Node报错 npm ERR! code EINVALIDTAGNAME",
        "description": "报错警告",
        "date": "2021-08-11T00:00:00.000Z",
        "formattedDate": "2021年8月11日",
        "tags": [
          {
            "label": "Node",
            "permalink": "/blog/tags/node"
          }
        ],
        "readingTime": 0.42,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Node报错 npm ERR! code EINVALIDTAGNAME",
          "date": "2021-8-11",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Node",
          "tags": [
            "Node"
          ]
        },
        "prevItem": {
          "title": "Express_01--Express中的基本常识和模板引擎的用法",
          "permalink": "/blog/Express_01--Express中的基本常识和模板引擎的用法"
        },
        "nextItem": {
          "title": "LeetCode——数组中的第K个最大元素（堆排序-大顶堆）",
          "permalink": "/blog/LeetCode——数组中的第K个最大元素（堆排序-大顶堆）"
        }
      },
      "content": "## 报错警告\r\nnpm ERR! code EINVALIDTAGNAME\r\n\r\n## 原因\r\n>没有进行npm init便开始安装包。\r\n\r\n## 注意事项\r\n这里我们需要注意的是npm init和npm i并不相同，npm i 代表的是npm install表示安装，并不表示初始化，初始化需要我们npm init这个命令不能够简写。"
    },
    {
      "id": "/LeetCode——数组中的第K个最大元素（堆排序-大顶堆）",
      "metadata": {
        "permalink": "/blog/LeetCode——数组中的第K个最大元素（堆排序-大顶堆）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——数组中的第K个最大元素（堆排序-大顶堆）.md",
        "source": "@site/blog\\LeetCode——数组中的第K个最大元素（堆排序-大顶堆）.md",
        "title": "LeetCode——数组中的第K个最大元素（堆排序-大顶堆）",
        "description": "题目描述",
        "date": "2021-08-10T00:00:00.000Z",
        "formattedDate": "2021年8月10日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 3.68,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——数组中的第K个最大元素（堆排序-大顶堆）",
          "date": "2021-8-10",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "Node报错 npm ERR! code EINVALIDTAGNAME",
          "permalink": "/blog/Node报错npm ERR code EINVALIDTAGNAME"
        },
        "nextItem": {
          "title": "Node 04--使用Node处理表单请求与两种暴露方式",
          "permalink": "/blog/Node 04--使用Node处理表单请求与两种暴露方式"
        }
      },
      "content": "## 题目描述\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/2387703be9cdedd3863db5c5c5359671.png)\r\n\r\n## 解题思路\r\n>本题如果直接再用API解题肯定是不行的，因为面试不可能考你API如何使用，前几天写过这个题目是通过快速排序写的，这次我们采用堆排序，通过大顶堆的方式来求出第K个最大的元素，其实这类问题都属于经典的TOP K问题，属于面试的常考题。\r\n\r\n### 1. 构建大顶堆\r\n>为什么要构建大顶堆，是因为大顶堆的对顶元素是整个数组中最大的元素.我们正式利用这点来求解问题的。\r\n1. 构建大顶堆的第一步是从最后一个非叶子节点开始，一直遍历到根节点.\r\n2. 一个节点的左子节点是 2*n + 1.\r\n3. 一个节点的右子节点是 2*n + 2.\r\n4. 一个节点的父节点是(n-1) / 2 (向下取整)\r\n5. 一棵树的最后一个非叶子节点是 Math.flool(nums.length/2)-1.\r\n\r\n### 2. 将大顶堆下沉K-1次，得到的就是第K大的元素\r\n>假如，我们要求的是第一大的元素，K-1就是零，也就是说不需要进行下沉，此时的大顶堆的堆顶就是最大的元素。若K-1=2，只需下沉两次，堆顶就是我们的最大的元素。所谓的下沉就是将堆顶与末尾元素进行交换。然后将堆的长度减一之后继续进行堆化。\r\n\r\n## 解题代码\r\n```js\r\n// 通过大顶堆求解问题\r\nvar findKthLargest = function(nums, k) {\r\n    // 堆的大小\r\n    let heapSize = nums.length;\r\n    // 调用大顶堆函数\r\n    buildMaxHeap(nums,heapSize);\r\n    // 要想求第K大的元素，就需要将大顶堆下沉K-1次，每下沉一次进行一次重新的堆化；\r\n    for (let i = 0; i < k - 1; i++ ) {\r\n        swap(nums,0,nums.length - 1 - i);\r\n        // 将最后一个元素忽略，不参与堆化\r\n        nums\r\n        heapSize--;\r\n        // 从第0个元素开始继续进行堆化\r\n        maxHeapify(nums,0,heapSize);\r\n    }\r\n    // 此时堆顶就是第K个最大元素\r\n    return nums[0]\r\n    // 构建大顶堆\r\n    function buildMaxHeap(nums,heapSize) {\r\n        for (let i = Math.floor(heapSize / 2) - 1; i >= 0; i--) {\r\n            maxHeapify(nums,i,heapSize)\r\n        }\r\n    }\r\n    function maxHeapify(nums,i,heapSize) {\r\n        // 首先假定第i个是最大的\r\n        let max = i;\r\n        let leftChild = 2 * i + 1;\r\n        let rightChild = 2 * i + 2;\r\n        // 如果下标不越界（即子孩子存在），并且子节点小于第i个元素\r\n        if (leftChild < heapSize && nums[leftChild] > nums[max]) {\r\n            max = leftChild;\r\n        }\r\n        if (rightChild < heapSize && nums[rightChild] > nums[max]) {\r\n            max = rightChild;\r\n        }\r\n        // 判断是否发生了交换\r\n        if (max !== i) {\r\n            swap(nums,i,max);\r\n            // 交换之后，从下面上来的元素的位置后面需要继续进行堆化\r\n            maxHeapify(nums,max,heapSize);\r\n        }\r\n    }\r\n\r\n    function swap (nums,i,j) {\r\n        let temp = nums[i];\r\n        nums[i] = nums[j];\r\n        nums[j] = temp;\r\n    }\r\n};\r\n\r\nfindKthLargest([8,5,0,3,7,1,2], 3)\r\n```\r\n\r\n## 题目反思\r\n* 学会使用大顶堆的方式来求解TOP K问题。\r\n* 本题的思路也是解决堆排序的核心思路。"
    },
    {
      "id": "/Node 04--使用Node处理表单请求与两种暴露方式",
      "metadata": {
        "permalink": "/blog/Node 04--使用Node处理表单请求与两种暴露方式",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Node 04--使用Node处理表单请求与两种暴露方式.md",
        "source": "@site/blog\\Node 04--使用Node处理表单请求与两种暴露方式.md",
        "title": "Node 04--使用Node处理表单请求与两种暴露方式",
        "description": "使用Node处理表单get请求",
        "date": "2021-08-09T00:00:00.000Z",
        "formattedDate": "2021年8月9日",
        "tags": [
          {
            "label": "Node",
            "permalink": "/blog/tags/node"
          }
        ],
        "readingTime": 2.825,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Node 04--使用Node处理表单请求与两种暴露方式",
          "date": "2021-8-9",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Node",
          "tags": [
            "Node"
          ]
        },
        "prevItem": {
          "title": "LeetCode——数组中的第K个最大元素（堆排序-大顶堆）",
          "permalink": "/blog/LeetCode——数组中的第K个最大元素（堆排序-大顶堆）"
        },
        "nextItem": {
          "title": "Node 03--在Node中使用模板引擎进行渲染",
          "permalink": "/blog/Node 03--在Node中使用模板引擎进行渲染"
        }
      },
      "content": "## 使用Node处理表单get请求\r\n### 表单的格式\r\n>一个HTML表单要想点击button按钮就能够提交数据，必须具备以下几个要素：\r\n1. 表单要有action属性，这个属性是告知浏览器要将数据发送到哪里。\r\n2. 每一个输入框要有name属性，这个属性是帮助我们定位输入的是什么的。\r\n3. button的type属性要是submit.\r\n\r\n```html\r\n<form action=\"/pinglun\" method=\"get\">\r\n    <div class=\"form-group\">\r\n        <label for=\"input_name\">你的大名</label>\r\n        <input type=\"text\" class=\"form-control\" required minlength=\"2\" maxlength=\"10\" id=\"input_name\"\r\n            name=\"name\" placeholder=\"请写入你的姓名\">\r\n    </div>\r\n    <div class=\"form-group\">\r\n        <label for=\"textarea_message\">留言内容</label>\r\n        <textarea class=\"form-control\" name=\"message\" id=\"textarea_message\" cols=\"30\" rows=\"10\" required\r\n            minlength=\"5\" maxlength=\"20\"></textarea>\r\n    </div>\r\n    <button type=\"submit\" class=\"btn btn-default\">发表</button>\r\n</form>\r\n```\r\n\r\n### 服务器端使用Node的核心模块url(将url字符串转换为对象)\r\n* 引入url模块\r\n```js\r\nconst urlParse = require('url')\r\n```\r\n* 将url字符串解析为url对象\r\n```js\r\nconst parseObj = urlParse.parse(url,true);\r\n```\r\n* 获取请求路径(这个请求路径是不包含查询字符串的)\r\n```js\r\nconst pathname = parseObj.pathname;\r\n```\r\n* 获取表单发送过来的数据\r\n```js\r\nparseObj.query\r\n```\r\n\r\n## 让客户端的请求进行重定向\r\n* 首先发送给客户端一个302状态码，让客户端进行临时重定向。\r\n```js\r\nres.statusCode = 302;\r\n```\r\n* 通过响应头让客户端跳转到指定的路径(下文的路径是根路径)\r\n```js\r\nres.setHeader('Location','/');\r\n```\r\n\r\n## Node中的两种暴露方式\r\n### 使用exports.xxx进行暴露（需要暴露的内容都在一个对象中）\r\n>使用这种暴露方式，暴露的是一个对象，我们以下面的例子进行举例说明：\r\n\r\n* a.js\r\n```js\r\nconst test = require('./b');\r\nconsole.log(test);\r\n```\r\n* b.js\r\n```js\r\nconst foo = '你好';\r\nexports.foo = foo;\r\n```\r\n\r\n**我们对a进行调用，输出结果如下所示**\r\n```json\r\n{ foo: '你好' }\r\n```\r\n\r\n### 使用module.exports = XXX (这样暴露的就是XXX，我们在实际开发的过程中推荐使用这个方式)\r\n* a.js\r\n```js\r\nconst test = require('./b');\r\nconsole.log(test);\r\n```\r\n* b.js\r\n```js\r\nconst foo = '你好';\r\nmodule.exports = foo;\r\n```\r\n\r\n**对a.js进行调用，输出结果如下所示：**\r\n```json\r\n你好\r\n```\r\n\r\n### 小结\r\n>**node中实际暴露的是module.exports这个对象，你给这个对象赋值，返回的就是值，你给对象添加属性，返回的就是含有属性的对象。**"
    },
    {
      "id": "/Node 03--在Node中使用模板引擎进行渲染",
      "metadata": {
        "permalink": "/blog/Node 03--在Node中使用模板引擎进行渲染",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Node 03--在Node中使用模板引擎进行渲染.md",
        "source": "@site/blog\\Node 03--在Node中使用模板引擎进行渲染.md",
        "title": "Node 03--在Node中使用模板引擎进行渲染",
        "description": "使用readdir获取指定路径下的所有文件名",
        "date": "2021-08-07T00:00:00.000Z",
        "formattedDate": "2021年8月7日",
        "tags": [
          {
            "label": "Node",
            "permalink": "/blog/tags/node"
          }
        ],
        "readingTime": 3.18,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Node 03--在Node中使用模板引擎进行渲染",
          "date": "2021-8-7",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Node",
          "tags": [
            "Node"
          ]
        },
        "prevItem": {
          "title": "Node 04--使用Node处理表单请求与两种暴露方式",
          "permalink": "/blog/Node 04--使用Node处理表单请求与两种暴露方式"
        },
        "nextItem": {
          "title": "Node 02--Node中的模块系统与响应中文编码",
          "permalink": "/blog/Node 02--Node中的模块系统与响应中文编码"
        }
      },
      "content": "## 使用readdir获取指定路径下的所有文件名\r\n>文件结构\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/df1513a7c737a86ed3280a72c236c79d.png)\r\n\r\n>实现代码\r\n```js\r\nconst fs = require('fs');\r\n\r\nfs.readdir('G:/pink_code/Node_Study/02',(err,list) => {\r\n    if (!err) {\r\n        console.log(list);\r\n    }\r\n})\r\n```\r\n\r\n>代码输出\r\n```js\r\n[ '01_http-helloWorld.js', '02_使用readdir获取指定路径下的所有文件名.js', 'www' ]\r\n```\r\n\r\n## 在浏览器中使用模板引擎\r\n### 1. 安装art-template\r\n```js\r\nnpm install art-template\r\n```\r\n### 2. 通过script标签引入art-template\r\n```js\r\n<script src=\"./node_modules/art-template/lib/template-web.js\"></script>\r\n```\r\n### 3. 使用模板引擎语法进行调用\r\n```js\r\n<script src=\"./node_modules/art-template/lib/template-web.js\"></script>\r\n<script type='text/template' id = 'tpl'>\r\n    这是{{name}}\r\n</script>\r\n\r\n<script>\r\n    const test = template('tpl',{\r\n        name: 'China'\r\n    });\r\n    console.log(test);\r\n</script>\r\n```\r\n\r\n## 在Node中使用模板引擎\r\n### 1. 安装art-template\r\n```js\r\nnpm install art-template\r\n```\r\n### 2. 在需要使用模板引擎的模块中加载art-template\r\n### 3. 查文档，使用模板引擎的API\r\n\r\n**在Node中使用模板引擎的一个小案例**\r\n```js\r\nconst template = require('art-template');\r\n\r\nconst test = template.render('hello {{name}}',{\r\n    name: 'NodeJs'\r\n})\r\n\r\nconsole.log(test);\r\n```\r\n**输出结果**\r\n```js\r\nhello NodeJs\r\n```\r\n\r\n## 一个使用模板引擎渲染HTML的小案例\r\n### HTML结构\r\n```html\r\n<html dir=\"ltr\" lang=\"zh\">\r\n\r\n<head>\r\n    <meta charset=\"utf-8\">\r\n    <meta name=\"google\" value=\"notranslate\">\r\n\r\n    <style>\r\n        h1 {\r\n            border-bottom: 1px solid #c0c0c0;\r\n            margin-bottom: 10px;\r\n            padding-bottom: 10px;\r\n            white-space: nowrap;\r\n        }\r\n\r\n        table {\r\n            border-collapse: collapse;\r\n        }\r\n\r\n        th {\r\n            cursor: pointer;\r\n        }\r\n\r\n        td.detailsColumn {\r\n            -webkit-padding-start: 2em;\r\n            text-align: end;\r\n            white-space: nowrap;\r\n        }\r\n\r\n        a.icon {\r\n            -webkit-padding-start: 1.5em;\r\n            text-decoration: none;\r\n            user-select: auto;\r\n        }\r\n\r\n        a.icon:hover {\r\n            text-decoration: underline;\r\n        }\r\n\r\n        a.file {\r\n            background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAAABnRSTlMAAAAAAABupgeRAAABHUlEQVR42o2RMW7DIBiF3498iHRJD5JKHurL+CRVBp+i2T16tTynF2gO0KSb5ZrBBl4HHDBuK/WXACH4eO9/CAAAbdvijzLGNE1TVZXfZuHg6XCAQESAZXbOKaXO57eiKG6ft9PrKQIkCQqFoIiQFBGlFIB5nvM8t9aOX2Nd18oDzjnPgCDpn/BH4zh2XZdlWVmWiUK4IgCBoFMUz9eP6zRN75cLgEQhcmTQIbl72O0f9865qLAAsURAAgKBJKEtgLXWvyjLuFsThCSstb8rBCaAQhDYWgIZ7myM+TUBjDHrHlZcbMYYk34cN0YSLcgS+wL0fe9TXDMbY33fR2AYBvyQ8L0Gk8MwREBrTfKe4TpTzwhArXWi8HI84h/1DfwI5mhxJamFAAAAAElFTkSuQmCC \") left top no-repeat;\r\n        }\r\n\r\n        a.dir {\r\n            background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAd5JREFUeNqMU79rFUEQ/vbuodFEEkzAImBpkUabFP4ldpaJhZXYm/RiZWsv/hkWFglBUyTIgyAIIfgIRjHv3r39MePM7N3LcbxAFvZ2b2bn22/mm3XMjF+HL3YW7q28YSIw8mBKoBihhhgCsoORot9d3/ywg3YowMXwNde/PzGnk2vn6PitrT+/PGeNaecg4+qNY3D43vy16A5wDDd4Aqg/ngmrjl/GoN0U5V1QquHQG3q+TPDVhVwyBffcmQGJmSVfyZk7R3SngI4JKfwDJ2+05zIg8gbiereTZRHhJ5KCMOwDFLjhoBTn2g0ghagfKeIYJDPFyibJVBtTREwq60SpYvh5++PpwatHsxSm9QRLSQpEVSd7/TYJUb49TX7gztpjjEffnoVw66+Ytovs14Yp7HaKmUXeX9rKUoMoLNW3srqI5fWn8JejrVkK0QcrkFLOgS39yoKUQe292WJ1guUHG8K2o8K00oO1BTvXoW4yasclUTgZYJY9aFNfAThX5CZRmczAV52oAPoupHhWRIUUAOoyUIlYVaAa/VbLbyiZUiyFbjQFNwiZQSGl4IDy9sO5Wrty0QLKhdZPxmgGcDo8ejn+c/6eiK9poz15Kw7Dr/vN/z6W7q++091/AQYA5mZ8GYJ9K0AAAAAASUVORK5CYII= \") left top no-repeat;\r\n        }\r\n\r\n        a.up {\r\n            background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAmlJREFUeNpsU0toU0EUPfPysx/tTxuDH9SCWhUDooIbd7oRUUTMouqi2iIoCO6lceHWhegy4EJFinWjrlQUpVm0IIoFpVDEIthm0dpikpf3ZuZ6Z94nrXhhMjM3c8895977BBHB2PznK8WPtDgyWH5q77cPH8PpdXuhpQT4ifR9u5sfJb1bmw6VivahATDrxcRZ2njfoaMv+2j7mLDn93MPiNRMvGbL18L9IpF8h9/TN+EYkMffSiOXJ5+hkD+PdqcLpICWHOHc2CC+LEyA/K+cKQMnlQHJX8wqYG3MAJy88Wa4OLDvEqAEOpJd0LxHIMdHBziowSwVlF8D6QaicK01krw/JynwcKoEwZczewroTvZirlKJs5CqQ5CG8pb57FnJUA0LYCXMX5fibd+p8LWDDemcPZbzQyjvH+Ki1TlIciElA7ghwLKV4kRZstt2sANWRjYTAGzuP2hXZFpJ/GsxgGJ0ox1aoFWsDXyyxqCs26+ydmagFN/rRjymJ1898bzGzmQE0HCZpmk5A0RFIv8Pn0WYPsiu6t/Rsj6PauVTwffTSzGAGZhUG2F06hEc9ibS7OPMNp6ErYFlKavo7MkhmTqCxZ/jwzGA9Hx82H2BZSw1NTN9Gx8ycHkajU/7M+jInsDC7DiaEmo1bNl1AMr9ASFgqVu9MCTIzoGUimXVAnnaN0PdBBDCCYbEtMk6wkpQwIG0sn0PQIUF4GsTwLSIFKNqF6DVrQq+IWVrQDxAYQC/1SsYOI4pOxKZrfifiUSbDUisif7XlpGIPufXd/uvdvZm760M0no1FZcnrzUdjw7au3vu/BVgAFLXeuTxhTXVAAAAAElFTkSuQmCC \") left top no-repeat;\r\n        }\r\n\r\n        html[dir=rtl] a {\r\n            background-position-x: right;\r\n        }\r\n\r\n        #parentDirLinkBox {\r\n            margin-bottom: 10px;\r\n            padding-bottom: 10px;\r\n        }\r\n\r\n        #listingParsingErrorBox {\r\n            border: 1px solid black;\r\n            background: #fae691;\r\n            padding: 10px;\r\n            display: none;\r\n        }\r\n    </style>\r\n\r\n    <title id=\"title\">C:\\Users\\HP\\Desktop\\共享文件\\ 的索引</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n    <div id=\"listingParsingErrorBox\">糟糕！Google Chrome无法解读服务器所发送的数据。请<a\r\n            href=\"http://code.google.com/p/chromium/issues/entry\">报告错误</a>，并附上<a href=\"LOCATION\">原始列表</a>。</div>\r\n\r\n    <h1 id=\"header\">C:\\Users\\HP\\Desktop\\共享文件\\ 的索引</h1>\r\n\r\n    <div id=\"parentDirLinkBox\" style=\"display: block;\">\r\n        <a id=\"parentDirLink\" class=\"icon up\" href=\"/C:/Users/HP/Desktop/%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6/..\">\r\n            <span id=\"parentDirText\">[上级目录]</span>\r\n        </a>\r\n    </div>\r\n\r\n    <table>\r\n        <thead>\r\n            <tr class=\"header\" id=\"theader\">\r\n                <th id=\"nameColumnHeader\" tabindex=\"0\" role=\"button\">名称</th>\r\n                <th id=\"sizeColumnHeader\" class=\"detailsColumn\" tabindex=\"0\" role=\"button\">\r\n                    大小\r\n                </th>\r\n                <th id=\"dateColumnHeader\" class=\"detailsColumn\" tabindex=\"0\" role=\"button\">\r\n                    修改日期\r\n                </th>\r\n            </tr>\r\n        </thead>\r\n        <tbody id=\"tbody\">\r\n            {{each files}} \r\n            <tr>\r\n                <td data-value=\"{{$value}}\"><a class=\"icon file\" draggable=\"true\" href=\"{{$value}}\">{{$value}}</a>\r\n                </td>\r\n                <td class=\"detailsColumn\" data-value=\"193955\">189 kB</td>\r\n                <td class=\"detailsColumn\" data-value=\"1627464963\">2021/7/28 下午5:36:03</td>\r\n            </tr>\r\n            {{/each}}\r\n        </tbody>\r\n    </table>\r\n\r\n</body>\r\n\r\n</html>\r\n```\r\n### Node代码\r\n```js\r\nconst http = require('http');\r\nconst template = require('art-template');\r\nconst fs = require('fs');\r\n\r\nconst server = http.createServer();\r\n\r\nserver.on('request', (req, res) => {\r\n    const url = req.url;\r\n\r\n    // 文件路径\r\n    const filePath = 'G:/pink_code/Node_Study/02';\r\n    // 获取文件路径下所有的文件名\r\n    let listName;\r\n    fs.readdir(filePath, (err, list) => {\r\n        if (!err) {\r\n            listName = list;\r\n        }\r\n    })\r\n    // 读取模板文件内容\r\n    fs.readFile('./www/template.html', (err, data) => {\r\n        if (!err) {\r\n            data = data.toString();\r\n            test = template.render(data,{\r\n                files: listName\r\n            })\r\n            res.end(test);\r\n        } else {\r\n            console.log('读取文件出错', err);\r\n        }\r\n    });\r\n\r\n})\r\n\r\n// 监听3000端口\r\nserver.listen(3000, (err) => {\r\n    if (!err) {\r\n        console.log('服务器启动成功！');\r\n    }\r\n})\r\n```\r\n### 实现效果\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/3244eaa440f676ca896d267cf556adda.png)"
    },
    {
      "id": "/Node 02--Node中的模块系统与响应中文编码",
      "metadata": {
        "permalink": "/blog/Node 02--Node中的模块系统与响应中文编码",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Node 02--Node中的模块系统与响应中文编码.md",
        "source": "@site/blog\\Node 02--Node中的模块系统与响应中文编码.md",
        "title": "Node 02--Node中的模块系统与响应中文编码",
        "description": "require的加载顺序",
        "date": "2021-08-06T00:00:00.000Z",
        "formattedDate": "2021年8月6日",
        "tags": [
          {
            "label": "Node",
            "permalink": "/blog/tags/node"
          }
        ],
        "readingTime": 1.94,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Node 02--Node中的模块系统与响应中文编码",
          "date": "2021-8-6",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Node",
          "tags": [
            "Node"
          ]
        },
        "prevItem": {
          "title": "Node 03--在Node中使用模板引擎进行渲染",
          "permalink": "/blog/Node 03--在Node中使用模板引擎进行渲染"
        },
        "nextItem": {
          "title": "Node 01--使用Node读写文件与简单的Http服务",
          "permalink": "/blog/Node 01--使用Node读写文件与简单的Http服务"
        }
      },
      "content": "## require的加载顺序\r\n>require加载文件是运行到该位置才加载，请看下面的一段代码\r\n**a.js**\r\n```js\r\nconsole.log('a开始执行了');\r\n\r\nrequire('./b');\r\n\r\nconsole.log('a 执行结束了');\r\n```\r\n\r\n**b.js**\r\n```js\r\nconsole.log('b执行结束');\r\n```\r\n\r\n**执行结果**\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/98ddaa4903f6a00c69ff9e802005767b.png)\r\n\r\n## Node中没有全局作用域只有模块作用域\r\n>请看下面的两端代码\r\n**a.js**\r\n\r\n```js\r\nvar a = '777'\r\nconsole.log('a开始执行了');\r\n\r\nrequire('./b');\r\n\r\nconsole.log('a 执行结束了');\r\n\r\nconsole.log('a的值是：',a);\r\n```\r\n\r\n**b.js**\r\n```js\r\nvar a = '666'\r\n\r\nconsole.log('b执行结束');\r\n```\r\n\r\n**执行结果**\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/15f0b3d999220af3744ae370143ec520.png)\r\n\r\n## 使用exports暴露模块\r\n>exports其实是一个空对象，我们相当于向这个空对象中添加元素，然后进行暴露。\r\n**a.js**\r\n```js\r\nconst test = require('./b');\r\n\r\nconsole.log(test.a);\r\n```\r\n\r\n**b.js**\r\n```js\r\nvar a = '666'\r\n\r\nexports.a = a;\r\n```\r\n\r\n**node运行 a.js**\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/22bef6f5fb36d2cb2a54b76929a02e4c.png)\r\n\r\n## 响应中文编码\r\n>服务器直接返回中文，在浏览器上显示的是乱码，所以我们可以通过设置setHeader中的编码格式来解决这一问题。\r\n\r\n```js\r\nserver.on('request',(req,res) => {\r\n    res.setHeader('Content-Type','text/plain; charset=utf-8');\r\n    res.end('Node,你好');\r\n})\r\n```\r\n\r\n### Content-Type有什么作用？\r\n>**Content-Type就是用来告知对方发送的数据内容是什么类型的。下面我们将给出Content-Type的例子**\r\n\r\n例子：设置为普通文本类型（plain）与html类型的\r\n```js\r\nserver.on('request',(req,res) => {\r\n    const url = req.url;\r\n    if (url === '/plain') {\r\n        res.setHeader('Content-Type','text/plain; charset=utf-8');\r\n        res.end('这是中文哦！');\r\n    } else if (url === '/html') {\r\n        res.end('<h1>你好这是一级标题</h1');\r\n    }\r\n})\r\n```\r\n>浏览器会默认将html的字符串解析为HTML代码，如果我们想要的不是HTML代码而是字符串，可以通过设置setHeader为text/plain；"
    },
    {
      "id": "/Node 01--使用Node读写文件与简单的Http服务",
      "metadata": {
        "permalink": "/blog/Node 01--使用Node读写文件与简单的Http服务",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Node 01--使用Node读写文件与简单的Http服务.md",
        "source": "@site/blog\\Node 01--使用Node读写文件与简单的Http服务.md",
        "title": "Node 01--使用Node读写文件与简单的Http服务",
        "description": "关于Node是什么，以及如何安装node等基础知识，本系列文章便不再赘述，本专栏的特点是只讲干货，从零基础开始学习NodeJs.",
        "date": "2021-08-05T00:00:00.000Z",
        "formattedDate": "2021年8月5日",
        "tags": [
          {
            "label": "Node",
            "permalink": "/blog/tags/node"
          }
        ],
        "readingTime": 2.615,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Node 01--使用Node读写文件与简单的Http服务",
          "date": "2021-8-5",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Node",
          "tags": [
            "Node"
          ]
        },
        "prevItem": {
          "title": "Node 02--Node中的模块系统与响应中文编码",
          "permalink": "/blog/Node 02--Node中的模块系统与响应中文编码"
        },
        "nextItem": {
          "title": "五分钟带你学会--图片懒加载",
          "permalink": "/blog/五分钟带你学会--图片懒加载"
        }
      },
      "content": ">关于Node是什么，以及如何安装node等基础知识，本系列文章便不再赘述，本专栏的特点是只讲干货，从零基础开始学习NodeJs.\r\n\r\n## Node和浏览器环境的不同之处\r\n### 1. Node中没有DOM和BOM\r\n```js\r\nconsole.log(window);\r\nconsole.log(document);\r\n```\r\n>我们通过node命令运行上面的代码是会报错的。\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/e8c95bf342087f58cc62ca4ff3376eae.png)\r\n\r\n### 2. 浏览器环境下的JS是没有操作文件的能力的，但是Node有\r\n>fs是file-system的简写，是文件系统的意思，在Node中如果想要进行文件操作，就必须引入fs这个核心模块，在fs这个核心模块中，提供了操作文件的相关API，例如fs.readFile就是用来读取文件的。\r\n```js\r\nconst fs = require('fs');\r\n\r\nfs.readFile('./readme.md',(err,data) => {\r\n    if (!err) {\r\n        console.log(data.toString());\r\n    }\r\n})\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/257d8b6e81d1848b3340ace8746c9f64.png)\r\n\r\n## 使用Node创建基础的HTTP服务\r\n```js\r\n// 1. 加载http核心模块\r\nconst http = require('http');\r\n\r\n// 2. 创建服务器实例\r\nconst server = http.createServer();\r\n\r\n// 3. 注册request请求事件\r\nserver.on('request',(request,response) => {\r\n    console.log('服务器端收到请求');\r\n    console.log('客户端的请求路径是：',request.url);\r\n    response.write('<h1>Hello,Node!</h1>');\r\n    // response.end();\r\n    if (request.usr = '/index') {\r\n        response.write('666');\r\n    }\r\n    response.end();\r\n})\r\n\r\n// 4. 绑定端口号，启动服务器\r\nserver.listen(3000,() => {\r\n    console.log('服务器启动成功');\r\n});\r\n```\r\n### 响应数组、对象、数字等格式的内容使用JSON.stringify\r\n```js\r\nconst http = require('http');\r\n\r\n// 1. 创建服务器实例\r\nconst server = http.createServer();\r\n\r\n// 2. 监听请求事件，设置请求处理函数\r\nserver.on('request',(request,response) => {\r\n    if (request.url === '/index') {\r\n        // response.write('666666');\r\n    }\r\n    const test = [{name: 'justin',phone: '11'}];\r\n    response.end(JSON.stringify(test));\r\n})\r\n\r\n// 3. 监听指定端口\r\nserver.listen(3000,() => {\r\n    console.log('服务器启动成功！');\r\n})\r\n```\r\n## 使用OS模块获取当前系统的信息\r\n```js\r\nconst os = require('os');\r\n\r\nconsole.log(os.cpus());\r\n```\r\n```json\r\n[\r\n  {\r\n    model: 'Intel(R) Core(TM) i5-6300HQ CPU @ 2.30GHz',\r\n    speed: 2304,\r\n    times: {\r\n      user: 1780218,\r\n      nice: 0,\r\n      sys: 2250343,\r\n      idle: 24643734,\r\n      irq: 617593\r\n    }\r\n  },\r\n  {\r\n    model: 'Intel(R) Core(TM) i5-6300HQ CPU @ 2.30GHz',\r\n    speed: 2304,\r\n    times: {\r\n      user: 1810000,\r\n      nice: 0,\r\n      sys: 1999546,\r\n      idle: 24864125,\r\n      irq: 370703\r\n    }\r\n  },\r\n  {\r\n    model: 'Intel(R) Core(TM) i5-6300HQ CPU @ 2.30GHz',\r\n    speed: 2304,\r\n    times: {\r\n      user: 1855187,\r\n      nice: 0,\r\n      sys: 1691656,\r\n      idle: 25126828,\r\n      irq: 148062\r\n    }\r\n  },\r\n  {\r\n    model: 'Intel(R) Core(TM) i5-6300HQ CPU @ 2.30GHz',\r\n    speed: 2304,\r\n    times: {\r\n      user: 1898781,\r\n      nice: 0,\r\n      sys: 1538750,\r\n      idle: 25236140,\r\n      irq: 65781\r\n    }\r\n  }\r\n]\r\n```"
    },
    {
      "id": "/五分钟带你学会--图片懒加载",
      "metadata": {
        "permalink": "/blog/五分钟带你学会--图片懒加载",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/五分钟带你学会--图片懒加载.md",
        "source": "@site/blog\\五分钟带你学会--图片懒加载.md",
        "title": "五分钟带你学会--图片懒加载",
        "description": "什么是图片懒加载",
        "date": "2021-08-04T00:00:00.000Z",
        "formattedDate": "2021年8月4日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 3.055,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "五分钟带你学会--图片懒加载",
          "date": "2021-8-4",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "Node 01--使用Node读写文件与简单的Http服务",
          "permalink": "/blog/Node 01--使用Node读写文件与简单的Http服务"
        },
        "nextItem": {
          "title": "FreeCodeCamp经典题目（收银机）",
          "permalink": "/blog/FreeCodeCamp经典题目（收银机）"
        }
      },
      "content": "## 什么是图片懒加载\r\n>随着网页中流媒体的不断增多，网页可能包含的图片也是越来越多，但是这些图片往往需要消耗巨大的流量，所以为了提高网页加载的效率，当用户请求一个网页的时候，并不会一次性把该网页中包含的图片全部发送给用户，而是只发送给用户当前浏览器窗口可视区域内的图片，这就是图片懒加载技术。\r\n\r\n## 如何实现图片懒加载？\r\n### 方法1：监听scroll事件\r\n>通过本方法来实现图片懒加载之前我们需要先知道两个概念即\r\n> 1. 窗口显示区域的高度(window.innerHeight)\r\n> 2. 图片到视窗最上面的距离(getBoundingClientRect().top)\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/55b26426445c1cd28fe9fece522b5a88.png)\r\n\r\n**通过给图片的src属性名设置为自定义属性data-src使得为滚动到图片时不加载图片**\r\n```html\r\n<img data-src=\"./CSS.png\" alt=\"\">\r\n<img data-src=\"./Debug.png\" alt=\"\">\r\n<img data-src=\"./Flex布局.png\" alt=\"\">\r\n```\r\n\r\n**实现代码**\r\n```js\r\n// 获取所有图片的DOM节点\r\nconst images = document.querySelectorAll('img');\r\n\r\n// 监听scroll事件，并计算每一个图片距离视窗顶部的高度和视窗高度的关系\r\nwindow.addEventListener('scroll',(e) => {\r\n    images.forEach(image => {\r\n        // 获取图片距离浏览器视窗顶部的高度\r\n        const imageTop = image.getBoundingClientRect().top;\r\n        if (imageTop < window.innerHeight) {\r\n            const data_src = image.getAttribute('data-src');\r\n            image.setAttribute('src',data_src);\r\n        }\r\n        console.log('scroll触发');\r\n    })\r\n})\r\n```\r\n\r\n**存在的问题**\r\n>只要浏览器监听到滚动变化，就会不断触发调用，严重影响性能。\r\n\r\n### 方法2：通过IntersectionObserver(交叉观察)（推荐使用）\r\n>这个API指的是当视窗和目标对象发生交集的时候调用。\r\n\r\n**详细思路代码版**\r\n```js\r\n// 获取所有图片的DOM节点\r\nconst images = document.querySelectorAll('img');\r\n\r\n// 观察函数的回调函数在观察到的时候触发一次，观察不到再触发一次\r\ncallback = (entries) => {\r\n    // 这个entries参数是绑定好的所有元素数组\r\n    // 如果某个元素被观察到了则修改属性，加载图片，然后取消观察，因为已经加载出来了\r\n    entries.forEach(entry => {\r\n        if (entry.isIntersecting) {\r\n            const image = entry.target;\r\n            const data_src = image.getAttribute('data-src');\r\n            image.setAttribute('src',data_src);\r\n            observer.unobserve(image);\r\n            console.log('触发单个观察');\r\n        }\r\n    })\r\n}\r\n\r\n// 构造IntersectionObserver函数\r\nconst observer = new IntersectionObserver(callback);\r\n\r\n// 给每一张图片绑定观察函数\r\nimages.forEach(image => {\r\n    observer.observe(image);\r\n})\r\n```\r\n\r\n[CodeSandBox在线实现](https://codesandbox.io/s/shixiantupianlanjiazai-f0xi6)\r\n\r\n## 思维导图\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/334cb5a677d74a2ad22a063e97e3ec20.png)\r\n\r\n## 参考资料\r\n[JavaScript 图片懒加载 - Web前端工程师面试题讲解](https://www.bilibili.com/video/BV1FU4y157Li?from=search&seid=11178547492618432649)"
    },
    {
      "id": "/FreeCodeCamp经典题目（收银机）",
      "metadata": {
        "permalink": "/blog/FreeCodeCamp经典题目（收银机）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/FreeCodeCamp经典题目（收银机）.md",
        "source": "@site/blog\\FreeCodeCamp经典题目（收银机）.md",
        "title": "FreeCodeCamp经典题目（收银机）",
        "description": "题目描述",
        "date": "2021-08-02T00:00:00.000Z",
        "formattedDate": "2021年8月2日",
        "tags": [
          {
            "label": "FreeCodeCamp",
            "permalink": "/blog/tags/free-code-camp"
          }
        ],
        "readingTime": 5.1,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "FreeCodeCamp经典题目（收银机）",
          "date": "2021-8-2",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "FreeCodeCamp",
          "tags": [
            "FreeCodeCamp"
          ]
        },
        "prevItem": {
          "title": "五分钟带你学会--图片懒加载",
          "permalink": "/blog/五分钟带你学会--图片懒加载"
        },
        "nextItem": {
          "title": "一篇文章学会Flex布局的基本使用",
          "permalink": "/blog/一篇文章学会Flex布局的基本使用"
        }
      },
      "content": "## 题目描述\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/d8e96ab79bb036246b7df189ee322a8a.png)\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/05cbdac0675592875c9617174eb29e53.png)\r\n\r\n## 测试案例\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/558c8b6e1189ab3ef28608e07e0eb819.png)\r\n\r\n## 题目分析\r\n>由于本题是我使用Chrome浏览器直接对题目进行的翻译，难免造成一些翻译上的错误。所以接下来，我们首先对题目进行一个分析，明确题目想要解决什么样的问题。\r\n\r\n### 题目接收的参数是什么？\r\n>本题给出的函数，总共接收三个参数。\r\n* 参数1：顾客所有产品的总价。\r\n* 参数2：顾客给的钱数。\r\n* 参数3：是一个二维数组，每一个小数组中的第一个元素是面值，第二个元素是收银机中该面额的总值（美元）。\r\n\r\n## 解题思路\r\n\r\n### 1. 建立一个面值和美元对应的二维数组。\r\n```js\r\nconst cashMap = [\r\n        [\"PENNY\", 0.01],\r\n        [\"NICKEL\", 0.05],\r\n        [\"DIME\", 0.1],\r\n        [\"QUARTER\", 0.25],\r\n        [\"ONE\", 1],\r\n        [\"FIVE\", 5],\r\n        [\"TEN\", 10],\r\n        [\"TWENTY\", 20],\r\n        [\"ONE HUNDRED\", 100]\r\n    ]\r\n```\r\n### 2. 计算出应找零多少\r\n```js\r\n// 首先计算出应找零多少钱\r\nconst shouldGive = cash - price;\r\n```\r\n### 3. 使用指针指向第一个小于等于找零金额的面值\r\n```js\r\n// 定义遍历指针，这个指针指向第一个小于等于需要找零金额的面值\r\nlet pointer;\r\nfor (let i = 0; i < cashMap.length; i++) {\r\n    if (cashMap[i][1] > shouldGive) {\r\n        pointer = i - 1;\r\n        break;\r\n    } else if (cashMap[i][1] === shouldGive) {\r\n        pointer = i;\r\n        break;\r\n    }\r\n}\r\n```\r\n### 4. 使用一个临时变量和临时指针保存需要找零的数字和第三步我们找到的指针。\r\n```js\r\nlet tempGive = shouldGive;\r\nlet Tpointer = pointer;\r\n// 定义最终返回的数组\r\nlet result = []\r\n```\r\n### 5. 找出指针指向的面额需要从收银机中拿出几张（下面的sub变量表示张数）\r\n```js\r\nlet sub = Math.floor(tempGive / cashMap[Tpointer][1])\r\nwhile (Tpointer >= 0) {\r\n    if (sub * cashMap[Tpointer][1] > cid[Tpointer][1]) {\r\n        sub = cid[Tpointer][1] / cashMap[Tpointer][1];\r\n        result.push([cid[Tpointer][0], sub * cashMap[Tpointer][1]])\r\n        tempGive = (tempGive - sub * cashMap[Tpointer][1]).toFixed(2)\r\n        Tpointer--;\r\n        if (Tpointer < 0) return { status: \"INSUFFICIENT_FUNDS\", change: [] };\r\n        sub = Math.floor(tempGive / cashMap[Tpointer][1]);\r\n    } else {\r\n        result.push([cid[Tpointer][0], sub * cashMap[Tpointer][1]])\r\n        tempGive = (tempGive - sub * cashMap[Tpointer][1]).toFixed(2)\r\n        Tpointer--;\r\n        if (Tpointer < 0) break;\r\n        sub = Math.floor(tempGive / cashMap[Tpointer][1]);\r\n    }\r\n}\r\n```\r\n### 6. 如果找零后，收银机中没有钱了，此时返回close的状态\r\n```js\r\nconst cidSum = cid.reduce((pre,item) => pre + item[1],0)\r\nfor (let i = 0; i < result.length; i++) {\r\n    if (cidSum === shouldGive) {\r\n        let test = [];\r\n        for (let v of cashMap) {\r\n            if (v[0] === result[i][0]) {\r\n                test.push([v[0],result[i][1]])\r\n            } else {\r\n                test.push([v[0],0])\r\n            }\r\n        }\r\n        return {\r\n            status: 'CLOSED',\r\n            change: test\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 全部代码\r\n```js\r\nfunction checkCashRegister(price, cash, cid) {\r\n    // 建立面值哈希表\r\n    const cashMap = [\r\n        [\"PENNY\", 0.01],\r\n        [\"NICKEL\", 0.05],\r\n        [\"DIME\", 0.1],\r\n        [\"QUARTER\", 0.25],\r\n        [\"ONE\", 1],\r\n        [\"FIVE\", 5],\r\n        [\"TEN\", 10],\r\n        [\"TWENTY\", 20],\r\n        [\"ONE HUNDRED\", 100]\r\n    ]\r\n    // 1：首先计算出应找零多少钱\r\n    const shouldGive = cash - price;\r\n    // 2. 定义遍历指针，这个指针指向第一个小于等于需要找零金额的面值\r\n    let pointer;\r\n    for (let i = 0; i < cashMap.length; i++) {\r\n        if (cashMap[i][1] > shouldGive) {\r\n            pointer = i - 1;\r\n            break;\r\n        } else if (cashMap[i][1] === shouldGive) {\r\n            pointer = i;\r\n            break;\r\n        }\r\n    }\r\n\r\n    let tempGive = shouldGive;\r\n    let Tpointer = pointer;\r\n    // 定义最终返回的数组\r\n    let result = []\r\n\r\n\r\n    // *  下面是需要反复修改的代码\r\n    // sub 表示Tpointer指向的这个面值应该出几张\r\n    let sub = Math.floor(tempGive / cashMap[Tpointer][1])\r\n    while (Tpointer >= 0) {\r\n        if (sub * cashMap[Tpointer][1] > cid[Tpointer][1]) {\r\n            sub = cid[Tpointer][1] / cashMap[Tpointer][1];\r\n            result.push([cid[Tpointer][0], sub * cashMap[Tpointer][1]])\r\n            tempGive = (tempGive - sub * cashMap[Tpointer][1]).toFixed(2)\r\n            Tpointer--;\r\n            if (Tpointer < 0) return { status: \"INSUFFICIENT_FUNDS\", change: [] };\r\n            sub = Math.floor(tempGive / cashMap[Tpointer][1]);\r\n        } else {\r\n            result.push([cid[Tpointer][0], sub * cashMap[Tpointer][1]])\r\n            tempGive = (tempGive - sub * cashMap[Tpointer][1]).toFixed(2)\r\n            Tpointer--;\r\n            if (Tpointer < 0) break;\r\n            sub = Math.floor(tempGive / cashMap[Tpointer][1]);\r\n        }\r\n    }\r\n    result = result.filter(item => item[1] !== 0)\r\n    \r\n    const cidSum = cid.reduce((pre,item) => pre + item[1],0)\r\n    for (let i = 0; i < result.length; i++) {\r\n        if (cidSum === shouldGive) {\r\n            let test = [];\r\n            for (let v of cashMap) {\r\n                if (v[0] === result[i][0]) {\r\n                    test.push([v[0],result[i][1]])\r\n                } else {\r\n                    test.push([v[0],0])\r\n                }\r\n            }\r\n            return {\r\n                status: 'CLOSED',\r\n                change: test\r\n            }\r\n        }\r\n    }\r\n    return { status: \"OPEN\", change: result }\r\n}\r\n\r\ncheckCashRegister(19.5, 20, [[\"PENNY\", 0.5], [\"NICKEL\", 0], [\"DIME\", 0], [\"QUARTER\", 0], [\"ONE\", 0], [\"FIVE\", 0], [\"TEN\", 0], [\"TWENTY\", 0], [\"ONE HUNDRED\", 0]]);\r\n```\r\n\r\n## 题目反思\r\n* 遇到难题不要怕，首先要学会将难题分解成一个一个的小问题。\r\n* 通过解决一个又一个的小问题，大的困难问题自然而解。\r\n* 必须熟练掌握四舍五入，保留小数，求和，去重等常见的API操作方法。"
    },
    {
      "id": "/一篇文章学会Flex布局的基本使用",
      "metadata": {
        "permalink": "/blog/一篇文章学会Flex布局的基本使用",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/一篇文章学会Flex布局的基本使用.md",
        "source": "@site/blog\\一篇文章学会Flex布局的基本使用.md",
        "title": "一篇文章学会Flex布局的基本使用",
        "description": "传统布局与Flex布局的区别",
        "date": "2021-08-01T00:00:00.000Z",
        "formattedDate": "2021年8月1日",
        "tags": [
          {
            "label": "Flex",
            "permalink": "/blog/tags/flex"
          }
        ],
        "readingTime": 3.72,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "一篇文章学会Flex布局的基本使用",
          "date": "2021-8-1",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "Flex",
          "tags": [
            "Flex"
          ]
        },
        "prevItem": {
          "title": "FreeCodeCamp经典题目（收银机）",
          "permalink": "/blog/FreeCodeCamp经典题目（收银机）"
        },
        "nextItem": {
          "title": "使用combineReducers合并多个reducer（基础文章）",
          "permalink": "/blog/使用combineReducers合并多个reducer（基础文章）"
        }
      },
      "content": "## 传统布局与Flex布局的区别\r\n* 传统布局兼容性好，flex布局兼容性较差。\r\n* 传统布局不能在移动端很好的布局，flex布局则适合在移动端布局。\r\n* 传统布局布局较为繁琐，Flex布局较为简单。\r\n\r\n## flxe的布局原理\r\n* flex布局意为弹性布局，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为flxe布局。\r\n* 当为父盒子设置flex布局之后，子元素的float、clear和vertical-align属性都将失效。\r\n* 采用Flex布局的元素，称为Flex容器，简称容器，它的所有子元素自动成为容器成员，并称为Flex项目。\r\n\r\n>**总结Flex布局原理：就是用过给父盒子添加flex属性，来控制子盒子的位置和排列方式。**\r\n\r\n## Flex布局常见的父项属性\r\n### 分清主轴和侧轴\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/c75b28991149bc19840e640ee86b5601.png)\r\n\r\n### flex-direction设置主轴方向\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/5b1e9011ad7026532eb59229e8a6e452.png)\r\n\r\n* row的默认值是从左到右排列。（相当于省略了flex-direction: row;）我们的元素是跟着主轴走的。\r\n\r\n[codeSandBox在线演示](https://codesandbox.io/s/02flex-directionshezhizhuzhoufangxiang-u9nsp?file=/index.html)\r\n\r\n### justify-content设置主轴上子元素的排列方式\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/669b98774d8dc629ee649e5771078dd4.png)\r\n\r\n* 这个属性的默认值是flex-start，假如不写就默认这个。\r\n```css\r\ndiv {   \r\n    display: flex;\r\n    width: 800px;\r\n    height: 300px;\r\n    background-color: pink;\r\n    /* justify-content: space-around; */\r\n    justify-content: space-between;\r\n    /* justify-content: space-around; */\r\n\r\n}\r\n```\r\n[codeSandBox在线演示](https://codesandbox.io/s/03justify-contentshezhizhuzhoushangziyuansudepailiefangshi-y0oi6?file=/index.html)\r\n\r\n### flex-wrap设置子元素是否换行\r\n>在flex布局中默认是不换行的。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/0cae09563a0451985110ea741bddecb8.png)\r\n\r\n```css\r\ndiv {   \r\n    display: flex;\r\n    width: 600px;\r\n    height: 400px;\r\n    background-color: pink;\r\n    flex-wrap: wrap;\r\n}\r\n```\r\n\r\n[codeSandBox在线演示](https://codesandbox.io/s/04flex-wrapshezhiziyuansushifouhuanxing-x3vwl)\r\n\r\n### align-items设置侧轴上的子元素排列方式（单行）\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/d2f0896a2d1c643d9dacf621cd423838.png)\r\n\r\n```css\r\ndiv {   \r\n    display: flex;\r\n    width: 600px;\r\n    height: 400px;\r\n    background-color: pink;\r\n    justify-content: center;\r\n    align-items: center;\r\n}\r\n```\r\n\r\n[codeSandBox在线演示](https://codesandbox.io/s/05align-itemsshezhizizhou-004vz?file=/index.html)\r\n\r\n### align-content：设置侧轴上子元素的排列方式（适用于多行，这个属性在单行下是没有效果的）\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/ab7838ced0b461577df276675ddf4187.png)\r\n\r\n```css\r\ndiv {   \r\n    display: flex;\r\n    width: 800px;\r\n    height: 400px;\r\n    background-color: pink;\r\n    flex-wrap: wrap;\r\n    /* align-content: flex-start; */\r\n    /* align-content: flex-end; */\r\n    align-content: space-between;\r\n}\r\n```\r\n\r\n[codeSandBox在线演示](https://codesandbox.io/s/06align-contentshezhizaicezhoufangxiangshangziyuansudepailiefangshijinguayongyuduoxingqingkuang-qk0b9?file=/index.html)\r\n\r\n### align-content和align-items的区别\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/764291bc98caa0cfac0aafa770aeb089.png)\r\n\r\n### flex-flow: flex-direction和flex-wrap属性的复合属性\r\n* 下面的两段代码是等价的\r\n```css\r\nflex-direction: column;\r\nflex-wrap: wrap;\r\n```\r\n```css\r\nflex-flow: column wrap;\r\n```\r\n\r\n[codeSandBox在线演示](https://codesandbox.io/s/07flex-flowshiflex-directionheflex-wrapdefuheshuxingyigedingliadexiaoguo-seste)\r\n\r\n## Flex布局中常见的子项属性\r\n### flex属性：将剩余空间分配给子项目，表示子项目占多少份数\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/5ac4d254a1d4a4ad1b94b2741b52eac3.png)\r\n```css\r\nsection {\r\n    display: flex;\r\n    width: 60%;\r\n    height: 150px;\r\n    background-color: pink;\r\n    margin: 0 auto;\r\n}\r\nsection div:nth-child(1) {\r\n    width: 100px;\r\n    height: 150px;\r\n    background-color: red;\r\n}\r\nsection div:nth-child(2) {\r\n    flex: 1;\r\n    background-color: aqua;\r\n}\r\nsection div:nth-child(3) {\r\n    width: 100px;\r\n    height: 150px;\r\n    background-color: blue;\r\n}\r\n```\r\n* [codeSandBox在线演示（圣杯布局）](https://codesandbox.io/s/08zixiangshuxingzhiflexshixianshengbeibuju-3cxeu?file=/index.html)\r\n\r\n### align-self：控制子项自己在侧轴上的排列方式（注意和align-items的区别）\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/31712246f2b71dc063cc9acb443172b4.png)\r\n\r\n```css\r\ndiv span:nth-child(3) {\r\n    align-self: flex-end;\r\n}\r\n```\r\n[codeSandBox在线演示](https://codesandbox.io/s/09align-selfdingyicezhoushanggebiezixiangdebuju-9g1gf?file=/index.html)\r\n\r\n### order属性：定义项目的排列顺序\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/a7f1a1b51d4b468cd651e9979f9a6e83.png)\r\n\r\n```css\r\n// 这个属性的初始值默认是0，如果你想交换到默认顺序的左边直接设置一个比0小的值即可。\r\ndiv span:nth-child(2) {\r\n    order: -1;\r\n}\r\n```\r\n[codeSandBox在线演示](https://codesandbox.io/s/10ordershuxingdingyizixiangdexianhoushunxu-j03iu?file=/index.html)"
    },
    {
      "id": "/使用combineReducers合并多个reducer（基础文章）",
      "metadata": {
        "permalink": "/blog/使用combineReducers合并多个reducer（基础文章）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/使用combineReducers合并多个reducer（基础文章）.md",
        "source": "@site/blog\\使用combineReducers合并多个reducer（基础文章）.md",
        "title": "使用combineReducers合并多个reducer（基础文章）",
        "description": "comineReducers旨在解决什么问题？",
        "date": "2021-07-31T00:00:00.000Z",
        "formattedDate": "2021年7月31日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.68,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "使用combineReducers合并多个reducer（基础文章）",
          "date": "2021-7-31",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "一篇文章学会Flex布局的基本使用",
          "permalink": "/blog/一篇文章学会Flex布局的基本使用"
        },
        "nextItem": {
          "title": "使用redux-thunk实现异步redux（基础文章）",
          "permalink": "/blog/使用redux-thunk实现异步redux（基础文章）"
        }
      },
      "content": "## comineReducers旨在解决什么问题？\r\n>这个函数是redux库中的函数，旨在解决多个reducer暴露的问题，因为一个组件往往用到的不止一个reducer。\r\n\r\n## 结合后的reducer函数\r\n```js\r\nimport {INCREMENT,DECREMENT} from './action-types'\r\nimport {combineReducers} from 'redux'\r\n// 管理count状态的reducer\r\n\r\nfunction count(state=1,action) {\r\n    console.log('count',state,action);\r\n    switch (action.type) {\r\n        case INCREMENT:\r\n            return state + action.data\r\n        case DECREMENT:\r\n            return state - action.data\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n// 管理user状态的reducer\r\nconst initUser = {};\r\n\r\nfunction user(state = initUser,action) {\r\n    switch (action.type) {\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nexport default combineReducers({\r\n    count,\r\n    user\r\n})\r\n```\r\n## 思维导图\r\n![](https://img-blog.csdnimg.cn/img_convert/43c88f68a5a8b904aeb8f1dabba4ffbd.png)"
    },
    {
      "id": "/使用redux-thunk实现异步redux（基础文章）",
      "metadata": {
        "permalink": "/blog/使用redux-thunk实现异步redux（基础文章）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/使用redux-thunk实现异步redux（基础文章）.md",
        "source": "@site/blog\\使用redux-thunk实现异步redux（基础文章）.md",
        "title": "使用redux-thunk实现异步redux（基础文章）",
        "description": "使用redux-thunk实现异步redux",
        "date": "2021-07-30T00:00:00.000Z",
        "formattedDate": "2021年7月30日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 1.32,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "使用redux-thunk实现异步redux（基础文章）",
          "date": "2021-7-30",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "使用combineReducers合并多个reducer（基础文章）",
          "permalink": "/blog/使用combineReducers合并多个reducer（基础文章）"
        },
        "nextItem": {
          "title": "react-redux的3个主要作用",
          "permalink": "/blog/react-redux的3个主要作用"
        }
      },
      "content": "## 使用redux-thunk实现异步redux\r\n>Redux存在一个问题，就是无法实现**异步的action**,这也就是为什么我们要引入redux-thunk的原因。\r\n\r\n## 在哪里引入redux-thunk？\r\n>在redux的核心组件store中引入。我们引入的这个thunk,相当于一个中间件。所以我们同时需要从redux中引入applyMiddleware，放入createStore的第二个参数中。\r\n\r\n```js\r\nimport {createStore,applyMiddleware} from 'redux';\r\nimport reducer from './reducer'\r\nimport thunk from 'redux-thunk'\r\n\r\nexport default createStore(reducer,applyMiddleware(thunk))\r\n```\r\n\r\n## 异步action和普通的action有什么不同？\r\n>普通action返回的是对象，但是异步action返回的是一个函数。\r\n\r\n**异步action和同步action的区别**\r\n\r\n```js\r\n// 同步action\r\nexport const decrement = (number) => ({type: DECREMENT,data: number});\r\n// 异步增加的action\r\nexport const incrementAsync = (number) => {\r\n    return dispatch => {\r\n        setTimeout(() => {\r\n            dispatch({type: INCREMENT,data: number})\r\n        },1000)\r\n    }\r\n}\r\n```\r\n\r\n## 最后别忘了，组件中已经没有定时器了，定时器在异步action中。\r\n```js\r\nincrementIfAsync = () => {\r\n    const number = this.numberRef.current.value * 1;\r\n    this.props.incrementAsync(number);\r\n}\r\n```\r\n## [codeSandBox在线演示(使用redux-thunk实现异步action操作状态)](https://codesandbox.io/s/shiyongredux-thunkshixianyibuactioncaozuozhuangtai-z9ped)"
    },
    {
      "id": "/react-redux的3个主要作用",
      "metadata": {
        "permalink": "/blog/react-redux的3个主要作用",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/react-redux的3个主要作用.md",
        "source": "@site/blog\\react-redux的3个主要作用.md",
        "title": "react-redux的3个主要作用",
        "description": "已经有了redux为什么还要设计react-redux?",
        "date": "2021-07-29T00:00:00.000Z",
        "formattedDate": "2021年7月29日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 2.87,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "react-redux的3个主要作用",
          "date": "2021-7-29",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "使用redux-thunk实现异步redux（基础文章）",
          "permalink": "/blog/使用redux-thunk实现异步redux（基础文章）"
        },
        "nextItem": {
          "title": "面试官：请说下CSS选择器优先级",
          "permalink": "/blog/面试官：请说下CSS选择器优先级"
        }
      },
      "content": "## 已经有了redux为什么还要设计react-redux?\r\n>因为redux和组件的耦合度太高，为了解耦，所以设计了redux。一旦我们引入了react-redux，我们便不再需要使用store的subscribe自己去订阅状态了。UI组件就像普通组件一样内部没有redux的身影。可读性更高。\r\n\r\n## UI组件和容器组件\r\n>react-redux将组件分为UI组件和容器组件，UI组件只负责UI的呈现，不带有任何业务逻辑，通过props接收数据，不使用Rdux的API，一般保存在components文件夹下，容器组件，只负责管理数据和业务逻辑，不负责UI的呈现，使用redux的API，一般保存在containers文件夹下。\r\n\r\n\r\n## react-redux的核心API\r\n### 1. Provider：该组件包含的组件能够获取到状态state.\r\n>Provider存在的意义相当于可以替换掉redux中的subscribe。\r\n```js\r\nReactDOM.render((\r\n    <Provider store={store}>\r\n        <App />\r\n    </Provider>\r\n),document.querySelector('#root'))\r\n```\r\n\r\n### 2. connect：连接UI组件和容器组件以及Redux\r\n\r\n## react-redux的三个主要作用\r\n### 作用1\r\n**将组件分为了容器组件和UI组件，UI组件通过props来获取状态和操作状态的方法。**\r\n\r\n### 作用2\r\n**通过Provider组件来取代redux中的store.subscribe来监听组件的状态变化，用于渲染组件。**\r\n\r\n### 作用3\r\n**在容器组件中通过核心API connect来连接UI组件和redux，connect是一个高阶函数，第一个参数接收的是两个回调函数，回调函数1：将接收一个state，然后返回一个对象对象中包含了UI组件想要的状态。回调函数2：接收一个dispatch，返回一个对象，对象中包含了UI组件想要操作状态的方法。同时还有一个简写方法，就是第二个参数直接传入一个对象，该对象包含操作状态的方法。（核心：就是将state和dispatch映射到UI组件的props中）**\r\n\r\n### 核心代码\r\n```js\r\nexport default connect(\r\n    state => ({count: state}),\r\n    dispatch => {\r\n        return {\r\n            increment: number => dispatch(increment(number)),\r\n            decrement: number => dispatch(decrement(number)),\r\n        }\r\n    }\r\n)(Counter)\r\n```\r\n**下面是简写形式**\r\n```js\r\nexport default connect(\r\n    state => ({count: state}),\r\n    {increment,decrement}\r\n)(Counter)\r\n```\r\n\r\n## 注意事项\r\n* 渲染的是容器组件，而不是UI组件。（Provider包裹的）"
    },
    {
      "id": "/面试官：请说下CSS选择器优先级",
      "metadata": {
        "permalink": "/blog/面试官：请说下CSS选择器优先级",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/面试官：请说下CSS选择器优先级.md",
        "source": "@site/blog\\面试官：请说下CSS选择器优先级.md",
        "title": "面试官：请说下CSS选择器优先级",
        "description": "什么是CSS选择器优先级？",
        "date": "2021-07-27T00:00:00.000Z",
        "formattedDate": "2021年7月27日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 0.995,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "面试官：请说下CSS选择器优先级",
          "date": "2021-7-27",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "react-redux的3个主要作用",
          "permalink": "/blog/react-redux的3个主要作用"
        },
        "nextItem": {
          "title": "LeetCode——数组中的第K个最大元素（JS实现）",
          "permalink": "/blog/LeetCode——数组中的第K个最大元素（JS实现）"
        }
      },
      "content": "## 什么是CSS选择器优先级？\r\n>CSS选择器优先级是指在给CSS元素设置样式的时候，如果同时有多个CSS选择器同时指向一个元素，那么优先级高的选择器的元素样式会最终应用到这个元素上。\r\n\r\n## 通过权重来计算CSS选择器的优先级\r\n**1. !important的优先级是最高的。（没有这个属性的话，则按照下面的向量来计算优先级）**\r\n\r\n****\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/55de2cc9a470a30526f0278866a0fb8b.png)\r\n\r\n**2. 权重相同，看谁的定义靠后，越靠后就会覆盖掉前面的样式**\r\n\r\n### 例子1\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/d9a685a108735d4dfd816dbaf83e1d1f.png)\r\n\r\n### 例子2\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/57b2543917ac378502f79883ad46d270.png)\r\n\r\n### 例子3（优先级相同，谁在后面谁起作用）\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/51d907e9bd4523ac9f36505d76805f8c.png)\r\n\r\n\r\n## [参考资料]\r\n[2分钟掌握 CSS 选择器优先级（特异性）](https://www.bilibili.com/video/BV1Fg4y1874w?from=search&seid=17581043688953657894)"
    },
    {
      "id": "/LeetCode——数组中的第K个最大元素（JS实现）",
      "metadata": {
        "permalink": "/blog/LeetCode——数组中的第K个最大元素（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——数组中的第K个最大元素（JS实现）.md",
        "source": "@site/blog\\LeetCode——数组中的第K个最大元素（JS实现）.md",
        "title": "LeetCode——数组中的第K个最大元素（JS实现）",
        "description": "题目描述",
        "date": "2021-07-26T00:00:00.000Z",
        "formattedDate": "2021年7月26日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.09,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——数组中的第K个最大元素（JS实现）",
          "date": "2021-7-26",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "面试官：请说下CSS选择器优先级",
          "permalink": "/blog/面试官：请说下CSS选择器优先级"
        },
        "nextItem": {
          "title": "LeetCode——两个数组的交集（JS实现）",
          "permalink": "/blog/LeetCode——两个数组的交集（JS实现）"
        }
      },
      "content": "## 题目描述\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/d786b713e65d832760ba4153e0ccd9ef.png)\r\n\r\n## 解题思路\r\n* 本题思路较为简单，首先对数组按照从小到大进行排序。\r\n* 使用reverse将数组进行反转。\r\n* 返回反转数组的第k-1个元素即可。\r\n* 本次没有采取JS自带的sort，而是自己实现了快速排序。\r\n\r\n## 解题代码\r\n```js\r\nvar findKthLargest = function (nums, k) {\r\n    // 快速排序\r\n\r\n    function sort(nums, Left, Right) {\r\n        let l = Left;\r\n        let r = Right;\r\n        let pivot = nums[l];\r\n        if (l >= r) return;\r\n\r\n        while (l < r) {\r\n            while (nums[r] >= pivot && l < r) {\r\n                r--;\r\n            }\r\n            if (nums[r] < pivot) {\r\n                nums[l] = nums[r];\r\n                l++;\r\n            }\r\n            while (nums[l] <= pivot && l < r) {\r\n                l++;\r\n            }\r\n            if (nums[l] > pivot) {\r\n                nums[r] = nums[l];\r\n                r--;\r\n            }\r\n            if (l === r) {\r\n                nums[l] = pivot\r\n            }\r\n        }\r\n\r\n        sort(nums, Left, l - 1);\r\n        sort(nums, r + 1, Right);\r\n    }\r\n    \r\n    sort(nums,0,nums.length-1);\r\n    nums\r\n    return nums.reverse()[k-1]\r\n};\r\n```\r\n\r\n## 题目反思\r\n* 熟练掌握快速排序。\r\n* 熟练使用JS中的各种常用API。"
    },
    {
      "id": "/LeetCode——两个数组的交集（JS实现）",
      "metadata": {
        "permalink": "/blog/LeetCode——两个数组的交集（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——两个数组的交集（JS实现）.md",
        "source": "@site/blog\\LeetCode——两个数组的交集（JS实现）.md",
        "title": "LeetCode——两个数组的交集（JS实现）",
        "description": "题目描述",
        "date": "2021-07-24T00:00:00.000Z",
        "formattedDate": "2021年7月24日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.725,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——两个数组的交集（JS实现）",
          "date": "2021-7-24",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "LeetCode——数组中的第K个最大元素（JS实现）",
          "permalink": "/blog/LeetCode——数组中的第K个最大元素（JS实现）"
        },
        "nextItem": {
          "title": "电话号码验证器（FreeCodeCamp）",
          "permalink": "/blog/电话号码验证器（FreeCodeCamp）"
        }
      },
      "content": "## 题目描述\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/fe4d35dcad75d216871e8a01071d9645.png)\r\n\r\n## 解题思路\r\n* 首先通过集合的方式对数组进行去重。\r\n* 去重之后遍历其中一个数组，如果该数组在另一个数组中则将其加入到结果数组中。\r\n* 最后返回结果数组。\r\n\r\n## 解题代码\r\n```js\r\nvar intersection = function(nums1, nums2) {\r\n    const temp1 = [...new Set(nums1)]\r\n    const temp2 = [...new Set(nums2)];\r\n    const result = [];\r\n    for (let v of temp1) {\r\n        if (temp2.includes(v)) {\r\n            result.push(v)\r\n        }\r\n    }\r\n    return result\r\n};\r\n```\r\n\r\n## 题目反思\r\n* 学会使用集合对数组去重。\r\n* 学会使用includes判断数组中是否存在某一元素。"
    },
    {
      "id": "/电话号码验证器（FreeCodeCamp）",
      "metadata": {
        "permalink": "/blog/电话号码验证器（FreeCodeCamp）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/电话号码验证器（FreeCodeCamp）.md",
        "source": "@site/blog\\电话号码验证器（FreeCodeCamp）.md",
        "title": "电话号码验证器（FreeCodeCamp）",
        "description": "题目描述",
        "date": "2021-07-23T00:00:00.000Z",
        "formattedDate": "2021年7月23日",
        "tags": [
          {
            "label": "FreeCodeCamp",
            "permalink": "/blog/tags/free-code-camp"
          }
        ],
        "readingTime": 0.715,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "电话号码验证器（FreeCodeCamp）",
          "date": "2021-7-23",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "FreeCodeCamp",
          "tags": [
            "FreeCodeCamp"
          ]
        },
        "prevItem": {
          "title": "LeetCode——两个数组的交集（JS实现）",
          "permalink": "/blog/LeetCode——两个数组的交集（JS实现）"
        },
        "nextItem": {
          "title": "TypeScript的类型推论与联合类型--(TypeScript 03)",
          "permalink": "/blog/TypeScript的类型推论与联合类型--(TypeScript 03)"
        }
      },
      "content": "## 题目描述\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/3609411cf95aedd8ece1e0c9d0548116.png)\r\n\r\n## 解题思路\r\n* 本题我采用的是正则的方法，通过考虑多种情况，因为所有的测试案例都已经给出，只要能够将所有情况考虑全面，通过正则表达式就可以通过测试。\r\n* 本题可能不是最优解，如果读者有其他更优解，欢迎留言评论。\r\n\r\n## 解题代码\r\n```js\r\nfunction telephoneCheck(str) {\r\n    let reg = /^1\\s?\\(\\d{3}\\).?\\d{3}.?\\d{4}|^1\\s\\d{3}[\\(|-]\\d{3}[-]\\d{4}|^\\d{10}$|\\d{3}\\s\\d{3}\\s\\d{4}|^\\(\\d{3}\\)\\d{3}-\\d{4}|^\\d{3}-\\d{3}-\\d{4}$/\r\n    const bol = reg.test(str);\r\n    return bol\r\n}\r\n```\r\n\r\n## 题目反思\r\n>熟练掌握正则表达式将极大的提高你的开发效率。"
    },
    {
      "id": "/TypeScript的类型推论与联合类型--(TypeScript 03)",
      "metadata": {
        "permalink": "/blog/TypeScript的类型推论与联合类型--(TypeScript 03)",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/TypeScript的类型推论与联合类型--(TypeScript 03).md",
        "source": "@site/blog\\TypeScript的类型推论与联合类型--(TypeScript 03).md",
        "title": "TypeScript的类型推论与联合类型--(TypeScript 03)",
        "description": "什么是TS中的类型推断？",
        "date": "2021-07-22T00:00:00.000Z",
        "formattedDate": "2021年7月22日",
        "tags": [
          {
            "label": "TypeScript",
            "permalink": "/blog/tags/type-script"
          }
        ],
        "readingTime": 1.225,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "TypeScript的类型推论与联合类型--(TypeScript 03)",
          "date": "2021-7-22",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "TypeScript",
          "tags": [
            "TypeScript"
          ]
        },
        "prevItem": {
          "title": "电话号码验证器（FreeCodeCamp）",
          "permalink": "/blog/电话号码验证器（FreeCodeCamp）"
        },
        "nextItem": {
          "title": "TypeScript的类型注解--(TypeScript 02)",
          "permalink": "/blog/TypeScript的类型注解--(TypeScript 02)"
        }
      },
      "content": "## 什么是TS中的类型推断？\r\n>以下面的例子为例，有时候我们并没有进行类型注解，TS经过推断后给我们添加的类型注解。\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/b836150831c19865195d5dfbb48506de.png)\r\n\r\n## 什么时候需要进行类型注解什么时候不需要呢？\r\n* 比如下面的代码，TS能够推断的，我们可以不进行注解\r\n```ts\r\nlet a = 3;\r\n```\r\n\r\n* 比如下面的代码，TS不能够对参数进行推断的情况下，我们需要进行注解\r\n```ts\r\nfunction test(a,b) {\r\n    return a + b;\r\n}\r\n```\r\n\r\n## 什么是联合类型？\r\n>联合类型指的是一个变量可能具有多种类型，下面我们看一个简单的例子就明白了。\r\n```ts\r\nlet a: string | number;\r\n\r\na = 2;\r\na = '123';\r\n```\r\n* 联合类型调用共有属性可以，但是如果是非共有属性则不行。\r\n```ts\r\nfunction test(a: number | string) {\r\n    return a.split('');   //Error\r\n}\r\n\r\nfunction test(a: number | string) {\r\n    return a.toString()    //Right\r\n}\r\n\r\ntest(1)\r\n```"
    },
    {
      "id": "/TypeScript的类型注解--(TypeScript 02)",
      "metadata": {
        "permalink": "/blog/TypeScript的类型注解--(TypeScript 02)",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/TypeScript的类型注解--(TypeScript 02).md",
        "source": "@site/blog\\TypeScript的类型注解--(TypeScript 02).md",
        "title": "TypeScript的类型注解--(TypeScript 02)",
        "description": "TS中的类型注解",
        "date": "2021-07-21T00:00:00.000Z",
        "formattedDate": "2021年7月21日",
        "tags": [
          {
            "label": "TypeScript",
            "permalink": "/blog/tags/type-script"
          }
        ],
        "readingTime": 6.59,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "TypeScript的类型注解--(TypeScript 02)",
          "date": "2021-7-21",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "TypeScript",
          "tags": [
            "TypeScript"
          ]
        },
        "prevItem": {
          "title": "TypeScript的类型推论与联合类型--(TypeScript 03)",
          "permalink": "/blog/TypeScript的类型推论与联合类型--(TypeScript 03)"
        },
        "nextItem": {
          "title": "如何排查是哪个插件影响了我们的CSS样式？",
          "permalink": "/blog/如何排查是哪个插件影响了我们的CSS样式？"
        }
      },
      "content": "## TS中的类型注解\r\n* 基础类型：boolean string number null undefined symbol any never\r\n* 对象：interface\r\n* 数组：number[] string[] boolean[] \r\n* 泛型的写法：Array\\<number/>\r\n\r\n## TS带来的新的语法特性\r\n1. as 断言\r\n2. class(OOP面向对象的三大特性)：封装、继承、多态\r\n还有其他的，后续文章会进行详细的介绍。\r\n\r\n## 创建tsconfig.json\r\n```\r\ntsc --init\r\n```\r\n\r\n## 修改tsc的输出路径\r\n1. 在tsconfig.json中对下面两行进行修改。\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/e83fb35f98746323709b2b422252c495.png)\r\n\r\n2. 直接运行tsc指令，系统将直接将编译好的js文件输出到dist目录下。\r\n\r\n## 原始数据的注解\r\n1. 布尔值的注解\r\n```js\r\nlet isDone: boolean = false;\r\n```\r\n2. 数字类型的注解\r\n```ts\r\nlet decLiteral: number = 6;\r\n```\r\n3. 字符串类型的注解\r\n```ts\r\nlet name2: string = \"bob\";\r\nname2 = \"smith\";\r\n```\r\n4. any类型的注解\r\n>any类型可以表示任意类型，通过此类型的注解，不会有相应的代码提示，但是可以赋值为不同类型的数据。\r\n```ts\r\nlet notSure: any = 4;\r\nnotSure = \"maybe a string instead\";\r\nnotSure = false; // okay, definitely a boolean\r\n```\r\n>通过Object类型的注解可以赋值为任意类型，但是却只能调用真正的Object上的属性，也就是说只有你是真的对象才可以调用上面的方法。\r\n```js\r\nlet notSure: any = 4;\r\nnotSure.ifItExists(); // okay, ifItExists might exist at runtime\r\nnotSure.toFixed(); // okay, toFixed exists (but the compiler doesn't check)\r\n\r\nlet prettySure: Object = 4;\r\nprettySure.toFixed(); // Error: Property 'toFixed' doesn't exist on type 'Object'.\r\n```\r\n>未给初始值的变量，初始值是any.\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/dc0dee707eb7c5c52ca47d35f4034fe2.png)\r\n\r\n5. void类型的注解\r\n>void类型的变量只能赋值为undefined和null,当一个函数没有返回值的时候，其注解类型为void.\r\n```js\r\nfunction warnUser(): void {\r\n    console.log(\"This is my warning message\");\r\n}\r\n```\r\n\r\n6. undefined和null类型的注解\r\n```js\r\n// Not much else we can assign to these variables!\r\nlet u: undefined = undefined;\r\nlet n: null = null;\r\n```\r\n>在配置项中将\"strictNullChecks\"置为false的时候，undefined和null可以成为任何类型的子类型，所谓的子类型，就是说类型为number或其他的类型的值可以使undefined和null.\r\n```js\r\nlet a: number = undefined;\r\nlet b: number = null;\r\n```\r\n\r\n**注意：在类型注解的时候，可以使用或运算符，同时注解多个类型**\r\n```ts\r\nlet a: string | boolean = true;\r\n```\r\n\r\n7. never类型的注解\r\n>返回never的函数必须存在无法达到的终点，never是任何类型的子类型，其他任何类型都不能赋值给never.\r\n```ts\r\n// 返回never的函数必须存在无法达到的终点\r\nfunction error(message: string): never {\r\n    throw new Error(message);\r\n}\r\n// 推断的返回值类型为never\r\nfunction fail() {\r\n    return error(\"Something failed\");\r\n}\r\n// 返回never的函数必须存在无法达到的终点\r\nfunction infiniteLoop(): never {\r\n    while (true) {\r\n    }\r\n}\r\n```\r\n\r\n8. Object类型的注解\r\n>使用Object类型的注解，可以很好的表示非原始类型，也就是除`number`，`string`，`boolean`，`symbol`，`null`或`undefined`之外的类型。使用Object类型进行注解，可以很好的表示很多API。\r\n```js\r\ndeclare function create(o: object | null): void;\r\n\r\ncreate({ prop: 0 }); // OK\r\ncreate(null); // OK\r\n\r\ncreate(42); // Error\r\ncreate(\"string\"); // Error\r\ncreate(false); // Error\r\ncreate(undefined); // Error\r\n```\r\n## 引用类型的注解\r\n1. 数组类型的注解\r\n```ts\r\n// 方式1\r\nlet list: number[] = [1,2,3];\r\n\r\n// 方式2\r\nlet list2: Array<number> = [4,5,6]\r\n// 使用接口注解数组\r\ninterface list {\r\n    [index: number] : number | string\r\n}\r\nlet temp: list = [1,2,3,'60']\r\n// 注解类数组\r\ninterface Args {\r\n    [index: number]: any;\r\n    length: number;\r\n    callee: Function;\r\n}\r\n\r\nfunction test() {\r\n    let args: IArguments = arguments;\r\n}\r\n\r\ntest()\r\n```\r\n2. 函数的注解\r\n* 函数声明的注解方式\r\n```ts\r\n// 函数声明的注解方式：参数和返回值\r\nfunction test(a: number,b: number): number {\r\n    return a + b;\r\n}\r\n\r\ntest(1,2)\r\n```\r\n* 函数表达式的注解方式\r\n```ts\r\n// 函数表达式的注解方式\r\nlet test2: (a: number, b: number) => number = function (a: number, b: number): number {\r\n    return a + b;\r\n}\r\n// 可以简写为下面的形式，也是较为常见的形式\r\nlet test: (a: number,b: number) => number = function (a,b) {\r\n    return a + b;\r\n}\r\n```\r\n* 可选参数和默认参数\r\n```ts\r\n// 可选参数\r\nfunction test(a: number,b?: number): number {\r\n    return a; \r\n}\r\n// 默认参数\r\nfunction test2(a: number,b = '666'): string {\r\n    return a + b;\r\n}\r\n```\r\n* 剩余参数\r\n```ts\r\n// 剩余参数\r\nfunction test(a: number,b: number,...restOfName: string[]): number {\r\n    return a + b;\r\n}\r\ntest(1,2,'3')\r\n```\r\n* 参数的解构赋值\r\n```ts\r\n// 参数的解构赋值\r\nfunction test({first,second}: {first: number,second: number}) {\r\n    return first + second;\r\n}\r\ntest({first: 1,second: 2})\r\n```\r\n### 函数注解中的this指向问题\r\n```ts\r\n\r\ninterface Card {\r\n    suits: string[];\r\n    cards: number[];\r\n}\r\n\r\ninterface Deck {\r\n    suits: string[];\r\n    cards: number[];\r\n    createCardPicker(this: Deck): () => Card;\r\n}\r\n\r\nlet deck = {\r\n    suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"],\r\n    cards: Array(52),\r\n    createCardPicker: function() {\r\n        return () => {\r\n            let pickedCard = Math.floor(Math.random() * 52);\r\n            let pickedSuit = Math.floor(pickedCard / 13);\r\n\r\n            return {suit: this.suits[pickedSuit], card: pickedCard % 13};\r\n        }\r\n    }\r\n}\r\n\r\nlet cardPicker = deck.createCardPicker();\r\nlet pickedCard = cardPicker();\r\n\r\nalert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit);\r\n```\r\n\r\n## 重载\r\n>重载的意义在于告诉我们传入不同的参数，得到不同的结果。\r\n\r\n```ts\r\n\r\n\r\n## 类型断言\r\n>类型断言类似于其他语言中的类型转换。\r\n\r\n**尖括号语法**\r\n```ts\r\nlet someValue: any = \"this is a string\";\r\n\r\nlet strLength: number = (<string>someValue).length;\r\n```\r\n\r\n**as语法**\r\n```ts\r\nlet someValue: any = \"this is a string\";\r\n\r\nlet strLength: number = (someValue as string).length;\r\n```\r\n\r\n**推荐使用as语法，因为如果你使用JSX的时候，只有as语法是被允许的。**\r\n\r\n## 欢迎大家关注我的专栏，一起学习TypeScript!"
    },
    {
      "id": "/如何排查是哪个插件影响了我们的CSS样式？",
      "metadata": {
        "permalink": "/blog/如何排查是哪个插件影响了我们的CSS样式？",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/如何排查是哪个插件影响了我们的CSS样式？.md",
        "source": "@site/blog\\如何排查是哪个插件影响了我们的CSS样式？.md",
        "title": "如何排查是哪个插件影响了我们的CSS样式？",
        "description": "问题描述",
        "date": "2021-07-21T00:00:00.000Z",
        "formattedDate": "2021年7月21日",
        "tags": [
          {
            "label": "debug",
            "permalink": "/blog/tags/debug"
          }
        ],
        "readingTime": 0.86,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "如何排查是哪个插件影响了我们的CSS样式？",
          "date": "2021-7-21",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "debug",
          "tags": [
            "debug"
          ]
        },
        "prevItem": {
          "title": "TypeScript的类型注解--(TypeScript 02)",
          "permalink": "/blog/TypeScript的类型注解--(TypeScript 02)"
        },
        "nextItem": {
          "title": "LeetCode——字符串相加（JS实现）",
          "permalink": "/blog/LeetCode——字符串相加（JS实现）"
        }
      },
      "content": "## 问题描述\r\n>今天在学习Flex布局的时候，首先定义了一个div盒子，但是页面竟然出现了三个div盒子，我首先想到可能是浏览器插件对样式进行了修改，后来果然是这样。\r\n\r\n## 排查方法\r\n1. 首先打开浏览器的网络页面。\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/3bffc9ab5fd2d197df76bd04c913cb48.png)\r\n\r\n2. 清空所有的请求。\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/78de53b524517c65c5b3ca446d457a46.png)\r\n\r\n3. 刷新页面。\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/b71834bc2e87aefd74eb3687e15ccfa9.png)\r\n\r\n4. 任意点击一个非本地的请求，从Request URL中判断是哪个插件的请求。\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/7bfdf42d171e300fbbd098a4fc29a665.png)\r\n\r\n## 排查结果\r\n>### 原来是SurfingKeys这个插件修改了我们的样式，我们只需将该插件设置为点击时使用，即可恢复原状。"
    },
    {
      "id": "/LeetCode——字符串相加（JS实现）",
      "metadata": {
        "permalink": "/blog/LeetCode——字符串相加（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——字符串相加（JS实现）.md",
        "source": "@site/blog\\LeetCode——字符串相加（JS实现）.md",
        "title": "LeetCode——字符串相加（JS实现）",
        "description": "题目描述",
        "date": "2021-07-20T00:00:00.000Z",
        "formattedDate": "2021年7月20日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.555,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "LeetCode——字符串相加（JS实现）",
          "date": "2021-7-20",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "如何排查是哪个插件影响了我们的CSS样式？",
          "permalink": "/blog/如何排查是哪个插件影响了我们的CSS样式？"
        },
        "nextItem": {
          "title": "TypeScript介绍--(TypeScript 01)",
          "permalink": "/blog/TypeScript介绍--(TypeScript 01)"
        }
      },
      "content": "## 题目描述\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/f80a005521c14d999cd8f45cf5d5d9fe.png)\r\n\r\n## 解题思路\r\n>由于本题不让使用BigInt等将字符串转换为整数形式，所以我们必须考虑使用其他的方法。所以本题考虑采用双指针的方法。\r\n\r\n1. 使用两个指针分别指向数字字符串的末尾位置。\r\n2. 使用变量carry记录进位。\r\n3. 当两个记录下标的位置大于等于0，或者进位不等于零的时候都进入循环。\r\n4. 在循环中当使用charAt这个API获取字符串对应下标的字符，两个字符相减会变成number类型。\r\n5. 每次循环结束都将两个指针左移一位。\r\n\r\n## 解题代码\r\n```js\r\nvar addStrings = function(num1, num2) {\r\n    \r\n    let l = num1.length - 1;\r\n    let r = num2.length - 1;\r\n    let carry = 0;\r\n    let ans = [];\r\n    while (l >= 0 || r >= 0 || carry !== 0) {\r\n\r\n        let c1 = l >= 0 ? num1.charAt(l) - '0' : 0;\r\n        let c2 = r >= 0 ? num2.charAt(r) - '0' : 0;\r\n        let sum = c1 + c2 +  carry;\r\n        ans.push(sum % 10);\r\n        carry = Math.floor(sum / 10);\r\n        l--;\r\n        r--;\r\n    }\r\n    return ans.reverse().join('')\r\n};\r\n```\r\n\r\n## 题目反思\r\n1. 两个数字字符相减会转换为number类型。\r\n2. 可以使用  字符串.charAt(index) 来获取字符串指定位置的字符。"
    },
    {
      "id": "/TypeScript介绍--(TypeScript 01)",
      "metadata": {
        "permalink": "/blog/TypeScript介绍--(TypeScript 01)",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/TypeScript介绍--(TypeScript 01).md",
        "source": "@site/blog\\TypeScript介绍--(TypeScript 01).md",
        "title": "TypeScript介绍--(TypeScript 01)",
        "description": "TypeScript的五个特点",
        "date": "2021-07-20T00:00:00.000Z",
        "formattedDate": "2021年7月20日",
        "tags": [
          {
            "label": "TypeScript",
            "permalink": "/blog/tags/type-script"
          }
        ],
        "readingTime": 0.985,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "TypeScript介绍--(TypeScript 01)",
          "date": "2021-7-20",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "TypeScript",
          "tags": [
            "TypeScript"
          ]
        },
        "prevItem": {
          "title": "LeetCode——字符串相加（JS实现）",
          "permalink": "/blog/LeetCode——字符串相加（JS实现）"
        },
        "nextItem": {
          "title": "这一次，彻底搞懂React生命周期",
          "permalink": "/blog/这一次，彻底搞懂React生命周期"
        }
      },
      "content": "## TypeScript的五个特点\r\n1. TS是由微软开发的开源编程语言。\r\n2. TS是JS的超集。（所谓的超集是指兼容了所有的特性）\r\n3. TS是开发大型应用的基石。\r\n4. TS提供了更加丰富的语法提示。\r\n5. TS在编写阶段能够检查错误。\r\n\r\n## 全局安装TS\r\n```\r\nnpm install typescript -g\r\n```\r\n\r\n## 将TS文件编译为JS文件\r\n```\r\ntsc index.ts\r\n```\r\n\r\n## 为什么说TS是静态类型，JS是动态类型？\r\n>在JS中给一个字符串变量赋值为number是可以的，但是在TS中则不行，这可以理解为为什么说TS是静态的，JS是动态的。可以理解为TS中类型是一旦确定下来无法更改，JS则不是。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/7eae35ed35d7d9cefc59bab3c1cca360.png)"
    },
    {
      "id": "/这一次，彻底搞懂React生命周期",
      "metadata": {
        "permalink": "/blog/这一次，彻底搞懂React生命周期",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/这一次，彻底搞懂React生命周期.md",
        "source": "@site/blog\\这一次，彻底搞懂React生命周期.md",
        "title": "这一次，彻底搞懂React生命周期",
        "description": "本文采用总分总的结构，首先给出React生命周期流程图，让大家知道我们的研究目标是什么，第二部分则分别对React生命周期中的重点难点的生命钩子函数进行介绍。第三部分给出React生命周期的总结。",
        "date": "2021-07-20T00:00:00.000Z",
        "formattedDate": "2021年7月20日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 3.785,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "这一次，彻底搞懂React生命周期",
          "date": "2021-7-20",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "TypeScript介绍--(TypeScript 01)",
          "permalink": "/blog/TypeScript介绍--(TypeScript 01)"
        },
        "nextItem": {
          "title": "React中的setState更新state是同步还是异步的？",
          "permalink": "/blog/React中的setState更新state是同步还是异步的？"
        }
      },
      "content": ">本文采用总分总的结构，首先给出React生命周期流程图，让大家知道我们的研究目标是什么，第二部分则分别对React生命周期中的重点难点的生命钩子函数进行介绍。第三部分给出React生命周期的总结。\r\n\r\n# React生命周期流程图\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/9ea61e1d763dbedca737486f3502e764.png)\r\n\r\n## 1. getDerivedStateFromProps(props, state)\r\n>官方解释：调用这个钩子函数，会使得state在任何时候的状态值都取决于props.\r\n\r\n### 这个函数是静态的，所以前面要加static.\r\n### 返回的是什么？\r\n>返回的应该是状态对象（或者null）,总之返回的应该是一个对象，如果你什么都不返回，会出现警告。**这个返回的对象就是render要渲染的state**\r\n\r\n### 接收的是什么？\r\n>接收两个参数，一个是最新的props，一个是最新的state.\r\n\r\n### [codeSandBox在线演示](https://codesandbox.io/s/reactzhonggetderivedstatefromprops-qzmmq?file=/src/index.js)\r\n\r\n---\r\n## 2. shouldComponentUpdate(nextProps, nextState)\r\n### 接收的是什么？\r\n>接收两个参数，一个是最新的但是还未render的props，另一个则是最新的但是还未render的state.\r\n\r\n### 返回的是什么？\r\n>返回的是布尔值，返回true则让当前组件进行更新，返回false则让当前组件不更新。\r\n\r\n### [codeSandBox在线演示](https://codesandbox.io/s/reactzhongshouldcomponentupdatedeyongfa-9v08q?file=/src/index.js)\r\n\r\n---\r\n\r\n## 3. componentDidMount\r\n### 接受的是什么？\r\n>这个生命周期钩子函数是在挂载的最后阶段调用，并未接收参数。\r\n### 可以在这个钩子函数中处理组件挂载后的一些操作。\r\n\r\n## 4. getSnapshotBeforeUpdate(preProps,preState)\r\n### 接收的是什么？\r\n>接收两个参数，一个是之前的props，一个是之前的state.\r\n\r\n### 返回的是什么？\r\n>在这个生命周期钩子函数中，记录了更新DOM之前的一些HTML属性，返回的值，会被componentDidUpdate的第三个参数接收。\r\n\r\n### [codeSandBox在线演示（新闻滚动条案例）](https://codesandbox.io/s/getsnapshotbeforeupdateyingyongxinwengundongtiaoanli-ryvlw)\r\n\r\n## 5. componentDidUpdate(prevProps, prevState, snapshot)\r\n### 接收的是什么？\r\n>接收的是之前的props和之前的state，这个state是滞后与DOM的，同时第三个参数是接收的getSnapshotBeforeUpdate传来的参数。\r\n\r\n### 返回的是什么？\r\n>并不会返回什么，但是可以在此处进行更新后的对比，并对DOM进行操作，或者发起网络请求。\r\n\r\n## 6. componentWillUnmount()\r\n>该生命周期函数会在组件卸载之前调用，在这个方法中可以进行清除定时器等操作。在这个生命周期钩子函数中不应调用setState，因为如果这样组件将永远不会重新渲染。\r\n\r\n## 7. forceUpdate(callback)\r\n>该生命周期函数不用更改state或props也能对组件进行更新，调用render，且不用通过shouldComponentUpdate这个钩子。\r\n\r\n### [codeSandBox在线演示](https://codesandbox.io/s/reactzhiforceupdatedeshiyong-nfb8r?file=/index.html)\r\n\r\n## 总结生命周期\r\n>React生命周期最关键的是要记住每一个生命周期钩子函数接收的是什么？返回的是什么？在什么阶段调用，这是核心也是关键，最后一定要熟记流程图！"
    },
    {
      "id": "/React中的setState更新state是同步还是异步的？",
      "metadata": {
        "permalink": "/blog/React中的setState更新state是同步还是异步的？",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React中的setState更新state是同步还是异步的？.md",
        "source": "@site/blog\\React中的setState更新state是同步还是异步的？.md",
        "title": "React中的setState更新state是同步还是异步的？",
        "description": "问题引入",
        "date": "2021-07-19T00:00:00.000Z",
        "formattedDate": "2021年7月19日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 8.835,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "React中的setState更新state是同步还是异步的？",
          "date": "2021-7-19",
          "author": "Justin",
          "top": true,
          "cover": true,
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "这一次，彻底搞懂React生命周期",
          "permalink": "/blog/这一次，彻底搞懂React生命周期"
        },
        "nextItem": {
          "title": "React之PureComponent的用法",
          "permalink": "/blog/React之PureComponent的用法"
        }
      },
      "content": "## 问题引入\r\n>React中的setState是用来更新状态的重要工具，但是setState是同步的还是异步的，需要我们进行一定的探讨，接下来让我们好好研究研究。\r\n\r\n## 使用setState的两种形式\r\n1. 函数形式的setState\r\n```js\r\ntest1 = () => {\r\n        // 函数形式的setState,函数形式的setState能够接收到两个参数，一个是state，另一个是props\r\n        this.setState(state => ({count: state.count + 1}))\r\n    }\r\n```\r\n\r\n2. 对象形式的setState\r\n```js\r\ntest2 = () => {\r\n        // 对象形式的setState\r\n        const count = this.state.count + 1;\r\n        this.setState({count})\r\n    }\r\n```\r\n\r\n## 使用过setState之后能否立即获取到状态更新后的值\r\n>答案是不能。\r\n\r\n```js\r\ntest1 = () => {\r\n        // 函数形式的setState,函数形式的setState能够接收到两个参数，一个是state，另一个是props\r\n        this.setState(state => ({count: state.count + 1}))\r\n        console.log('函数形式的setState更新后：',this.state.count);\r\n    }\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/78dd77a5aa0a67baf75f69112f7cd8b8.png)\r\n\r\n## 如何立即获取到状态更新后的值\r\n>使用setState的第二个参数，这个参数接收的是一个回调函数，这个回调函数会在界面渲染之后调用。\r\n\r\n```js\r\ntest3 = () => {\r\n        this.setState(state => ({count: state.count + 1}),() => {\r\n            console.log('函数形式的setState更新后：',this.state.count);\r\n        });\r\n    }\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/6f0b820c172c3d308877763f1da3e274.png)\r\n\r\n## setState()更新状态是同步还是异步的？\r\n>回到我们要探讨的正题，setState()更新状态时同步的还是异步的？\r\n\r\n**判断setState()更新状态时异步还是同步的，主要是看执行setState的位置**\r\n\r\n1. 在React控制的回调函数中（生命周期钩子，react事件监听回调）这种情况是异步的。\r\n2. 在非react控制的异步回调函数中（定时器回调/原生事件监听回调/promise回调）这种情况是同步的。\r\n\r\n### 异步举例\r\n\r\n* 在React事件回调函数中使用setState(异步的)\r\n```js\r\n// React事件回调函数中\r\nupdate1 = () => {\r\n    console.log('React事件回调函数更新之前：',this.state.count);\r\n    this.setState(state => ({count: state.count + 1}))\r\n    console.log('React事件回调函数更新之后：',this.state.count);\r\n}\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/4280e7af6888177abc7a060f94229ab3.png)\r\n\r\n* 在生命周期钩子函数中使用setState(异步的)\r\n```js\r\n// 在生命周期钩子函数中\r\ncomponentDidMount() {\r\n    console.log('生命周期钩子函数更新之前：',this.state.count);\r\n    this.setState(state => ({count: state.count + 1}))\r\n    console.log('生命周期钩子函数更新之后：',this.state.count);\r\n}\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/87e8a0af7fa8ad795469686d5437eb97.png)\r\n\r\n### 同步举例\r\n* setTimeout\r\n```js\r\n// 定时器回调\r\nupdate2 = () => {\r\n    setTimeout(() => {\r\n        console.log('setTimeout 更新之前：', this.state.count);\r\n        this.setState(state => ({ count: state.count + 1 }))\r\n        console.log('setTimeout 更新之后：', this.state.count);\r\n    })\r\n}\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/65894a301b2694840dfbf379c7ea6988.png)\r\n\r\n* 原生onclick\r\n```js\r\nupdate3 = () => {\r\n    const h1 = this.refs.count;\r\n    h1.onclick = () => {\r\n        console.log('onclick 更新之前：', this.state.count);\r\n        this.setState(state => ({ count: state.count + 1 }))\r\n        console.log('onclick 更新之后：', this.state.count);\r\n    }\r\n}\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/f0fdca44083e264dc490332a5ad9a669.png)\r\n\r\n* Promise\r\n```js\r\nupdate4 = () => {\r\n    Promise.resolve().then(value => {\r\n        console.log('Promise 更新之前：', this.state.count);\r\n        this.setState(state => ({ count: state.count + 1 }))\r\n        console.log('Promise 更新之后：', this.state.count);\r\n    })\r\n}\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/5cdb8340d2c2f94a222b177cd10f542d.png)\r\n\r\n## setState多次调用的问题\r\n>下面要讨论的多次调用的问题是基于异步的前提下来讨论的。\r\n\r\n### 情况1：两个函数式setState的情况（不会合并）\r\n```js\r\n// 测试函数式 setState合并 与更新的问题\r\nupdate5 = () => {\r\n    console.log('测试通过函数式更新setState的合并问题 更新之前：', this.state.count);\r\n    this.setState(state => ({ count: state.count + 1 }))\r\n    console.log('测试通过函数式更新setState的合并问题 更新之后：', this.state.count);\r\n    console.log('测试通过函数式更新setState的合并问题 更新之前：', this.state.count);\r\n    this.setState(state => ({ count: state.count + 1 }))\r\n    console.log('测试通过函数式更新setState的合并问题 更新之后：', this.state.count);\r\n}\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/57dfbe0ad19ee329af054a7f1c1c2daa.png)\r\n\r\n### 情况2：两个对象式setState的情况（会合并）\r\n```js\r\n// 测试对象式 setState合并 与更新的问题\r\nupdate6 = () => {\r\n    console.log('测试通过对象式更新setState的合并问题 更新之前：', this.state.count);\r\n    this.setState({count: this.state.count + 1})\r\n    console.log('测试通过对象式更新setState的合并问题 更新之后：', this.state.count);\r\n    console.log('测试通过对象式更新setState的合并问题 更新之前：', this.state.count);\r\n    this.setState({count: this.state.count + 1})\r\n    console.log('测试通过对象式更新setState的合并问题 更新之后：', this.state.count);\r\n}\r\n```\r\n### 情况3：先函数式后对象式（会合并）\r\n```js\r\nupdate7 = () => {\r\n    console.log('测试通过函数式更新setState的合并问题 更新之前：', this.state.count);\r\n    this.setState(state => ({ count: state.count + 1 }))\r\n    console.log('测试通过函数式更新setState的合并问题 更新之后：', this.state.count);\r\n    console.log('测试通过对象式更新setState的合并问题 更新之前：', this.state.count);\r\n    this.setState({count: this.state.count + 1})\r\n    console.log('测试通过对象式更新setState的合并问题 更新之后：', this.state.count);\r\n}\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/817c7527e7b9fa81bd5e813b960aaf7c.png)\r\n\r\n### 情况4：先对象式后函数式\r\n```js\r\nupdate7 = () => {\r\n    console.log('测试通过对象式更新setState的合并问题 更新之前：', this.state.count);\r\n    this.setState({count: this.state.count + 1})\r\n    console.log('测试通过对象式更新setState的合并问题 更新之后：', this.state.count);\r\n    console.log('测试通过函数式更新setState的合并问题 更新之前：', this.state.count);\r\n    this.setState(state => ({ count: state.count + 1 }))\r\n    console.log('测试通过函数式更新setState的合并问题 更新之后：', this.state.count);\r\n}\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/64ea64cff48fab36e9565fa169c032c1.png)\r\n>### 核心技巧：函数式传入的state总是能够获取到最新的state,但是对象式则不能，但是最后render只会更新一次。\r\n\r\n## 一道经典的setState的面试题（看懂这个，你可能就懂了！）\r\n**请问下面的APP组件打印的是什么？**\r\n\r\n```js\r\nclass App extends Component {\r\n    state = {\r\n        count: 0\r\n    }\r\n    // 在生命周期钩子函数中\r\n    componentDidMount() {\r\n        this.setState({ count: this.state.count + 1 })\r\n        this.setState({ count: this.state.count + 1 })\r\n        console.log(this.state.count);\r\n\r\n        this.setState(state => ({ count: state.count + 1 }))\r\n        this.setState(state => ({ count: state.count + 1 }))\r\n        console.log(this.state.count);\r\n\r\n        setTimeout(() => {\r\n            this.setState(state => ({ count: state.count + 1 }))\r\n            console.log('setTimeout:', this.state.count);\r\n\r\n            this.setState(state => ({ count: state.count + 1 }))\r\n            console.log('setTimeout:', this.state.count);\r\n        }, 0)\r\n        Promise.resolve().then(value => {\r\n            this.setState(state => ({ count: state.count + 1 }))\r\n            console.log('Promise',this.state.count);\r\n            this.setState(state => ({ count: state.count + 1 }))\r\n            console.log('Promise:',this.state.count);\r\n        })\r\n    }\r\n\r\n    render() {\r\n        const { count } = this.state;\r\n        console.log('render: ', count);\r\n        return (\r\n            <div>\r\n                <h1>当前求和为{count}</h1>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n```\r\n\r\n### 答案\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/3263ee2352ed9f60b04038eef651c584.png)\r\n\r\n### 答案解析（按输出顺序进行解析）\r\n1. 第一行： react首先会渲染下组件，此时获取到的count值是state中存的初始值，所以是0.\r\n2. 第2、3行：执行完render之后，会进入componentDidMount钩子函数，遇到两个对象式的setState会进行合并，但由于此时在钩子函数中，获取state是异步的，所以打印的都是0，但是当遇到函数式的setState，则不会合并，此时count的值已经变为了3.\r\n3. 第四行：此时componentDidMount中出了Promise和setTimeout外都执行了，上面的代码对JS来说都属于同步代码，此时可以进行更新render了，所以打印了render 3.\r\n4. 第五行：setTimeout和Promise中，由于Promise是微任务，所以优先执行，在执行的时候，这里的setState是同步更新state的，所以调用一次setState就要调用一次render,所以第五行打印的是render: 4.\r\n5. 第六行：执行log操作，打印的是Promise: 4。。。\r\n\r\n**剩下的内容均属于JS事件循环的知识了，如果你有不懂的地方可以参考我的专栏中的事件循环机制的基本认知这篇博文。**\r\n\r\n### [codeSandBox](https://codesandbox.io/s/yidaoguanyusetstatedejingdianmianshiti-fm4j6)"
    },
    {
      "id": "/React之PureComponent的用法",
      "metadata": {
        "permalink": "/blog/React之PureComponent的用法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React之PureComponent的用法.md",
        "source": "@site/blog\\React之PureComponent的用法.md",
        "title": "React之PureComponent的用法",
        "description": "PureComponent有什么用？",
        "date": "2021-07-19T00:00:00.000Z",
        "formattedDate": "2021年7月19日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 1.235,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "React之PureComponent的用法",
          "date": "2021-7-19",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React中的setState更新state是同步还是异步的？",
          "permalink": "/blog/React中的setState更新state是同步还是异步的？"
        },
        "nextItem": {
          "title": "React之shouldComponentUpdate的用法",
          "permalink": "/blog/React之shouldComponentUpdate的用法"
        }
      },
      "content": "## PureComponent有什么用？\r\n>一般组件的shouldComponentUpdate默认返回的是true,但是一旦父组件及时状态或props没有变化，也会造成子组件的render调用，这是很不合理的，我们可以让子组件继承自PureComponent来解决这个问题。\r\n\r\n## PureComponent的基本原理\r\n1. 重写了shouldComponentUpdate方法。\r\n2. 对组件的新/旧 state和props中的数据进行浅比较，如果没有变化则返回false，反之返回true.\r\n\r\n## PureComponent用法实例\r\n```js\r\nimport React, { Component,PureComponent } from 'react'\r\nimport ReactDOM from 'react-dom'\r\n\r\n\r\nclass App extends Component {\r\n    state = {\r\n        m1: 1\r\n    }\r\n    \r\n    test1 = () => {\r\n        this.setState(state => ({\r\n            m1: state.m1 + 1\r\n        }))\r\n        // this.setState({})\r\n    }\r\n    render() {\r\n        console.log('调用了A render: ');\r\n        return (\r\n            <div>\r\n                <h1>A组件：m1={this.state.m1}</h1>\r\n                <button onClick={this.test1}>A 测试1</button>\r\n                <B m1={this.state.m1}/>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nclass B extends PureComponent {\r\n    state = {\r\n        m2: 1\r\n    }\r\n    \r\n    test2 = () => {\r\n        this.setState({})\r\n    }\r\n    render() {\r\n        console.log('调用了 B render: ');\r\n        return (\r\n            <div>\r\n                <h1>B组件：m2={this.state.m2}, m1={this.props.m1}</h1>\r\n                <button onClick={this.test2}>B 测试2</button>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nReactDOM.render(<App />, document.querySelector('#root'));\r\n```\r\n>### [codeSandBox在线演示](https://codesandbox.io/s/reactzhongpurecomponent-ycetr?file=/src/index.js)"
    },
    {
      "id": "/React之shouldComponentUpdate的用法",
      "metadata": {
        "permalink": "/blog/React之shouldComponentUpdate的用法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React之shouldComponentUpdate的用法.md",
        "source": "@site/blog\\React之shouldComponentUpdate的用法.md",
        "title": "React之shouldComponentUpdate的用法",
        "description": "为什么要使用shouldComponentUpdate?",
        "date": "2021-07-19T00:00:00.000Z",
        "formattedDate": "2021年7月19日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.825,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "React之shouldComponentUpdate的用法",
          "date": "2021-7-19",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React之PureComponent的用法",
          "permalink": "/blog/React之PureComponent的用法"
        },
        "nextItem": {
          "title": "这一次彻底搞懂JS中的防抖和节流",
          "permalink": "/blog/这一次彻底搞懂JS中的防抖和节流"
        }
      },
      "content": "## 为什么要使用shouldComponentUpdate?\r\n>只要是组件继承自React.Component就会存在当父组件重新render的时候，子组件也会重新执行render,即使这个子组件没有任何变化。子组件只要调用setState就会重新执行render,及时setState的参数是一个空对象。\r\n\r\n\r\n## shouldComponentUpdate的用法\r\n**在子组件中：**\r\n```js\r\nshouldComponentUpdate(nextProps,nextState) {\r\n    if (nextProps.m1 === this.props.m1 && nextState.m2 === this.state.m2) {\r\n        return false;\r\n    } else {\r\n        return true;\r\n    }\r\n}\r\n```\r\n\r\n>根据下面的React生命周期流程图可知，当shouldComponentUpdate返回为true的时候，当前组件进行render，如果返回的是false则不进行render.\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/66a7f53b2d64bfc5357631bcb108a359.png)\r\n\r\n### [codeSandBox在线演示](https://codesandbox.io/s/reactzhongshouldcomponentupdatedeyongfa-9v08q?file=/src/index.js)"
    },
    {
      "id": "/这一次彻底搞懂JS中的防抖和节流",
      "metadata": {
        "permalink": "/blog/这一次彻底搞懂JS中的防抖和节流",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/这一次彻底搞懂JS中的防抖和节流.md",
        "source": "@site/blog\\这一次彻底搞懂JS中的防抖和节流.md",
        "title": "这一次彻底搞懂JS中的防抖和节流",
        "description": "什么是防抖？",
        "date": "2021-07-19T00:00:00.000Z",
        "formattedDate": "2021年7月19日",
        "tags": [
          {
            "label": "JavaScript基础",
            "permalink": "/blog/tags/java-script基础"
          }
        ],
        "readingTime": 3.795,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "这一次彻底搞懂JS中的防抖和节流",
          "date": "2021-7-19",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "JavaScript基础",
          "tags": [
            "JavaScript基础"
          ]
        },
        "prevItem": {
          "title": "React之shouldComponentUpdate的用法",
          "permalink": "/blog/React之shouldComponentUpdate的用法"
        },
        "nextItem": {
          "title": "HOT100——搜索旋转排序数组（JS实现）",
          "permalink": "/blog/HOT100——搜索旋转排序数组（JS实现）"
        }
      },
      "content": "## 什么是防抖？\r\n>通过setTimeout的方式，在一定的时间间隔内，将多次触发变成一次触发。（通俗的说是在最后一次点击间隔规定时间之后才能再次成功触发，否则触发不成功）\r\n\r\n## 防抖的实现思路\r\n1. 在防抖函数返回的函数的上级作用域设置一个定时器变量t置为null;\r\n2. 通过t来判断是否是第一次执行。\r\n3. 如果不是第一次执行，清空定时器\r\n4. 如果是第一次执行，则通过apply(this,arguments)进行执行.\r\n5. 最后设置定时器，规定时间之后将t设置为null,使得间隔时间之后t为null，间隔时间之后的点击变为第一次点击。\r\n\r\n## 防抖实现代码（立即执行版）\r\n```js\r\nconst btn = document.querySelector('#input');\r\n\r\nbtn.addEventListener('click',debounce(submit,3000),false);\r\n\r\nfunction submit(e) {\r\n    console.log(1);\r\n}\r\n// 防抖函数：最后一次点击之后，3秒之内的点击都无效\r\nfunction debounce(fn,timer) {\r\n    let t = null;\r\n    return function() {\r\n        // 判断是否是第一次执行\r\n        let firstClick = !t;\r\n        // 如果不是第一次执行，则清空延时  之所以要清空延时就是要防止前面的定时器对最新的定时器产生影响，\r\n        if (t) { clearTimeout(t)};\r\n        // 如果是第一次执行则直接执行\r\n        if (firstClick) {\r\n            fn.apply(this,arguments)\r\n        }\r\n        // 在第一次点击之后 间隔的规定时间之后，才将t置为null 为下一次第一次点击做准备\r\n        t = setTimeout(() => {\r\n            t = null;                    \r\n        },timer)\r\n    }\r\n}\r\n```\r\n>### [codeSandBox在线演示](https://codesandbox.io/s/shouxiefangdouhanshu-8mf22?file=/index.html)\r\n\r\n## 防抖实现代码（延迟执行版）\r\n```js\r\nfunction debounce(fn,time) {\r\n    let t = null;\r\n    return function() {\r\n        clearTimeout(t);\r\n        t = setTimeout(() => {\r\n            fn.apply(this,arguments);\r\n        },time)\r\n    }\r\n}\r\n```\r\n\r\n-------\r\n## 什么是节流？\r\n>节流指的是减少一段时间内的触发频率。只有在上一次成功触发间隔规定时间之后，才能再次触发。\r\n\r\n## 节流的实现思路\r\n1. 在返回函数的上级作用域定义一个初始时间值begin = 0;\r\n2. 获取当前时间戳，如果(当前时间戳 - 初始值 > 规定时间间隔)则通过apply修改this指向并传参;\r\n3. 修改初始值为当前值;\r\n\r\n## 节流实现代码\r\n```js\r\nconst btn = document.querySelector('#input');\r\n\r\nbtn.addEventListener('click',throttle(submit,2000),false);\r\n\r\nfunction submit(e) {\r\n    console.log(1);\r\n}\r\n// 节流函数：减少一段时间的触发频率，只有在上一次成功触发 间隔规定时间之后才能再次成功触发。\r\n\r\nfunction throttle(fn,delay) {\r\n    let begin = 0;\r\n    return function() {\r\n        let cur = new Date().getTime();\r\n\r\n        if (cur - begin > delay) {\r\n            fn.apply(this,arguments);\r\n            begin = cur;\r\n        }\r\n    }\r\n}\r\n```\r\n>### [codeSandBox在线演示](https://codesandbox.io/s/shouxiejieliuhanshu-645r1?file=/index.html)\r\n\r\n## 节流与防抖的区别是什么？\r\n1. 防抖只在最后一次成功点击之后间隔规定时间之后才能再次成功触发，如果在时间间隔之内就被点击，需要重新间隔时间间隔才能点击。\r\n2. 节流则不同，节流只要在上一次成功触发规定时间之后点击就能再次触发，中间的触发不会产生影响。"
    },
    {
      "id": "/HOT100——搜索旋转排序数组（JS实现）",
      "metadata": {
        "permalink": "/blog/HOT100——搜索旋转排序数组（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/HOT100——搜索旋转排序数组（JS实现）.md",
        "source": "@site/blog\\HOT100——搜索旋转排序数组（JS实现）.md",
        "title": "HOT100——搜索旋转排序数组（JS实现）",
        "description": "题目描述",
        "date": "2021-07-18T00:00:00.000Z",
        "formattedDate": "2021年7月18日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.45,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "HOT100——搜索旋转排序数组（JS实现）",
          "date": "2021-7-18",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "这一次彻底搞懂JS中的防抖和节流",
          "permalink": "/blog/这一次彻底搞懂JS中的防抖和节流"
        },
        "nextItem": {
          "title": "凯撒密码（FreeCodeCamp）",
          "permalink": "/blog/凯撒密码（FreeCodeCamp）"
        }
      },
      "content": "## 题目描述\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/f8c165422e830abf11255a6f14e35435.png)\r\n\r\n## 解题思路\r\n>**本题最核心的在于寻找峰值，所谓的峰值指的是该值比左边元素大，该值比右边元素也大，然后根据峰值分割数组，判断target是在数组的左边还是右边，然后使用indexOf判断位置，最后返回。**\r\n\r\n## 解题代码\r\n```js\r\nvar search = function (nums, target) {\r\n    let left = 0;\r\n    let right = nums.length - 1;\r\n    let mid = left + right >>> 1;\r\n    // 开始寻找中位数\r\n    if (nums.length > 2) {\r\n        for (let i = 1; i < nums.length; i++) {\r\n            if (nums[i] > nums[i-1] && nums[i] > nums[i+1]) {\r\n                mid = i;\r\n                break;\r\n            }\r\n            if (nums[i] < nums[i-1] && nums[i] < nums[i+1]) {\r\n                mid = i-1;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    mid\r\n    if (target < nums[mid]) {\r\n        // nums.slice(mid)\r\n        if (target < nums[0] && target <= nums[nums.length - 1]) {\r\n            if (nums.slice(mid).indexOf(target) !== -1) {\r\n                const temp = nums.slice(mid);\r\n                return temp.indexOf(target) + mid\r\n            } else {\r\n                return -1;\r\n            }\r\n        } else {\r\n            const temp = nums.slice(0, mid);\r\n            return temp.indexOf(target)\r\n        }\r\n    } else if (target === nums[mid]) {\r\n        return mid;\r\n    } else {\r\n        if (target > nums[0] && target <= nums[nums.length - 1]) {\r\n            if (nums.slice(mid).indexOf(target) !== -1) {\r\n                const temp = nums.slice(mid);\r\n                return temp.indexOf(target) + mid\r\n            } else {\r\n                return -1;\r\n            }\r\n        } else {\r\n            return -1\r\n        }\r\n    }\r\n};\r\n```\r\n## 启示\r\n* 学会通过位运算的方式求中位数。\r\n* 学会求峰值。"
    },
    {
      "id": "/凯撒密码（FreeCodeCamp）",
      "metadata": {
        "permalink": "/blog/凯撒密码（FreeCodeCamp）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/凯撒密码（FreeCodeCamp）.md",
        "source": "@site/blog\\凯撒密码（FreeCodeCamp）.md",
        "title": "凯撒密码（FreeCodeCamp）",
        "description": "题目描述",
        "date": "2021-07-18T00:00:00.000Z",
        "formattedDate": "2021年7月18日",
        "tags": [
          {
            "label": "FreeCodeCamp",
            "permalink": "/blog/tags/free-code-camp"
          }
        ],
        "readingTime": 1.275,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "凯撒密码（FreeCodeCamp）",
          "date": "2021-7-18",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "FreeCodeCamp",
          "tags": [
            "FreeCodeCamp"
          ]
        },
        "prevItem": {
          "title": "HOT100——搜索旋转排序数组（JS实现）",
          "permalink": "/blog/HOT100——搜索旋转排序数组（JS实现）"
        },
        "nextItem": {
          "title": "手写快速排序（JavaScript）",
          "permalink": "/blog/手写快速排序（JavaScript）"
        }
      },
      "content": "## 题目描述\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/b538f1ac36756e10a871f9deec0e1cae.png)\r\n\r\n## 解题思路\r\n1. 首先遍历每一个字符。\r\n2. 通过charCodeAt()来判断字符的ASCII码值，如果该值在A-Z之间继续判断-13之后是否还在这个范围，如果还在这个范围直接通过charCodeAt()进行转换字符即可。\r\n3. 如果该值不在A-Z之间，直接进行拼接原字符即可。\r\n\r\n## 实现代码\r\n```js\r\nfunction rot13(str) {\r\n    let temp = '';\r\n    for (let v of str) {\r\n        if (v.charCodeAt() < 65 || v.charCodeAt() > 90) {\r\n            temp = temp + v\r\n        } else {\r\n            if (v.charCodeAt()-13 < 65) {\r\n                temp = temp + String.fromCharCode(91 - (65 - v.charCodeAt() + 13))\r\n            } else {\r\n                temp = temp + String.fromCharCode(v.charCodeAt()-13)\r\n            }\r\n        }\r\n    }\r\n    temp\r\n    return temp;\r\n}\r\n\r\nrot13(\"SERR CVMMN!\");\r\n```\r\n\r\n## 题目链接\r\n**[凯撒密码](https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/javascript-algorithms-and-data-structures-projects/caesars-cipher)**\r\n\r\n## 题目反思\r\n* 学会使用charCodeAt()将字符转换为对应的ASCII码值。\r\n* 学会使用fromCharCode将ASCII码值转换为对应的字符。\r\n* 学会使用new Map(数组)，来将一个数组转换为对应的Map,这样比一个一个的添加进Map要方便的多。"
    },
    {
      "id": "/手写快速排序（JavaScript）",
      "metadata": {
        "permalink": "/blog/手写快速排序（JavaScript）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/手写快速排序（JavaScript）.md",
        "source": "@site/blog\\手写快速排序（JavaScript）.md",
        "title": "手写快速排序（JavaScript）",
        "description": "实现思路",
        "date": "2021-07-18T00:00:00.000Z",
        "formattedDate": "2021年7月18日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 1.405,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "手写快速排序（JavaScript）",
          "date": "2021-7-18",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "凯撒密码（FreeCodeCamp）",
          "permalink": "/blog/凯撒密码（FreeCodeCamp）"
        },
        "nextItem": {
          "title": "手写call、apply和bind",
          "permalink": "/blog/手写call、apply和bind"
        }
      },
      "content": "## 实现思路\r\n* 快速排序是在实践中已知的最快的排序方法。\r\n* 快速排序采用了分治的思想，这也意味着在代码中需要用到递归。\r\n1. 选择A中的任意一个元素pivot,该元素作为基准。\r\n2. 将小于基准的元素移到基准左边，将大于基准的元素移动到基准的右边。\r\n3. A被pivot分为两部分，继续对剩下的两部分做同样的处理。\r\n4. 使用递归将上述的两部分继续进行同样的排序。\r\n\r\n## 实现代码\r\n>三个参数分别为，要排序的数组，数组的第一个下标，最后一个下标\r\n```js\r\nfunction Quick_Sort(nums,left,right) {\r\n\r\n    if (left >= right) return;\r\n    let pivot = nums[left];\r\n    let l = left;\r\n    let r = right;\r\n\r\n    while (l < r) {\r\n        while (l < r && nums[r] >= pivot) {\r\n            r--;\r\n        }\r\n        if (l < r) {\r\n            nums[l] = nums[r];\r\n        }\r\n        while (l < r && nums[l] <= pivot) {\r\n            l++;\r\n        }\r\n        if (l < r) {\r\n            nums[r] = nums[l];\r\n        }\r\n        if (l >= r) {\r\n            nums[l] = pivot;\r\n        }\r\n    }\r\n    Quick_Sort(nums,left,r-1);\r\n    Quick_Sort(nums,r+1,right);\r\n    nums\r\n}\r\n\r\nconst nums = [17,97,9,17,1,8];\r\nQuick_Sort(nums,0,5);\r\nnums\r\n```\r\n\r\n## 启示\r\n* 学会使用分治思想来求解问题。"
    },
    {
      "id": "/手写call、apply和bind",
      "metadata": {
        "permalink": "/blog/手写call、apply和bind",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/手写call、apply和bind.md",
        "source": "@site/blog\\手写call、apply和bind.md",
        "title": "手写call、apply和bind",
        "description": "1. 手写call",
        "date": "2021-07-17T00:00:00.000Z",
        "formattedDate": "2021年7月17日",
        "tags": [
          {
            "label": "JavaScript基础",
            "permalink": "/blog/tags/java-script基础"
          }
        ],
        "readingTime": 2.98,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "手写call、apply和bind",
          "date": "2021-7-17",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "JavaScript基础",
          "tags": [
            "JavaScript基础"
          ]
        },
        "prevItem": {
          "title": "手写快速排序（JavaScript）",
          "permalink": "/blog/手写快速排序（JavaScript）"
        },
        "nextItem": {
          "title": "Hexo部署到服务器后和本地出现CSS不一致的问题",
          "permalink": "/blog/Hexo部署到服务器后和本地出现CSS不一致的问题"
        }
      },
      "content": "## 1. 手写call\r\n**原生call具备的三个功能**\r\n\r\n1. 改变this指向。\r\n2. 调用call就是调用函数。（能够返回结果）\r\n\r\n**实现代码**\r\n```js\r\nfunction person(a,b,c) {\r\n    return {\r\n        name: this.name,\r\n        a: a,\r\n        b: b,\r\n        c: c\r\n    }\r\n}\r\n\r\nconst egg = {name: 'hello'};\r\n\r\nFunction.prototype.myCall = function(obj) {\r\n    obj = obj || window\r\n    obj.p = this;\r\n    const newArg = [];\r\n    for (let i = 1; i < arguments.length; i++) {\r\n        newArg.push(arguments[i]);\r\n    }\r\n    \r\n    const result = obj.p(...newArg);\r\n   \r\n    delete obj.p;\r\n    return result;\r\n}\r\n\r\nperson.myCall(egg,'点赞','收藏','转发')\r\nperson.call(egg,'点赞','收藏','转发')\r\n```\r\n\r\n## 2. 手写apply\r\n>apply和call很类似，区别在于apply只接受两个参数，一个是this的指向，另一个是是一个数组。\r\n\r\n**原生apply具备的几个功能**\r\n\r\n1. 改变this指向。\r\n2. 调用函数并接受返回值。\r\n\r\n**实现代码**\r\n```js\r\nfunction person(a,b,c) {\r\n    return {\r\n        name: this.name,\r\n        a: a,\r\n        b: b,\r\n        c: c\r\n    }\r\n}\r\n\r\nconst egg = {name: 'hello'};\r\n\r\nFunction.prototype.myApply = function(obj,arr) {\r\n    obj.p = this;\r\n    let result;\r\n    if (!arr) {\r\n        result = obj.p();\r\n    } else {\r\n        result = obj.p(...arr);\r\n    }\r\n\r\n    delete obj.p;\r\n    return result;\r\n}\r\n\r\nperson.myApply(egg,['点赞','收藏','转发'])\r\nperson.apply(egg,['点赞','收藏','转发'])\r\n```\r\n## 3. 手写bind\r\n**原生bind具备的功能**\r\n\r\n1. 会返回一个函数。（这个返回的函数应该是改变过this的，并且接受参数就能执行的）\r\n2. 会修改this指向。\r\n3. 原生bind方法返回的函数如果通过new创建实例的时候，会使得this失效。不调用new，this不会失效。\r\n\r\n**注意事项**\r\n\r\n5. arguments其实是对象，而不是数组。\r\n6. 使用Array.prototype.slice.call(arguments,1)：可以获取arguments包括第二个元素之后的所有元素，并将其装换为数组。\r\n7. 下面的题解涉及到了原型链的知识，值得我们多次反复揣摩。\r\n\r\n**实现代码**\r\n```js\r\nfunction person(a,b,c) {\r\n    console.log(this.name);\r\n    console.log(a,b,c);\r\n}\r\n\r\nconst egg = {name: 'hello'};\r\n\r\nFunction.prototype.myBind = function(obj) {\r\n    let that = this;\r\n    let arr = Array.prototype.slice.call(arguments,1);\r\n    // 定义一个空函数作为桥梁\r\n    let empty = function() {}\r\n    let newf = function () {\r\n        let arr2 = [].slice.call(arguments);\r\n        let arrSum = arr.concat(arr2);\r\n        // 判断是否调用了new\r\n        if (this instanceof empty) {\r\n            that.apply(this,arrSum);\r\n        } else {\r\n            that.apply(obj,arrSum);\r\n        }\r\n    }\r\n\r\n    empty.prototype = that.prototype;\r\n    newf.prototype = new empty;\r\n    return newf;\r\n}\r\n\r\nconst bibi = person.myBind(egg,'点赞','投币')\r\n// const b = new bibi('充电')\r\nbibi('充电')\r\n// person.apply(egg,['点赞','收藏','转发'])\r\n```\r\n* [CodeSandBox在线代码](https://codesandbox.io/s/shouxiebind-d1b5u)\r\n\r\n## 参考链接\r\n**[原生JavaScript实现call、apply和bind - Web前端工程师面试题讲解](https://www.bilibili.com/video/BV1m54y1q7hc?from=search&seid=17001305094652810245)**\r\n\r\n## 启示\r\n* 首先call、apply、bind看似简单，实则需要很强的基本功。\r\n* 本文需要多次反复阅读，揣摩，加油，希望多看几遍！"
    },
    {
      "id": "/Hexo部署到服务器后和本地出现CSS不一致的问题",
      "metadata": {
        "permalink": "/blog/Hexo部署到服务器后和本地出现CSS不一致的问题",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Hexo部署到服务器后和本地出现CSS不一致的问题.md",
        "source": "@site/blog\\Hexo部署到服务器后和本地出现CSS不一致的问题.md",
        "title": "Hexo部署到服务器后和本地出现CSS不一致的问题",
        "description": "问题描述",
        "date": "2021-07-15T00:00:00.000Z",
        "formattedDate": "2021年7月15日",
        "tags": [
          {
            "label": "hexo",
            "permalink": "/blog/tags/hexo"
          }
        ],
        "readingTime": 0.875,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "Hexo部署到服务器后和本地出现CSS不一致的问题",
          "date": "2021-7-15",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "hexo",
          "tags": [
            "hexo"
          ]
        },
        "prevItem": {
          "title": "手写call、apply和bind",
          "permalink": "/blog/手写call、apply和bind"
        },
        "nextItem": {
          "title": "使用Python对指定文件夹下的所有文件中的指定位置添加内容",
          "permalink": "/blog/使用Python对指定文件夹下的所有文件中的指定位置添加内容"
        }
      },
      "content": "## 问题描述\r\n>通过hexo s部署到本地，博客的title属性，显示的是20px，但是部署到服务器后显示的却是1.6rem,为什么会出现这样的情况，经过一上午的艰苦调试，终于解决了这个问题。\r\n\r\n## 问题原因\r\n**因为博客使用了阿里云全站加速，造成访问域名的时候，返回的都是阿里云缓存的内容，但是阿里云并不是每时每刻都会刷新缓存的，所以造成没有生效的假象。**\r\n\r\n## 解决办法\r\n* 在阿里云全站加速的控制面板中，对域名进行URL刷新、目录刷新等操作即可。"
    },
    {
      "id": "/使用Python对指定文件夹下的所有文件中的指定位置添加内容",
      "metadata": {
        "permalink": "/blog/使用Python对指定文件夹下的所有文件中的指定位置添加内容",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/使用Python对指定文件夹下的所有文件中的指定位置添加内容.md",
        "source": "@site/blog\\使用Python对指定文件夹下的所有文件中的指定位置添加内容.md",
        "title": "使用Python对指定文件夹下的所有文件中的指定位置添加内容",
        "description": "现在有一个文件夹，文件夹中有几百个markdown文件，我们想在每一个文件的第二行和第三行，分别添加date和title属性。",
        "date": "2021-07-14T00:00:00.000Z",
        "formattedDate": "2021年7月14日",
        "tags": [
          {
            "label": "python",
            "permalink": "/blog/tags/python"
          }
        ],
        "readingTime": 1.62,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "使用Python对指定文件夹下的所有文件中的指定位置添加内容",
          "date": "2021-7-14",
          "author": "Justin",
          "top": true,
          "cover": true,
          "categories": "python",
          "tags": [
            "python"
          ]
        },
        "prevItem": {
          "title": "Hexo部署到服务器后和本地出现CSS不一致的问题",
          "permalink": "/blog/Hexo部署到服务器后和本地出现CSS不一致的问题"
        },
        "nextItem": {
          "title": "HOT100——下一个排列（JS实现）",
          "permalink": "/blog/HOT100——下一个排列（JS实现）"
        }
      },
      "content": ">现在有一个文件夹，文件夹中有几百个markdown文件，我们想在每一个文件的第二行和第三行，分别添加date和title属性。\r\n\r\n## python如何读取markdown文件\r\n**我们只需使用open函数即可，但是在解码格式上年一定要采用UTF-8，否则会报错**\r\n\r\n## 如何获取文件的创建时间\r\n```py\r\nt = os.path.getmtime(filePath + '\\\\' + i)\r\n```\r\n\r\n## 如何得到文件指定行的内容(通过linecache这个包)\r\n```py\r\nimport linecache\r\ncategories_add = 'categories: ' + linecache.getline(filePath + '\\\\' + i, 5).strip()[2:]\r\n```\r\n\r\n## 全部代码\r\n```py\r\nimport os\r\nimport time\r\nimport linecache\r\nfilePath = 'G:\\HEXO\\添加文件名和时间\\\\test'\r\ndef TimeStampToTime(timestamp):\r\n    timeStruct = time.localtime(timestamp)\r\n    return time.strftime('%Y-%m-%d',timeStruct)\r\nfor i in os.listdir(filePath):\r\n    print(i)\r\n    t = os.path.getmtime(filePath + '\\\\' + i)\r\n    print(TimeStampToTime(t))\r\n    file = open(filePath + '\\\\' + i, \"r\",encoding='utf-8') \r\n\r\n    text = file.read()\r\n    # print(text)\r\n    content_add = i[:-3]\r\n    text_add = TimeStampToTime(t)\r\n    pointer = text.find(\"date:\")\r\n    pos = text.find(\"title:\")\r\n    \r\n    categories_add = 'categories: ' + linecache.getline(filePath + '\\\\' + i, 5).strip()[2:]\r\n    print(categories_add)\r\n    \r\n    if pointer != -1 & pos != -1:\r\n            # text = text[:pointer+6] + text_add  + text[pointer+6:]\r\n            # text = text[:pos+7] + content_add + text[pos+7:]\r\n            tagP = text.find(\"tags:\")\r\n            text = text[:tagP] + categories_add  + '\\n' + text[tagP:]\r\n\r\n            file = open(filePath + '\\\\' + i, \"w\",encoding='utf-8')\r\n            file.write(text)\r\n            file.close()\r\n    # 下面的是写入标题   \r\n\r\n    # print(i[:-3])\r\n    # file = open(filePath + '\\\\' + i, \"r\",encoding='utf-8')\r\n\r\n    # content = file.read()\r\n    # content_add = i[:-3]\r\n    # pos = content.find(\"title:\")\r\n    # if pos != -1:\r\n    #     content = content[:pos+6] + content_add + content[pos+6:]\r\n    #     file = open(filePath + '\\\\' + i, \"w\")\r\n    #     file.write(content)\r\n    #     file.close()\r\n```"
    },
    {
      "id": "/HOT100——下一个排列（JS实现）",
      "metadata": {
        "permalink": "/blog/HOT100——下一个排列（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/HOT100——下一个排列（JS实现）.md",
        "source": "@site/blog\\HOT100——下一个排列（JS实现）.md",
        "title": "HOT100——下一个排列（JS实现）",
        "description": "题目描述",
        "date": "2021-07-13T00:00:00.000Z",
        "formattedDate": "2021年7月13日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.78,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "HOT100——下一个排列（JS实现）",
          "date": "2021-7-13",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "使用Python对指定文件夹下的所有文件中的指定位置添加内容",
          "permalink": "/blog/使用Python对指定文件夹下的所有文件中的指定位置添加内容"
        },
        "nextItem": {
          "title": "浏览器生成消息的过程《网络是怎样连接的(第一章)》",
          "permalink": "/blog/浏览器生成消息的过程《网络是怎样连接的(第一章)》"
        }
      },
      "content": "## 题目描述\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/79d457fd686b48788f4941c715e1a82c.png)\r\n\r\n## 解题思路\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/bcd895391bcf5966b782171e50005a52.png)\r\n\r\n## 解题代码\r\n```js\r\nvar nextPermutation = function(nums) {\r\n    // 从又往左找到第一个降序的位置\r\n    let right = nums.length-1;\r\n    let flag = false;\r\n    while (right) {\r\n        if (nums[right] > nums[right-1]) {\r\n            right--;\r\n            flag = true;\r\n            break;\r\n        } else {\r\n            right--;\r\n        }\r\n    }\r\n    if (!flag) {\r\n        nums.sort((next,pre) => next - pre)\r\n    } else {\r\n\r\n        let sorted = nums.splice(right+1).sort((next,pre) => next - pre)\r\n        let move;\r\n        for (let i = 0; i < sorted.length;i++) {\r\n            if (sorted[i] > nums[right]) {\r\n                move = i;\r\n                break;\r\n            }\r\n        }\r\n        let temp = sorted[move];\r\n        sorted[move] = nums[right];\r\n        nums[right] = temp;\r\n        sorted.sort((next,pre) => next - pre);\r\n        nums.push(...sorted)\r\n    }\r\n    nums\r\n};\r\n```\r\n\r\n## 启示\r\n* 学会使用sorted、splice、slice等常用API。\r\n* 学会引入第三方变量来辅助我们的思路。"
    },
    {
      "id": "/浏览器生成消息的过程《网络是怎样连接的(第一章)》",
      "metadata": {
        "permalink": "/blog/浏览器生成消息的过程《网络是怎样连接的(第一章)》",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/浏览器生成消息的过程《网络是怎样连接的(第一章)》.md",
        "source": "@site/blog\\浏览器生成消息的过程《网络是怎样连接的(第一章)》.md",
        "title": "浏览器生成消息的过程《网络是怎样连接的(第一章)》",
        "description": "子网掩码中网络号和主机号的关系",
        "date": "2021-07-11T00:00:00.000Z",
        "formattedDate": "2021年7月11日",
        "tags": [
          {
            "label": "网络是怎样连接的",
            "permalink": "/blog/tags/网络是怎样连接的"
          }
        ],
        "readingTime": 8.655,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "浏览器生成消息的过程《网络是怎样连接的(第一章)》",
          "date": "2021-7-11",
          "author": "Justin",
          "top": true,
          "cover": true,
          "categories": "网络是怎样连接的",
          "tags": [
            "网络是怎样连接的"
          ]
        },
        "prevItem": {
          "title": "HOT100——下一个排列（JS实现）",
          "permalink": "/blog/HOT100——下一个排列（JS实现）"
        },
        "nextItem": {
          "title": "JS中取余与取整",
          "permalink": "/blog/JS中取余与取整"
        }
      },
      "content": "### 子网掩码中网络号和主机号的关系\r\n* 子网掩码表示的是IP地址的内部结构\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/76ed7440f6bef8f02f90c19ef66dc7b7.png)\r\n\r\n### 主机号部分的比特全零或全1代表的含义\r\n1. 全零（表示整个子网，而不是子网的某台设备）\r\n2. 全1（表示向子网上的所有设备发送包，即广播）\r\n\r\n## 为什么采用域名访问服务器，而不是直接使用IP地址？\r\n* 使用IP地址只需要处理四字节的数字，而域名则需要处理几十个到255个字节的字符，这增加了路由器的负担，传送数据也会花费更长的时间。\r\n\r\n## 什么是DNS？\r\n>通俗的讲，就是讲域名和IP地址建立一个映射关系。\r\n\r\n## 什么是Socket库？\r\n>Socket库是操作系统提供的一种库，通过这个库，可以让其他应用程序调用操作系统的网络功能。负责执行DNS查询IP地址的解析器就在这个库中。浏览器程序只需调用这个接口，解析器就会向DNS服务器发送查询消息，然后DNS服务器会返回相应的响应消息，响应消息中包含查询到的IP地址，解析器会取出这个IP地址，然后将其放入浏览器指定的内存地址中。\r\n\r\n## 什么是DNS服务器的记录类型？\r\n>当类型为A时，表示域名对应的时IP地址，当类型为MX时，表示域名对应的是邮件服务器。对于不同的记录类型，DNS服务器向客户端返回的信息也会不同。\r\n\r\n## 域名的层次结构\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/ee2e4c5589bb9c47ca8ac3dbdf81eec8.png)\r\n\r\n## 寻找相应的DNS服务器并获取IP地址\r\n1. 客户端首先会访问最近的一台DNS服务器。（这台最近的DNS服务器是我们设置的DNS服务器）\r\n2. 如果对应的DNS服务器没有存放我们要查找的域名信息，就从根域名DNS服务器开始从上往下进行查找，直到找到我们想要的域名信息为止\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/20121fae84b2652b6b8ea14a00befc13.png)\r\n\r\n## 通过缓存加快DNS服务器的响应\r\n* 现实中一个DNS服务器可能管理着多个域的信息。\r\n* 现实中上级域和下级域可能共享同一台DNS服务器。\r\n* DNS服务器有一个缓存功能，可以记住查询过的域名，如果要查询的域名和相关信息已经在缓存中，那么可以直接返回响应，接下来的查询可以从缓存的位置继续。\r\n* 如果查询结果不存在，这个不存在的情况也会被缓存\r\n* 如果信息被缓存后，原本注册的信息发生了变化，那么这个缓存中的信息就是不正确的。因此DNS服务器缓存中保存的信息具有一个有效期，当缓存中的有效期超过之后，这个信息就会被删除。\r\n\r\n## 什么是套接字?\r\n>客户端与服务器进行通信时，通信管道的两端的数据出入口就称为套接字。我们需要先创建套接字，然后将套接字连接起来形成管道。\r\n\r\n1. 服务器端先创建套接字，然后等待客户端向该套接字连接管道。服务器程序一般会在启动后就创建好套接字等待客户端来接连管道。\r\n2. 客户端创建好套接字后延伸出管道，最后管道连接到服务器端的套接字，双方的通信准备就完成了。\r\n3. 管道在连接时是由客户端发起的，但在断开时可以由任意一方发起。\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/0aa3ab9748a01249c0ccd7efe20bcbd1.png)\r\n* 上面的操作都是操作系统的协议栈完成的，而不是浏览器等应用程序完成的\r\n\r\n### 创建套接字阶段\r\n* 客户端创建套接字的操作非常简单，只需要调用Socket库中的socket程序组件即可。\r\n* 套接字创建完成之后，协议栈会返回一个描述符，应用程序会将收到的描述符存放在内存中，描述符是用来识别不同的套接字的，因为一台计算机可能需要进行多个通信管道的建立，所以需要识别不同的套接字。\r\n\r\n### 连接阶段：把管道接上去\r\n* 接下来，我们需要委托协议栈将客户端创建的套接字和服务器端创建的套接字连接起来，应用程序通过调用Socket库中的connect的程序组件来完成这一操作。\r\n* 当连接成功后，协议栈就会将对方的IP地址和端口号等信息保存在套接字中，这样我们就可以开始收发数据了。\r\n* 描述符：应用程序用来识别套接字的机制。\r\n* IP地址和端口号：客户端和服务器之间用来识别对方套接字的机制。\r\n\r\n### 通信阶段：传递消息\r\n* 应用程序通过调用Socket库中的write程序组件，指定描述符和发送数据，然后委托操作系统的协议栈将数据发送给服务器。\r\n* 由于套接字中已经保存了已连接的通信对象的相关信息，所以只要通过描述符指定套接字，就可以识别出通信对象，并向其发送数据。\r\n* 当服务器返回响应的数据后，应用程序接收消息的操作是通过Socket库中的read程序组件委托协议栈来完成的。\r\n* 调用read时需要指定用于存在接收到的响应消息的内存地址，这一内存地址被称为接收缓冲区。\r\n\r\n### 断开阶段：收发数据结束\r\n* 当浏览器收到数据之后，收发数据的过程就结束了。\r\n* 接下来，我们需要调用Socket库中的close程序组件进入断开阶段，最终链接在套接字之间的管道会被断开，套接字本身也会被删除。\r\n* Web服务器会首先调用close来断开连接，断开操作传达到客户端之后，客户端在调用read执行接收数据操作时，read会告知浏览器收发数据操作已经结束，连接已经断开，浏览器得知后，也会调用close进入断开阶段。\r\n>HTTP协议将HTML文档和图片都作为单独的对象来处理，每获取一次数据，就要执行一次连接、发送、断开，如果网页包含多张图片，这时势必会造成服务器的效率降低，因此HTTP1.1版本中当所有的数据都请求完成之后，浏览器才会主动触发断开连接的操作。"
    },
    {
      "id": "/JS中取余与取整",
      "metadata": {
        "permalink": "/blog/JS中取余与取整",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/JS中取余与取整.md",
        "source": "@site/blog\\JS中取余与取整.md",
        "title": "JS中取余与取整",
        "description": "取余",
        "date": "2021-07-06T00:00:00.000Z",
        "formattedDate": "2021年7月6日",
        "tags": [
          {
            "label": "JavaScript常用API",
            "permalink": "/blog/tags/java-script常用-api"
          }
        ],
        "readingTime": 0.27,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "JS中取余与取整",
          "date": "2021-07-06T00:00:00.000Z",
          "categories": "JavaScript常用API",
          "tags": [
            "JavaScript常用API"
          ]
        },
        "prevItem": {
          "title": "浏览器生成消息的过程《网络是怎样连接的(第一章)》",
          "permalink": "/blog/浏览器生成消息的过程《网络是怎样连接的(第一章)》"
        },
        "nextItem": {
          "title": "罗马数字转换器（FreeCodeCamp）",
          "permalink": "/blog/罗马数字转换器（FreeCodeCamp）"
        }
      },
      "content": "## 取余\r\n```\r\n6 % 2\r\n```\r\n## 取整\r\n### 抛弃整数\r\n```js\r\nparseInt(7/3)\r\n```\r\n### 向上取整（天花板嘛，代表上）\r\n```js\r\nMath.ceil(7/3)\r\n```\r\n### 向下取整（地板嘛，代表下）\r\n```js\r\nMath.floor(7/3)\r\n```\r\n### 四舍五入\r\n```js\r\nMath.round(7/3)\r\n```"
    },
    {
      "id": "/罗马数字转换器（FreeCodeCamp）",
      "metadata": {
        "permalink": "/blog/罗马数字转换器（FreeCodeCamp）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/罗马数字转换器（FreeCodeCamp）.md",
        "source": "@site/blog\\罗马数字转换器（FreeCodeCamp）.md",
        "title": "罗马数字转换器（FreeCodeCamp）",
        "description": "题目描述",
        "date": "2021-07-05T00:00:00.000Z",
        "formattedDate": "2021年7月5日",
        "tags": [
          {
            "label": "FreeCodeCamp",
            "permalink": "/blog/tags/free-code-camp"
          }
        ],
        "readingTime": 0.945,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "罗马数字转换器（FreeCodeCamp）",
          "date": "2021-07-05T00:00:00.000Z",
          "categories": "FreeCodeCamp",
          "tags": [
            "FreeCodeCamp"
          ]
        },
        "prevItem": {
          "title": "JS中取余与取整",
          "permalink": "/blog/JS中取余与取整"
        },
        "nextItem": {
          "title": "ByteDance的面试题",
          "permalink": "/blog/ByteDance的面试题"
        }
      },
      "content": "## 题目描述\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/38ebc497a82f40359c291f88035aa66c.png)\r\n\r\n## 测试实例\r\n![](https://img-blog.csdnimg.cn/img_convert/4937ecb91076dca85bbe7556caae49ce.png)\r\n\r\n## 解题思路\r\n* 构造罗马数字和整数的基本元素对应哈希表\r\n* 将目标整数依次除以哈希表的每一个元素，并向下取整，如果取整后结果大于0，则拼接上述结果个数个罗马数字，然后对哈希表中的对应整数取余赋值给num\r\n* 如何构造这个哈希表是本题的关键难点。\r\n\r\n## 解题代码\r\n```js\r\nfunction convertToRoman(num) {\r\n    const map = new Map([['M',1000],['CM',900],['D',500],['CD',400],['C',100],['XC',90],['L',50],['XL',40],['X',10],['IX',9],['V',5],['IV',4],['I',1]]);\r\n    let result = '';\r\n    for (let v of map) {\r\n        const temp = parseInt(num/v[1],0);\r\n        if (temp > 0) {\r\n            for (let i = 0; i < temp; ++i) {\r\n                result += v[0]\r\n            }\r\n        }\r\n        num = num % v[1]\r\n    }\r\n    return result\r\n}\r\n\r\nconvertToRoman(44);\r\n```\r\n## 启示\r\n* 学会使用parseInt向下取整"
    },
    {
      "id": "/ByteDance的面试题",
      "metadata": {
        "permalink": "/blog/ByteDance的面试题",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ByteDance的面试题.md",
        "source": "@site/blog\\ByteDance的面试题.md",
        "title": "ByteDance的面试题",
        "description": "直接上图",
        "date": "2021-07-02T00:00:00.000Z",
        "formattedDate": "2021年7月2日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 0.32,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ByteDance的面试题",
          "date": "2021-07-02T00:00:00.000Z",
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "罗马数字转换器（FreeCodeCamp）",
          "permalink": "/blog/罗马数字转换器（FreeCodeCamp）"
        },
        "nextItem": {
          "title": "JS中将ASCII码值转换为对应字符",
          "permalink": "/blog/JS中将ASCII码值转换为对应字符"
        }
      },
      "content": "## 直接上图\r\n![](https://img-blog.csdnimg.cn/img_convert/b1516a18d9d26658bdbe6850ed3d51ce.png)\r\n\r\n>做完题，并没有直接给出答案，而是得了80分，第十题我选的D，后续有时间会进行详细讲解。本题的答案还待商榷，因为并没有直接给出答案。"
    },
    {
      "id": "/JS中将ASCII码值转换为对应字符",
      "metadata": {
        "permalink": "/blog/JS中将ASCII码值转换为对应字符",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/JS中将ASCII码值转换为对应字符.md",
        "source": "@site/blog\\JS中将ASCII码值转换为对应字符.md",
        "title": "JS中将ASCII码值转换为对应字符",
        "description": "通过String.fromCharCode",
        "date": "2021-06-27T00:00:00.000Z",
        "formattedDate": "2021年6月27日",
        "tags": [
          {
            "label": "JavaScript常用API",
            "permalink": "/blog/tags/java-script常用-api"
          }
        ],
        "readingTime": 0.075,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "JS中将ASCII码值转换为对应字符",
          "date": "2021-06-27T00:00:00.000Z",
          "categories": "JavaScript常用API",
          "tags": [
            "JavaScript常用API"
          ]
        },
        "prevItem": {
          "title": "ByteDance的面试题",
          "permalink": "/blog/ByteDance的面试题"
        },
        "nextItem": {
          "title": "JS中将二进制字符串转换为十进制的方法",
          "permalink": "/blog/JS中将二进制字符串转换为十进制的方法"
        }
      },
      "content": "## 通过String.fromCharCode\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210624101052927.png)"
    },
    {
      "id": "/JS中将二进制字符串转换为十进制的方法",
      "metadata": {
        "permalink": "/blog/JS中将二进制字符串转换为十进制的方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/JS中将二进制字符串转换为十进制的方法.md",
        "source": "@site/blog\\JS中将二进制字符串转换为十进制的方法.md",
        "title": "JS中将二进制字符串转换为十进制的方法",
        "description": "通过parseInt",
        "date": "2021-06-27T00:00:00.000Z",
        "formattedDate": "2021年6月27日",
        "tags": [
          {
            "label": "JavaScript常用API",
            "permalink": "/blog/tags/java-script常用-api"
          }
        ],
        "readingTime": 0.075,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "JS中将二进制字符串转换为十进制的方法",
          "date": "2021-06-27T00:00:00.000Z",
          "categories": "JavaScript常用API",
          "tags": [
            "JavaScript常用API"
          ]
        },
        "prevItem": {
          "title": "JS中将ASCII码值转换为对应字符",
          "permalink": "/blog/JS中将ASCII码值转换为对应字符"
        },
        "nextItem": {
          "title": "零基础学习Webpack—01",
          "permalink": "/blog/零基础学习Webpack—01"
        }
      },
      "content": "## 通过parseInt\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021062410083959.png)"
    },
    {
      "id": "/零基础学习Webpack—01",
      "metadata": {
        "permalink": "/blog/零基础学习Webpack—01",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/零基础学习Webpack—01.md",
        "source": "@site/blog\\零基础学习Webpack—01.md",
        "title": "零基础学习Webpack—01",
        "description": "Webpack是什么？",
        "date": "2021-06-27T00:00:00.000Z",
        "formattedDate": "2021年6月27日",
        "tags": [
          {
            "label": "Webpack",
            "permalink": "/blog/tags/webpack"
          }
        ],
        "readingTime": 2.81,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "零基础学习Webpack—01",
          "date": "2021-06-27T00:00:00.000Z",
          "categories": "Webpack",
          "tags": [
            "Webpack"
          ]
        },
        "prevItem": {
          "title": "JS中将二进制字符串转换为十进制的方法",
          "permalink": "/blog/JS中将二进制字符串转换为十进制的方法"
        },
        "nextItem": {
          "title": "你会求《数字范围内的最小公倍数》吗？",
          "permalink": "/blog/你会求《数字范围内的最小公倍数》吗？"
        }
      },
      "content": "## Webpack是什么？\r\n>Webpack是一种前端资源构建工具，一个静态模块打包器，在Webpack看来，前端的所有资源文件都会作为模块处理。它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源(bundle).\r\n\r\n**举例**\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/838b2aa7a61abe2923b1029acdad036e.png)\r\n\r\n## 引出构建工具\r\n* 在上面的例子中，很多文件中的语法浏览器并不能识别，需要将这些文件中的语法转换为浏览器能够识别的语法。因此构建工具应运而生了，通过构建工具可以将各种语法转换的工具进行汇总，我们只需关注这个构建工具如何使用即可，而不用分别去学习如何将less转为css,如何将js中的语法转换为ES5等。本次要学习的Webpack就是构建工具的一种。\r\n\r\n## 打包是什么意思？\r\n1. 在Webpack工作的时候，我们首先要告诉Webpack一个打包的起点，即入口文件。\r\n2. webpack将文件中的每一个依赖记录好，然后形成一个依赖关系树状图。\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/42c62d9b447166000783620d825a66e9.png)\r\n\r\n3. 根据依赖关系树，依次将资源引入。\r\n4. 资源引入后形成一个代码块（chunk）。\r\n5. 对chunk中的代码进行分别处理，比如将less编译成css,将js语法编译为浏览器能够识别的js语法。\r\n\r\n**上面介绍的五个步骤，统一概括起来就是打包！**\r\n\r\n## 打包好之后开始进行输出\r\n* 输出后叫bundle.\r\n\r\n## Webpack的五个核心概念\r\n### 1. Entry\r\n* 入口Entry指示Webpack以哪个文件为入口起点开始打包，分析构建内部依赖图。\r\n\r\n### 2. Output\r\n* 输出（Output）指示Webpack打包后的资源bundles输出到哪里去，以及如何命名。\r\n\r\n### 3. Loader\r\n* Loader让Webpack能够去处理那些非JS文件，Webpack自身只理解JS。（Loader就像是翻译官）\r\n\r\n### 4. Plugins\r\n* 插件（Plugins）可以用于执行范围更广的任务，插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等。\r\n\r\n### 5. Mode\r\n* 模式（Mode）指示Webpack使用相应模式的配置\r\n\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/a9b3b99605621be81f768f4b4b64a72b.png)"
    },
    {
      "id": "/你会求《数字范围内的最小公倍数》吗？",
      "metadata": {
        "permalink": "/blog/你会求《数字范围内的最小公倍数》吗？",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/你会求《数字范围内的最小公倍数》吗？.md",
        "source": "@site/blog\\你会求《数字范围内的最小公倍数》吗？.md",
        "title": "你会求《数字范围内的最小公倍数》吗？",
        "description": "今天我在练习FreeCodeCamp的时候，发现一道很有意思的初级算法题目，特地和大家分享一下。",
        "date": "2021-06-25T00:00:00.000Z",
        "formattedDate": "2021年6月25日",
        "tags": [
          {
            "label": "FreeCodeCamp",
            "permalink": "/blog/tags/free-code-camp"
          }
        ],
        "readingTime": 3.22,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "你会求《数字范围内的最小公倍数》吗？",
          "date": "2021-06-25T00:00:00.000Z",
          "categories": "FreeCodeCamp",
          "tags": [
            "FreeCodeCamp"
          ]
        },
        "prevItem": {
          "title": "零基础学习Webpack—01",
          "permalink": "/blog/零基础学习Webpack—01"
        },
        "nextItem": {
          "title": "解决React脚手架保存后浏览器不能及时刷新的问题",
          "permalink": "/blog/解决React脚手架保存后浏览器不能及时刷新的问题"
        }
      },
      "content": ">今天我在练习FreeCodeCamp的时候，发现一道很有意思的初级算法题目，特地和大家分享一下。\r\n\r\n## 题目描述\r\n找到可以被两者以及这些参数之间范围内的所有序列号均分的所提供参数的最小公倍数。\r\n\r\n该范围将是一个由两个数字组成的数组，不一定按数字顺序排列。\r\n\r\n例如，如果给定 1 和 3，请找出 1 和 3 的最小公倍数，该倍数也可以被1 和 3之间的所有数字整除。 这里的答案是 6。\r\n\r\n## 测试实例\r\n![](https://img-blog.csdnimg.cn/img_convert/f65d02e3ad185c4aacb9d464146e62c8.png)\r\n\r\n## 解题思路\r\n>当我刚刚看到这道题目的时候，我在想求最小公倍数这还不简单？但是事情仿佛没那么容易，原因在于题目中让我们求的不是两个数字的最小公倍数，而是这个区间范围内的最小公倍数，所以看懂题目很关键。\r\n\r\n**难点**：如何求两个数的最小公倍数\r\n\r\n**思路**\r\n\r\n1. 首先默认两个数字中较大的那个为最小公倍数。\r\n2. 通过while循环，只要默认的最小公倍数小于等于两数的乘积便进入循环，如果这个默认的最小公倍数对左边的数趋于为零，说明这个是最小公倍数直接返回即可，反之，让这个默认的最小公倍数加上右边的值继续循环。\r\n\r\n**代码**\r\n```js\r\n// 获取最小公倍数的函数\r\n    function getSCM(left, right) {\r\n\r\n        // 首先默认最小公倍数为right\r\n        let SCM = right;\r\n\r\n        while (SCM <= right * left) {\r\n            if (SCM % left === 0) {\r\n                return SCM\r\n            } else {\r\n                SCM = SCM + right;\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n## 解题代码\r\n```js\r\nfunction smallestCommons(arr) {\r\n    arr.sort((next, pre) => next - pre);\r\n\r\n    // 获取最小公倍数的函数\r\n    function getSCM(left, right) {\r\n\r\n        // 首先默认最小公倍数为right\r\n        let SCM = right;\r\n\r\n        while (SCM <= right * left) {\r\n            if (SCM % left === 0) {\r\n                return SCM\r\n            } else {\r\n                SCM = SCM + right;\r\n            }\r\n        }\r\n    }\r\n\r\n    // 生成数组\r\n    const newArr = [];\r\n    for (let i = arr[0]; i <= arr[1]; i++) {\r\n        newArr.push(i);\r\n    }\r\n    let result = arr[0] * (arr[0] + 1);\r\n    // 通过循环不断更新最小公倍数\r\n    for (let i = 2; i < newArr.length; i++) {\r\n        result = getSCM(newArr[i], result);\r\n    }\r\n    return result;\r\n}\r\n\r\n\r\nsmallestCommons([1, 5]);\r\n```\r\n\r\n## 本题给我们的启示\r\n1. 学会通过循环的方式来求两个数字的最小公倍数。\r\n2. 学会通过更新的方式来获取，范围内的最小公倍数。\r\n\r\n## 参考链接\r\n* [找出数字范围的最小公倍数](https://singsing.io/blog/fcc/intermediate-smallest-common-multiple/)"
    },
    {
      "id": "/解决React脚手架保存后浏览器不能及时刷新的问题",
      "metadata": {
        "permalink": "/blog/解决React脚手架保存后浏览器不能及时刷新的问题",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/解决React脚手架保存后浏览器不能及时刷新的问题.md",
        "source": "@site/blog\\解决React脚手架保存后浏览器不能及时刷新的问题.md",
        "title": "解决React脚手架保存后浏览器不能及时刷新的问题",
        "description": "问题描述",
        "date": "2021-06-20T00:00:00.000Z",
        "formattedDate": "2021年6月20日",
        "tags": [
          {
            "label": "debug",
            "permalink": "/blog/tags/debug"
          }
        ],
        "readingTime": 0.46,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "解决React脚手架保存后浏览器不能及时刷新的问题",
          "date": "2021-06-20T00:00:00.000Z",
          "categories": "debug",
          "tags": [
            "debug"
          ]
        },
        "prevItem": {
          "title": "你会求《数字范围内的最小公倍数》吗？",
          "permalink": "/blog/你会求《数字范围内的最小公倍数》吗？"
        },
        "nextItem": {
          "title": "HOT100——最长有效括号（JS实现）",
          "permalink": "/blog/HOT100——最长有效括号（JS实现）"
        }
      },
      "content": "## 问题描述\r\n>当我使用React脚手架创建一个项目后，发现保存代码后，浏览器并不会自动刷新，需要我手动刷新后，才会显示出来。\r\n\r\n## 问题解决方案\r\n在package.json同级目录下新建一个文件名为.env,并添加下面的内容\r\n```\r\nFAST_REFRESH=false\r\n```\r\n\r\n## 停止项目，重新npm start"
    },
    {
      "id": "/HOT100——最长有效括号（JS实现）",
      "metadata": {
        "permalink": "/blog/HOT100——最长有效括号（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/HOT100——最长有效括号（JS实现）.md",
        "source": "@site/blog\\HOT100——最长有效括号（JS实现）.md",
        "title": "HOT100——最长有效括号（JS实现）",
        "description": "题目描述",
        "date": "2021-06-18T00:00:00.000Z",
        "formattedDate": "2021年6月18日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.385,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "HOT100——最长有效括号（JS实现）",
          "date": "2021-06-18T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "解决React脚手架保存后浏览器不能及时刷新的问题",
          "permalink": "/blog/解决React脚手架保存后浏览器不能及时刷新的问题"
        },
        "nextItem": {
          "title": "155个JavaScript基础问题（136-145）",
          "permalink": "/blog/155个JavaScript基础问题（136-145）"
        }
      },
      "content": "## 题目描述\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/c610ac3e373ccb49688957d5344e0e46.png)\r\n\r\n## 解题思路\r\n* 使用辅助栈 + 求连续最长的元素序列。\r\n* 为什么要使用栈？通过这个辅助栈可以帮助我们更好的定位哪些位置上的字符能够构成有效的括号。\r\n* 如何求连续最长的元素序列，是通过循环更新最大值的方法来求解的。\r\n\r\n## 解题代码\r\n```js\r\nvar longestValidParentheses = function(s) {\r\n\r\n    if (s.length === 0) return 0;\r\n    // 创建一个同纬度的数组，用于判断哪些下标组合是有效的括号\r\n    const fillArr = new Array(s.length).fill(0);\r\n    // 辅助栈\r\n    const stack = [];\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] === '(') {\r\n            stack.push(i);\r\n        } else {\r\n            if (stack.length > 0) {\r\n                fillArr[i] = 1;\r\n                fillArr[stack.pop()]=1\r\n                \r\n            }\r\n        }\r\n    }\r\n    fillArr\r\n    // 计算最长连续的1\r\n    let count = 0;\r\n    let max = 0;\r\n\r\n    for (let v of fillArr) {\r\n        if (v === 1) {\r\n            count++;\r\n            max = max > count ? max : count;\r\n        } else {\r\n            count = 0;\r\n        }\r\n    }\r\n    return max;\r\n};\r\n```\r\n\r\n## 启示\r\n* 学会使用辅助栈来解决有效的括号这一类的问题。\r\n* 学会通过更新最大值的方式来获取最大值。"
    },
    {
      "id": "/155个JavaScript基础问题（136-145）",
      "metadata": {
        "permalink": "/blog/155个JavaScript基础问题（136-145）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/155个JavaScript基础问题（136-145）.md",
        "source": "@site/blog\\155个JavaScript基础问题（136-145）.md",
        "title": "155个JavaScript基础问题（136-145）",
        "description": "136. 以下哪一项会对对象person有副作用？",
        "date": "2021-06-17T00:00:00.000Z",
        "formattedDate": "2021年6月17日",
        "tags": [
          {
            "label": "155个JavaScript基础问题",
            "permalink": "/blog/tags/155-个-java-script基础问题"
          }
        ],
        "readingTime": 4.71,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "155个JavaScript基础问题（136-145）",
          "date": "2021-06-17T00:00:00.000Z",
          "categories": "155个JavaScript基础问题",
          "tags": [
            "155个JavaScript基础问题"
          ]
        },
        "prevItem": {
          "title": "HOT100——最长有效括号（JS实现）",
          "permalink": "/blog/HOT100——最长有效括号（JS实现）"
        },
        "nextItem": {
          "title": "155个JavaScript基础问题（146-155）",
          "permalink": "/blog/155个JavaScript基础问题（146-155）"
        }
      },
      "content": "## 136. 以下哪一项会对对象person有副作用？\r\n```js\r\nconst person = { name: \"Lydia Hallie\" };\r\n\r\nObject.seal(person);\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/b994d79601c7b67ecd4baa536a2ef904.png)\r\n>答：A,首先我们要明白Object.seal的作用，是防止添加新属性或者对原有属性进行删除，B属于添加新属性，C属于删除原有属性，D属于将所有可枚举对象的属性的值从源对象分配到目标对象，并返回目标对象，所以属于添加，所以只有A项对person对象产生了副作用。\r\n\r\n## 137. 以下哪一项会对对象person产生副作用？\r\n```js\r\nconst person = {\r\n\tname: \"Lydia Hallie\",\r\n\taddress: {\r\n\t\tstreet: \"100 Main St\"\r\n\t}\r\n};\r\n\r\nObject.freeze(person);\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/4c014a48fc9e94ea55455ec82fbfee21.png)\r\n>答：C，本题考查我们对Object.freeze这个API的用法的了解程度，这个冻结属于浅冻结，所以对内部对象的属性是可以修改的，比如这个street属性。\r\n\r\n## 138. 输出什么？\r\n```js\r\nconst add = x => x + x;\r\n\r\nfunction myFunc(num = 2, value = add(num)) {\r\n\tconsole.log(num, value);\r\n}\r\n\r\nmyFunc();\r\nmyFunc(3);\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/586b8d71279c6ac5acc1ff558783215a.png)\r\n>答：A，本题没什么坑，就是考查我们对默认传参的了解。\r\n\r\n## 139. 输出什么？\r\n```js\r\nclass Counter {\r\n  #number = 10\r\n\r\n  increment() {\r\n    this.#number++\r\n  }\r\n\r\n  getNum() {\r\n    return this.#number\r\n  }\r\n}\r\n\r\nconst counter = new Counter()\r\ncounter.increment()\r\n\r\nconsole.log(counter.#number)\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/de12ae325140186a31c00d18895f95c4.png)\r\n>答：D，本题考查的是ES2020的新特性，访问类的私有属性，不能通过实例直接调用，可以通过实例的方法获取到，所以选D。\r\n\r\n## 140. 选择哪一个？\r\n```js\r\nconst teams = [\r\n\t{ name: \"Team 1\", members: [\"Paul\", \"Lisa\"] },\r\n\t{ name: \"Team 2\", members: [\"Laura\", \"Tim\"] }\r\n];\r\n\r\nfunction* getMembers(members) {\r\n\tfor (let i = 0; i < members.length; i++) {\r\n\t\tyield members[i];\r\n\t}\r\n}\r\n\r\nfunction* getTeams(teams) {\r\n\tfor (let i = 0; i < teams.length; i++) {\r\n\t\t// ✨ SOMETHING IS MISSING HERE ✨\r\n\t}\r\n}\r\n\r\nconst obj = getTeams(teams);\r\nobj.next(); // { value: \"Paul\", done: false }\r\nobj.next(); // { value: \"Lisa\", done: false }\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/68ed5757359e48bb2b32c9805a5f0448.png)\r\n>答：B,本题主要是考查我们队yield和yield* 的认知，yield返回的是一个值，yield*则是将函数委托到另一个生成器函数或可迭代对象，显然本题适用于后者，所以选B。\r\n\r\n## 141. 输出什么？\r\n```js\r\nconst person = {\r\n\tname: \"Lydia Hallie\",\r\n\thobbies: [\"coding\"]\r\n};\r\n\r\nfunction addHobby(hobby, hobbies = person.hobbies) {\r\n\thobbies.push(hobby);\r\n\treturn hobbies;\r\n}\r\n\r\naddHobby(\"running\", []);\r\naddHobby(\"dancing\");\r\naddHobby(\"baking\", person.hobbies);\r\n\r\nconsole.log(person.hobbies);\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/54e721b8c3483776491d5b8103788b77.png)\r\n>答：C，本题还是考查默认传参和实际传参的区别，running加不到数组hobbies中是因为，传递了实参空数组，其余的都是传递了person对象的引用，则能够添加进去，所以选C。\r\n\r\n## 142. 输出什么？\r\n```js\r\nclass Bird {\r\n\tconstructor() {\r\n\t\tconsole.log(\"I'm a bird. 🦢\");\r\n\t}\r\n}\r\n\r\nclass Flamingo extends Bird {\r\n\tconstructor() {\r\n\t\tconsole.log(\"I'm pink. 🌸\");\r\n\t\tsuper();\r\n\t}\r\n}\r\n\r\nconst pet = new Flamingo();\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/c71e2dc04999ca4501045c469038ad3b.png)\r\n>答：B，本题考查我们对继承的理解，首先会调用子类的构造函数，其次调用父类的构造函数，所以打印的是B。\r\n\r\n## 143. 哪一个选项会导致报错？\r\n```js\r\nconst emojis = [\"🎄\", \"🎅🏼\", \"🎁\", \"⭐\"];\r\n\r\n/* 1 */ emojis.push(\"🦌\");\r\n/* 2 */ emojis.splice(0, 2);\r\n/* 3 */ emojis = [...emojis, \"🥂\"];\r\n/* 4 */ emojis.length = 0;\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/4c8ce095063c501779cf6bf689a911cf.png)\r\n>答：D，长度属性是可以修改的，所以第4个并没有错，第三个错在对emojis的地址进行修改，这是不允许的，因为这是const关键字修饰的。\r\n\r\n## 144. 我们需要向person对象添加什么，以致执行 [...person] 时获得形如 [\"Lydia Hallie\", 21] 的输出？\r\n```js\r\nconst person = {\r\n  name: \"Lydia Hallie\",\r\n  age: 21\r\n}\r\n\r\n[...person] // [\"Lydia Hallie\", 21]\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/35edfbff0de3d02c3503037d5ab2bbe4.png)\r\n>答：C，本题需要添加迭代器来定义迭代规则，对象默认并不是可迭代的，在添加规则的时候，生成器对象一定要yield* Object.values.\r\n\r\n## 145. 输出什么？\r\n```js\r\nlet count = 0;\r\nconst nums = [0, 1, 2, 3];\r\n\r\nnums.forEach(num => {\r\n\tif (num) count += 1\r\n})\r\n\r\nconsole.log(count)\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/7643d622f57fc31725a39833533f8070.png)\r\n>答：C，当num为0的时候，count并不加，所以总共加了三次，选C。\r\n\r\n## 题目来源\r\nhttps://github.com/lydiahallie/javascript-questions"
    },
    {
      "id": "/155个JavaScript基础问题（146-155）",
      "metadata": {
        "permalink": "/blog/155个JavaScript基础问题（146-155）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/155个JavaScript基础问题（146-155）.md",
        "source": "@site/blog\\155个JavaScript基础问题（146-155）.md",
        "title": "155个JavaScript基础问题（146-155）",
        "description": "146. 输出是什么？",
        "date": "2021-06-17T00:00:00.000Z",
        "formattedDate": "2021年6月17日",
        "tags": [
          {
            "label": "155个JavaScript基础问题",
            "permalink": "/blog/tags/155-个-java-script基础问题"
          }
        ],
        "readingTime": 4.215,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "155个JavaScript基础问题（146-155）",
          "date": "2021-06-17T00:00:00.000Z",
          "categories": "155个JavaScript基础问题",
          "tags": [
            "155个JavaScript基础问题"
          ]
        },
        "prevItem": {
          "title": "155个JavaScript基础问题（136-145）",
          "permalink": "/blog/155个JavaScript基础问题（136-145）"
        },
        "nextItem": {
          "title": "155个JavaScript基础问题（116-125）",
          "permalink": "/blog/155个JavaScript基础问题（116-125）"
        }
      },
      "content": "## 146. 输出是什么？\r\n```js\r\nfunction getFruit(fruits) {\r\n\tconsole.log(fruits?.[1]?.[1])\r\n}\r\n\r\ngetFruit([['🍊', '🍌'], ['🍍']])\r\ngetFruit()\r\ngetFruit([['🍍'], ['🍊', '🍌']])\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/45cbdf4b2768069a01de5d724a9a1035.png)\r\n>答：D，本题主要考察的是可选链操作符，只要不存在返回的是undefined，所以选D。\r\n\r\n## 147. 输出什么？\r\n```js\r\nclass Calc {\r\n\tconstructor() {\r\n\t\tthis.count = 0 \r\n\t}\r\n\r\n\tincrease() {\r\n\t\tthis.count ++\r\n\t}\r\n}\r\n\r\nconst calc = new Calc()\r\nnew Calc().increase()\r\n\r\nconsole.log(calc.count)\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/ed8f284e9ef8c79b1bf8f5aee1cb907b.png)\r\n>答：A，本题调用increase的对象和calc不是同一个对象，所以答案还是0.\r\n\r\n## 148. 输出什么？\r\n```js\r\nconst user = {\r\n\temail: \"e@mail.com\",\r\n\tpassword: \"12345\"\r\n}\r\n\r\nconst updateUser = ({ email, password }) => {\r\n\tif (email) {\r\n\t\tObject.assign(user, { email })\r\n\t}\r\n\r\n\tif (password) {\r\n\t\tuser.password = password\r\n\t}\r\n\r\n\treturn user\r\n}\r\n\r\nconst updatedUser = updateUser({ email: \"new@email.com\" })\r\n\r\nconsole.log(updatedUser === user)\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/eaabf70242c72c33598c8bdcda227a4e.png)\r\n>答：B，本题中并未对user这个对象的地址进行修改，只是对内部进行了修改，所以updatedUser和user地址相同。\r\n\r\n## 149. 输出什么？\r\n```js\r\nconst fruit = ['🍌', '🍊', '🍎']\r\n\r\nfruit.slice(0, 1)\r\nfruit.splice(0, 1)\r\nfruit.unshift('🍇')\r\n\r\nconsole.log(fruit)\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/7b81e4a787d0e0a1f434ac0f330fcd82.png)\r\n>答：C，本题就是考查我们对常用API的熟系程度，splice会对原数组产生副作用，unshift则是在数组最前面添加元素，所以答案是C。\r\n\r\n## 150. 输出什么？\r\n```js\r\nconst animals = {};\r\nlet dog = { emoji: '🐶' }\r\nlet cat = { emoji: '🐈' }\r\n\r\nanimals[dog] = { ...dog, name: \"Mara\" }\r\nanimals[cat] = { ...cat, name: \"Sara\" }\r\n\r\nconsole.log(animals[dog])\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/1b8e867a9a217e3d84c46223332540b7.png)\r\n>答：B，用一个对象作为键，底层存储的是\"object Object\"，所以这样看来，dog和cat在animals的键是相同的，所以cat对应的值能够覆盖dog，所以选B。\r\n\r\n## 151. 输出什么？\r\n```js\r\nconst user = {\r\n\temail: \"my@email.com\",\r\n\tupdateEmail: email => {\r\n\t\tthis.email = email\r\n\t}\r\n}\r\n\r\nuser.updateEmail(\"new@email.com\")\r\nconsole.log(user.email)\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/3ba62c845bb237e1d623cab66fcb0999.png)\r\n>答：A，本题考查的是箭头函数this指向的问题，此时this指向的是全局对象，由于全局没有email这个属性，所以会报错：![image.png](https://img-blog.csdnimg.cn/img_convert/ee00d2ea63b1c9e1919ae8eecca98fa9.png)\r\n\r\n## 152. 输出什么？\r\n```js\r\nconst promise1 = Promise.resolve('First')\r\nconst promise2 = Promise.resolve('Second')\r\nconst promise3 = Promise.reject('Third')\r\nconst promise4 = Promise.resolve('Fourth')\r\n\r\nconst runPromises = async () => {\r\n\tconst res1 = await Promise.all([promise1, promise2])\r\n\tconst res2  = await Promise.all([promise3, promise4])\r\n\treturn [res1, res2]\r\n}\r\n\r\nrunPromises()\r\n\t.then(res => console.log(res))\r\n\t.catch(err => console.log(err))\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/ab58dc7754516db432e2d3c28a0d33f7.png)\r\n>答：D,本题主要考察我们对Promise.all的了解，只要接收到了一个reject,直接将异步结果返回给捕捉错误的回调函数，所以直接打印Third.\r\n\r\n## 153. 哪个作为method的值可以打印{ name: \"Lydia\", age: 22 }?\r\n```js\r\nconst keys = [\"name\", \"age\"]\r\nconst values = [\"Lydia\", 22]\r\n\r\nconst method = /* ?? */\r\nObject[method](keys.map((_, i) => {\r\n\treturn [keys[i], values[i]]\r\n})) // { name: \"Lydia\", age: 22 }\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/93278d891b8fe8619dc7eb67684ae7fd.png)\r\n>答：C,本题主要是考查我们是否知道如何将二维数组转换为对象，可以通过C这个API，![image.png](https://img-blog.csdnimg.cn/img_convert/cddda98157f11fa2fc491918ae1aad16.png)\r\n\r\n## 154. 输出什么？\r\n```js\r\nconst createMember = ({ email, address = {}}) => {\r\n\tconst validEmail = /.+\\@.+\\..+/.test(email)\r\n\tif (!validEmail) throw new Error(\"Valid email pls\")\r\n\r\n\treturn {\r\n\t\temail,\r\n\t\taddress: address ? address : null\r\n\t}\r\n}\r\n\r\nconst member = createMember({ email: \"my@email.com\" })\r\nconsole.log(member)\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/274e092f5f617bf02863cfd0c0959bf9.png)\r\n>答：C，本题需要知道一点，那就是空对象属于真值，所以在返回对象的时候，address并不是返回null,而是返回的{}.\r\n\r\n## 155. 输出什么？\r\n```js\r\nlet randomValue = { name: \"Lydia\" }\r\nrandomValue = 23\r\n\r\nif (!typeof randomValue === \"string\") {\r\n\tconsole.log(\"It's not a string!\")\r\n} else {\r\n\tconsole.log(\"Yay it's a string!\")\r\n}\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/6cbab5d6a48e3ebea1a3044d02ac04f2.png)\r\n>答：B，首先我们要知道本题的运算优先级，首先会计算typeof randomValue,这回返回一个\"number\"，这是一个字符串，对字符串取反，返回false，false并不等于\"string\"，所以最后输出的是else对应的语句，\"Yay it's a string!\"。\r\n\r\n## 题目来源\r\nhttps://github.com/lydiahallie/javascript-questions"
    },
    {
      "id": "/155个JavaScript基础问题（116-125）",
      "metadata": {
        "permalink": "/blog/155个JavaScript基础问题（116-125）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/155个JavaScript基础问题（116-125）.md",
        "source": "@site/blog\\155个JavaScript基础问题（116-125）.md",
        "title": "155个JavaScript基础问题（116-125）",
        "description": "116. 输出什么？",
        "date": "2021-06-16T00:00:00.000Z",
        "formattedDate": "2021年6月16日",
        "tags": [
          {
            "label": "155个JavaScript基础问题",
            "permalink": "/blog/tags/155-个-java-script基础问题"
          }
        ],
        "readingTime": 4.18,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "155个JavaScript基础问题（116-125）",
          "date": "2021-06-16T00:00:00.000Z",
          "categories": "155个JavaScript基础问题",
          "tags": [
            "155个JavaScript基础问题"
          ]
        },
        "prevItem": {
          "title": "155个JavaScript基础问题（146-155）",
          "permalink": "/blog/155个JavaScript基础问题（146-155）"
        },
        "nextItem": {
          "title": "155个JavaScript基础问题（126-135）",
          "permalink": "/blog/155个JavaScript基础问题（126-135）"
        }
      },
      "content": "## 116. 输出什么？\r\n```js\r\nconst person = {\r\n  name: \"Lydia\",\r\n  age: 21\r\n}\r\n\r\nconst changeAge = (x = { ...person }) => x.age += 1\r\nconst changeAgeAndName = (x = { ...person }) => {\r\n  x.age += 1\r\n  x.name = \"Sarah\"\r\n}\r\n\r\nchangeAge(person)\r\nchangeAgeAndName()\r\n\r\nconsole.log(person)\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/f50a70eaed601820b493908a40077b75.png)\r\n>答：C，本题主要考查函数传参和默认参数的区别，传参如果传的是引用地址，则会对这个引用产生影响，但是如果是默认参数，则是创建了一个新对象，对原引用没有影响。\r\n\r\n## 117. 下面哪个选项会返回6？\r\n```js\r\nfunction sumValues(x, y, z) {\r\n\treturn x + y + z;\r\n}\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/01a78b5b4e7f7aebd6e313c07c086ce4.png)\r\n>答：C，本题考查我们对拓展运算符的熟悉程度，只有C选项是将数组变为了三个元素，其余选项均为一个数组，所以选C。\r\n\r\n## 118. 输出什么？\r\n```js\r\nlet num = 1;\r\nconst list = [\"🥳\", \"🤠\", \"🥰\", \"🤪\"];\r\n\r\nconsole.log(list[(num += 1)]);\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/6b425ec14b1b12f710f0bbc854544614.png)\r\n>答：B，本题我们需要看清的是，这不是num++,而是num+=1,所以其实打印的是list[2].\r\n\r\n## 119. 输出什么？\r\n```js\r\nconst person = {\r\n\tfirstName: \"Lydia\",\r\n\tlastName: \"Hallie\",\r\n\tpet: {\r\n\t\tname: \"Mara\",\r\n\t\tbreed: \"Dutch Tulip Hound\"\r\n\t},\r\n\tgetFullName() {\r\n\t\treturn `${this.firstName} ${this.lastName}`;\r\n\t}\r\n};\r\n\r\nconsole.log(person.pet?.name);\r\nconsole.log(person.pet?.family?.name);\r\nconsole.log(person.getFullName?.());\r\nconsole.log(member.getLastName?.());\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/05b6287f59381f470e0626657441d876.png)\r\n>答：B，本题主要考查可选连操作符(?.)，这是一个新特性，作用是如果该操作符前面的属性对象存在，则打印该属性对应的内容，如果不存在则返回undefined，至于第四个打印member的这个选项，答案应是报错的。\r\n\r\n## 120. 输出什么？\r\n```js\r\nconst groceries = [\"banana\", \"apple\", \"peanuts\"];\r\n\r\nif (groceries.indexOf(\"banana\")) {\r\n\tconsole.log(\"We have to buy bananas!\");\r\n} else {\r\n\tconsole.log(`We don't have to buy bananas!`);\r\n}\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/89d9a58b5ab5a7e83911c5fe7f3d270d.png)\r\n>答：B，这是因为indexOf返回的下标是0，这是一个假值，所以触发了else.\r\n\r\n## 121. 输出什么？\r\n```js\r\nconst config = {\r\n\tlanguages: [],\r\n\tset language(lang) {\r\n\t\treturn this.languages.push(lang);\r\n\t}\r\n};\r\n\r\nconsole.log(config.language);\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/596a3746ed07707caa5aed50b3110d38.png)\r\n>答：D，本题考查我们对setter的认识，这个方法存在的意义是修改对象的属性，如果调用的话返回的是undefined。\r\n\r\n## 122. 输出什么？\r\n```js\r\nconst name = \"Lydia Hallie\";\r\n\r\nconsole.log(!typeof name === \"object\");\r\nconsole.log(!typeof name === \"string\");\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/18a679277cfb496af1ad8e048bcdb0ff.png)\r\n>答：C，本题非运算的优先级高于三个等号的优先级，所以先计算typeof name结果为字符串类型的string,取非之后，返回的是false,这个和后两个均不等，所以选C。\r\n\r\n## 123. 输出什么？\r\n```js\r\nconst add = x => y => z => {\r\n\tconsole.log(x, y, z);\r\n\treturn x + y + z;\r\n};\r\n\r\nadd(4)(5)(6);\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/bebc135293cac113cacb9302a0ad4386.png)\r\n>答：A，这题主要考查箭头函数的作用域链，所以打印的是 4 5 6，选A。\r\n\r\n## 124. 输出什么？\r\n```js\r\nasync function* range(start, end) {\r\n\tfor (let i = start; i <= end; i++) {\r\n\t\tyield Promise.resolve(i);\r\n\t}\r\n}\r\n\r\n(async () => {\r\n\tconst gen = range(1, 3);\r\n\tfor await (const item of gen) {\r\n\t\tconsole.log(item);\r\n\t}\r\n})();\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/8982b04c52a92021c78032d584a25401.png)\r\n>答：C，本题主要是考查生成器函数和for await of这种循环的用法，首先range这个生成器函数返回了3个Promise对象，通过for await of 这种循环可以将每个promise的值打印出来，所以选C。\r\n\r\n## 125. 输出什么？\r\n```js\r\nconst myFunc = ({ x, y, z }) => {\r\n\tconsole.log(x, y, z);\r\n};\r\n\r\nmyFunc(1, 2, 3);\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/03ff3d6511abc786320d1244ab61bc08.png)\r\n>答：D，本题主要考察对象的解构赋值，传入的应该是一个拥有x y z三个属性的对象，但是题目并未传入一个对象，所以打印的是3个undefined.\r\n\r\n## 题目来源\r\nhttps://github.com/lydiahallie/javascript-questions"
    },
    {
      "id": "/155个JavaScript基础问题（126-135）",
      "metadata": {
        "permalink": "/blog/155个JavaScript基础问题（126-135）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/155个JavaScript基础问题（126-135）.md",
        "source": "@site/blog\\155个JavaScript基础问题（126-135）.md",
        "title": "155个JavaScript基础问题（126-135）",
        "description": "126. 输出什么？",
        "date": "2021-06-16T00:00:00.000Z",
        "formattedDate": "2021年6月16日",
        "tags": [
          {
            "label": "155个JavaScript基础问题",
            "permalink": "/blog/tags/155-个-java-script基础问题"
          }
        ],
        "readingTime": 4.465,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "155个JavaScript基础问题（126-135）",
          "date": "2021-06-16T00:00:00.000Z",
          "categories": "155个JavaScript基础问题",
          "tags": [
            "155个JavaScript基础问题"
          ]
        },
        "prevItem": {
          "title": "155个JavaScript基础问题（116-125）",
          "permalink": "/blog/155个JavaScript基础问题（116-125）"
        },
        "nextItem": {
          "title": "HOT100——合并K个升序链表（JS实现）",
          "permalink": "/blog/HOT100——合并K个升序链表（JS实现）"
        }
      },
      "content": "## 126. 输出什么？\r\n```js\r\nfunction getFine(speed, amount) {\r\n  const formattedSpeed = new Intl.NumberFormat({\r\n    'en-US',\r\n    { style: 'unit', unit: 'mile-per-hour' }\r\n  }).format(speed)\r\n\r\n  const formattedAmount = new Intl.NumberFormat({\r\n    'en-US',\r\n    { style: 'currency', currency: 'USD' }\r\n  }).format(amount)\r\n\r\n  return `The driver drove ${formattedSpeed} and has to pay ${formattedAmount}`\r\n}\r\n\r\nconsole.log(getFine(130, 300))\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/a78864c35b11375c5462bb91f85fbc78.png)\r\n>答：B，本题主要考察Intl.NumberFormat的用法，意在输出指定类型的字符串，所以选B。\r\n\r\n## 127. 输出什么？\r\n```js\r\nconst spookyItems = [\"👻\", \"🎃\", \"🕸\"];\r\n({ item: spookyItems[3] } = { item: \"💀\" });\r\n\r\nconsole.log(spookyItems);\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/0d17026ae437386739fed2efcbdb6059.png)\r\n>答：B，本题在解构对象的时候，对数组进行了赋值，所以选B。\r\n\r\n## 128. 输出什么？\r\n```js\r\nconst name = \"Lydia Hallie\";\r\nconst age = 21;\r\n\r\nconsole.log(Number.isNaN(name));\r\nconsole.log(Number.isNaN(age));\r\n\r\nconsole.log(isNaN(name));\r\nconsole.log(isNaN(age));\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/4cc66ecf0dad5ae7607fc3a2fe6f54c8.png)\r\n>答：C，本题主要是考查我们对Number.isNaN和isNaN这两种API的用法区别的认识，前者不仅要检查是否是非数字，还要检查是否等于NaN,后者则只用检查是否是非数字，所以最终的结果选C。\r\n\r\n## 129. 输出什么？\r\n```js\r\nconst randomValue = 21;\r\n\r\nfunction getInfo() {\r\n\tconsole.log(typeof randomValue);\r\n\tconst randomValue = \"Lydia Hallie\";\r\n}\r\n\r\ngetInfo();\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/58051682d5b142ab55914d434ae92e83.png)\r\n>答：D，这种问题属于考查临时性死区的问题，在const形成的块级作用域中，变量声明提升了，但是并未初始化，此时调用会产生一个临时性死区，一旦调用就会报错。\r\n\r\n## 130. 输出什么？\r\n```js\r\nconst myPromise = Promise.resolve(\"Woah some cool data\");\r\n\r\n(async () => {\r\n\ttry {\r\n\t\tconsole.log(await myPromise);\r\n\t} catch {\r\n\t\tthrow new Error(`Oops didn't work`);\r\n\t} finally {\r\n\t\tconsole.log(\"Oh finally!\");\r\n\t}\r\n})();\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/8b92ed74f3db23688b0bd4809cbbb2a4.png)\r\n>答：C，本题并没有太多的坑，只要知道正常的async和await的用法，即可知道选C。\r\n\r\n## 131. 输出什么？\r\n```js\r\nconst emojis = [\"🥑\", [\"✨\", \"✨\", [\"🍕\", \"🍕\"]]];\r\n\r\nconsole.log(emojis.flat(1));\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/78dba2226619707b042be84a4e7ef844.png)\r\n>答：B，这里的flat(1)，我们可以理解为将数组降维处理，去掉数组里面的一维数组，测试案例看这个图：![image.png](https://img-blog.csdnimg.cn/img_convert/67ceec46e935951babba60cee9d91b56.png)，所以选B。\r\n\r\n## 132. 输出什么？\r\n```js\r\nclass Counter {\r\n\tconstructor() {\r\n\t\tthis.count = 0;\r\n\t}\r\n\r\n\tincrement() {\r\n\t\tthis.count++;\r\n\t}\r\n}\r\n\r\nconst counterOne = new Counter();\r\ncounterOne.increment();\r\ncounterOne.increment();\r\n\r\nconst counterTwo = counterOne;\r\ncounterTwo.increment();\r\n\r\nconsole.log(counterOne.count);\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/5bb4e8a3e7e116bfcd49a3e6c9787118.png)\r\n>答：D，本题中counterTwo和counterOne指向的是同一片对象，所以对counterTwo的加就是对counterOne的加，所以最终的结果是3.\r\n\r\n## 133.输出什么？\r\n```js\r\nconst myPromise = Promise.resolve(Promise.resolve(\"Promise!\"));\r\n\r\nfunction funcOne() {\r\n\tmyPromise.then(res => res).then(res => console.log(res));\r\n\tsetTimeout(() => console.log(\"Timeout!\"), 0);\r\n\tconsole.log(\"Last line!\");\r\n}\r\n\r\nasync function funcTwo() {\r\n\tconst res = await myPromise;\r\n\tconsole.log(await res);\r\n\tsetTimeout(() => console.log(\"Timeout!\"), 0);\r\n\tconsole.log(\"Last line!\");\r\n}\r\n\r\nfuncOne();\r\nfuncTwo();\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/db69c3fbe4598095a9cf51ad25fdb84b.png)\r\n>答：D，本题主要是考查事件循环机制，详情请看我的专栏，首先调用栈执行第一个函数中的同步代码，然后微任务Promise，然后开始执行第二个函数，因为await关键字的存在，函数会一直等到Promise的状态变为resolved才会继续执行同步代码，所以打印了Promise,然后执行同步代码Last line，当调用栈为空的时候，最后执行两个宏任务setTimeout，先1后2.\r\n\r\n## 134. 如何在index.js中调用sum.js中的sum方法？\r\n```js\r\n// sum.js\r\nexport default function sum(x) {\r\n\treturn x + x;\r\n}\r\n\r\n// index.js\r\nimport * as sum from \"./sum\";\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/829a28e06b32a34eae1450b23a5b06c7.png)\r\n>答：C，本题主要是考查我们对通过import * 导入一个默认暴露函数的理解，只有通过C是可以的。\r\n\r\n## 135. 输出什么？\r\n```js\r\nconst handler = {\r\n\tset: () => console.log(\"Added a new property!\"),\r\n\tget: () => console.log(\"Accessed a property!\")\r\n};\r\n\r\nconst person = new Proxy({}, handler);\r\n\r\nperson.name = \"Lydia\";\r\nperson.name;\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/c2945693de32ee1b67600d9a50814417.png)\r\n>答：C，本题主要考查我们对Proxy对象的用法熟悉程度，通过该API，我们可以给对象添加自定义行为，当给对象设置值的时候，set方法会被调用，当调用对象的时候，get方法将会被调用。\r\n\r\n## 题目来源\r\nhttps://github.com/lydiahallie/javascript-questions"
    },
    {
      "id": "/HOT100——合并K个升序链表（JS实现）",
      "metadata": {
        "permalink": "/blog/HOT100——合并K个升序链表（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/HOT100——合并K个升序链表（JS实现）.md",
        "source": "@site/blog\\HOT100——合并K个升序链表（JS实现）.md",
        "title": "HOT100——合并K个升序链表（JS实现）",
        "description": "题目描述",
        "date": "2021-06-15T00:00:00.000Z",
        "formattedDate": "2021年6月15日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.075,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "HOT100——合并K个升序链表（JS实现）",
          "date": "2021-06-15T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "155个JavaScript基础问题（126-135）",
          "permalink": "/blog/155个JavaScript基础问题（126-135）"
        },
        "nextItem": {
          "title": "这一次，彻底搞懂Promise的状态转换",
          "permalink": "/blog/这一次，彻底搞懂Promise的状态转换"
        }
      },
      "content": "## 题目描述\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/319a49c3742d1a12fdd64647f270f1a5.png)\r\n\r\n## 解题思路\r\n* 暴力法\r\n1. 首先遍历每一个链表元素，然后将其值存入到一个数组中。\r\n2. 将第一步获得的数组进行排序。\r\n3. 遍历第二步的数组，分别生成节点，然后存入一个临时数组。\r\n4. 以第三步获得的临时数组为基础，依次修改指针的指向，最后返回头指针即可。\r\n\r\n## 解题代码\r\n```js\r\nvar mergeKLists = function(lists) {\r\n    // 暴力法\r\n    if (lists.length === 0) return null\r\n    const res = [];\r\n    for (let v of lists) {\r\n        while (v) {\r\n            res.push(v.val);\r\n            v = v.next;\r\n        }\r\n    }\r\n    if (res.length === 0) return null;\r\n    res.sort((num1,num2) => num1 - num2);\r\n    const temp = [];\r\n    for (let v of res) {\r\n        temp.push(new ListNode(v))\r\n    }\r\n    for (let i = 0; i < temp.length-1; i++) {\r\n        temp[i].next = temp[i+1];\r\n    }\r\n    temp[temp.length-1].next = null;\r\n    return temp[0]\r\n};\r\n```\r\n\r\n## 启示\r\n* 学会使用数组来辅助链表的生成与遍历。"
    },
    {
      "id": "/这一次，彻底搞懂Promise的状态转换",
      "metadata": {
        "permalink": "/blog/这一次，彻底搞懂Promise的状态转换",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/这一次，彻底搞懂Promise的状态转换.md",
        "source": "@site/blog\\这一次，彻底搞懂Promise的状态转换.md",
        "title": "这一次，彻底搞懂Promise的状态转换",
        "description": "这篇文章解决了我很久的困惑，也希望能够解决看到的小伙伴的困惑，谢谢。",
        "date": "2021-06-15T00:00:00.000Z",
        "formattedDate": "2021年6月15日",
        "tags": [
          {
            "label": "Promise",
            "permalink": "/blog/tags/promise"
          }
        ],
        "readingTime": 2.145,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "这一次，彻底搞懂Promise的状态转换",
          "date": "2021-06-15T00:00:00.000Z",
          "categories": "Promise",
          "tags": [
            "Promise"
          ]
        },
        "prevItem": {
          "title": "HOT100——合并K个升序链表（JS实现）",
          "permalink": "/blog/HOT100——合并K个升序链表（JS实现）"
        },
        "nextItem": {
          "title": "155个JavaScript基础问题（106-115）",
          "permalink": "/blog/155个JavaScript基础问题（106-115）"
        }
      },
      "content": ">这篇文章解决了我很久的困惑，也希望能够解决看到的小伙伴的困惑，谢谢。\r\n\r\n## Promise的三种状态到底是什么？\r\n1. pending\r\n2. fulfilled\r\n3. rejected\r\n\r\n## 下面我们先看下三种状态的产生\r\n### 1.pending状态的Promise\r\n```js\r\nconst promise1 = new Promise((resolve,reject) => {\r\n \r\n})\r\nconsole.log(promise1);\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/0fb0383855534c50f93755dc831b226e.png)\r\n\r\n### 2. fulfilled状态的Promise\r\n```js\r\nconst promise1 = new Promise((resolve, reject) => {\r\n    setTimeout(() => {\r\n        resolve()\r\n    })\r\n})\r\nconsole.log(promise1);\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/d9534a37142ab8666294b29cb5dcedc8.png)\r\n\r\n### 3. rejected状态的Promise\r\n```js\r\nconst promise = new Promise((resolve, reject) => {\r\n        setTimeout(() => {\r\n            reject();\r\n        })\r\n    });\r\n    console.log(promise);\r\n```\r\n\r\n## 从pending状态到fulfilled状态的变化过程\r\n* resolve()后状态从pending变为了fulfilled\r\n```js\r\nconst promise = new Promise((resolve, reject) => {\r\n        setTimeout(() => {\r\n            console.log('resolve前Promise的状态：',promise);\r\n            resolve();\r\n            console.log('resolve后Promise的状态：',promise);\r\n        })\r\n    });\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/6ec564abc907c64577e63cd1b7d42b0e.png)\r\n\r\n## 从pending状态到rejected状态的变化过程\r\n* reject()后状态从pending变为了rejected\r\n```js\r\nconst promise = new Promise((resolve, reject) => {\r\n        setTimeout(() => {\r\n            console.log(\"Promise的状态：reject前：\",promise);\r\n            reject();\r\n            console.log(\"Promise的状态：reject后：\",promise);\r\n        })\r\n    });\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/c1e78c4f0825fca4533989d8dc2208b2.png)\r\n\r\n## 下面介绍下关于Promise状态的可能的疑问\r\n### 疑问1：resolved状态和fulfilled状态是一回事吗？\r\n>答：并不是一回事，resoved状态指的是完成了，不会再改变的状态,只是一种叫法，并不是真正的状态，真正的状态还是前文提到的那三种，pending、fulfilled、rejected这三种，所以resolved状态可能是fulfilled也可能是rejected。\r\n### 疑问2：Chrome浏览器显示的状态时pending，点开却是fulfilled，到底哪个才是真正的状态？\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/1c82387f79feefc170eec32e3a156adc.png)\r\n上述的情况，我们还是可以叫做pending状态。\r\n\r\n## 参考文献\r\n[Promise中的resolved和fulfilled到底什么关系，又或者这只是叫法的问题？](https://segmentfault.com/q/1010000020423077)\r\n\r\n[Promise的状态和现象【JS面试题】](https://www.bilibili.com/video/BV1vB4y1A7xJ)"
    },
    {
      "id": "/155个JavaScript基础问题（106-115）",
      "metadata": {
        "permalink": "/blog/155个JavaScript基础问题（106-115）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/155个JavaScript基础问题（106-115）.md",
        "source": "@site/blog\\155个JavaScript基础问题（106-115）.md",
        "title": "155个JavaScript基础问题（106-115）",
        "description": "106. 输出什么？",
        "date": "2021-06-12T00:00:00.000Z",
        "formattedDate": "2021年6月12日",
        "tags": [
          {
            "label": "155个JavaScript基础问题",
            "permalink": "/blog/tags/155-个-java-script基础问题"
          }
        ],
        "readingTime": 3.675,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "155个JavaScript基础问题（106-115）",
          "date": "2021-06-12T00:00:00.000Z",
          "categories": "155个JavaScript基础问题",
          "tags": [
            "155个JavaScript基础问题"
          ]
        },
        "prevItem": {
          "title": "这一次，彻底搞懂Promise的状态转换",
          "permalink": "/blog/这一次，彻底搞懂Promise的状态转换"
        },
        "nextItem": {
          "title": "155个JavaScript基础问题（96-105）",
          "permalink": "/blog/155个JavaScript基础问题（96-105）"
        }
      },
      "content": "## 106. 输出什么？\r\n```js\r\nconst colorConfig = {\r\n  red: true,\r\n  blue: false,\r\n  green: true,\r\n  black: true,\r\n  yellow: false,\r\n}\r\n\r\nconst colors = [\"pink\", \"red\", \"blue\"]\r\n\r\nconsole.log(colorConfig.colors[1])\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/723039ea112cf76799a0fcfe0e2f1b45.png)\r\n>答：D，JS通过点访问对象属性的时候，会把colors当做一个属性，发现找不到为undefined，然后调用[1]会报错。\r\n\r\n## 107. 输出什么？\r\n```js\r\nconsole.log('❤️' === '❤️')\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/ddd3730f925cc12983cc3f8af49f98dc.png)\r\n>答：A，显然这两个字面量是相等的。\r\n\r\n## 108. 那些方法修改了原数组？\r\n```js\r\nconst emojis = ['✨', '🥑', '😍']\r\n\r\nemojis.map(x => x + '✨')\r\nemojis.filter(x => x !== '🥑')\r\nemojis.find(x => x !== '🥑')\r\nemojis.reduce((acc, cur) => acc + '✨')\r\nemojis.slice(1, 2, '✨') \r\nemojis.splice(1, 2, '✨')\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/330763e07ee315fe30a8273b5bdd3775.png)\r\n>答：map,filter,slice返回的是新数组，find返回的是数组中的某个元素，reduce返回的是一个值，只有splice是对原数组产生了更改。\r\n\r\n## 109. 输出什么？\r\n```js\r\nconst food = ['🍕', '🍫', '🥑', '🍔']\r\nconst info = { favoriteFood: food[0] }\r\n\r\ninfo.favoriteFood = '🍝'\r\n\r\nconsole.log(food)\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/526b9fcd1844e0370a0029d33ce7e28b.png)\r\n>答：A，上述代码只是修改了info中的值，并未对food对象产生任何影响。\r\n\r\n## 110. 下面的函数干了什么？\r\n```js\r\nJSON.parse()\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/1e1beba5a460368f912a4c58b12f3d94.png)\r\n>答：A，这个题就看我们对JS中常用API的了解程度了，就是将JSON字符串转换为对应的JavaScript值。\r\n\r\n## 111. 输出什么？\r\n```js\r\nlet name = 'Lydia'\r\n\r\nfunction getName() {\r\n  console.log(name)\r\n  let name = 'Sarah'\r\n}\r\n\r\ngetName()\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/faf5b041a9eb2d5d5e83c3505828093a.png)\r\n>答：D，本题中let存在变量声明的提升，但是并未进行初始化，此时存在暂时性死区，在暂时性死区中调用let定义的变量会报错，所以选D。\r\n\r\n## 112. 输出什么？\r\n```js\r\nfunction* generatorOne() {\r\n  yield ['a', 'b', 'c'];\r\n}\r\n\r\nfunction* generatorTwo() {\r\n  yield* ['a', 'b', 'c'];\r\n}\r\n\r\nconst one = generatorOne()\r\nconst two = generatorTwo()\r\n\r\nconsole.log(one.next().value)\r\nconsole.log(two.next().value)\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/70d689ccbd86275e7c2216dcc2a84135.png)\r\n>答：C，本题中的两个函数猛一看没区别，实际上第二个函数多了一个*号，所以调用第二个函数的next().value返回的其实是一个元素，所以本题选C。\r\n\r\n## 113. 输出什么？\r\n```js\r\nconsole.log(`${(x => x)('I love')} to program`)\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/2cc590f0275113522636351e34ef25c9.png)\r\n>答：A，本题的模板字符串大括号中是一个立即执行函数，所以打印的结果是A。\r\n\r\n## 114. 下面的函数将会发生什么？\r\n```js\r\nlet config = {\r\n  alert: setInterval(() => {\r\n    console.log('Alert!')\r\n  }, 1000)\r\n}\r\n\r\nconfig = null\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/adb1e4b6accd0bfcc8e120f5cea26232.png)\r\n>答：C，这是因为循环定时器中的参数是一个箭头函数，箭头函数中的上下文绑定到config了，通过赋值为null,回调函数仍然保留着对config的引用，所以循环定时器不会停止，仍然是每隔1秒继续打印，可以通过clear的方式取消掉这个循环定时器。\r\n\r\n## 115. 下面哪一个方法会返回'Hello World!'?\r\n```js\r\nconst myMap = new Map()\r\nconst myFunc = () => 'greeting'\r\n\r\nmyMap.set(myFunc, 'Hello world!')\r\n\r\n//1\r\nmyMap.get('greeting')\r\n//2\r\nmyMap.get(myFunc)\r\n//3\r\nmyMap.get(() => 'greeting')\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/38acb4041bd2753f07a90e013d70e7c1.png)\r\n>答：B，首先我们要明确一点，Map中值为Hello world!的键是myFunc的地址引用，1,2,3中只有第二个键是myFunc的地址引用，3是一个新地址，所以选B。\r\n\r\n## 题目来源\r\nhttps://github.com/lydiahallie/javascript-questions"
    },
    {
      "id": "/155个JavaScript基础问题（96-105）",
      "metadata": {
        "permalink": "/blog/155个JavaScript基础问题（96-105）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/155个JavaScript基础问题（96-105）.md",
        "source": "@site/blog\\155个JavaScript基础问题（96-105）.md",
        "title": "155个JavaScript基础问题（96-105）",
        "description": "96. 输出什么？",
        "date": "2021-06-12T00:00:00.000Z",
        "formattedDate": "2021年6月12日",
        "tags": [
          {
            "label": "155个JavaScript基础问题",
            "permalink": "/blog/tags/155-个-java-script基础问题"
          }
        ],
        "readingTime": 4.01,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "155个JavaScript基础问题（96-105）",
          "date": "2021-06-12T00:00:00.000Z",
          "categories": "155个JavaScript基础问题",
          "tags": [
            "155个JavaScript基础问题"
          ]
        },
        "prevItem": {
          "title": "155个JavaScript基础问题（106-115）",
          "permalink": "/blog/155个JavaScript基础问题（106-115）"
        },
        "nextItem": {
          "title": "HOT100——括号生成（JS实现）",
          "permalink": "/blog/HOT100——括号生成（JS实现）"
        }
      },
      "content": "## 96. 输出什么？\r\n```js\r\nclass Person {\r\n  constructor() {\r\n    this.name = \"Lydia\"\r\n  }\r\n}\r\n\r\nPerson = class AnotherPerson {\r\n  constructor() {\r\n    this.name = \"Sarah\"\r\n  }\r\n}\r\n\r\nconst member = new Person()\r\nconsole.log(member.name)\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/354480c476fe30bb33caa15b12e656f1.png)\r\n>答：B，这题可以理解为Person中存放了新的地址，Person也指向了新的类，所以其实例也是新的类的实例对象，所以打印出的是B。\r\n\r\n## 97. 输出什么？\r\n```js\r\nconst info = {\r\n  [Symbol('a')]: 'b'\r\n}\r\n\r\nconsole.log(info)\r\nconsole.log(Object.keys(info))\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/3c237c160cfc8ba12134a15e9134f41e.png)\r\n>答：D，本题意在考查我们对Symbol的理解，Symbol是不可枚举的，但是通过访问整个对象可以看到，所以答案选D。\r\n\r\n## 98. 输出什么？\r\n```js\r\nconst getList = ([x, ...y]) => [x, y]\r\nconst getUser = user => { name: user.name, age: user.age }\r\n\r\nconst list = [1, 2, 3, 4]\r\nconst user = { name: \"Lydia\", age: 21 }\r\n\r\nconsole.log(getList(list))\r\nconsole.log(getUser(user))\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/b88f5487c940b6df8760dbc343e05cfd.png)\r\n>答：A，本题意在考查数组的解构赋值和箭头函数如何返回一个对象，我们要切记箭头函数在简写的情形下，要想返回一个对象，需要用小括号包着，否则会报错，但是题目中选的是undefined,其次数组的解构赋值中拓展运算符后面存放的是一个剩余数组，所以选A。\r\n\r\n## 99. 输出什么？\r\n```js\r\nconst name = \"Lydia\"\r\n\r\nconsole.log(name())\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/73bf1a372da50af0546959eaa19c39a6.png)\r\n>答：C，本题中JS会将name当作函数运行，所以会出现类型错误。\r\n\r\n## 100. 输出什么？\r\n```js\r\n// 🎉✨ This is my 100th question! ✨🎉\r\n\r\nconst output = `${[] && 'Im'}possible!\r\nYou should${'' && `n't`} see a therapist after so much JavaScript lol`\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/be774b7942c37d9e81b36cedfca9ce6e.png)\r\n>答：B，本题主要是需要我们直到空字符串属于假的值，但是空对象和空数组都属于真值，所以本题选B。\r\n\r\n## 101. 输出什么？\r\n```js\r\nconst one = (false || {} || null)\r\nconst two = (null || false || \"\")\r\nconst three = ([] || 0 || true)\r\n\r\nconsole.log(one, two, three)\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/874aac5648513453c611a7e026081397.png)\r\n>答：C，空对象属于真值，null属于假值，[]属于真值，所以本题选C。\r\n\r\n## 102. 依次输出什么？\r\n```js\r\nconst myPromise = () => Promise.resolve('I have resolved!')\r\n\r\nfunction firstFunction() {\r\n  myPromise().then(res => console.log(res))\r\n  console.log('second')\r\n}\r\n\r\nasync function secondFunction() {\r\n  console.log(await myPromise())\r\n  console.log('second')\r\n}\r\n\r\nfirstFunction()\r\nsecondFunction()\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/362160ebbd510b66c4bfb659e0ec483b.png)\r\n>答：D，本题主要考查事件循环机制和.then和await的区别，在第一个函数中，同步代码是要优先于微任务的执行的，在第二个函数中，await会由暂停机制，等接收到成功的Promise对象后，才继续执行后续代码，所以有一种看起来是同步代码的感觉，所以本题选D。\r\n\r\n## 103. 输出什么？\r\n```js\r\nconst set = new Set()\r\n\r\nset.add(1)\r\nset.add(\"Lydia\")\r\nset.add({ name: \"Lydia\" })\r\n\r\nfor (let item of set) {\r\n  console.log(item + 2)\r\n}\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/62d92deda972e3eeb3e1c23fb142fe72.png)\r\n>答：C，本题意在考查不同类型的值通过+号后的变化，数值型的则是直接相加，字符串的则是拼接，对象形式的，则是C项的第三个那样进行拼接。\r\n\r\n## 104. 结果是什么？\r\n```js\r\nPromise.resolve(5)\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/47add6abc3a09ac442465b50aae22026.png)\r\n>答：C，通过resolve后，返回的是fulfilled的Promise.\r\n\r\n## 105. 输出什么？\r\n```js\r\nfunction compareMembers(person1, person2 = person) {\r\n  if (person1 !== person2) {\r\n    console.log(\"Not the same!\")\r\n  } else {\r\n    console.log(\"They are the same!\")\r\n  }\r\n}\r\n\r\nconst person = { name: \"Lydia\" }\r\n\r\ncompareMembers(person)\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/a16412cc2ca817d9d35aee34f41cfd72.png)\r\n>答：B，本题函数中的两个参数实际上都是Person的引用，所以答案选B。\r\n\r\n## 题目来源\r\nhttps://github.com/lydiahallie/javascript-questions"
    },
    {
      "id": "/HOT100——括号生成（JS实现）",
      "metadata": {
        "permalink": "/blog/HOT100——括号生成（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/HOT100——括号生成（JS实现）.md",
        "source": "@site/blog\\HOT100——括号生成（JS实现）.md",
        "title": "HOT100——括号生成（JS实现）",
        "description": "题目描述",
        "date": "2021-06-11T00:00:00.000Z",
        "formattedDate": "2021年6月11日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.045,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "HOT100——括号生成（JS实现）",
          "date": "2021-06-11T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "155个JavaScript基础问题（96-105）",
          "permalink": "/blog/155个JavaScript基础问题（96-105）"
        },
        "nextItem": {
          "title": "一段代码看懂原型对象中的callback",
          "permalink": "/blog/一段代码看懂原型对象中的callback"
        }
      },
      "content": "## 题目描述\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/224fe661d8d7cd2d4f092308a3857393.png)\r\n\r\n## 解题思路\r\n1. 本题采用DFS的思想。\r\n2. 只要有左括号剩余的时候，就将左括号剩余数量-1，然后继续投入DFS。\r\n3. 当左括号的长度小于有括号的长度时，将右括号剩余数量-1，然后继续投入DFS。\r\n\r\n## 实现代码\r\n```js\r\nvar generateParenthesis = function(n) {\r\n    // 定义最终返回的结果\r\n    const res = [];\r\n    dfs(n,n,'');\r\n    // dfs函数\r\n    function dfs(Lremain,Rremain,str) {\r\n        // 如果str参数的长度等于2n，说明递归结束了\r\n        if (str.length === 2*n) {\r\n            res.push(str);\r\n            return;\r\n        }\r\n        // 如果左括号剩余的多，将左括号放入递归\r\n        if (Lremain > 0) {\r\n            dfs(Lremain-1,Rremain,str+'(')\r\n        }\r\n        if (Lremain < Rremain) {\r\n            dfs(Lremain,Rremain-1,str+')')\r\n        }\r\n    }\r\n    return res;\r\n};\r\n```\r\n## 启示\r\n学会使用DFS的相关思想，来解决遍历所有情况的问题。\r\n\r\n## 参考题解\r\nhttps://leetcode-cn.com/problems/generate-parentheses/solution/shou-hua-tu-jie-gua-hao-sheng-cheng-hui-su-suan-fa/"
    },
    {
      "id": "/一段代码看懂原型对象中的callback",
      "metadata": {
        "permalink": "/blog/一段代码看懂原型对象中的callback",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/一段代码看懂原型对象中的callback.md",
        "source": "@site/blog\\一段代码看懂原型对象中的callback.md",
        "title": "一段代码看懂原型对象中的callback",
        "description": "代码图示",
        "date": "2021-06-11T00:00:00.000Z",
        "formattedDate": "2021年6月11日",
        "tags": [
          {
            "label": "JavaScript基础",
            "permalink": "/blog/tags/java-script基础"
          }
        ],
        "readingTime": 0.205,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "一段代码看懂原型对象中的callback",
          "date": "2021-06-11T00:00:00.000Z",
          "categories": "JavaScript基础",
          "tags": [
            "JavaScript基础"
          ]
        },
        "prevItem": {
          "title": "HOT100——括号生成（JS实现）",
          "permalink": "/blog/HOT100——括号生成（JS实现）"
        },
        "nextItem": {
          "title": "155个JavaScript基础问题（76-85）",
          "permalink": "/blog/155个JavaScript基础问题（76-85）"
        }
      },
      "content": "## 代码图示\r\n![](https://img-blog.csdnimg.cn/img_convert/a4882652b92f93240c19cbb8526869fe.png)\r\n\r\n```js\r\nvar s = [23, 65, 98, 5];\r\n\r\nArray.prototype.myMap = function (callback) {\r\n    var newArray = [];\r\n\r\n    this.forEach(value => newArray.push(callback(value)))\r\n\r\n    return newArray;\r\n};\r\n\r\nvar new_s = s.myMap(function (item) {\r\n    return item * 2;\r\n});\r\n```"
    },
    {
      "id": "/155个JavaScript基础问题（76-85）",
      "metadata": {
        "permalink": "/blog/155个JavaScript基础问题（76-85）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/155个JavaScript基础问题（76-85）.md",
        "source": "@site/blog\\155个JavaScript基础问题（76-85）.md",
        "title": "155个JavaScript基础问题（76-85）",
        "description": "76. 输出是什么？",
        "date": "2021-06-10T00:00:00.000Z",
        "formattedDate": "2021年6月10日",
        "tags": [
          {
            "label": "155个JavaScript基础问题",
            "permalink": "/blog/tags/155-个-java-script基础问题"
          }
        ],
        "readingTime": 3.455,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "155个JavaScript基础问题（76-85）",
          "date": "2021-06-10T00:00:00.000Z",
          "categories": "155个JavaScript基础问题",
          "tags": [
            "155个JavaScript基础问题"
          ]
        },
        "prevItem": {
          "title": "一段代码看懂原型对象中的callback",
          "permalink": "/blog/一段代码看懂原型对象中的callback"
        },
        "nextItem": {
          "title": "155个JavaScript基础问题（86-95）",
          "permalink": "/blog/155个JavaScript基础问题（86-95）"
        }
      },
      "content": "## 76. 输出是什么？\r\n```js\r\nconst { name: myName } = { name: \"Lydia\" };\r\n\r\nconsole.log(name);\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/cf4d5ee3129aef999fef4528566ce1a7.png)\r\n>答：D，题目中的解构方式相当于将字符串的值赋给了myName,而不是name,所以下文调用name，相当于调用一个没有声明的变量。\r\n\r\n## 77. 下面的函数是纯函数吗？\r\n```js\r\nfunction sum(a, b) {\r\n  return a + b;\r\n}\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/163c021cdd86b110a3445ae6bd15f7df.png)\r\n>答：A，因为同样的输入是同样的输出，且不受输入值以外的其他信息影响。\r\n\r\n## 78. 输出是什么？\r\n```js\r\nconst add = () => {\r\n  const cache = {};\r\n  return num => {\r\n    if (num in cache) {\r\n      return `From cache! ${cache[num]}`;\r\n    } else {\r\n      const result = num + 10;\r\n      cache[num] = result;\r\n      return `Calculated! ${result}`;\r\n    }\r\n  };\r\n};\r\n\r\nconst addFunction = add();\r\nconsole.log(addFunction(10));\r\nconsole.log(addFunction(10));\r\nconsole.log(addFunction(5 * 2));\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/f91f806a79c8249bc8a53bc48fbf4459.png)\r\n>答：C，本题主要考查的是闭包的理解，函数首先检查cache中是否有传入的参数，有则返回无则+10然后存进去，然后返回。\r\n\r\n## 79. 输出什么？\r\n```js\r\nconst myLifeSummedUp = [\"☕\", \"💻\", \"🍷\", \"🍫\"]\r\n\r\nfor (let item in myLifeSummedUp) {\r\n  console.log(item)\r\n}\r\n\r\nfor (let item of myLifeSummedUp) {\r\n  console.log(item)\r\n}\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/4d1010f837e3618c123b8f518f36bb9e.png)\r\n>答：A，本题意在考查我们对for-in和for-of的理解，我们只需要记住一点，for-in遍历的是键，但是for-of遍历的是值。\r\n\r\n## 80. 输出是什么?\r\n```js\r\nconst list = [1 + 2, 1 * 2, 1 / 2]\r\nconsole.log(list)\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/cdf4ae9aed953e297b91e7b4b4ecfd0f.png)\r\n>答：C，本题考查JS的默认机制。\r\n\r\n## 81. 输出什么？\r\n```js\r\nfunction sayHi(name) {\r\n  return `Hi there, ${name}`\r\n}\r\n\r\nconsole.log(sayHi())\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/1b474c22c68e9e3f26a84bb72d61b411.png)\r\n>答：B，本题由于模板字符串中没有接收到name，所以返回的是undefined，所以最终答案是B。\r\n\r\n## 82. 输出是什么？\r\n```js\r\nvar status = \"😎\"\r\n\r\nsetTimeout(() => {\r\n  const status = \"😍\"\r\n\r\n  const data = {\r\n    status: \"🥑\",\r\n    getStatus() {\r\n      return this.status\r\n    }\r\n  }\r\n\r\n  console.log(data.getStatus())\r\n  console.log(data.getStatus.call(this))\r\n}, 0)\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/607aa9c5acf3868210421d8dfe7ea76c.png)\r\n>答：B，本题意在考查setTimeout函数在特定情况下的this指向问题，在上面这种情况下，this指向的是全局，全局下正好有个😎，所以本题选B。\r\n\r\n## 83. 输出什么？\r\n```js\r\nconst person = {\r\n  name: \"Lydia\",\r\n  age: 21\r\n}\r\n\r\nlet city = person.city\r\ncity = \"Amsterdam\"\r\n\r\nconsole.log(person)\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/feb123f803a4c435b3fcbe93835c71de.png)\r\n>答：A，仔细想想本题并未对person对象添加任何属性，所以选A。\r\n\r\n## 84. 输出什么？\r\n```js\r\nfunction checkAge(age) {\r\n  if (age < 18) {\r\n    const message = \"Sorry, you're too young.\"\r\n  } else {\r\n    const message = \"Yay! You're old enough!\"\r\n  }\r\n\r\n  return message\r\n}\r\n\r\nconsole.log(checkAge(21))\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/852ca7485c598b1affbfcb84ac647c61.png)\r\n>答：C，这题真的挺坑的，意在考查const、let引起的块级作用域，由于块级作用域的存在，我们无法在块级作用域之外访问到声明的变量，请记住这个题。\r\n\r\n## 85. 下面的代码将打印出什么？\r\n```js\r\nfetch('https://www.website.com/api/user/1')\r\n  .then(res => res.json())\r\n  .then(res => console.log(res))\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/c04edcbc9a6091438801ddb2e39488d7.png)\r\n>答：C，这就是考查我们对Promise的理解程度了，必然是前一个then中回调方法返回的结果了。\r\n\r\n## 题目来源\r\nhttps://github.com/lydiahallie/javascript-questions"
    },
    {
      "id": "/155个JavaScript基础问题（86-95）",
      "metadata": {
        "permalink": "/blog/155个JavaScript基础问题（86-95）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/155个JavaScript基础问题（86-95）.md",
        "source": "@site/blog\\155个JavaScript基础问题（86-95）.md",
        "title": "155个JavaScript基础问题（86-95）",
        "description": "86. 那个选项是将hasName置为true的方法，前提是不能将true作为参数进行传递？",
        "date": "2021-06-10T00:00:00.000Z",
        "formattedDate": "2021年6月10日",
        "tags": [
          {
            "label": "155个JavaScript基础问题",
            "permalink": "/blog/tags/155-个-java-script基础问题"
          }
        ],
        "readingTime": 3.405,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "155个JavaScript基础问题（86-95）",
          "date": "2021-06-10T00:00:00.000Z",
          "categories": "155个JavaScript基础问题",
          "tags": [
            "155个JavaScript基础问题"
          ]
        },
        "prevItem": {
          "title": "155个JavaScript基础问题（76-85）",
          "permalink": "/blog/155个JavaScript基础问题（76-85）"
        },
        "nextItem": {
          "title": "155个JavaScript基础问题（66-75）",
          "permalink": "/blog/155个JavaScript基础问题（66-75）"
        }
      },
      "content": "## 86. 那个选项是将hasName置为true的方法，前提是不能将true作为参数进行传递？\r\n```js\r\nfunction getName(name) {\r\n  const hasName = //\r\n}\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/04e672abae84a5c2628008297a1b63b7.png)\r\n>答：A，对name取!返回的是布尔值，C项返回的是一个对象包装器，B返回的是name本身，D返回的是name的长度。\r\n\r\n## 87. 输出是什么？\r\n```js\r\nconsole.log(\"I want pizza\"[0])\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/65adfae8c852fc02e1213b7641c158e0.png)\r\n>答：B，本题意在告诉我们字符串也是可以通过类似数组下标的方式进行取值的。\r\n\r\n## 88. 输出什么？\r\n```js\r\nfunction sum(num1, num2 = num1) {\r\n  console.log(num1 + num2)\r\n}\r\n\r\nsum(10)\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/9ab55a4ea35a360624ef2c09ccacac7d.png)\r\n>答：B，本题考查的是函数的默认传参，在本题的情况下，如果只传一个参数，第二个参数默认是第一个参数的值。\r\n\r\n## 89. 输出什么？\r\n```js\r\n// module.js \r\nexport default () => \"Hello world\"\r\nexport const name = \"Lydia\"\r\n\r\n// index.js \r\nimport * as data from \"./module\"\r\n\r\nconsole.log(data)\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/e5765076078b3b0dd2c2898eb406400e.png)\r\n>答：A，本题意在考查import * as的用法，通过这种用法，会将module.js文件中的所有暴露导入到index.js中的data对象中，所以选A，下面是测试截图。![image.png](https://img-blog.csdnimg.cn/img_convert/56dcfc72e954462a3632d56a3967a0c8.png)\r\n\r\n## 90. 输出什么？\r\n```js\r\nclass Person {\r\n  constructor(name) {\r\n    this.name = name\r\n  }\r\n}\r\n\r\nconst member = new Person(\"John\")\r\nconsole.log(typeof member)\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/91be7189caf3620da03dd0236dd950af.png)\r\n>答：C，Person类的实例对象属于object。\r\n\r\n## 91. 输出什么？\r\n```js\r\nlet newList = [1, 2, 3].push(4)\r\n\r\nconsole.log(newList.push(5))\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/161ddcdc41e8acb23f2fa2c24311808c.png)\r\n>答：D，本题意在考查push方法的返回值，我们要知道返回的并不是一个新数组而是新数组的长度，所以给一个数字添加元素，是要报错的，所以选D。\r\n\r\n## 92. 输出什么？\r\n```js\r\nfunction giveLydiaPizza() {\r\n  return \"Here is pizza!\"\r\n}\r\n\r\nconst giveLydiaChocolate = () => \"Here's chocolate... now go hit the gym already.\"\r\n\r\nconsole.log(giveLydiaPizza.prototype)\r\nconsole.log(giveLydiaChocolate.prototype)\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/9a61a86bdfd6287b8ec7a81d4a63e7df.png)\r\n>答：D，常规函数有prototype属性，但是箭头函数没有这个属性，所以选D，下面是codepen的测试截图：![](https://img-blog.csdnimg.cn/img_convert/f81a655af70853fe53df16252f55c2a6.png)\r\n\r\n## 93. 输出什么？\r\n```js\r\nconst person = {\r\n  name: \"Lydia\",\r\n  age: 21\r\n}\r\n\r\nfor (const [x, y] of Object.entries(person)) {\r\n  console.log(x, y)\r\n}\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/285303e33a67441a654e2f31b80124e2.png)\r\n>答：A，本题意在考查Object.entries这个API的用法，这个API将对象键值对存入一个二维数组，具体解释请看下图：![image.png](https://img-blog.csdnimg.cn/img_convert/032739f3ef5147ca1fe1fefdbe07b714.png)\r\n\r\n## 94. 输出什么？\r\n```js\r\nfunction getItems(fruitList, ...args, favoriteFruit) {\r\n  return [...fruitList, ...args, favoriteFruit]\r\n}\r\n\r\ngetItems([\"banana\", \"apple\"], \"pear\", \"orange\")\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/cb825fd7c6b07a26bceca76a50a04395.png)\r\n>答：D，本题意在考查我们对拓展运算符的理解，这里的拓展运算符必须放在最后一个参数，不然会报错。![](https://img-blog.csdnimg.cn/img_convert/0d6eac0b4bc28b2db5460216f9187a56.png)\r\n\r\n## 95. 输出什么？\r\n```js\r\nfunction nums(a, b) {\r\n  if\r\n  (a > b)\r\n  console.log('a is bigger')\r\n  else \r\n  console.log('b is bigger')\r\n  return \r\n  a + b\r\n}\r\n\r\nconsole.log(nums(4, 2))\r\nconsole.log(nums(1, 2))\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/1b748ec379e5a45706607e5b341a26bc.png)\r\n>答：B，这道题有点坑，主要是JS在编译的时候会自动给return后面加个分号，所以永远访问不到a+b,所以选B。\r\n\r\n## 题目来源\r\nhttps://github.com/lydiahallie/javascript-questions"
    },
    {
      "id": "/155个JavaScript基础问题（66-75）",
      "metadata": {
        "permalink": "/blog/155个JavaScript基础问题（66-75）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/155个JavaScript基础问题（66-75）.md",
        "source": "@site/blog\\155个JavaScript基础问题（66-75）.md",
        "title": "155个JavaScript基础问题（66-75）",
        "description": "66. 使用哪个构造函数可以成功继承Dog类?",
        "date": "2021-06-09T00:00:00.000Z",
        "formattedDate": "2021年6月9日",
        "tags": [
          {
            "label": "155个JavaScript基础问题",
            "permalink": "/blog/tags/155-个-java-script基础问题"
          }
        ],
        "readingTime": 3.86,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "155个JavaScript基础问题（66-75）",
          "date": "2021-06-09T00:00:00.000Z",
          "categories": "155个JavaScript基础问题",
          "tags": [
            "155个JavaScript基础问题"
          ]
        },
        "prevItem": {
          "title": "155个JavaScript基础问题（86-95）",
          "permalink": "/blog/155个JavaScript基础问题（86-95）"
        },
        "nextItem": {
          "title": "HOT100——合并两个有序列表（JS实现）",
          "permalink": "/blog/HOT100——合并两个有序列表（JS实现）"
        }
      },
      "content": "## 66. 使用哪个构造函数可以成功继承Dog类?\r\n```js\r\nclass Dog {\r\n  constructor(name) {\r\n    this.name = name;\r\n  }\r\n};\r\n\r\nclass Labrador extends Dog {\r\n  // 1 \r\n  constructor(name, size) {\r\n    this.size = size;\r\n  }\r\n  // 2\r\n  constructor(name, size) {\r\n    super(name);\r\n    this.size = size;\r\n  }\r\n  // 3\r\n  constructor(size) {\r\n    super(name);\r\n    this.size = size;\r\n  }\r\n  // 4 \r\n  constructor(name, size) {\r\n    this.name = name;\r\n    this.size = size;\r\n  }\r\n\r\n};\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/9d08ea1710984b8bb226dcc51ac8e1da.png)\r\n>答：B，在子类调用super之前不能访问this，所以1,4会报错，在调用super的时候需要使用到子类的参数，所以2正确。\r\n\r\n## 67. 输出是什么？\r\n```js\r\n// index.js\r\nconsole.log('running index.js');\r\nimport { sum } from './sum.js';\r\nconsole.log(sum(1, 2));\r\n\r\n// sum.js\r\nconsole.log('running sum.js');\r\nexport const sum = (a, b) => a + b;\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/b8f81c1013c9d66f7f637878c0573b28.png)\r\n>答：B，此题考查的是CommonJS中require和import的区别，import是在代码编译阶段执行的，所以会先于代码执行，但是require则不同，require是需要的时候才调用。\r\n\r\n## 68. 输出是什么?\r\n```js\r\nconsole.log(Number(2) === Number(2))\r\nconsole.log(Boolean(false) === Boolean(false))\r\nconsole.log(Symbol('foo') === Symbol('foo'))\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/10769cd96df90fbd9a761487ace138ea.png)\r\n>答：B，本题意在考查我们对Symbol的认知，每个Symbol都是唯一的，给Symbol传参数，只是对Symbol的描述。\r\n\r\n## 69. 输出是什么？\r\n```js\r\nconst name = \"Lydia Hallie\"\r\nconsole.log(name.padStart(13))\r\nconsole.log(name.padStart(2))\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/5163fe2e8b801911f03f5337ce2c47da.png)\r\n>答：C，本题意在考查padStart的用法，这个API的作用是当参数大于字符串的长度时，多几个就在字符串的左侧添加几个空格，但是如果参数小于字符串的长度，则不添加。\r\n\r\n## 70. 输出是什么？\r\n```js\r\nconsole.log(\"🥑\" + \"💻\");\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/3447b23df56d9717172d954ea5fae953.png)\r\n>答：A，本题就是考查字符串拼接，不要被图画吓到。\r\n\r\n## 71. 如何能打印出console.log后面的注释值。\r\n```js\r\nfunction* startGame() {\r\n  const 答案 = yield \"Do you love JavaScript?\";\r\n  if (答案 !== \"Yes\") {\r\n    return \"Oh wow... Guess we're gone here\";\r\n  }\r\n  return \"JavaScript loves you back ❤️\";\r\n}\r\n\r\nconst game = startGame();\r\nconsole.log(/* 1 */); // Do you love JavaScript?\r\nconsole.log(/* 2 */); // JavaScript loves you back ❤️\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/063da016735e84ef0c03a334b38f5c4d.png)\r\n>答：C，本题主要考察的是生成器函数的用法和yield关键字，所以本题选C，不理解的可以查查生成器函数的用法。\r\n\r\n## 72. 输出是什么？\r\n```js\r\nconsole.log(String.raw`Hello\\nworld`);\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/876aff04df04b21fed99d12d86a87be0.png)\r\n>答：C，本题意在考查模板标记函数和String.raw这个API的用法，我们其实只需要知道String.raw会将\\n,\\t等打印出来，所以选C。\r\n\r\n## 73. 输出是什么？\r\n```js\r\nasync function getData() {\r\n  return await Promise.resolve(\"I made it!\");\r\n}\r\n\r\nconst data = getData();\r\nconsole.log(data);\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/fc53c0b3692da8295965ab124ecf9b9a.png)\r\n>答：C，通过上述方法返回的是一个等待态的Promise。\r\n\r\n## 74. 输出是什么？\r\n```js\r\nfunction addToList(item, list) {\r\n  return list.push(item);\r\n}\r\n\r\nconst result = addToList(\"apple\", [\"banana\"]);\r\nconsole.log(result);\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/aee8f1e264089363078514033e706b8d.png)\r\n>答：B，此题意在考查push方法返回值是什么，我一直以为push方法返回的是undefined，其实是添加元素后数组的长度，所以本题选B。\r\n\r\n## 75. 输出是什么？\r\n```js\r\nconst box = { x: 10, y: 20 };\r\n\r\nObject.freeze(box);\r\n\r\nconst shape = box;\r\nshape.x = 100;\r\nconsole.log(shape)\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/3d115ee358d129930832edb96a56f0e2.png)\r\n>答：B，本题意在考查Object.freeze的用法，此方法见名思意，是将对象进行冻结，使得无法对冻结的对象添加、修改、删除属性操作，在非严格模式下选B，但是在严格模式下会出现TypeError。\r\n\r\n## 题目来源\r\nhttps://github.com/lydiahallie/javascript-questions"
    },
    {
      "id": "/HOT100——合并两个有序列表（JS实现）",
      "metadata": {
        "permalink": "/blog/HOT100——合并两个有序列表（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/HOT100——合并两个有序列表（JS实现）.md",
        "source": "@site/blog\\HOT100——合并两个有序列表（JS实现）.md",
        "title": "HOT100——合并两个有序列表（JS实现）",
        "description": "题目描述",
        "date": "2021-06-09T00:00:00.000Z",
        "formattedDate": "2021年6月9日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.24,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "HOT100——合并两个有序列表（JS实现）",
          "date": "2021-06-09T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "155个JavaScript基础问题（66-75）",
          "permalink": "/blog/155个JavaScript基础问题（66-75）"
        },
        "nextItem": {
          "title": "155个JavaScript基础问题（56-65）",
          "permalink": "/blog/155个JavaScript基础问题（56-65）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/966b3fd3b508e1c8c22e0cec3e5f7b7f.png)\r\n\r\n## 解题思路\r\n* 首先我们要看清题干，本题给出的两个链表都是有序的，所以我们可以考虑双指针。\r\n* 使用一个指针指向了l1的头节点，使用另一个指针指向l2的头节点，比较大小谁小谁添加到新节点的下一个。\r\n* 当一个遍历完之后，结束循环，如果另一个有剩余则将其全部加到最新的链表末尾。\r\n\r\n## 解题代码\r\n```js\r\nvar mergeTwoLists = function(l1, l2) {\r\n    // 首先两个链表都是升序的，我们可以考虑双指针\r\n    let left = l1;\r\n    let right = l2;\r\n    const node = new ListNode();\r\n    let head = node;\r\n    while (left && right) {\r\n        if (left.val < right.val) {\r\n            head.next = left;\r\n            left = left.next; \r\n            head = head.next;\r\n        } else {\r\n            head.next = right;\r\n            right = right.next;\r\n            head = head.next;\r\n        }\r\n    }\r\n    if (!left && right) {\r\n        head.next = right;\r\n    }\r\n    if (!right && left) {\r\n        head.next = left;\r\n    }\r\n    return node.next\r\n};\r\n```\r\n\r\n## 启示\r\n* 学会使用双指针来对链表进行合并排序。"
    },
    {
      "id": "/155个JavaScript基础问题（56-65）",
      "metadata": {
        "permalink": "/blog/155个JavaScript基础问题（56-65）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/155个JavaScript基础问题（56-65）.md",
        "source": "@site/blog\\155个JavaScript基础问题（56-65）.md",
        "title": "155个JavaScript基础问题（56-65）",
        "description": "56. 输出是什么？",
        "date": "2021-06-08T00:00:00.000Z",
        "formattedDate": "2021年6月8日",
        "tags": [
          {
            "label": "155个JavaScript基础问题",
            "permalink": "/blog/tags/155-个-java-script基础问题"
          }
        ],
        "readingTime": 3.665,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "155个JavaScript基础问题（56-65）",
          "date": "2021-06-08T00:00:00.000Z",
          "categories": "155个JavaScript基础问题",
          "tags": [
            "155个JavaScript基础问题"
          ]
        },
        "prevItem": {
          "title": "HOT100——合并两个有序列表（JS实现）",
          "permalink": "/blog/HOT100——合并两个有序列表（JS实现）"
        },
        "nextItem": {
          "title": "HOT100——删除链表的倒数第N个节点（JS实现）",
          "permalink": "/blog/HOT100——删除链表的倒数第N个节点（JS实现）"
        }
      },
      "content": "## 56. 输出是什么？\r\n```js\r\nconst set = new Set([1, 1, 2, 3, 4]);\r\n\r\nconsole.log(set);\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/bf1f348e4a49fdd0687e198b179cf9d7.png)\r\n\r\n>答：D、本题考查集合的用法，集合有去重的功能，所以答案是打印出集合形式的1 2 3 4.\r\n\r\n## 57. 输出是什么？\r\n```js\r\n// counter.js\r\nlet counter = 10;\r\nexport default counter;\r\n```\r\n```js\r\n// index.js\r\nimport myCounter from \"./counter\";\r\n\r\nmyCounter += 1;\r\n\r\nconsole.log(myCounter);\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/a6ae112b4782d31c229f0067d0830886.png)\r\n>答：C，引入的模块是只读的，不能修改引入的模块。\r\n\r\n## 58. 输出是什么？\r\n```js\r\nconst name = \"Lydia\";\r\nage = 21;\r\n\r\nconsole.log(delete name);\r\nconsole.log(delete age);\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/5e635dd2a56d54183141e46546652442.png)\r\n>答：A，只需记住一点，属性是还可以删除的，定义的变量无法使用delete的，age相当于给全局对象添加属性，name则是定义变量。\r\n\r\n## 59. 输出是什么？\r\n```js\r\nconst numbers = [1, 2, 3, 4, 5];\r\nconst [y] = numbers;\r\n\r\nconsole.log(y);\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/eb9e9ada553a3b5a2c97aca528609db1.png)\r\n>答：C，本题主要考察数组的解构赋值，所以y是1，因为需要个数上对应。\r\n\r\n## 60. 输出是什么？\r\n```js\r\nconst user = { name: \"Lydia\", age: 21 };\r\nconst admin = { admin: true, ...user };\r\n\r\nconsole.log(admin);\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/175bc12ae319e546bc775b2d16830eb2.png)\r\n>答：B，本题主要考察的是通过拓展运算符对对象进行解构，所以答案选B。\r\n\r\n## 61. 输出是什么？\r\n```js\r\nconst person = { name: \"Lydia\" };\r\n\r\nObject.defineProperty(person, \"age\", { value: 21 });\r\n\r\nconsole.log(person);\r\nconsole.log(Object.keys(person));\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/2b0dc02cd70ed2b5bc62e2196a879332.png)\r\n>答：B，本题主要考察的是defineProperty的用法，通过该方法给对象添加的属性，需要声明其属性是否可迭代，如果没有声明默认是不可迭代，所以本题选B。\r\n\r\n## 62. 输出是什么？\r\n```js\r\nconst settings = {\r\n  username: \"lydiahallie\",\r\n  level: 19,\r\n  health: 90\r\n};\r\n\r\nconst data = JSON.stringify(settings, [\"level\", \"health\"]);\r\nconsole.log(data);\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/56442ae1658487bfbffeafd86d0f732b.png)\r\n>答：A，本题主要考察JSON.stringify的用法，第二个参数意味着将哪些属性转换为字符串，所以本题选A。\r\n\r\n## 63. 输出是什么？\r\n```js\r\nlet num = 10;\r\n\r\nconst increaseNumber = () => num++;\r\nconst increasePassedNumber = number => number++;\r\n\r\nconst num1 = increaseNumber();\r\nconst num2 = increasePassedNumber(num1);\r\n\r\nconsole.log(num1);\r\nconsole.log(num2);\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/7c0436538e11a875650f3c62738551d9.png)\r\n>答：A，本题主要考察的是x++的调用顺序问题，两次调用都是将10返回之后再加的。\r\n\r\n## 64. 输出是什么？\r\n```js\r\nconst value = { number: 10 };\r\n\r\nconst multiply = (x = { ...value }) => {\r\n  console.log(x.number *= 2);\r\n};\r\n\r\nmultiply();\r\nmultiply();\r\nmultiply(value);\r\nmultiply(value);\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/b73f5243b9d9bd2ba96c7711f4d1e5bd.png)\r\n>答：C，本题考查的是默认参数和传参的区别，通过默认参数每次都会创建一个新对象，对源对象没有影响，但是直接传参的话，如果传的是引用，则会产生影响。\r\n\r\n## 65. 输出是什么？\r\n```js\r\n[1, 2, 3, 4].reduce((x, y) => console.log(x, y));\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/7c6a1f917bf09486aea74ec4a4f58c8d.png)\r\n>答：D，本题主要考察的是reduce函数的用法，reduce的第一个参数是累积器的值，第二个参数的值是当前元素的值，如果不指定累积器的值，那么累积器的值是第一个元素的值即1，y是2。后面由于没有加减操作，所以累积器为undefined.\r\n\r\n## 题目来源\r\nhttps://github.com/lydiahallie/javascript-questions\r\n\r\n## 欢迎大家关注专栏，每日更新。"
    },
    {
      "id": "/HOT100——删除链表的倒数第N个节点（JS实现）",
      "metadata": {
        "permalink": "/blog/HOT100——删除链表的倒数第N个节点（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/HOT100——删除链表的倒数第N个节点（JS实现）.md",
        "source": "@site/blog\\HOT100——删除链表的倒数第N个节点（JS实现）.md",
        "title": "HOT100——删除链表的倒数第N个节点（JS实现）",
        "description": "题目描述",
        "date": "2021-06-08T00:00:00.000Z",
        "formattedDate": "2021年6月8日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.945,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "HOT100——删除链表的倒数第N个节点（JS实现）",
          "date": "2021-06-08T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "155个JavaScript基础问题（56-65）",
          "permalink": "/blog/155个JavaScript基础问题（56-65）"
        },
        "nextItem": {
          "title": "155个JavaScript基础问题（41-45）",
          "permalink": "/blog/155个JavaScript基础问题（41-45）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/e3046f870e63461d60c4eb2e81ceeb12.png)\r\n\r\n## 解题思路\r\n* 本题主要思路是使用哈希表，具体思路如下：\r\n1. 使用哈希表存储每一个节点，键为第几个元素，值为当前节点指针。\r\n2. 找到倒数第几个节点的键。\r\n3. 修改当前键的值的前一个和后一个nxet域即可。\r\n\r\n## 实现代码\r\n```js\r\nvar removeNthFromEnd = function(head, n) {\r\n    if (!head) return null;\r\n    // 建立哈希表\r\n    const m = new Map();\r\n    // 让临时指针指向head\r\n    let temp = head;\r\n    let i = 1;\r\n    // 循环开始\r\n    while (temp) {\r\n        m.set(i,temp);\r\n        temp = temp.next;\r\n        i++;\r\n    }\r\n    const x = i - n;\r\n    if (x > 1) {\r\n        m.get(x-1).next = m.get(x+1) || null;\r\n    } else {\r\n        return head.next;\r\n    }\r\n\r\n    return head\r\n};\r\n```\r\n\r\n## 启示\r\n* 学会通过哈希表来遍历链表节点。"
    },
    {
      "id": "/155个JavaScript基础问题（41-45）",
      "metadata": {
        "permalink": "/blog/155个JavaScript基础问题（41-45）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/155个JavaScript基础问题（41-45）.md",
        "source": "@site/blog\\155个JavaScript基础问题（41-45）.md",
        "title": "155个JavaScript基础问题（41-45）",
        "description": "41. 输出是什么?",
        "date": "2021-06-07T00:00:00.000Z",
        "formattedDate": "2021年6月7日",
        "tags": [
          {
            "label": "155个JavaScript基础问题",
            "permalink": "/blog/tags/155-个-java-script基础问题"
          }
        ],
        "readingTime": 2.38,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "155个JavaScript基础问题（41-45）",
          "date": "2021-06-07T00:00:00.000Z",
          "categories": "155个JavaScript基础问题",
          "tags": [
            "155个JavaScript基础问题"
          ]
        },
        "prevItem": {
          "title": "HOT100——删除链表的倒数第N个节点（JS实现）",
          "permalink": "/blog/HOT100——删除链表的倒数第N个节点（JS实现）"
        },
        "nextItem": {
          "title": "155个JavaScript基础问题（46-55）",
          "permalink": "/blog/155个JavaScript基础问题（46-55）"
        }
      },
      "content": "## 41. 输出是什么?\r\n```js\r\n!!null\r\n!!''\r\n!!1\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/ad7d109357cd905beef89d1deca1535e.png)\r\n>答：B，本题属于考查让我们判断哪些属于真值，哪些属于假值。三个语句全都采用了两次非，所以我们直接可以看除去!的元素即可，null,''均属于假值，1则属于真值，所以本题选B。\r\n\r\n## 42. setInterval方法的返回值是什么？\r\n```js\r\nsetInterval(() => console.log('Hi'), 1000)\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/215031ce92305e6ef466680d744963fe.png)\r\n>答：A，本题考查我们对循环定时器的熟系程度，循环定时器之所以要返回一个id，是因为在很多时候，我们卸载组件后，同时需要将循环定时器关闭，如何关闭呢？所以开发人员为我们提供了一个循环定时器id，这个id就是循环定时器的返回结果。\r\n\r\n## 43. 输出是什么？\r\n```js\r\n[...'Lydia']\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/c03b3ecb095b57c9657157633b601b49.png)\r\n>答：A，本题考查拓展运算符，首先字符串类型的值是属于可迭代的，所以拓展运算符会把字符串中的每个元素映射成一个字符，然后放到数组中，如下图所示。![](https://img-blog.csdnimg.cn/img_convert/5fa1055c387456b9322c8d6ddaa1e339.png)\r\n\r\n## 44. 输出是什么？\r\n```js\r\nfunction* generator(i) {\r\n  yield i;\r\n  yield i * 2;\r\n}\r\n\r\nconst gen = generator(10);\r\n\r\nconsole.log(gen.next().value);\r\nconsole.log(gen.next().value);\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/d3d008cdbe2a125a68a222fb572fdb53.png)\r\n>答：C，本题考查的是生成器函数，生成器函数是一种可以暂停的函数，通过next调用生成器函数，但是遇到yield则暂停，并返回生成的结果，然后下一个next，继续从暂停的位置继续运行。\r\n\r\n## 45. 返回值是什么？\r\n```js\r\nconst firstPromise = new Promise((res, rej) => {\r\n  setTimeout(res, 500, \"one\");\r\n});\r\n\r\nconst secondPromise = new Promise((res, rej) => {\r\n  setTimeout(res, 100, \"two\");\r\n});\r\n\r\nPromise.race([firstPromise, secondPromise]).then(res => console.log(res));\r\n```\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/a407efead08e411f3778347cae3ad459.png)\r\n>答：B，本题主要是考查Promise.race方法，针对这个方法，我们只需要记住一点，谁先执行完就是谁，所以本题选B，因为第二个Promise,100ms就执行完了。\r\n\r\n## 题目来源\r\nhttps://github.com/lydiahallie/javascript-questions"
    },
    {
      "id": "/155个JavaScript基础问题（46-55）",
      "metadata": {
        "permalink": "/blog/155个JavaScript基础问题（46-55）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/155个JavaScript基础问题（46-55）.md",
        "source": "@site/blog\\155个JavaScript基础问题（46-55）.md",
        "title": "155个JavaScript基础问题（46-55）",
        "description": "46. 输出是什么？",
        "date": "2021-06-07T00:00:00.000Z",
        "formattedDate": "2021年6月7日",
        "tags": [
          {
            "label": "155个JavaScript基础问题",
            "permalink": "/blog/tags/155-个-java-script基础问题"
          }
        ],
        "readingTime": 3.73,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "155个JavaScript基础问题（46-55）",
          "date": "2021-06-07T00:00:00.000Z",
          "categories": "155个JavaScript基础问题",
          "tags": [
            "155个JavaScript基础问题"
          ]
        },
        "prevItem": {
          "title": "155个JavaScript基础问题（41-45）",
          "permalink": "/blog/155个JavaScript基础问题（41-45）"
        },
        "nextItem": {
          "title": "刷题打卡获得掘金随机周边感言",
          "permalink": "/blog/刷题打卡获得掘金随机周边感言"
        }
      },
      "content": "## 46. 输出是什么？\r\n```js\r\nlet person = { name: \"Lydia\" };\r\nconst members = [person];\r\nperson = null;\r\n\r\nconsole.log(members);\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/b30d203ba99176abeb72a39af99cba99.png)\r\n>答：D，很多朋友认为person改为了null，members中的person也应该变为null，其实person中存放的是对象的地址，members[0]中存放的也是这个对象的地址，person只是将地址置为了null,并不影响members[0]中存放的地址，所以本题选D。\r\n\r\n## 47. 输出是什么？\r\n```js\r\nconst person = {\r\n  name: \"Lydia\",\r\n  age: 21\r\n};\r\n\r\nfor (const item in person) {\r\n  console.log(item);\r\n}\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/6f235c428dde7e99060c918ea6d3bcdd.png)\r\n>答：B，本题考查的是for in循环，该循环遍历的是对象的键，而对象的键在底层存放的都是字符串。\r\n\r\n## 48. 输出是什么？\r\n```js\r\nconsole.log(3 + 4 + \"5\");\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/dd3a1a06e0504f5ad501b1d6df118107.png)\r\n>答：B,此题考查的是运算符\r\n\r\n## 49. num的值是什么？\r\n```js\r\nconst num = parseInt(\"7*6\", 10);\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/ddb97edd2c50d987ca7393df618fa052.png)\r\n>答：C，本题想考查的是parseInt在进制转换的用法，本意是想将第一个参数转为十进制数字，但是解析到*便暂停了，所以是7.\r\n\r\n## 50. 输出是什么？\r\n```js\r\n[1, 2, 3].map(num => {\r\n  if (typeof num === \"number\") return;\r\n  return num * 2;\r\n});\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/32fb5d6ae9fd340dfa13e32ed4cc297d.png)\r\n>答：C，本题考查map的用法，但是每一个元素都返回的是undefined.\r\n\r\n## 51. 输出是什么？\r\n```js\r\nfunction getInfo(member, year) {\r\n  member.name = \"Lydia\";\r\n  year = \"1998\";\r\n}\r\n\r\nconst person = { name: \"Sarah\" };\r\nconst birthYear = \"1997\";\r\n\r\ngetInfo(person, birthYear);\r\n\r\nconsole.log(person, birthYear);\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/7079502590112411296af8f1f1e76c2e.png)\r\n>答：A，本题考查函数传参过程中是值传递还是引用传递，传递一个对象是引用传递，引用传递会影响到引用本身，但是值传递则不会。\r\n\r\n## 52. 输出是什么？\r\n```js\r\nfunction greeting() {\r\n  throw \"Hello world!\";\r\n}\r\n\r\nfunction sayHi() {\r\n  try {\r\n    const data = greeting();\r\n    console.log(\"It worked!\", data);\r\n  } catch (e) {\r\n    console.log(\"Oh no an error:\", e);\r\n  }\r\n}\r\n\r\nsayHi();\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/6059f0c81e12324f8e43c35b3fdd17a7.png)\r\n>答：D，本题考查try catch的用法，当greeting函数返回一个错误时，便不再继续执行try中的其他语句了，并将错误字符串传给e,所以最后打印的是D。\r\n\r\n## 53. 输出是什么？\r\n```js\r\nfunction Car() {\r\n  this.make = \"Lamborghini\";\r\n  return { make: \"Maserati\" };\r\n}\r\n\r\nconst myCar = new Car();\r\nconsole.log(myCar.make);\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/7c4ab633a3d75090e8883ece7e8dcdf6.png)\r\n>答：B，返回属性时，值不是构造函数设定的值，而是返回的值，所以选B![image.png](https://img-blog.csdnimg.cn/img_convert/7bac1fab5bed57681ad21465756e4eea.png)\r\n\r\n## 54. 输出是什么？\r\n```js\r\n(() => {\r\n  let x = (y = 10);\r\n})();\r\n\r\nconsole.log(typeof x);\r\nconsole.log(typeof y);\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/26062dea48bf6281e80a560835614f54.png)\r\n>答：A，本题考查的是立即执行函数和函数的执行顺序问题，所以本题y是number类型的，x属于undefined类型的。\r\n\r\n## 55. 输出是什么？\r\n```js\r\nclass Dog {\r\n  constructor(name) {\r\n    this.name = name;\r\n  }\r\n}\r\n\r\nDog.prototype.bark = function() {\r\n  console.log(`Woof I am ${this.name}`);\r\n};\r\n\r\nconst pet = new Dog(\"Mara\");\r\n\r\npet.bark();\r\n\r\ndelete Dog.prototype.bark;\r\n\r\npet.bark();\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/b6bbe4fff518a75dd254dbce49f52e59.png)\r\n>答：A，本题考查原型链的问题，原型对象中的this也是指向实例对象的，所以ABC三个选项的第一部分都是对的，通过delete方法删除了原型对象上的bark方法，所以此时再次调用bark会报错，所以此时只有A是对的。\r\n\r\n## 题目来源\r\nhttps://github.com/lydiahallie/javascript-questions"
    },
    {
      "id": "/刷题打卡获得掘金随机周边感言",
      "metadata": {
        "permalink": "/blog/刷题打卡获得掘金随机周边感言",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/刷题打卡获得掘金随机周边感言.md",
        "source": "@site/blog\\刷题打卡获得掘金随机周边感言.md",
        "title": "刷题打卡获得掘金随机周边感言",
        "description": "时间：2021-4-22",
        "date": "2021-06-07T00:00:00.000Z",
        "formattedDate": "2021年6月7日",
        "tags": [
          {
            "label": "个人荣誉记录",
            "permalink": "/blog/tags/个人荣誉记录"
          }
        ],
        "readingTime": 0.68,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "刷题打卡获得掘金随机周边感言",
          "date": "2021-06-07T00:00:00.000Z",
          "categories": "个人荣誉记录",
          "tags": [
            "个人荣誉记录"
          ]
        },
        "prevItem": {
          "title": "155个JavaScript基础问题（46-55）",
          "permalink": "/blog/155个JavaScript基础问题（46-55）"
        },
        "nextItem": {
          "title": "掘力计划月度榜单获奖感言",
          "permalink": "/blog/掘力计划月度榜单获奖感言"
        }
      },
      "content": "时间:mag:：2021-4-22\r\n\r\n## 发现同道中人:sailboat:\r\n从今年三月份开始计划刷LeetCode，正巧无意中在掘金论坛发现了四月刷题打卡活动，通过刷题打卡连续14天可以获得掘金随机周边一件，我比较喜欢掘金的桌垫，哈哈，然后就开始在掘金进行打卡刷题，在刷题的过程中，我发现掘金的编辑器的自定义主题功能真的不错，很喜欢。\r\n## 刷题过程:strawberry:\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20210422160052.png)\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20210422160120.png)\r\n\r\n## 获奖了:palm_tree:\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20210422160355.png)"
    },
    {
      "id": "/掘力计划月度榜单获奖感言",
      "metadata": {
        "permalink": "/blog/掘力计划月度榜单获奖感言",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/掘力计划月度榜单获奖感言.md",
        "source": "@site/blog\\掘力计划月度榜单获奖感言.md",
        "title": "掘力计划月度榜单获奖感言",
        "description": "午休醒来，看到掘金上的通知数字，以为只是普通的评论与点赞，点开才发现原来是一个获奖通知。",
        "date": "2021-06-07T00:00:00.000Z",
        "formattedDate": "2021年6月7日",
        "tags": [
          {
            "label": "个人荣誉记录",
            "permalink": "/blog/tags/个人荣誉记录"
          }
        ],
        "readingTime": 0.695,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "掘力计划月度榜单获奖感言",
          "date": "2021-06-07T00:00:00.000Z",
          "categories": "个人荣誉记录",
          "tags": [
            "个人荣誉记录"
          ]
        },
        "prevItem": {
          "title": "刷题打卡获得掘金随机周边感言",
          "permalink": "/blog/刷题打卡获得掘金随机周边感言"
        },
        "nextItem": {
          "title": "155个JavaScript基础问题（31-40）",
          "permalink": "/blog/155个JavaScript基础问题（31-40）"
        }
      },
      "content": ">午休醒来，看到掘金上的通知数字，以为只是普通的评论与点赞，点开才发现原来是一个获奖通知。\r\n## 获奖通知快照\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20210607145231.png)\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20210607145256.png)\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20210607145323.png)\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20210607145343.png)\r\n\r\n## 个人快报\r\n ![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/fc182880a9edf6d8f9d061f4a279c05.png)\r\n## 感言\r\n>本次获奖真的很意外，坚持写文章，说实话不是为了点赞和流量，只是想记录自己的学习过程，并希望给遇到同样问题的同学提供一些解决方案，今后的日子里，就像掘金说的，代码不停，掘金不止。"
    },
    {
      "id": "/155个JavaScript基础问题（31-40）",
      "metadata": {
        "permalink": "/blog/155个JavaScript基础问题（31-40）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/155个JavaScript基础问题（31-40）.md",
        "source": "@site/blog\\155个JavaScript基础问题（31-40）.md",
        "title": "155个JavaScript基础问题（31-40）",
        "description": "31. 当点击按钮时,event.target是什么？",
        "date": "2021-06-06T00:00:00.000Z",
        "formattedDate": "2021年6月6日",
        "tags": [
          {
            "label": "155个JavaScript基础问题",
            "permalink": "/blog/tags/155-个-java-script基础问题"
          }
        ],
        "readingTime": 3.12,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "155个JavaScript基础问题（31-40）",
          "date": "2021-06-06T00:00:00.000Z",
          "categories": "155个JavaScript基础问题",
          "tags": [
            "155个JavaScript基础问题"
          ]
        },
        "prevItem": {
          "title": "掘力计划月度榜单获奖感言",
          "permalink": "/blog/掘力计划月度榜单获奖感言"
        },
        "nextItem": {
          "title": "HOT100——电话号码的字母组合（JS实现）",
          "permalink": "/blog/HOT100——电话号码的字母组合（JS实现）"
        }
      },
      "content": "## 31. 当点击按钮时,event.target是什么？\r\n```js\r\n<div onclick=\"console.log('first div')\">\r\n  <div onclick=\"console.log('second div')\">\r\n    <button onclick=\"console.log('button')\">\r\n      Click!\r\n    </button>\r\n  </div>\r\n</div>\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/11b5e19532086ea655412bad59c7fdae.png)\r\n>答：C，触发事件的对象的引用是button.\r\n\r\n## 32. 单击该段落时，输出是什么？\r\n```js\r\n<div onclick=\"console.log('div')\">\r\n  <p onclick=\"console.log('p')\">\r\n    Click here!\r\n  </p>\r\n</div>\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/f50214891000d89972b313aafc698601.png)\r\n>答：A，本题考查的是事件冒泡。\r\n\r\n## 33. 输出是什么？\r\n```js\r\nconst person = { name: 'Lydia' }\r\n\r\nfunction sayHi(age) {\r\n  console.log(`${this.name} is ${age}`)\r\n}\r\n\r\nsayHi.call(person, 21)\r\nsayHi.bind(person, 21)\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/e903932b0a9e9295230ba0a1334118d8.png)\r\n>答：D，本题之所以选D的原因在于，call是立即执行的，bind返回一个函数。\r\n\r\n## 34. 输出是什么？\r\n```js\r\nfunction sayHi() {\r\n  return (() => 0)()\r\n}\r\n\r\ntypeof sayHi()\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/16d7ca36183c8439517ead1f1efb54bd.png)\r\n>答：B,这是因为sayHi函数返回的是一个立即执行函数的结果，所以返回的是0,0属于number类型的。\r\n\r\n## 35. 下面哪些值是假值?\r\n```js\r\n0\r\nnew Number(0)\r\n('')\r\n(' ')\r\nnew Boolean(false)\r\nundefined\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/3aa8f94d26bf08ae74c01f33c31e74af.png)\r\n>答：A，首先我们要明确一点，new Number和new Boolean都不是字面量了，而是一个对象，所以他们不等价于假值，'' 和 ' '这两个也不一样，一个是空串可以表示假值，但是另一个是空格，不代表假值，所以本题选A。![](https://img-blog.csdnimg.cn/img_convert/4b70977ca0d800b86f79ed062bd27545.png)\r\n\r\n## 36. 输出是什么？\r\n```js\r\nconsole.log(typeof typeof 1)\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/827d9593b19cdd7426309613ce3685d4.png)\r\n>答：B，这题有点坑，是因为typeof 1返回的是字符串 \"number\",这也就是为什么再次typeof返回的是string了。\r\n\r\n## 37. 输出是什么？\r\n```js\r\nconst numbers = [1, 2, 3]\r\nnumbers[10] = 11\r\nconsole.log(numbers)\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/5f031f06ee244ed581f20845d21f4c52.png)\r\n>答：C，当给超过数组长度的位置设置值的时候，其实中间都是undefined，打印出来就像下面这样。![](https://img-blog.csdnimg.cn/img_convert/cc825869d50be7b230a4f33af2758dff.png)\r\n\r\n## 38. 输出是什么？\r\n```js\r\n(() => {\r\n  let x, y\r\n  try {\r\n    throw new Error()\r\n  } catch (x) {\r\n    (x = 1), (y = 2)\r\n    console.log(x)\r\n  }\r\n  console.log(x)\r\n  console.log(y)\r\n})()\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/cead90fab41f3e01514a90e70acb45cf.png)\r\n>答：A，这道题主要是想考察catch会形成一个块级作用域，catch中接收到的x和let 定义的x不是同一个，但是catch中操作的y是同一个，这也就是为什么返回的是1 undefined 2的原因了。\r\n\r\n## 39. JavaScript中的一切都是什么？\r\n![](https://img-blog.csdnimg.cn/img_convert/ddf03a3cc57920dc09c155264c4d742e.png)\r\n>答：A，这道题我原本想选C来着，但是仔细想想单纯的字面量必须要归为一类。\r\n## 40. 输出是什么？\r\n```js\r\n[[0, 1], [2, 3]].reduce(\r\n  (acc, cur) => {\r\n    return acc.concat(cur)\r\n  },\r\n  [1, 2]\r\n)\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/815bff5a602c255bd9cde8333c27c747.png)\r\n>答：C，这题没有什么坑，关键就是看清一点，使用reduce之前给了初始值[1,2].\r\n\r\n## 题目来源\r\nhttps://github.com/lydiahallie/javascript-questions\r\n## 欢迎大家批评指针，共同努力，共同进步！"
    },
    {
      "id": "/HOT100——电话号码的字母组合（JS实现）",
      "metadata": {
        "permalink": "/blog/HOT100——电话号码的字母组合（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/HOT100——电话号码的字母组合（JS实现）.md",
        "source": "@site/blog\\HOT100——电话号码的字母组合（JS实现）.md",
        "title": "HOT100——电话号码的字母组合（JS实现）",
        "description": "题目描述",
        "date": "2021-06-06T00:00:00.000Z",
        "formattedDate": "2021年6月6日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.205,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "HOT100——电话号码的字母组合（JS实现）",
          "date": "2021-06-06T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "155个JavaScript基础问题（31-40）",
          "permalink": "/blog/155个JavaScript基础问题（31-40）"
        },
        "nextItem": {
          "title": "Antd V4版本中Form resetFields无效",
          "permalink": "/blog/Antd V4版本中Form resetFields无效"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/a2372e2a19aaa2917c9d41bf4a1a093d.png)\r\n\r\n## 解题思路\r\n* 本题采用的是DFS的解题思路。\r\n* 本题的特点在于递归中有循环。\r\n* DFS函数接收两个参数，一个是当前字符串，一个是指针，当指针超过了digits的长度的时候，说明可以存储并返回了，然后上一层循环继续遍历下一个字符，真的很奇妙。\r\n\r\n## 解题代码\r\n```js\r\nvar letterCombinations = function(digits) {\r\n    // 边界条件\r\n    if (digits === '') return [];\r\n    // 构建2-9对应字符的哈希表\r\n    const m = new Map();\r\n    m.set('2','abc');\r\n    m.set('3','def');\r\n    m.set('4','ghi');\r\n    m.set('5','jkl');\r\n    m.set('6','mno');\r\n    m.set('7','pqrs');\r\n    m.set('8','tuv');\r\n    m.set('9','wxyz');\r\n    \r\n    // 定义返回的数组\r\n    const res = [];\r\n    // 使用DFS的思想\r\n    function dfs(str,pointer) {\r\n        // 递归的结束条件\r\n        if (pointer > digits.length-1) {\r\n            res.push(str);\r\n            return;\r\n        }\r\n        let letters = m.get(digits[pointer]);\r\n        for (let v of letters) {\r\n            dfs(str + v,pointer + 1);\r\n        }\r\n        return;\r\n    }\r\n    dfs('',0)\r\n    return res\r\n};\r\n```\r\n## 启示\r\n* 学会DFS的思想。\r\n* 在DFS中加入循环是解决这类问题的好方法。\r\n\r\n## 参考链接\r\nhttps://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/shou-hua-tu-jie-liang-chong-jie-fa-dfshui-su-bfsya/"
    },
    {
      "id": "/Antd V4版本中Form resetFields无效",
      "metadata": {
        "permalink": "/blog/Antd V4版本中Form resetFields无效",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Antd V4版本中Form resetFields无效.md",
        "source": "@site/blog\\Antd V4版本中Form resetFields无效.md",
        "title": "Antd V4版本中Form resetFields无效",
        "description": "问题描述",
        "date": "2021-06-05T00:00:00.000Z",
        "formattedDate": "2021年6月5日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.84,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Antd V4版本中Form resetFields无效",
          "date": "2021-06-05T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "HOT100——电话号码的字母组合（JS实现）",
          "permalink": "/blog/HOT100——电话号码的字母组合（JS实现）"
        },
        "nextItem": {
          "title": "HOT100——三数之和（JS实现）",
          "permalink": "/blog/HOT100——三数之和（JS实现）"
        }
      },
      "content": "## 问题描述\r\n* 给表单中的每一个表单项传入一个参数的时候，参数已经传进去了，但是initialValue并没有发生变化。\r\n![](https://img-blog.csdnimg.cn/img_convert/f93418bd92cf40a2b4eae38046373697.png)\r\n\r\n## 原因\r\n>这是因为调用resetFileds的时机不对，也就是生命周期的问题。\r\n\r\n## 解决办法\r\n* 在生命周期函数componentDidUpdate中添加下面的代码即可。\r\n```js\r\ncomponentDidUpdate() {\r\n    if (this.formRef.current !== null) {\r\n        this.formRef.current.resetFields();\r\n    }\r\n}\r\n```\r\n\r\n## 全部代码\r\n```js\r\nexport default class UpdateForm extends Component {\r\n    formRef = React.createRef();\r\n    static propTypes = {\r\n        categoryName: PropTypes.string.isRequired\r\n    }\r\n    componentDidUpdate() {\r\n        if (this.formRef.current !== null) {\r\n            this.formRef.current.resetFields();\r\n        }\r\n    }\r\n    render() {\r\n        const { categoryName } = this.props;\r\n        \r\n        console.log(categoryName);\r\n        \r\n        return (\r\n            <Form ref={this.formRef}>\r\n                    \r\n                <Item initialValue={categoryName} name=\"categoryName\" >\r\n                    <Input placeholder=\"请输入分类名称\" />\r\n                </Item>\r\n                    \r\n            </Form>\r\n        )\r\n    }\r\n}\r\n```"
    },
    {
      "id": "/HOT100——三数之和（JS实现）",
      "metadata": {
        "permalink": "/blog/HOT100——三数之和（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/HOT100——三数之和（JS实现）.md",
        "source": "@site/blog\\HOT100——三数之和（JS实现）.md",
        "title": "HOT100——三数之和（JS实现）",
        "description": "题目描述",
        "date": "2021-06-05T00:00:00.000Z",
        "formattedDate": "2021年6月5日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 2.16,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "HOT100——三数之和（JS实现）",
          "date": "2021-06-05T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "Antd V4版本中Form resetFields无效",
          "permalink": "/blog/Antd V4版本中Form resetFields无效"
        },
        "nextItem": {
          "title": "HOT100——盛最多水的容器（JS实现）",
          "permalink": "/blog/HOT100——盛最多水的容器（JS实现）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/9d17834ec2c713d5a84e50fef5ddbaef.png)\r\n\r\n## 解题思路\r\n1. 如果元素的个数小于3，直接返回空数组。\r\n2. 对数组进行从小到大排序。\r\n3. 定义三个指针，分别是i,left,right。其中i是我们固定循环的指针，一直循环到nums.length - 2,其中left每次开始循环的时候是比i+1,right每次开始循环是最后一个数字。\r\n4. 当三数之和等于0时进行存储，小于0，left++,大于0，right--。\r\n5. 本题还有一个非常重要需要考虑的地方就是，重复值的问题，当三数之和为0的时候，如果left++的值和left的值相同，那么这就是一个重复的值，这个值是不需要添加进去的，如果right--的值和right的值相同也是同样的道理，并且，在判断是我们同时要考虑left++后依然要小于right,right--之后依然要大于left.\r\n\r\n## 解题代码\r\n```js\r\nvar threeSum = function (nums) {\r\n    // 如果元素的个数小于4，直接返回空数组\r\n    if (nums.length < 3) {\r\n        return [];\r\n    }\r\n    let res = [];\r\n    let temp = [];\r\n    nums.sort((num1, num2) => num1 - num2);\r\n    for (let i = 0; i < nums.length - 2; i++) {\r\n        if (i > 0 && (nums[i] === nums[i - 1])) {\r\n            continue;\r\n        }\r\n        let left = i + 1;\r\n        let right = nums.length - 1;\r\n        while (left < right) {\r\n            if (nums[i] + nums[left] + nums[right] === 0) {\r\n                if (nums[left] === nums[left + 1] && right > left+1) {\r\n                    left++\r\n                    continue;\r\n                } else if (nums[right] === nums[right - 1] && right > left + 1) {\r\n                    right--;\r\n                    continue;\r\n                }\r\n                temp.push(nums[i]);\r\n                temp.push(nums[left]);\r\n                temp.push(nums[right]);\r\n                res.push(temp);\r\n                temp = [];\r\n                left++\r\n            } else if (nums[i] + nums[left] + nums[right] < 0) {\r\n                left++;\r\n            } else {\r\n                right--;\r\n            }\r\n        }\r\n    }\r\n    return res\r\n};\r\n```\r\n\r\n## 启示\r\n* 学会固定一个指针，然后移动其余两个指针的方法来解决问题。"
    },
    {
      "id": "/HOT100——盛最多水的容器（JS实现）",
      "metadata": {
        "permalink": "/blog/HOT100——盛最多水的容器（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/HOT100——盛最多水的容器（JS实现）.md",
        "source": "@site/blog\\HOT100——盛最多水的容器（JS实现）.md",
        "title": "HOT100——盛最多水的容器（JS实现）",
        "description": "题目描述",
        "date": "2021-06-04T00:00:00.000Z",
        "formattedDate": "2021年6月4日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 2.03,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "HOT100——盛最多水的容器（JS实现）",
          "date": "2021-06-04T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "HOT100——三数之和（JS实现）",
          "permalink": "/blog/HOT100——三数之和（JS实现）"
        },
        "nextItem": {
          "title": "155个JavaScript基础问题（26-30）",
          "permalink": "/blog/155个JavaScript基础问题（26-30）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/92b4e407b526331081c90197b854e7fb.png)\r\n\r\n## 解题思路\r\n* 当拿到这道题目的时候，我首先想到的是暴力法，一个元素与后面的所有元素进行比较，取较小值，然后乘上距离，保存到临时数组中，最后取最大值即可，但是你懂得，时间复杂度肯定是要超标的，所以考虑其他更优解。\r\n* 本次采用的双指针，一个指针指向最左边，一个指针指向最右边，然后比较所在值的大小，谁小谁往中间移动，知道left不再小于right，通过不断更新面积的最大值即可获得最大值。\r\n\r\n## 双指针的合理性问题\r\n>很多人在使用双指针的时候，会担心会不会出现漏考虑的情况，实际上这点我也考虑到了，但是，其实不会，因为我们每次移动的都是值较低的元素，因为只要高的不动，移动较低的，就可能更新面积的高，这样就可以更新我们的最大值。\r\n\r\n## 解题代码\r\n```js\r\nvar maxArea = function(height) {\r\n    // 左指针\r\n    let left = 0;\r\n    // 右指针\r\n    let right = height.length - 1;\r\n    // 定义最大值\r\n    let max = 0;\r\n    while (left < right) {\r\n        // 判断谁低,谁低谁往中间移动\r\n        let minHeight = height[left] < height[right] ? height[left++] : height[right--];\r\n        // 由于指针的移动,所以面积为下面的结果\r\n        let area = minHeight * (right - left + 1);\r\n        // 不断更新最大值\r\n        max = Math.max(max,area);\r\n    }\r\n    return max;\r\n};\r\n```\r\n## 启示\r\n* 学会使用双指针，求解移动面积的最大值问题。"
    },
    {
      "id": "/155个JavaScript基础问题（26-30）",
      "metadata": {
        "permalink": "/blog/155个JavaScript基础问题（26-30）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/155个JavaScript基础问题（26-30）.md",
        "source": "@site/blog\\155个JavaScript基础问题（26-30）.md",
        "title": "155个JavaScript基础问题（26-30）",
        "description": "26. JavaScript全局执行上下文做了两件事：全局对象和this关键字",
        "date": "2021-06-03T00:00:00.000Z",
        "formattedDate": "2021年6月3日",
        "tags": [
          {
            "label": "155个JavaScript基础问题",
            "permalink": "/blog/tags/155-个-java-script基础问题"
          }
        ],
        "readingTime": 1.865,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "155个JavaScript基础问题（26-30）",
          "date": "2021-06-03T00:00:00.000Z",
          "categories": "155个JavaScript基础问题",
          "tags": [
            "155个JavaScript基础问题"
          ]
        },
        "prevItem": {
          "title": "HOT100——盛最多水的容器（JS实现）",
          "permalink": "/blog/HOT100——盛最多水的容器（JS实现）"
        },
        "nextItem": {
          "title": "HOT100——正则表达式匹配（JS实现）",
          "permalink": "/blog/HOT100——正则表达式匹配（JS实现）"
        }
      },
      "content": "## 26. JavaScript全局执行上下文做了两件事：全局对象和this关键字\r\n![](https://img-blog.csdnimg.cn/img_convert/80e49c11587124548272f844944c3635.png)\r\n>答：A，一行JavaScript代码运行的时候，是在执行上下文运行的，在JS代码执行前，执行上下文将会做三件事：1. this绑定。2. 创建词法环境。3. 创建变量环境。\r\n\r\n## 27. 输出是什么？\r\n```js\r\nfor (let i = 1; i < 5; i++) {\r\n  if (i === 3) continue\r\n  console.log(i)\r\n}\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/97a239f6d88a471b9f30cb35e76227bb.png)\r\n>答：C，因为3被跳过了，continue这个关键词的作用是，跳过本次循环继续下次循环。\r\n\r\n## 28. 输出是什么？\r\n```js\r\nString.prototype.giveLydiaPizza = () => {\r\n  return 'Just give Lydia pizza already!'\r\n}\r\n\r\nconst name = 'Lydia'\r\n\r\nname.giveLydiaPizza()\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/636375a0a5a11df576bed7a027444ee6.png)\r\n>答：A，因为String也属于构造函数，所以通过给构造函数的原型对象添加方法，实例是能够访问到的。\r\n\r\n## 29. 输出是什么？\r\n```js\r\nconst a = {}\r\nconst b = { key: 'b' }\r\nconst c = { key: 'c' }\r\n\r\na[b] = 123\r\na[c] = 456\r\n\r\nconsole.log(a[b])\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/34c8459a7a63dccb4f44a3f055b6a956.png)\r\n>答：B，这是因为一个对象作为键的时候，是将下面的形式存进去了。这也就是为什么答案选B。\r\n![](https://img-blog.csdnimg.cn/img_convert/2f926862e0edb9360a661ec6accc127e.png)\r\n\r\n## 30. 输出是什么？\r\n```js\r\nconst foo = () => console.log('First')\r\nconst bar = () => setTimeout(() => console.log('Second'))\r\nconst baz = () => console.log('Third')\r\n\r\nbar()\r\nfoo()\r\nbaz()\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/4911f95d8aceff3d5c82bfc46f67e06b.png)\r\n>答：B，本题考查的其实是JS事件循环，首先会运行同步代码，其次是微任务和宏任务。\r\n\r\n## 题目来源\r\n[155个JavaScript基础问题](https://github.com/lydiahallie/javascript-questions)\r\n## 感谢批评指针！共同学习！"
    },
    {
      "id": "/HOT100——正则表达式匹配（JS实现）",
      "metadata": {
        "permalink": "/blog/HOT100——正则表达式匹配（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/HOT100——正则表达式匹配（JS实现）.md",
        "source": "@site/blog\\HOT100——正则表达式匹配（JS实现）.md",
        "title": "HOT100——正则表达式匹配（JS实现）",
        "description": "题目描述",
        "date": "2021-06-03T00:00:00.000Z",
        "formattedDate": "2021年6月3日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.265,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "HOT100——正则表达式匹配（JS实现）",
          "date": "2021-06-03T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "155个JavaScript基础问题（26-30）",
          "permalink": "/blog/155个JavaScript基础问题（26-30）"
        },
        "nextItem": {
          "title": "155个JavaScript基础问题（21-25）",
          "permalink": "/blog/155个JavaScript基础问题（21-25）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/8df3831bb21cc7bb8c3be85774c38b82.png)\r\n\r\n## 解题思路\r\n* 本题采用的是回溯的思想。\r\n* 主要需要考虑的情况有以下几种\r\n1. 字符串和模式串的字符相等。\r\n2. 模式串的字符为点。\r\n3. 模式串为\\*的时候，分两种情况讨论，一是0次，一是多次。\r\n\r\n## 解题代码\r\n```js\r\nvar isMatch = function (s, p) {\r\n    return helper(s, p);\r\n    function helper(str, pattern) {\r\n        if (pattern.length === 0) {\r\n            if (str.length === 0) {\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n        // 不是 * 号的情况\r\n        if (str.length > 2 && (str[0] === pattern[0] || pattern[0] === '.') && pattern[1] !== '*') {\r\n            res = helper(str.slice(1),pattern.slice(1));\r\n        } else if (str.length > 0 && (str[0] === pattern[0] || pattern[0] === '.') && pattern[1] === '*'){\r\n            // 这是 *号 代表0次的情况        多次的情况\r\n            res = helper(str,pattern.slice(2)) || helper(str.slice(1),pattern)\r\n        } else {\r\n            if (str.length > 0 && (str[0] === pattern[0] || pattern[0] === '.') && pattern[1] !== '*') {\r\n                res = helper(str.slice(1),pattern.slice(1)); \r\n            } else if (pattern[1] === '*') {\r\n                res = helper(str,pattern.slice(2))\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n## 启示\r\n* 学会在多种限制条件下使用递归回溯解决问题。"
    },
    {
      "id": "/155个JavaScript基础问题（21-25）",
      "metadata": {
        "permalink": "/blog/155个JavaScript基础问题（21-25）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/155个JavaScript基础问题（21-25）.md",
        "source": "@site/blog\\155个JavaScript基础问题（21-25）.md",
        "title": "155个JavaScript基础问题（21-25）",
        "description": "21. 输出是什么？",
        "date": "2021-06-02T00:00:00.000Z",
        "formattedDate": "2021年6月2日",
        "tags": [
          {
            "label": "155个JavaScript基础问题",
            "permalink": "/blog/tags/155-个-java-script基础问题"
          }
        ],
        "readingTime": 1.49,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "155个JavaScript基础问题（21-25）",
          "date": "2021-06-02T00:00:00.000Z",
          "categories": "155个JavaScript基础问题",
          "tags": [
            "155个JavaScript基础问题"
          ]
        },
        "prevItem": {
          "title": "HOT100——正则表达式匹配（JS实现）",
          "permalink": "/blog/HOT100——正则表达式匹配（JS实现）"
        },
        "nextItem": {
          "title": "HOT100——最长回文子串（JS实现）",
          "permalink": "/blog/HOT100——最长回文子串（JS实现）"
        }
      },
      "content": "## 21. 输出是什么？\r\n```js\r\nconst sum = eval('10*10+5')\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/66af1ba27d80e44f65ddbc83bbdfe72c.png)\r\n>答：A，eval会将字符串变为表达式，然后执行。\r\n\r\n## 22. cool_secret能够访问多长时间？\r\n```js\r\nsessionStorage.setItem('cool_secret', 123)\r\n```\r\n>答：使用sessionStorage存储内容时，一旦用户关闭Tab标签页，存储的内容将消失，localStorage则不会，除非调用localStorage.clear().\r\n\r\n## 23. 输出是什么？\r\n```js\r\nvar num = 8\r\nvar num = 10\r\n\r\nconsole.log(num)\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/a535ca17b13d72e57dec87914eb7a166.png)\r\n>答：B，因为这是var声明的变量，会出现同名定义，然后变量保存最新的值的情况。\r\n\r\n## 24. 输出是什么？\r\n```js\r\nconst obj = { 1: 'a', 2: 'b', 3: 'c' }\r\nconst set = new Set([1, 2, 3, 4, 5])\r\n\r\nobj.hasOwnProperty('1')\r\nobj.hasOwnProperty(1)\r\nset.has('1')\r\nset.has(1)\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/4ab475d4efad0188b627166021c15423.png)\r\n>答：C，因为除了Symbol之外，所有的对象的键在底层实现都是字符串，所以通过hasOwnProperty检测字符串1和数字1返回的都是true,但是集合是区分字符串和数字的，所以是false,true.\r\n\r\n## 25. 输出是什么？\r\n```js\r\nconst obj = { a: 'one', b: 'two', a: 'three' }\r\nconsole.log(obj)\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/2869390402e90f1706f18c2bdc8db9b3.png)\r\n>答：C，在对象中，如果出现重名键的情况，键的顺序不发生变化，但是后面的值会覆盖掉同名键前边的值。"
    },
    {
      "id": "/HOT100——最长回文子串（JS实现）",
      "metadata": {
        "permalink": "/blog/HOT100——最长回文子串（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/HOT100——最长回文子串（JS实现）.md",
        "source": "@site/blog\\HOT100——最长回文子串（JS实现）.md",
        "title": "HOT100——最长回文子串（JS实现）",
        "description": "题目描述",
        "date": "2021-06-02T00:00:00.000Z",
        "formattedDate": "2021年6月2日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.525,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "HOT100——最长回文子串（JS实现）",
          "date": "2021-06-02T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "155个JavaScript基础问题（21-25）",
          "permalink": "/blog/155个JavaScript基础问题（21-25）"
        },
        "nextItem": {
          "title": "155个JavaScript基础问题（11-20）",
          "permalink": "/blog/155个JavaScript基础问题（11-20）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/6d11890632807ff33a9c23f0fbc8c800.png)\r\n\r\n## 解题思路\r\n* 方法：中心扩散法。\r\n* 核心：目标字符的左右是否相等。\r\n* 讨论两种情况：回文子串的长度是奇数的情况和偶数的情况。\r\n* 循环时，一看是否越界，二看是否相等。\r\n* 具体思路请看代码注释。\r\n\r\n## 手绘思路（以cbbd字符串为例，看懂循环体内部的执行过程）\r\n![](https://img-blog.csdnimg.cn/img_convert/4a4f694cdc1f7d3105d89b9a1498c834.png)\r\n\r\n## 解题代码\r\n```js\r\nvar longestPalindrome = function(s) {\r\n    // 定义返回的最长回文子串\r\n    let res = '';\r\n    // 开始循环每一个字符\r\n    for (let i = 0; i < s.length; i++) {\r\n        // 当回文子串为奇数时\r\n        test(i,i);\r\n        // 当回文子串为偶数时\r\n        test(i,i+1);\r\n    }\r\n    function test(m,n) {\r\n        // 首先不能越界，其次两个元素要相等，然后m左移，n右移进行比较\r\n        while (m >= 0 && n < s.length && s[m] === s[n]) {\r\n            m--;\r\n            n++;\r\n        }\r\n        // 比较当前回文字符串的长度是否比前面的回文字符串长度长，长则进行更新。\r\n        if (n - m - 1 > res.length) {\r\n            res = s.slice(m+1,n);\r\n        }\r\n    }\r\n    return res;\r\n};\r\n```\r\n## 总结（本题给我们的启示思路）\r\n* 学会使用中心扩散法求解最长回文子串问题。"
    },
    {
      "id": "/155个JavaScript基础问题（11-20）",
      "metadata": {
        "permalink": "/blog/155个JavaScript基础问题（11-20）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/155个JavaScript基础问题（11-20）.md",
        "source": "@site/blog\\155个JavaScript基础问题（11-20）.md",
        "title": "155个JavaScript基础问题（11-20）",
        "description": "11. 输出是什么？",
        "date": "2021-06-01T00:00:00.000Z",
        "formattedDate": "2021年6月1日",
        "tags": [
          {
            "label": "155个JavaScript基础问题",
            "permalink": "/blog/tags/155-个-java-script基础问题"
          }
        ],
        "readingTime": 4.525,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "155个JavaScript基础问题（11-20）",
          "date": "2021-06-01T00:00:00.000Z",
          "categories": "155个JavaScript基础问题",
          "tags": [
            "155个JavaScript基础问题"
          ]
        },
        "prevItem": {
          "title": "HOT100——最长回文子串（JS实现）",
          "permalink": "/blog/HOT100——最长回文子串（JS实现）"
        },
        "nextItem": {
          "title": "HOT100——寻找两个正序数组的中位数（JS实现）",
          "permalink": "/blog/HOT100——寻找两个正序数组的中位数（JS实现）"
        }
      },
      "content": "## 11. 输出是什么？\r\n```js\r\nfunction Person(firstName, lastName) {\r\n  this.firstName = firstName;\r\n  this.lastName = lastName;\r\n}\r\n\r\nconst member = new Person(\"Lydia\", \"Hallie\");\r\nPerson.getFullName = function () {\r\n  return `${this.firstName} ${this.lastName}`;\r\n}\r\n\r\nconsole.log(member.getFullName());\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/bb1d4a2282306ef1dc2202beb5ef268d.png)\r\n\r\n>答：A，本题中Person是一个构造函数，不能像普通的对象给构造函数添加属性，要想给构造函数的实例添加属性，可以通过原型的方式来实现。\r\n\r\n## 12. 输出是什么？\r\n```js\r\nfunction Person(firstName, lastName) {\r\n  this.firstName = firstName\r\n  this.lastName = lastName\r\n}\r\n\r\nconst lydia = new Person('Lydia', 'Hallie')\r\nconst sarah = Person('Sarah', 'Smith')\r\n\r\nconsole.log(lydia)\r\nconsole.log(sarah)\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/7d22adf5ab0ab3a8f5826bb6a5b204ae.png)\r\n\r\n>答：A，关于Lydia的选项一般不易选错，因为通过new关键词，this会引用我们创建的空对象，但是sarah没有使用new关键词，所以，此时的this是指向global的，而sarah本身是undefined.\r\n\r\n## 13. 事件捕获的三个阶段是哪些？\r\n![](https://img-blog.csdnimg.cn/img_convert/561c062c904081f4136c0184e429f7d7.png)\r\n\r\n>答：选D、DOM事件流的三个阶段分别是事件捕获阶段、处于目标阶段、事件冒泡阶段。事件捕获的三个阶段图示：![](https://img-blog.csdnimg.cn/img_convert/a62390057b66bda69fa9fa9f2d7fc67a.png)\r\n\r\n## 14. 所有的对象都有原型？\r\n![](https://img-blog.csdnimg.cn/img_convert/d85f4d790b94ac5aaefd02040c3092b3.png)\r\n\r\n>答：错。这句话是不够准确的，准确的说应该是除去Object之外的所有对象都有原型。\r\n\r\n## 15. 输出是什么？\r\n```js\r\nfunction sum(a, b) {\r\n  return a + b\r\n}\r\n\r\nsum(1, '2')\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/bf3ceb532a4e9cfe8743a7c4f44a62cc.png)\r\n\r\n>答：C，因为JS将字符串2和数字1相加时，会进行类型转换，将1转换为字符串类型的，然后就相当于一种字符串拼接。\r\n\r\n## 16. 输出是什么？\r\n```js\r\nlet number = 0\r\nconsole.log(number++)\r\nconsole.log(++number)\r\nconsole.log(number)\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/9df0951d8fee2123a94f94e777e376bd.png)\r\n\r\n>答：C，number++是先输出值，再进行加，但是++number则是先加，再进行输出。\r\n\r\n## 17. 输出是什么？\r\n```js\r\nfunction getPersonInfo(one, two, three) {\r\n  console.log(one)\r\n  console.log(two)\r\n  console.log(three)\r\n}\r\n\r\nconst person = 'Lydia'\r\nconst age = 21\r\n\r\ngetPersonInfo`${person} is ${age} years old`\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/5bef2ad85bb78ed2b1cdcce8bb835e87.png)\r\n\r\n>答：B，我刚开始看到这道题的时候，我在想getPersonInfo是不是少加一个括号，后来我发现并不是这样，本题意在考查标签函数。所谓的标签函数就是函数名后面直接带一个模板字符串，并从模板字符串中的插值表达式中获取参数。标签表达式的第一个参数是模板字符串中的普通文本，大括号标记的地方视为空字符串，第二个参数则是模板字符第一个大括号中的，以此类推。\r\n\r\n## 18. 输出是什么？\r\n```js\r\nfunction checkAge(data) {\r\n  if (data === { age: 18 }) {\r\n    console.log('You are an adult!')\r\n  } else if (data == { age: 18 }) {\r\n    console.log('You are still an adult.')\r\n  } else {\r\n    console.log(`Hmm.. You don't have an age I guess`)\r\n  }\r\n}\r\n\r\ncheckAge({ age: 18 })\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/03ff811fb18e02bc17be1e51e8aae4fd.png)\r\n\r\n>答：C，对象在进行比较时，比较的是引用的内存地址，此处参数形式的对象的地址和用于比较的对象的地址是不同的，所以=== 和 == 返回的都是false,所以最后答案选C。\r\n\r\n## 19. 输出是什么？\r\n```js\r\nfunction getAge(...args) {\r\n  console.log(typeof args)\r\n}\r\n\r\ngetAge(21)\r\n```\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/778d806389204f1f8a1ca377c48ed76c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n>答：C、拓展运算符返回的是实参数组，数组属于object类型。\r\n\r\n## 20. 输出是什么？\r\n```js\r\nfunction getAge() {\r\n  'use strict'\r\n  age = 21\r\n  console.log(age)\r\n}\r\n\r\ngetAge()\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/a952524c9835489c8df56ac35fa8b387.png)\r\n\r\n>答：C、因为这是严格模式，所以会出现引用错误，如果不是严格模式的话，age属性会被添加到全局对象中去。\r\n\r\n## 参考文献\r\n[题目来源](https://github.com/lydiahallie/javascript-questions)\r\n\r\n[JavaScript事件捕获和事件冒泡](https://www.bilibili.com/video/BV1m7411L7YW?from=search&seid=5828352374642195178)\r\n\r\n[ES6 - 标签函数](https://zhuanlan.zhihu.com/p/31687266)\r\n\r\n## 为什么不一次性放完所有题目？\r\n博主认为学习贵在坚持，而不是三天打鱼两天晒网，学习不是收藏不看，而是每天进步一点点，大家一起加油！\r\n>## 欢迎大家指正批评"
    },
    {
      "id": "/HOT100——寻找两个正序数组的中位数（JS实现）",
      "metadata": {
        "permalink": "/blog/HOT100——寻找两个正序数组的中位数（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/HOT100——寻找两个正序数组的中位数（JS实现）.md",
        "source": "@site/blog\\HOT100——寻找两个正序数组的中位数（JS实现）.md",
        "title": "HOT100——寻找两个正序数组的中位数（JS实现）",
        "description": "题目描述",
        "date": "2021-06-01T00:00:00.000Z",
        "formattedDate": "2021年6月1日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.68,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "HOT100——寻找两个正序数组的中位数（JS实现）",
          "date": "2021-06-01T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "155个JavaScript基础问题（11-20）",
          "permalink": "/blog/155个JavaScript基础问题（11-20）"
        },
        "nextItem": {
          "title": "155个JavaScript基础问题（6-10）",
          "permalink": "/blog/155个JavaScript基础问题（6-10）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/5040bc51d780fb4971f220f7c2f383cd.png)\r\n\r\n## 解题思路\r\n* 本题采用双指针的解题方法。\r\n* 一个指针指向数组1。\r\n* 一个指针指向数组2。\r\n* 依次比较两个指针指向的元素的大小，谁小谁加到排序好的数组中，直到一方遍历完，将没遍历完的全部加到排序好的数组中即可。\r\n* 最后判断结果数组的个数是奇数还是偶数，如果是奇数直接返回中位数元素，如果是偶数则返回中位数元素和中位数元素后边的一位元素，两者求和然后/2,返回。\r\n\r\n## 解题代码\r\n```js\r\nvar findMedianSortedArrays = function(nums1, nums2) {\r\n    // 首先我们要明确一点，两个数组都是正序的\r\n    // 双指针\r\n    let left = 0;\r\n    let right = 0;\r\n    // 定义合并数组\r\n    const mergeArr = [];\r\n    // 当其中一个数组遍历到最后时结束\r\n    while (left < nums1.length && right < nums2.length) {\r\n        if (nums1[left] <= nums2[right]) {\r\n            mergeArr.push(nums1[left]);\r\n            left++;\r\n        } else {\r\n            mergeArr.push(nums2[right]);\r\n            right++;\r\n        }\r\n    }\r\n    if (right === nums2.length) {\r\n        mergeArr.push(...nums1.slice(left))\r\n    }\r\n    if (left === nums1.length) {\r\n        mergeArr.push(...nums2.slice(right))\r\n    }\r\n    if (mergeArr.length % 2) {\r\n        return mergeArr[(mergeArr.length-1) >> 1]\r\n    } else {\r\n        return (mergeArr[(mergeArr.length-1) >> 1] + mergeArr[((mergeArr.length-1) >> 1) + 1]) / 2\r\n    }\r\n\r\n};\r\n```\r\n## 总结（本题给我们的启示思路）\r\n* 学会使用双指针的思路求解问题。\r\n* 学会使用位移的方式求中位数。"
    },
    {
      "id": "/155个JavaScript基础问题（6-10）",
      "metadata": {
        "permalink": "/blog/155个JavaScript基础问题（6-10）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/155个JavaScript基础问题（6-10）.md",
        "source": "@site/blog\\155个JavaScript基础问题（6-10）.md",
        "title": "155个JavaScript基础问题（6-10）",
        "description": "6. 输出是什么？",
        "date": "2021-05-31T00:00:00.000Z",
        "formattedDate": "2021年5月31日",
        "tags": [
          {
            "label": "155个JavaScript基础问题",
            "permalink": "/blog/tags/155-个-java-script基础问题"
          }
        ],
        "readingTime": 2.23,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "155个JavaScript基础问题（6-10）",
          "date": "2021-05-31T00:00:00.000Z",
          "categories": "155个JavaScript基础问题",
          "tags": [
            "155个JavaScript基础问题"
          ]
        },
        "prevItem": {
          "title": "HOT100——寻找两个正序数组的中位数（JS实现）",
          "permalink": "/blog/HOT100——寻找两个正序数组的中位数（JS实现）"
        },
        "nextItem": {
          "title": "The href attribute requires a valid value to be accessible",
          "permalink": "/blog/The href attribute requires a valid value to be accessible"
        }
      },
      "content": "## 6. 输出是什么？\r\n```js\r\nlet c = { greeting: 'Hey!' }\r\nlet d\r\n\r\nd = c\r\nc.greeting = 'Hello'\r\nconsole.log(d.greeting)\r\n```\r\n>答：输出是 'Hello'，因为在JS中对象是一种引用类型，d和c指向的是同一片内存区域，所以对c进行修改，d指向的内容也发生了改变。\r\n\r\n## 7. 输出是什么？\r\n```js\r\nlet a = 3\r\nlet b = new Number(3)\r\nlet c = 3\r\n\r\nconsole.log(a == b)\r\nconsole.log(a === b)\r\nconsole.log(b === c)\r\n```\r\n>答：输出是 true、false、false。之所以是这样，当我们是用\\==符号时，系统会检测两边是否有相同的值，有时候还会对值进行转换的比较，但是如果我们使用===符号时，不仅要求两边要有相同的值，还要求有相同的类型，new Number出来的是一种对象，其身上不仅仅有值，还有一堆额外的功能。\r\n\r\n## 8. 输出是什么？\r\n```js\r\nclass Chameleon {\r\n  static colorChange(newColor) {\r\n    this.newColor = newColor\r\n    return this.newColor\r\n  }\r\n\r\n  constructor({ newColor = 'green' } = {}) {\r\n    this.newColor = newColor\r\n  }\r\n}\r\n\r\nconst freddie = new Chameleon({ newColor: 'purple' })\r\nfreddie.colorChange('orange')\r\n```\r\n>答：输出是TypeError，之所以是错误，原因在于Chameleon是一个类，colorChange是类中的静态方法，类中的静态方法只能被构造器使用，不能被实例进行调用。\r\n\r\n## 9. 输出是什么？\r\n```js\r\nlet greeting\r\ngreetign = {} // Typo!\r\nconsole.log(greetign)\r\n```\r\n>答：输出的是{},表面上看greetign存在拼写错误，应该报错才对，但是这是在全局作用域下的，实际上是进行了赋值的，所以打印出的是{}.\r\n\r\n## 10. 当我们这么做会发生什么？\r\n```js\r\nfunction bark() {\r\n  console.log('Woof!')\r\n}\r\n\r\nbark.animal = 'dog'\r\n```\r\n>答：正常运行！之所以会这样，是因为JS中的函数也是一类特殊的对象，所以也可以通过点的形式添加属性。"
    },
    {
      "id": "/The href attribute requires a valid value to be accessible",
      "metadata": {
        "permalink": "/blog/The href attribute requires a valid value to be accessible",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/The href attribute requires a valid value to be accessible.md",
        "source": "@site/blog/The href attribute requires a valid value to be accessible.md",
        "title": "The href attribute requires a valid value to be accessible",
        "description": "警告原因",
        "date": "2021-05-30T00:00:00.000Z",
        "formattedDate": "2021年5月30日",
        "tags": [
          {
            "label": "debug",
            "permalink": "/blog/tags/debug"
          }
        ],
        "readingTime": 0.445,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "The href attribute requires a valid value to be accessible",
          "date": "2021-05-30T00:00:00.000Z",
          "categories": "debug",
          "tags": [
            "debug"
          ]
        },
        "prevItem": {
          "title": "155个JavaScript基础问题（6-10）",
          "permalink": "/blog/155个JavaScript基础问题（6-10）"
        },
        "nextItem": {
          "title": "HOT100——无重复字符的最长子串（JS实现）",
          "permalink": "/blog/HOT100——无重复字符的最长子串（JS实现）"
        }
      },
      "content": "## 警告原因\r\n```js\r\nhref=\"javascript:;\"\r\n```\r\n上面这段代码的存在。\r\n\r\n## 解决办法\r\n```js\r\n使用href=\"/#\"代替\r\n```\r\n\r\n## 潜在问题\r\n虽然上述方法可以解决Rract的警告问题，但是可能会影响到页面跳转功能的实现，如果你想使用的是Link-Button的功能，可以考虑下面的方法\r\n```\r\n<Button type=\"link\">Link Button</Button>\r\n```"
    },
    {
      "id": "/HOT100——无重复字符的最长子串（JS实现）",
      "metadata": {
        "permalink": "/blog/HOT100——无重复字符的最长子串（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/HOT100——无重复字符的最长子串（JS实现）.md",
        "source": "@site/blog\\HOT100——无重复字符的最长子串（JS实现）.md",
        "title": "HOT100——无重复字符的最长子串（JS实现）",
        "description": "题目描述",
        "date": "2021-05-29T00:00:00.000Z",
        "formattedDate": "2021年5月29日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 2.67,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "HOT100——无重复字符的最长子串（JS实现）",
          "date": "2021-05-29T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "The href attribute requires a valid value to be accessible",
          "permalink": "/blog/The href attribute requires a valid value to be accessible"
        },
        "nextItem": {
          "title": "155个JavaScript基础问题（1-5）",
          "permalink": "/blog/155个JavaScript基础问题（1-5）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/e134f590cce5c300618b5187d2e5baf7.png)\r\n\r\n## 解题思路\r\n* 本题采用双指针 + 哈希表的方式解决问题。\r\n* 最大值是通过不断更新出来的。\r\n* 右指针移动到字符串的最后一个元素循环结束。\r\n* 循环体中首先判断右指针指向的元素是否出现在哈希表中，如果出现了，对应的值+1，反之赋值为1.\r\n* 哈希表存在的意义就是为了辅助我们的左指针的移动，当右指针的元素出现的次数大于2，此时说明重复了，我们要不断移动左指针，直到右指针重复的这个元素不重复为止，移动左指针之前还要将左指针指向的这个元素的哈希值-1，防止后面出现了同样的元素\r\n* 最后右指针右移，然后不断比较res和right - left的较大值赋给res。\r\n\r\n## 解题代码\r\n```js\r\nvar lengthOfLongestSubstring = function(s) {\r\n    // 本题采用滑动窗口 + 双指针的方法\r\n    // 定义左指针\r\n    let left = 0;\r\n    // 定义右指针\r\n    let right = 0;\r\n    // 定义最大值\r\n    let res = 0;\r\n    // 定义滑动窗口（哈希表）\r\n    let window = new Map();\r\n\r\n    // 循环结束条件是 右指针走到了最右边\r\n    while (right < s.length) {\r\n        // 判断右指针指向的元素，是否在哈希表中，在则+1，不在则添加进去\r\n        if (window.has(s[right])) {\r\n            window.set(s[right],window.get(s[right]) + 1);\r\n        } else {\r\n            window.set(s[right],1);\r\n        }\r\n        // 判断右指针指向的元素，是否出现了重复\r\n        while (window.get(s[right]) > 1) {\r\n            // 当右指针指向的元素出现了两次，说明重复了，左指针指向的元素在哈希表中的值-1，然后左指针右移\r\n            // 之所以 -1 之后再右移，根本原因在于防止左边的元素重复出现\r\n            window.set(s[left],window.get(s[left]) -1);\r\n            left++;\r\n        }\r\n        // 指针右移,不断更新最大值\r\n        right++;\r\n        res = Math.max(res,right - left);\r\n    }\r\n\r\n    return res;\r\n};\r\n```\r\n## 总结（本题给我们的启示思路）\r\n* 学会通过不断更新的方式获取最大值。\r\n* 学会通过哈希表 + 双指针的方式来解决问题。"
    },
    {
      "id": "/155个JavaScript基础问题（1-5）",
      "metadata": {
        "permalink": "/blog/155个JavaScript基础问题（1-5）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/155个JavaScript基础问题（1-5）.md",
        "source": "@site/blog\\155个JavaScript基础问题（1-5）.md",
        "title": "155个JavaScript基础问题（1-5）",
        "description": "1. 输出是什么？",
        "date": "2021-05-28T00:00:00.000Z",
        "formattedDate": "2021年5月28日",
        "tags": [
          {
            "label": "155个JavaScript基础问题",
            "permalink": "/blog/tags/155-个-java-script基础问题"
          }
        ],
        "readingTime": 2.63,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "155个JavaScript基础问题（1-5）",
          "date": "2021-05-28T00:00:00.000Z",
          "categories": "155个JavaScript基础问题",
          "tags": [
            "155个JavaScript基础问题"
          ]
        },
        "prevItem": {
          "title": "HOT100——无重复字符的最长子串（JS实现）",
          "permalink": "/blog/HOT100——无重复字符的最长子串（JS实现）"
        },
        "nextItem": {
          "title": "HOT100——两数相加（JS实现）",
          "permalink": "/blog/HOT100——两数相加（JS实现）"
        }
      },
      "content": "## 1. 输出是什么？\r\n```js\r\nfunction sayHi() {\r\n  console.log(name)\r\n  console.log(age)\r\n  var name = 'Lydia'\r\n  let age = 21\r\n}\r\n\r\nsayHi()\r\n```\r\n>答案是：undefined和报错\r\n>因为var 定义的变量具有变量提升的效果，但是仅仅是变量声明的提升，并未进行赋值，所以是undefined，let定义的变量不具备变量提升的效果，所以是报错的。\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/506807e62e77477b9c40c3ac861547d2~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 2. 输出是什么？\r\n```js\r\nfor (var i = 0; i < 3; i++) {\r\n  setTimeout(() => console.log(i), 1)\r\n}\r\n\r\nfor (let i = 0; i < 3; i++) {\r\n  setTimeout(() => console.log(i), 1)\r\n}\r\n\r\n```\r\n>答案是：333 和 012，因为JS的事件循环机制，setTimeout属于宏任务，要等到同步代码执行完之后才能执行，var在此处定义的是全局变量，因此同步代码执行完之后i已经变成了3，所以打印3个3，但是let定义的变量会形成一个块级作用域，因此是0 1 2\r\n\r\n## 3. 输出是什么？\r\n```js\r\nconst shape = {\r\n  radius: 10,\r\n  diameter() {\r\n    return this.radius * 2\r\n  },\r\n  perimeter: () => 2 * Math.PI * this.radius\r\n}\r\n\r\nshape.diameter()\r\nshape.perimeter()\r\n\r\n```\r\n>答：输出是20和NaN，因为diameter中的this指的是shape中的radius，但是perimeter由于是箭头函数所以，它的this取决于调用的位置，不取决于定义的位置，由于调用的位置在全局window，此处并没有radius所以值是undefined，所以进行乘积之后是NaN。\r\n\r\n## 4. 输出是什么？\r\n```js\r\n+true;\r\n!\"Lydia\";\r\n```\r\n>解：+号会将true变为1，+号倾向于返回一个值，但是!倾向于返回一个布尔值，因为\"Lydia\"是真实存在的，所以取反之后是false。\r\n\r\n## 5. 哪一个是正确的？\r\n```js\r\nconst bird = {\r\n  size: 'small'\r\n}\r\nconst mouse = {\r\n  name: 'Mickey',\r\n  small: true\r\n}\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/193c0ec0e56c7ce02b00ca621e95c8eb.png)\r\n>答案：A，因为mouse通过点的形式调用bird的前提是mouse有这个属性，但是它没有，所以是无效的，但是bird.size是真实存在的，通过[]调用里面存放的是small这个字符串，这个和C选项是一样的，同理说明D的说法是不对的，所以本题选A。"
    },
    {
      "id": "/HOT100——两数相加（JS实现）",
      "metadata": {
        "permalink": "/blog/HOT100——两数相加（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/HOT100——两数相加（JS实现）.md",
        "source": "@site/blog\\HOT100——两数相加（JS实现）.md",
        "title": "HOT100——两数相加（JS实现）",
        "description": "题目描述",
        "date": "2021-05-27T00:00:00.000Z",
        "formattedDate": "2021年5月27日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.87,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "HOT100——两数相加（JS实现）",
          "date": "2021-05-27T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "155个JavaScript基础问题（1-5）",
          "permalink": "/blog/155个JavaScript基础问题（1-5）"
        },
        "nextItem": {
          "title": "剑指Offer——打印从1到最大的n位数（JS实现）",
          "permalink": "/blog/剑指Offer——打印从1到最大的n位数（JS实现）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/42c01b039a88f45bc1f7465038375042.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/0abd0cf9de8093257185ddee481fb855.png)\r\n\r\n## 解题思路\r\n* 本次使用暴力解法：\r\n1. 拿到链表对应的字符字符串数值，然后将数值反转之后转为BigInt类型，之所以转为BigInt类型的原因在于后期测试用例中有大数形式。\r\n2. 将两个数值相加，然后转为字符数组，然后反转。\r\n3. 定义一个数组，将字符数组的每一个元素变为相应节点后，添加进数组。\r\n4. 遍历这个临时数组，依次改变指针。\r\n5. 返回数组的头元素即可。\r\n\r\n## 手绘思路\r\n![](https://img-blog.csdnimg.cn/img_convert/d8671e42435abfe40548331ebcfcdf09.png)\r\n\r\n## 解题代码\r\n```js\r\nvar addTwoNumbers = function(l1, l2) {\r\n    function ListNode(val,next) {\r\n        this.val = val;\r\n        this.next = null;\r\n    }\r\n    // 拿到链表1的数值\r\n    let str1 = '';\r\n    let temp1 = l1;\r\n    while (temp1 !== null) {\r\n        str1 = str1 + temp1.val;\r\n        temp1 = temp1.next;\r\n    }\r\n    str1 = str1.split('').reverse().join('');\r\n    let num1 = BigInt(str1);\r\n    // 拿到链表2的数值\r\n    let str2 = '';\r\n    let temp2 = l2;\r\n    while (temp2 !== null) {\r\n        str2 = str2 + temp2.val;\r\n        temp2 = temp2.next;\r\n    }\r\n    str2 = str2.split('').reverse().join('');\r\n    let num2 = BigInt(str2);\r\n\r\n    let result = num1 + num2;\r\n    // 以result为基础倒着建立一个链表\r\n    let strResult = String(result).split('');\r\n    strResult.reverse();\r\n    let res = [];\r\n    for (let v of strResult) {\r\n        res.push(new ListNode(Number(v)))\r\n    };\r\n    for (let i = 0 ; i < res.length - 1;i++) {\r\n        res[i].next = res[i+1]\r\n    }\r\n\r\n    return res[0]\r\n    \r\n    \r\n};\r\n```\r\n## 总结（本题给我们的启示思路）\r\n* 本题不是最优解，但是思路较为简单。\r\n* 学会使用JS中的BigInt类型来解决大数问题。\r\n* 学会使用遍历数组来改变节点指针的方法。"
    },
    {
      "id": "/剑指Offer——打印从1到最大的n位数（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——打印从1到最大的n位数（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——打印从1到最大的n位数（JS实现）.md",
        "source": "@site/blog\\剑指Offer——打印从1到最大的n位数（JS实现）.md",
        "title": "剑指Offer——打印从1到最大的n位数（JS实现）",
        "description": "题目描述",
        "date": "2021-05-26T00:00:00.000Z",
        "formattedDate": "2021年5月26日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.56,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——打印从1到最大的n位数（JS实现）",
          "date": "2021-05-26T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "HOT100——两数相加（JS实现）",
          "permalink": "/blog/HOT100——两数相加（JS实现）"
        },
        "nextItem": {
          "title": "VSCode根据文件名快速打开文件的方法",
          "permalink": "/blog/VSCode根据文件名快速打开文件的方法"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/d6e59b5b4d6e66c669ff522504db4e9c.png)\r\n\r\n## 解题思路\r\n* 循环结束的位置就是10**位数 -1\r\n* 从1开始循环到指定位置即可。\r\n\r\n## 解题代码\r\n```js\r\nvar printNumbers = function(n) {\r\n\r\n    // 定义循环结束的位置\r\n    const deadline = 10 ** n - 1;\r\n    // 定义最终返回的数组\r\n    const res = [];\r\n    // 开始循环\r\n    for (let i = 1; i <= deadline; i++) {\r\n        res.push(i)\r\n    }\r\n    return res;\r\n}\r\n```\r\n## 启示\r\n* 学会JS中的幂运算。"
    },
    {
      "id": "/VSCode根据文件名快速打开文件的方法",
      "metadata": {
        "permalink": "/blog/VSCode根据文件名快速打开文件的方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/VSCode根据文件名快速打开文件的方法.md",
        "source": "@site/blog\\VSCode根据文件名快速打开文件的方法.md",
        "title": "VSCode根据文件名快速打开文件的方法",
        "description": "使用快捷键",
        "date": "2021-05-25T00:00:00.000Z",
        "formattedDate": "2021年5月25日",
        "tags": [
          {
            "label": "VSCode",
            "permalink": "/blog/tags/vs-code"
          }
        ],
        "readingTime": 0.065,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "VSCode根据文件名快速打开文件的方法",
          "date": "2021-05-25T00:00:00.000Z",
          "categories": "VSCode",
          "tags": [
            "VSCode"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——打印从1到最大的n位数（JS实现）",
          "permalink": "/blog/剑指Offer——打印从1到最大的n位数（JS实现）"
        },
        "nextItem": {
          "title": "剑指Offer——表示数值的字符串（JS实现）",
          "permalink": "/blog/剑指Offer——表示数值的字符串（JS实现）"
        }
      },
      "content": "## 使用快捷键\r\n`Ctrl + P`  搜索即可。"
    },
    {
      "id": "/剑指Offer——表示数值的字符串（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——表示数值的字符串（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——表示数值的字符串（JS实现）.md",
        "source": "@site/blog\\剑指Offer——表示数值的字符串（JS实现）.md",
        "title": "剑指Offer——表示数值的字符串（JS实现）",
        "description": "题目描述",
        "date": "2021-05-24T00:00:00.000Z",
        "formattedDate": "2021年5月24日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.08,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——表示数值的字符串（JS实现）",
          "date": "2021-05-24T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "VSCode根据文件名快速打开文件的方法",
          "permalink": "/blog/VSCode根据文件名快速打开文件的方法"
        },
        "nextItem": {
          "title": "时间管理精细化",
          "permalink": "/blog/时间管理精细化"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/7164491de7452fed76feb6a59b81fc7d.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/e072c505f0f054e5a74be95084ef4760.png)\r\n\r\n## 解题思路\r\n* 本题采用正则表达式的解法，就当作练习自己的正则表达式了\r\n1. 使用trim去除字符串两侧的空格。\r\n2. 小数的情况。\r\n3. 整数的情况。\r\n4. 为e或E的情况，然后后面跟着一个整数的情况\r\n综合上面四种情况，来综合判断是否符合表示数值的字符串。这道题题干真的很清晰。\r\n\r\n## 解题代码\r\n```js\r\nvar isNumber = function(s) {\r\n    // 去除字符串两侧的空格\r\n    s = s.trim();\r\n    // 判断是否有 + - 号，有则继续判断\r\n    const num = s.match(/^[+-]?\\d{1,}\\.([eE][+-]?\\d+)?$/);\r\n    const num2 = s.match(/^[+-]?\\d{1,}\\.\\d{1,}([eE][+-]?\\d+)?$/);\r\n    const num3 = s.match(/^[+-]?\\.\\d{1,}([eE][+-]?\\d+)?$/);\r\n    const num4 = s.match(/^[+-]?\\d+([eE][+-]?\\d+)?$/)\r\n    if (!num && !num2 && !num3 && !num4) {\r\n        return false;\r\n    } else {\r\n        return true\r\n    }\r\n};\r\n```\r\n## 总结（本题给我们的启示思路）\r\n* 学会灵活运用正则表达式。"
    },
    {
      "id": "/时间管理精细化",
      "metadata": {
        "permalink": "/blog/时间管理精细化",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/时间管理精细化.md",
        "source": "@site/blog\\时间管理精细化.md",
        "title": "时间管理精细化",
        "description": "细化时间管理",
        "date": "2021-05-24T00:00:00.000Z",
        "formattedDate": "2021年5月24日",
        "tags": [
          {
            "label": "学习方法",
            "permalink": "/blog/tags/学习方法"
          }
        ],
        "readingTime": 5.08,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "时间管理精细化",
          "date": "2021-05-24T00:00:00.000Z",
          "categories": "学习方法",
          "tags": [
            "学习方法"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——表示数值的字符串（JS实现）",
          "permalink": "/blog/剑指Offer——表示数值的字符串（JS实现）"
        },
        "nextItem": {
          "title": "剑指Offer——把字符串转换成整数（JS实现）",
          "permalink": "/blog/剑指Offer——把字符串转换成整数（JS实现）"
        }
      },
      "content": "## 细化时间管理\r\n1. 通过计时的方式来给自己每日安排计划。\r\n2. 以点滴的积累来完成自己的目标。\r\n\r\n## 番茄工作法\r\n>众多研究表明，人的注意力很难持续半小时以上，番茄工作法首先在时间上做强制性拆分，把25分钟作为一个时间单位，称作一个番茄钟。\r\n\r\n### 使用方法\r\n1. 番茄钟时间只许学习，不许做其他任何事情！\r\n2. 每个番茄钟完成时，强制休息5分钟！\r\n\r\n### 方法原理\r\n#### 1. 解决走神问题\r\n* 开着闹钟学习，有一种紧迫感，就像有一条狼狗追着你，你会下意识的学习。\r\n* 着眼于当下。任务太复杂，会让人产生恐惧，恐惧就会产生拖延，别想太多，赶紧上手。\r\n* 形成条件反射。经过反复的训练，我们的大脑会把开启番茄钟和集中注意力建立联系。\r\n* 奖励的快感。五分钟的休息是25分钟努力的一个小奖励，小奖励会带给一种完成任务的快感，激励我们产生奖励->专注->奖励->专注 的良性循环。\r\n\r\n#### 2. 保持良好节奏：短休息和长休息\r\n* 番茄工作法想要实现的是保持专注，确保学要好好的投入进去，玩就要好好的玩。\r\n* 每1个番茄钟的结束需要进行5分钟的短休息，每4个番茄钟的结束需要进行30分钟的长休息。\r\n* 休息的时候不要进行任何脑力思考，尤其是和学习相关的东西。（起身去上个厕所，喝口水，活动活动身体都可以）\r\n* 短休息不要玩手机！\r\n* 学习与休息达到一个平衡的状态，学习效率才会越高。\r\n\r\n#### 3. 维护良好节奏：自我打断与外部打断\r\n* 学习中被各种琐事打断是影响效率的重要因素。番茄工作法将打断情况分为自我打断和外部打断，自我打断指的是那些心里惦记的事情，外部打断指的是因为各种琐事来找你的同学等。\r\n* 处理自我打断的三个步骤：\r\n1. 接受，不要抑制想法。\r\n2. 记录，把想法记到备忘录中，等到番茄钟结束的时候再做。\r\n3. 继续，立刻返回学习的状态。\r\n* 处理外部打断的方式：根据自己的实际情况进行协调。\r\n\r\n#### 4. 解决拖延症：任务分解\r\n* 你可能会遇到单词这么多什么时候能背完，大作业这么难，什么时候才能写完的问题，这些都是因为目标过大，产生的恐惧心理，恐惧使你拖延。\r\n* 任务分解就是解决拖延的神兵利器。\r\n* 开始一件任务之前，必须要通过番茄钟的个数来衡量一个任务。\r\n* 如果一个任务超过了7个番茄钟，说明这件任务很复杂，需要拆分，将其拆分为几个小任务，每个小任务占据几个番茄钟，然后分步实施。\r\n* 切记番茄钟是不可拆分的，不可设置带有小数的番茄钟。\r\n\r\n#### 5. 提升宏观效率：计划与改进\r\n>为什么要有计划与改进？\r\n答：学习既要专注于当下，又要看清楚前进的方向，这就是古人讲的“吾日三省吾身”的道理。\r\n* 通过三张表格来促进改进我们的计划，分别是下面三点。\r\n1. 周计划清单。（本周有什么任务就写什么，不用区分优先级）\r\n2. 日计划清单。（日计划清单是从周计划清单中挑选出来的，需要区分优先级）\r\n3. 跟踪表格。（跟踪表格是用来记录计划清单中完成的番茄数和被打断的次数，不断优化我们的计划设置，使得计划设置更合理）"
    },
    {
      "id": "/剑指Offer——把字符串转换成整数（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——把字符串转换成整数（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——把字符串转换成整数（JS实现）.md",
        "source": "@site/blog\\剑指Offer——把字符串转换成整数（JS实现）.md",
        "title": "剑指Offer——把字符串转换成整数（JS实现）",
        "description": "题目描述",
        "date": "2021-05-22T00:00:00.000Z",
        "formattedDate": "2021年5月22日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.615,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——把字符串转换成整数（JS实现）",
          "date": "2021-05-22T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "时间管理精细化",
          "permalink": "/blog/时间管理精细化"
        },
        "nextItem": {
          "title": "can‘t convert BigInt value to Number value",
          "permalink": "/blog/can‘t convert BigInt value to Number value"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/c1b8cdb5f387c1df1b57be5f273e577a.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/57ed40cded6e61d71a19375ca13fc093.png)\r\n\r\n## 解题思路\r\n* 本题需要考虑的一是数值是由范围的，其次就是正则表达式怎么写，当然本题也可以不使用正则表达式，但是本次题解采用的是正则，因为这样简单易懂。\r\n1. 首先去除字符串两侧的空格。\r\n2. 使用正则表达式匹配出带正负号或者不带的数字部分。\r\n3. 判断匹配的是否存在，存在就继续判断是否在数值范围内，反之则返回0。\r\n\r\n## 解题代码\r\n```js\r\nvar strToInt = function(str) {\r\n    // 首先去除字符串两侧空格\r\n    str = str.trim();\r\n    // 使用正则表达式匹配出数字部分\r\n    let num = str.match(/^[+-]?\\d+/);\r\n    if (!num) {\r\n        return 0;\r\n    } else {\r\n        num = num[0];\r\n    }\r\n    // 确定数值范围的最大值和最小值\r\n    const min = - (2 ** 31);\r\n    const max = (2 ** 31) - 1;\r\n    // 判断num是否超出数值范围\r\n    return num < min ? min : num > max ? max : num;\r\n};\r\n```\r\n## 总结（本题给我们的启示思路）\r\n* 学会去除字符串两侧的空格，trim这个API不会对原字符串产生影响。\r\n* 学会使用正则表达式。\r\n* 学会通过三目运算符进行连续的判断。"
    },
    {
      "id": "/can‘t convert BigInt value to Number value",
      "metadata": {
        "permalink": "/blog/can‘t convert BigInt value to Number value",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/can‘t convert BigInt value to Number value.md",
        "source": "@site/blog\\can‘t convert BigInt value to Number value.md",
        "title": "can‘t convert BigInt value to Number value",
        "description": "错误原因",
        "date": "2021-05-21T00:00:00.000Z",
        "formattedDate": "2021年5月21日",
        "tags": [
          {
            "label": "debug",
            "permalink": "/blog/tags/debug"
          }
        ],
        "readingTime": 0.32,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "can‘t convert BigInt value to Number value",
          "date": "2021-05-21T00:00:00.000Z",
          "categories": "debug",
          "tags": [
            "debug"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——把字符串转换成整数（JS实现）",
          "permalink": "/blog/剑指Offer——把字符串转换成整数（JS实现）"
        },
        "nextItem": {
          "title": "剑指Offer——剪绳子II（JS实现）",
          "permalink": "/blog/剑指Offer——剪绳子II（JS实现）"
        }
      },
      "content": "## 错误原因\r\n>通过sort这个API对全是BigInt的数组进行排序导致的错误\r\nsort((num1,num2) => num1 - num2)\r\n\r\n## 解决办法\r\n使用下面的排序方式\r\n```js\r\nsort((a, b) => (a < b) ? -1 : ((a > b) ? 1 : 0));\r\n```"
    },
    {
      "id": "/剑指Offer——剪绳子II（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——剪绳子II（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——剪绳子II（JS实现）.md",
        "source": "@site/blog\\剑指Offer——剪绳子II（JS实现）.md",
        "title": "剑指Offer——剪绳子II（JS实现）",
        "description": "题目描述",
        "date": "2021-05-21T00:00:00.000Z",
        "formattedDate": "2021年5月21日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.665,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——剪绳子II（JS实现）",
          "date": "2021-05-21T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "can‘t convert BigInt value to Number value",
          "permalink": "/blog/can‘t convert BigInt value to Number value"
        },
        "nextItem": {
          "title": "剑指Offer——I. 斐波那契数列（JS实现）",
          "permalink": "/blog/剑指Offer——I. 斐波那契数列（JS实现）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/aa3025f79bc112bb9f334d442bd8692c.png)\r\n\r\n## 解题思路\r\n* 本题与《剪绳子I》这个题目本质是一样的，但是区别在于，本题加大了数字范围需要对答案进行取模1000000007，但是我们在调用Math.max函数的时候，里面不能有BigInt类型，所以我们必须自己实现Max函数，本题采用的是排序的方式求出最大值，但是排序的写法有讲究，具体看下面的解题代码\r\n\r\n## 解题代码\r\n```js\r\nvar cuttingRope = function(n) {\r\n    // 本题可以采用动态规划的思想\r\n    // 动态规划的结束条件是dp[2] = 1  代表的含义是长度为2的绳子剪成几段后最大乘积是1\r\n    // 本题有个默认条件：就是 输入的n是大于等于2的\r\n    const dp = new Array(n + 1);\r\n    dp.fill(BigInt(1));\r\n    for (let i = 3; i < dp.length;i++) {\r\n        for (let j = 1; j < i;j++) {\r\n            dp[i] = max(dp[i],BigInt(j*(i-j)),BigInt(j)*dp[i-j]);\r\n        }\r\n    }\r\n    return dp[n] % 1000000007n\r\n    function max(...args) {\r\n        args.sort((a, b) => (a < b) ? -1 : ((a > b) ? 1 : 0));\r\n        return args[2];\r\n    }\r\n};\r\n```\r\n## 总结（本题给我们的启示思路）\r\n* 学会通过动态规划的思想解决剪绳子的问题。\r\n* 学会使用BigInt。\r\n* 学会使用sort比较大小的方式进行排序。\r\n\r\n## 参考文献\r\n[剑指Offer——剪绳子（JS实现）](https://juejin.cn/post/6954166487938498590)"
    },
    {
      "id": "/剑指Offer——I. 斐波那契数列（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——I. 斐波那契数列（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——I. 斐波那契数列（JS实现）.md",
        "source": "@site/blog\\剑指Offer——I. 斐波那契数列（JS实现）.md",
        "title": "剑指Offer——I. 斐波那契数列（JS实现）",
        "description": "题目描述",
        "date": "2021-05-20T00:00:00.000Z",
        "formattedDate": "2021年5月20日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.965,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——I. 斐波那契数列（JS实现）",
          "date": "2021-05-20T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——剪绳子II（JS实现）",
          "permalink": "/blog/剑指Offer——剪绳子II（JS实现）"
        },
        "nextItem": {
          "title": "剑指Offer——数值的整数次方（JS实现）",
          "permalink": "/blog/剑指Offer——数值的整数次方（JS实现）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/13390458dabe9c341e65013ae9679f6e.png)\r\n\r\n## 解题思路\r\n* 本题如果直接使用递归进行计算，思路上是简单的，但是一定会超时，因为递归的时间复杂度太高，所以本题采用循环计算法。\r\n* 所谓循环计算法，就是用两个临时变量，指向第i个元素的前两个元素，随着i的更新而不断更新。\r\n\r\n## 解题代码\r\n```js\r\nvar fib = function(n) {\r\n    if (n <= 1) return n;\r\n    let temp1 = 1;\r\n    let temp2 = 1;\r\n    let res;\r\n    for (let i = 0 ; i < n; i++) {\r\n        res = temp1;\r\n        temp1 = temp2;\r\n        temp2 = (res + temp1) % 1000000007\r\n    }\r\n    return res;\r\n};\r\n```\r\n## 总结（本题给我们的启示思路）\r\n* 学会通过循环计算法来解决斐波那契数列等递归问题。"
    },
    {
      "id": "/剑指Offer——数值的整数次方（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——数值的整数次方（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——数值的整数次方（JS实现）.md",
        "source": "@site/blog\\剑指Offer——数值的整数次方（JS实现）.md",
        "title": "剑指Offer——数值的整数次方（JS实现）",
        "description": "题目描述",
        "date": "2021-05-20T00:00:00.000Z",
        "formattedDate": "2021年5月20日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.26,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——数值的整数次方（JS实现）",
          "date": "2021-05-20T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——I. 斐波那契数列（JS实现）",
          "permalink": "/blog/剑指Offer——I. 斐波那契数列（JS实现）"
        },
        "nextItem": {
          "title": "React项目中一种维持登录的方法",
          "permalink": "/blog/React项目中一种维持登录的方法"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/e6fe46193d5dd219ddd4ffff8fa39071.png)\r\n\r\n## 解题思路\r\n* 本题核心： 当n为奇数和偶数时两种情况的讨论，同时要注意n为0、负数是的情况。\r\n- 情况1： (2,4) = (2,2) * (2,2)\r\n- 情况2：(2,5) = (2,2) * (2,2) * 2\r\n* 具体详尽思路请看注释\r\n\r\n## 解题代码\r\n```js\r\nvar myPow = function(x, n) {\r\n    \r\n    // !本题核心： 当n为奇数和偶数时两种情况的讨论\r\n    // 情况1： (2,4) = (2,2) * (2,2)\r\n    // 情况2：(2,5) = (2,2) * (2,2) * 2\r\n    // 首先n是有可能为0，正，负数的\r\n    if (n === 0) return 1;\r\n    // 无论正负数我们都先将其转换为正数计算\r\n    const res = dfs(x,Math.abs(n));\r\n\r\n    if (n > 0) {\r\n        return res;\r\n    } else {\r\n        return 1/res;\r\n    }\r\n\r\n    function dfs(x,n) {\r\n        // 递归的结束条件\r\n        if (n === 1) {\r\n            return x;\r\n        }\r\n        let temp = dfs(x,Math.floor(n/2));\r\n\r\n        return n % 2 ? (x * temp * temp) : (temp * temp)\r\n    }\r\n}\r\n```\r\n## 总结（本题给我们的启示思路）\r\n* 学会通过递归找到幂指数运算之间的规律。"
    },
    {
      "id": "/React项目中一种维持登录的方法",
      "metadata": {
        "permalink": "/blog/React项目中一种维持登录的方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React项目中一种维持登录的方法.md",
        "source": "@site/blog\\React项目中一种维持登录的方法.md",
        "title": "React项目中一种维持登录的方法",
        "description": "1. 引入store.js库",
        "date": "2021-05-19T00:00:00.000Z",
        "formattedDate": "2021年5月19日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 1.77,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React项目中一种维持登录的方法",
          "date": "2021-05-19T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——数值的整数次方（JS实现）",
          "permalink": "/blog/剑指Offer——数值的整数次方（JS实现）"
        },
        "nextItem": {
          "title": "剑指Offer——正则表达式匹配（JS实现）",
          "permalink": "/blog/剑指Offer——正则表达式匹配（JS实现）"
        }
      },
      "content": "## 1. 引入store.js库\r\n[项目地址](https://github.com/marcuswestin/store.js#user-content-installation)\r\n```\r\nnpm i store\r\n```\r\n## 2. 定义并导出存储到本地的模块(storageUtils.js)\r\n```js\r\n// ! 本模块主要是进行local数据存储\r\nimport store from 'store'\r\nconst USER_KEY = 'user_key';\r\n\r\nexport default {\r\n    // 保存用户\r\n    saveUser(user) {\r\n        store.set(USER_KEY,user);// 登录成功的时候，读取用户数据并放在内存中\r\n            const user = result.data;\r\n            // memoryUtils.user = user;\r\n            storageUtils.saveUser(user);\r\n    },\r\n\r\n    // 读取用户\r\n    getUser() {\r\n        return store.get(USER_KEY) || {}\r\n    },\r\n\r\n    // 删除用户\r\n    removeUser() {\r\n        store.remove(USER_KEY);\r\n    }\r\n}\r\n```\r\n## 3. 登录成功时将用户的数据通过storageUtils的saveUser方法进行保存\r\n```js\r\n// 登录成功的时候，读取用户数据并放在内存中// 将local中的user保存到内存中去\r\nconst user = storageUtils.getUser();\r\nmemoryUtils.user = user;\r\nconst user = result.data;\r\n// memoryUtils.user = user;\r\nstorageUtils.saveUser(user);\r\n```\r\n## 4. 定义记录用户信息的内存文件（memoryUtils.js）\r\n```js\r\n// ! 本文件主要存放需要存储的用户信息等内容\r\nexport default {\r\n    user: {}\r\n}\r\n```\r\n## 5. 在入口文件将local中的用户信息保存到内存文件中\r\n```js\r\n// 将local中的user保存到内存中去\r\nconst user = storageUtils.getUser();\r\nmemoryUtils.user = user;\r\n```\r\n## 6. 登录成功后的界面首先检测内存文件中是否有用户，有则加载，无则跳转到登录路由\r\n```js\r\nconst user = memoryUtils.user;\r\n// 如果没有获取到用户id则直接返回登录页面\r\nif (!user._id) {\r\n    return <Redirect to='/login' />\r\n}\r\n```"
    },
    {
      "id": "/剑指Offer——正则表达式匹配（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——正则表达式匹配（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——正则表达式匹配（JS实现）.md",
        "source": "@site/blog\\剑指Offer——正则表达式匹配（JS实现）.md",
        "title": "剑指Offer——正则表达式匹配（JS实现）",
        "description": "题目描述",
        "date": "2021-05-19T00:00:00.000Z",
        "formattedDate": "2021年5月19日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 5.38,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——正则表达式匹配（JS实现）",
          "date": "2021-05-19T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "React项目中一种维持登录的方法",
          "permalink": "/blog/React项目中一种维持登录的方法"
        },
        "nextItem": {
          "title": "事件循环机制（Event Loop）的基本认知",
          "permalink": "/blog/事件循环机制（Event Loop）的基本认知"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/b89c1df5b4f2ae859f75b5ed3aa82c80.png)\r\n\r\n## 解题思路\r\n* 本题的主流解法包括两种，主要是递归回溯与动态规划，鉴于动态规划不易理解，本文采用递归回溯的方法进行讲解，步骤如下：\r\n\r\n#### 1. 判断p字符串是否为空，如果为空则继续判断字符串s是否为空\r\n* 我们首先要准确理解字符s和字符p的含义，字符s代表的是待匹配的字符串，而字符串p则代表的是我们的匹配模式\r\n* 如果匹配模式为空，我们要看待匹配的字符s是否为空，如果两者皆为空，说明空匹配空，结果返回true,如果p为空，但是s不为空，说明让空去匹配非空，肯定false,这是我们递归的出口。\r\n```js\r\nif (p.length === 0) {\r\n    if (s.length === 0) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n```\r\n\r\n#### 2. 判断在字符串s非空的情况下，第一个字符是否能够成功匹配\r\n为什么要在字符串s非空的情况下，去进行匹配？\r\n>答：因为字符串s如果为空，去匹配第一个字符是没有意义的，如果字符s为空，且能够走到这里，说明字符串p不为空，要不然也不能走到第二步就返回了，如果字符s为空我们跳转到后面的第三步。\r\n\r\n1. s的第一个字符和p的第一个字符相等，或者p的第一个字符为 \".\"，都说明成功匹配到了。\r\n2. 判断字符串p的长度，此时存在两种情况，一种是小于2，一种是大于等于2，如果小于2，我们就没必要判断当前字符p的第二个字符是不是\\*号了，直接将s去掉首元素和p去掉首元素，投入到递归函数中去继续判断，如果大于等于2的情况，则是有必要继续判断的，我们要判断p字符的第二个字符是不是\\*号的，如果第二个是\\*号则存在两种情况，一个是这个\\*号代表前面的字符出现了0次，另一种情况是前面的字符出现了多次，此时我们就要分情况讨论了，如果代表的是0次，则将s不变和p去掉前两个字符，投入递归函数，如果代表的是多次，我们首先当作一次，把s去掉首元素，p不变继续递归。\r\n3. 如果字符串p的长度小于2，由于前面的条件限制使得首元素是相同的，我们只用将s和p分别去掉首元素，继续投入递归，由结束条件来帮助我们继续判断。\r\n4. 如果字符串s为空，或者第一个字符不匹配，我们首先判断p的长度，如果p的长度是小于2的，当前元素不同，后面又没有\\*了，所以直接返回false,如果p的长度是大于等于2的，继续判断p的第二个元素是不是\\*，如果是，则将s不变，p去掉两个首元素继续递归判断，如果第二个元素不是\\*，直接返回false.\r\n\r\n## 解题代码\r\n```js\r\nvar isMatch = function (s, p) {\r\n    // 判断模式p是否为空，如果为空，则判断s是否为空\r\n    if (p.length === 0) {\r\n        if (s.length === 0) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    // 判断第一个字符是否匹配\r\n    if (s.length !== 0 && (s[0] === p[0] || p[0] === '.')) {\r\n        // 走到这里说明，第一个字符是匹配的\r\n        if (p.length >= 2) {\r\n            // 判断第二个字符是不是 *\r\n            if (p[1] === '*') {\r\n                return isMatch(s, p.slice(2)) || isMatch(s.slice(1), p)\r\n            } else {\r\n                return isMatch(s.slice(1), p.slice(1));\r\n            }\r\n        } else {\r\n            return isMatch(s.slice(1), p.slice(1));\r\n        }\r\n\r\n    } else {\r\n        if (p.length >= 2) {\r\n            if (p[1] === '*') {\r\n                return isMatch(s, p.slice(2));\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n        \r\n    }\r\n};\r\n```\r\n## 总结（本题给我们的启示思路）\r\n* 学会通过递归回溯解决多边界条件问题\r\n* 本题的难点在于\\*这种情况的考虑，刚开始不会也是正常，千万不要焦躁，不要放弃，仔细想想总会解出来的。"
    },
    {
      "id": "/事件循环机制（Event Loop）的基本认知",
      "metadata": {
        "permalink": "/blog/事件循环机制（Event Loop）的基本认知",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/事件循环机制（Event Loop）的基本认知.md",
        "source": "@site/blog\\事件循环机制（Event Loop）的基本认知.md",
        "title": "事件循环机制（Event Loop）的基本认知",
        "description": "一、什么是事件循环机制？",
        "date": "2021-05-18T00:00:00.000Z",
        "formattedDate": "2021年5月18日",
        "tags": [
          {
            "label": "浏览器知识",
            "permalink": "/blog/tags/浏览器知识"
          }
        ],
        "readingTime": 3.225,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "事件循环机制（Event Loop）的基本认知",
          "date": "2021-05-18T00:00:00.000Z",
          "categories": "浏览器知识",
          "tags": [
            "浏览器知识"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——正则表达式匹配（JS实现）",
          "permalink": "/blog/剑指Offer——正则表达式匹配（JS实现）"
        },
        "nextItem": {
          "title": "推荐一个在线下载Youtube的网站",
          "permalink": "/blog/推荐一个在线下载Youtube的网站"
        }
      },
      "content": "## 一、什么是事件循环机制？\r\n>在介绍事件循环机制之前，我们要首先了解以下什么是事件循环机制，我们首先看下下面这段代码的执行顺序，正确的执行顺序应该是序号1>3>2\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/d725ac1dc59a44f7311a8b1841510daf.png)\r\n\r\n### 为什么是上面的顺序呢？\r\n原因是JS引擎指向代码是从上往下执行的，所以首先会执行序号1这个语句，JS引擎会将这个语句放在调用栈当中，然后执行代码，将序号1打印在控制台当中，当这段代码执行完毕之后，便将这段代码从调用栈中移出去。然后开始执行后续的代码，此时setTimeout这段代码进入调用栈，这段代码，会调用Web API,2秒之后进入callback队列，此时JS引擎将setTimeout移出调用栈，继续执行后面的代码，所以屏幕上会先打印出序号1,3，此时eventLoop登场了，它会不断循环的访问callbackqueue，等2s之后Web API会将要执行的打印序号2这句话放入callbackqueue,eventLoop将callbackQueue中的内容放入调用栈，开始执行，然后屏幕上打印出序号2，这就是eventLoop的基本流程。\r\n### 执行顺序图解\r\n![](https://img-blog.csdnimg.cn/img_convert/d49b4d614dd7d061a67249e2b0eae291.png)\r\n\r\n### 引出事件循环是什么\r\n>JS的运行机制就是事件循环!\r\n## 二、JS的执行顺序是什么？\r\n1. JS是从上到下一行一行执行。\r\n2. 如果某一行执行报错，则停止执行下面的代码。\r\n3. 先执行同步代码，再执行异步代码\r\n\r\n## 三、事件循环的执行过程\r\n* 同步代码，调用栈执行后直接出栈\r\n* 异步代码，放到Web API中，等待时机，等合适的时候放入回调队列（callbackQueue），等到调用栈空时eventLoop开始工作，轮询\r\n* 微任务执行时机比宏任务要早\r\n![](https://img-blog.csdnimg.cn/img_convert/c3dbc1a173bddef90d1a4a7ef7a16aef.png)\r\n\r\n* 微任务在DOM渲染前触发，宏任务在DOM渲染后触发\r\n\r\n## 四、微任务和宏任务的根本区别\r\n* 微任务是由ES6语法规定的\r\n* 宏任务是由浏览器规定的\r\n\r\n## 五、事件循环的整体流程\r\n1. 先清空call stack中的同步代码\r\n2. 执行微任务队列中的微任务\r\n3. 尝试DOM渲染\r\n4. 触发Event Loop反复询问callbackQueue中是否有要执行的语句，有则放入call back继续执行\r\n![](https://img-blog.csdnimg.cn/img_convert/bf35f47b530b624884c99f520551cd0c.png)\r\n\r\n## 六、事件循环经典案例\r\n![](https://img-blog.csdnimg.cn/20201015205742198.gif)\r\n\r\n## 参考资料\r\n[什么是Event Loop?](https://www.bilibili.com/video/BV1u54y1j7Yu?from=search&seid=14237450040319513888)\r\n\r\n[[JavaScript]什么是事件循环(Event Loop)？](https://blog.csdn.net/iChangebaobao/article/details/109283166)"
    },
    {
      "id": "/推荐一个在线下载Youtube的网站",
      "metadata": {
        "permalink": "/blog/推荐一个在线下载Youtube的网站",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/推荐一个在线下载Youtube的网站.md",
        "source": "@site/blog\\推荐一个在线下载Youtube的网站.md",
        "title": "推荐一个在线下载Youtube的网站",
        "description": "通过该网站可以实现在线下载YouTube视频",
        "date": "2021-05-18T00:00:00.000Z",
        "formattedDate": "2021年5月18日",
        "tags": [
          {
            "label": "效率",
            "permalink": "/blog/tags/效率"
          }
        ],
        "readingTime": 0.125,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "推荐一个在线下载Youtube的网站",
          "date": "2021-05-18T00:00:00.000Z",
          "categories": "效率",
          "tags": [
            "效率"
          ]
        },
        "prevItem": {
          "title": "事件循环机制（Event Loop）的基本认知",
          "permalink": "/blog/事件循环机制（Event Loop）的基本认知"
        },
        "nextItem": {
          "title": "HTTP协议中的常用状态码",
          "permalink": "/blog/HTTP协议中的常用状态码"
        }
      },
      "content": "## 通过该网站可以实现在线下载YouTube视频\r\n![](https://img-blog.csdnimg.cn/img_convert/9f11f5c35ce7563e1cc75fc5ac3745a0.png)\r\n\r\n## [点击下载](https://zh.savefrom.net/7/)"
    },
    {
      "id": "/HTTP协议中的常用状态码",
      "metadata": {
        "permalink": "/blog/HTTP协议中的常用状态码",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/HTTP协议中的常用状态码.md",
        "source": "@site/blog\\HTTP协议中的常用状态码.md",
        "title": "HTTP协议中的常用状态码",
        "description": "一、设置状态码的意义",
        "date": "2021-05-17T00:00:00.000Z",
        "formattedDate": "2021年5月17日",
        "tags": [
          {
            "label": "HTTP",
            "permalink": "/blog/tags/http"
          }
        ],
        "readingTime": 3.92,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "HTTP协议中的常用状态码",
          "date": "2021-05-17T00:00:00.000Z",
          "categories": "HTTP",
          "tags": [
            "HTTP"
          ]
        },
        "prevItem": {
          "title": "推荐一个在线下载Youtube的网站",
          "permalink": "/blog/推荐一个在线下载Youtube的网站"
        },
        "nextItem": {
          "title": "剑指Offer——二维数组中的查找（JS实现）",
          "permalink": "/blog/剑指Offer——二维数组中的查找（JS实现）"
        }
      },
      "content": "## 一、设置状态码的意义\r\n>HTTP协议是在web浏览器和服务器之间进行传递信息的协议，HTTP协议中设置状态码的意义在于，服务器端通过状态码来高速浏览器端，当前的网页请求发生了什么以及当前WEB服务器的相应状态，HTTP状态码可以用来判断当前服务器端的的运行状况以及浏览器端网页的请求情况。\r\n\r\n***\r\n\r\n## 二、常用的HTTP状态码分类\r\n1. **1XX (服务器端接收请求，正在处理)**\r\n* 场景介绍：假如浏览器端想给服务器发送一个较大的文件，如果服务器端给浏览器端返回的是1XX的状态码，则表示服务器端已经接收到了请求，正在处理。\r\n2. **2XX（请求成功）**\r\n* 场景介绍：服务器端接收到了请求，并进行了处理。\r\n3. **3XX（重定向状态码）**\r\n* 场景介绍：这个状态码表示服务器端认为浏览器端需要采取进一步的操作才能完成请求，重定向的目标在本次响应的Location域中。\r\n4. **4XX（浏览器端/客户端错误）**\r\n* 场景介绍：这类状态码代表着浏览器端可能发生了错误，妨碍了服务器的处理。\r\n5. **5XX（服务器端错误）**\r\n* 场景介绍：这类状态码表示服务器在处理请求的时候出现了错误，或者异常。\r\n\r\n***\r\n\r\n## 三、常见状态码含义\r\n* **100**：这是一个临时响应，表示服务器端已经接受部分请求，客户端应该继续发送请求的剩余部分。\r\n* **200**：服务器端已经成功收到并处理了请求。\r\n* **204**：服务器端成功处理，但是并未返回内容\r\n* **301**：永久重定向，请求的资源已经被永久的移动到了新的URL，返回的信息会包括新的URL，浏览器会自动定向到新的URL。\r\n* **302**：临时重定向，请求的资源临时的被移动到了新的URL，客户端应继续使用原有的URL。\r\n* **304**：这是客户端有缓存情况下服务端的一种响应，客户端在请求一个文件的时候发现有缓存，那么请求中就会包含这个缓存文件的时间，服务器端收到请求之后会和本地文件进行对比，没有更新的话就返回状态码304，客户端收到响应后就会从本地缓存中加载这个资源。\r\n* **400**：客户端的错误，服务器不理解请求的语法。\r\n* **403**：服务器端拒绝执行客户端的请求。\r\n* **404**：客户端请求的资源不存在。\r\n* **500**：服务器内部的错误，使得服务器无法完成请求。\r\n* **502**：服务器作为网关或代理，从上游服务器收到无效响应。\r\n\r\n***\r\n## 参考文献\r\n[http与https，http状态码详细列表](https://blog.csdn.net/lijie45655/article/details/91359707)\r\n\r\n[HTTP面试-常用状态码（status code）的那些事](https://juejin.cn/post/6844904080838492174#heading-6)\r\n\r\n[HTTP 中常用的状态码（14种）](https://juejin.cn/post/6844904202863394830)"
    },
    {
      "id": "/剑指Offer——二维数组中的查找（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——二维数组中的查找（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——二维数组中的查找（JS实现）.md",
        "source": "@site/blog\\剑指Offer——二维数组中的查找（JS实现）.md",
        "title": "剑指Offer——二维数组中的查找（JS实现）",
        "description": "题目描述",
        "date": "2021-05-17T00:00:00.000Z",
        "formattedDate": "2021年5月17日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.565,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——二维数组中的查找（JS实现）",
          "date": "2021-05-17T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "HTTP协议中的常用状态码",
          "permalink": "/blog/HTTP协议中的常用状态码"
        },
        "nextItem": {
          "title": "剑指Offer——数字序列中某一位的数字（JS实现）",
          "permalink": "/blog/剑指Offer——数字序列中某一位的数字（JS实现）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/8f0ca65120b9dbfae3877b608475f8c8.png)\r\n\r\n## 解题思路（数学规律）\r\n* 本题主要是从二维数组的左下角的元素出发，不断的进行移动比较，因为本题给出的二维数组存在一个特点就是，从左小角的元素出发，一列的元素中，上面的元素总是比下面的元素小，一行的元素中，右边的元素总是比左边的大，这个特点就是我们解题的关键。\r\n\r\n## 解题代码\r\n```js\r\nvar findNumberIn2DArray = function(matrix, target) {\r\n    // ! 本题核心：以左下角为起始点，如果比左下角的数字小，向上移动一位进行比较\r\n    // ! 如果比左下角的数字大，向右移动一位进行比较\r\n    if (matrix.length === 0) return false;\r\n    // if (matrix[0])\r\n    // 定位到左下角元素\r\n    let origin = matrix[matrix.length - 1][0];\r\n    // 定义移动时的指针;\r\n    let top = matrix.length - 1;\r\n    let right = 0;\r\n    // 定义最终返回的结果\r\n    let res;\r\n    while (1) {\r\n        if (top < 0 || right === matrix[0].length) return false;\r\n        origin = matrix[top][right];\r\n        if (origin === target) return true;\r\n        if (origin < target) {\r\n            right++;\r\n        }\r\n        if (origin > target) {\r\n            top--;\r\n        }\r\n    }\r\n};\r\n```\r\n## 总结（本题给我们的启示思路）\r\n* 启示：学会通过二维数组中的内在规律来解题。"
    },
    {
      "id": "/剑指Offer——数字序列中某一位的数字（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——数字序列中某一位的数字（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——数字序列中某一位的数字（JS实现）.md",
        "source": "@site/blog\\剑指Offer——数字序列中某一位的数字（JS实现）.md",
        "title": "剑指Offer——数字序列中某一位的数字（JS实现）",
        "description": "题目描述",
        "date": "2021-05-17T00:00:00.000Z",
        "formattedDate": "2021年5月17日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 2.465,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——数字序列中某一位的数字（JS实现）",
          "date": "2021-05-17T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——二维数组中的查找（JS实现）",
          "permalink": "/blog/剑指Offer——二维数组中的查找（JS实现）"
        },
        "nextItem": {
          "title": "Chrome插件Vimium的基础用法",
          "permalink": "/blog/Chrome插件Vimium的基础用法"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/8661736a565a732556d287cf5baf35b3.png)\r\n\r\n## 解题思路（数学规律）\r\n* 本题主要是寻找数学规律，通过暴力的方法肯定是超时的，下面就简单介绍下本题的解题思路，我认为核心还是在于理解将字符串拆分为不同位数的区间。\r\n1. 首先判断n在哪一个区间，区间的划分按照 1 - 9，10-99，100-999...\r\n2. 计算下标n在当前区间的哪一个\r\n3. 求出n下标对应的真实的数字\r\n4. 求出该真实数字的哪一位是我们最终要返回的结果\r\n\r\n## 公式\r\n\r\n$$\r\nn下标对应的真实数字 = 区间起始值 + （区间第几个 - 1） / 第几个区间\r\n$$\r\n$$\r\n真实数字的哪一位 = （区间第几个 - 1）\\%  第几个区间取余\r\n$$\r\n\r\n## 解题代码\r\n```js\r\nvar findNthDigit = function(n) {\r\n    // 这里的n是下标\r\n    // 如果下标小于10，直接返回n即可\r\n    if (n < 10) {\r\n        return n;\r\n    }\r\n    // 走到这里，说明n大于等于10，如果大于等于10，则要首先判断在下标n在哪个区间\r\n    let numInterval = 0;\r\n    for (let i = 1; i < 100; i++) {\r\n        if ((n - 9) < 9 * Math.pow(10,i) * (i+1)) {\r\n            numInterval = i+1;\r\n            break;\r\n        } \r\n    }\r\n    // 计算下标n  在当前区间的第几个  \r\n    for (let i = 0; i < numInterval-1; i++) {\r\n        n = n - 9 * (10 ** i) * (i+1);\r\n    }\r\n    // n所指向的下标对应的真实的数字 = 区间起始值 + （区间第几个 - 1） / 第几个区间\r\n    const trueNum = 10 ** (numInterval - 1) + parseInt( (n - 1) / numInterval )\r\n    // 真实的数字可能是一个多位数，但是题目要求返回的是下标指向的一个数字，所以下标指向的一个数字就是 \r\n    // (区间第几个 - 1) % 第几个区间\r\n    const numIndex = (n - 1) % numInterval;\r\n    return String(trueNum)[numIndex]\r\n};\r\n```\r\n## 总结（本题给我们的启示思路）\r\n* 启示：学会通过数学规律来求解问题"
    },
    {
      "id": "/Chrome插件Vimium的基础用法",
      "metadata": {
        "permalink": "/blog/Chrome插件Vimium的基础用法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Chrome插件Vimium的基础用法.md",
        "source": "@site/blog\\Chrome插件Vimium的基础用法.md",
        "title": "Chrome插件Vimium的基础用法",
        "description": "| 功能 | 快捷键 |",
        "date": "2021-05-16T00:00:00.000Z",
        "formattedDate": "2021年5月16日",
        "tags": [
          {
            "label": "效率",
            "permalink": "/blog/tags/效率"
          }
        ],
        "readingTime": 0.4,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Chrome插件Vimium的基础用法",
          "date": "2021-05-16T00:00:00.000Z",
          "categories": "效率",
          "tags": [
            "效率"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——数字序列中某一位的数字（JS实现）",
          "permalink": "/blog/剑指Offer——数字序列中某一位的数字（JS实现）"
        },
        "nextItem": {
          "title": "Promise与async的区别",
          "permalink": "/blog/Promise与async的区别"
        }
      },
      "content": "| 功能 | 快捷键 |\r\n| --- | --- |\r\n| 快速打开新标签页 | T |\r\n| 快速滚动到底G | G |\r\n| 快速滚动到顶部 | gg |\r\n| 向下滑动 | j |\r\n| 向上滚动 | k |\r\n| 调出页面链接或按钮的按键 | f |\r\n| 搜索标签 | b |\r\n| 搜索url | o |"
    },
    {
      "id": "/Promise与async的区别",
      "metadata": {
        "permalink": "/blog/Promise与async的区别",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Promise与async的区别.md",
        "source": "@site/blog\\Promise与async的区别.md",
        "title": "Promise与async的区别",
        "description": "1. 执行async函数返回的都是Promise对象",
        "date": "2021-05-16T00:00:00.000Z",
        "formattedDate": "2021年5月16日",
        "tags": [
          {
            "label": "Per Day",
            "permalink": "/blog/tags/per-day"
          }
        ],
        "readingTime": 0.945,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Promise与async的区别",
          "date": "2021-05-16T00:00:00.000Z",
          "categories": "Per Day",
          "tags": [
            "Per Day"
          ]
        },
        "prevItem": {
          "title": "Chrome插件Vimium的基础用法",
          "permalink": "/blog/Chrome插件Vimium的基础用法"
        },
        "nextItem": {
          "title": "剑指Offer——II. 青蛙跳台阶问题（JS实现）",
          "permalink": "/blog/剑指Offer——II. 青蛙跳台阶问题（JS实现）"
        }
      },
      "content": "## 1. 执行async函数返回的都是Promise对象\r\n* return的只要不是promise对象，那么返回的则是成功的promise对象\r\n* async函数返回的是error，那么返回的是失败的Promise\r\n* async函数返回的是promise对象，则根据这个对象的状态来决定Promise的状态\r\n\r\n## 2. Promise.then成功的情况下对应await\r\n![](https://img-blog.csdnimg.cn/img_convert/27710d45418668875340ebfbe2be5306.png)\r\n\r\n## 3. Promise.catch异常的情况对应 async中的try catch\r\n![](https://img-blog.csdnimg.cn/img_convert/5f21ed8ab15bb8a5c42cc6ec6071b2d4.png)\r\n\r\n## 4. async/await更符合同步语义，容易理解，使得异步代码更像是同步代码\r\n## 5. async/await是基于promise实现的\r\n## 6. async/await是生成器函数的语法糖，拥有内置执行器，不需要额外的调用，直接会自动调用并返回一个promise对象"
    },
    {
      "id": "/剑指Offer——II. 青蛙跳台阶问题（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——II. 青蛙跳台阶问题（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——II. 青蛙跳台阶问题（JS实现）.md",
        "source": "@site/blog\\剑指Offer——II. 青蛙跳台阶问题（JS实现）.md",
        "title": "剑指Offer——II. 青蛙跳台阶问题（JS实现）",
        "description": "题目描述",
        "date": "2021-05-16T00:00:00.000Z",
        "formattedDate": "2021年5月16日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 3.69,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——II. 青蛙跳台阶问题（JS实现）",
          "date": "2021-05-16T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "Promise与async的区别",
          "permalink": "/blog/Promise与async的区别"
        },
        "nextItem": {
          "title": "React项目引入路由（基础）",
          "permalink": "/blog/React项目引入路由（基础）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/45be453b4fa96c6109f7d9a0ae55eccb.png)\r\n\r\n## 解题思路一（暴力法）\r\n1. 当只有一级台阶的时候 F(1) = 1  只有一种跳法\r\n2. 当有两级台阶的时候 要么 1 + 1  要么 2  所以，F(2) = 2,此时有两种跳法\r\n3. 当台阶数大于2的时候，我们只用考虑最后一步的跳法\r\n4. 最后一步要么跳1步，要么跳2步\r\n5. 假设最后一步跳的是1步，则F(n) = F(n-1) + 1;\r\n6. 假设最后一步跳的是2步，则F(n) = F(n-2) + 1;\r\n7. 所以最后一步有这样的跳法 F(n) = F(n-1) + F(n-2);\r\n8. 最后得到的答案要取模 % 1000000007\r\n\r\n## 解题代码一（超时，时间复杂度太高）\r\n```js\r\nvar numWays = function(n) {\r\n    // 当只有一级台阶的时候 F(1) = 1  只有一种跳法\r\n    // 当有两级台阶的时候 要么 1 + 1  要么 2  所以，F(2) = 2,此时有两种跳法\r\n    // 当台阶数大于2的时候，我们只用考虑最后一步的跳法\r\n    // 最后一步要么跳1步，要么跳2步\r\n    // 假设最后一步跳的是1步，则F(n) = F(n-1) + 1;\r\n    // 假设最后一步跳的是2步，则F(n) = F(n-2) + 1;\r\n    // 所以最后一步有这样的跳法 F(n) = F(n-1) + F(n-2);\r\n    // 最后得到的答案要取模 % 1000000007\r\n    if (n === 1) return 1;\r\n    if (n === 2) return 2;\r\n    if (n === 0) return 1;\r\n    return (numWays(n-1) + numWays(n-2)) % 1000000007\r\n};\r\n```\r\n## 解题思路二（备忘录的方法） \r\n上面的解法之所以会超时，原因在于上面存在两个递归，第二个递归和第一个递归走了重复的路，因此时间复杂度较高，下面我们采用备忘录的方法，所谓的备忘录的方法就是用一个数组将第一个递归走过的路记录下来，这样第二的递归可以直接用，这样时间复杂度就会降下来。\r\n## 解题代码二\r\n```js\r\nvar numWays = function(n) {\r\n    // ! 备忘录的方法\r\n    // 定义一个备忘录\r\n    // 这里之所以要n+1，就是要确保数组的最后一个元素的下标就是台阶数\r\n    // 这里之所以填充负数，原因在于走法不可能是负数，用此来判断这个位置是否被遍历过\r\n    const cache = new Array(n + 1).fill(-1);\r\n    dfs(n,cache);\r\n    return cache[n];\r\n};\r\n\r\nfunction dfs(n,cache) {\r\n    // 下面的两个条件是递归的基础条件\r\n    if (n <= 1) cache[n] = 1;\r\n    if (n === 2) cache[n] = 2;\r\n    // 下面的这个是用来判断该位置是否已经填充，如果已经填充则不需要继续了，直接返回即可\r\n    if (cache[n] !== -1) return cache[n];\r\n    cache[n] = (dfs(n - 1,cache) + dfs(n - 2,cache)) % 1000000007;\r\n    return cache[n];\r\n}\r\n```\r\n## 总结（本题给我们的启示思路）\r\n* 启示：学会使用备忘录数组的方法来记录已经递归过的元素，降低递归的时间复杂度。"
    },
    {
      "id": "/React项目引入路由（基础）",
      "metadata": {
        "permalink": "/blog/React项目引入路由（基础）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React项目引入路由（基础）.md",
        "source": "@site/blog\\React项目引入路由（基础）.md",
        "title": "React项目引入路由（基础）",
        "description": "1. 安装工具包",
        "date": "2021-05-15T00:00:00.000Z",
        "formattedDate": "2021年5月15日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.3,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React项目引入路由（基础）",
          "date": "2021-05-15T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——II. 青蛙跳台阶问题（JS实现）",
          "permalink": "/blog/剑指Offer——II. 青蛙跳台阶问题（JS实现）"
        },
        "nextItem": {
          "title": "重置PC端页面的CSS样式代码（reset.css）",
          "permalink": "/blog/重置PC端页面的CSS样式代码（reset.css）"
        }
      },
      "content": "## 1. 安装工具包\r\n```\r\nnpm install react-router-dom\r\n```\r\n## 2. 引入路由器、路由、Switch等\r\n```js\r\nimport {BrowserRouter,Route,Switch} from 'react-router-dom'\r\nimport Admin from './pages/admin';\r\nimport Login from './pages/login';\r\nexport default class App extends Component {\r\n\r\n    render() {\r\n        return (\r\n            <BrowserRouter>\r\n                <Switch>\r\n                    <Route path='/login' component={Login}></Route>\r\n                    <Route path='/' component={Admin}></Route>\r\n                </Switch>\r\n            </BrowserRouter>\r\n        )\r\n    }\r\n}\r\n```"
    },
    {
      "id": "/重置PC端页面的CSS样式代码（reset.css）",
      "metadata": {
        "permalink": "/blog/重置PC端页面的CSS样式代码（reset.css）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/重置PC端页面的CSS样式代码（reset.css）.md",
        "source": "@site/blog\\重置PC端页面的CSS样式代码（reset.css）.md",
        "title": "重置PC端页面的CSS样式代码（reset.css）",
        "description": "reset.css",
        "date": "2021-05-15T00:00:00.000Z",
        "formattedDate": "2021年5月15日",
        "tags": [
          {
            "label": "CSS",
            "permalink": "/blog/tags/css"
          }
        ],
        "readingTime": 0.54,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "重置PC端页面的CSS样式代码（reset.css）",
          "date": "2021-05-15T00:00:00.000Z",
          "categories": "CSS",
          "tags": [
            "CSS"
          ]
        },
        "prevItem": {
          "title": "React项目引入路由（基础）",
          "permalink": "/blog/React项目引入路由（基础）"
        },
        "nextItem": {
          "title": "使用Git管理项目",
          "permalink": "/blog/使用Git管理项目"
        }
      },
      "content": "## reset.css\r\n>来源：https://github.com/jgthms/minireset.css/blob/master/minireset.css\r\n```css\r\n/*! minireset.css v0.0.6 | MIT License | github.com/jgthms/minireset.css */\r\nhtml,\r\nbody,\r\np,\r\nol,\r\nul,\r\nli,\r\ndl,\r\ndt,\r\ndd,\r\nblockquote,\r\nfigure,\r\nfieldset,\r\nlegend,\r\ntextarea,\r\npre,\r\niframe,\r\nhr,\r\nh1,\r\nh2,\r\nh3,\r\nh4,\r\nh5,\r\nh6 {\r\n  margin: 0;\r\n  padding: 0;\r\n}\r\n\r\nh1,\r\nh2,\r\nh3,\r\nh4,\r\nh5,\r\nh6 {\r\n  font-size: 100%;\r\n  font-weight: normal;\r\n}\r\n\r\nul {\r\n  list-style: none;\r\n}\r\n\r\nbutton,\r\ninput,\r\nselect {\r\n  margin: 0;\r\n}\r\n\r\nhtml {\r\n  box-sizing: border-box;\r\n}\r\n\r\n*, *::before, *::after {\r\n  box-sizing: inherit;\r\n}\r\n\r\nimg,\r\nvideo {\r\n  height: auto;\r\n  max-width: 100%;\r\n}\r\n\r\niframe {\r\n  border: 0;\r\n}\r\n\r\ntable {\r\n  border-collapse: collapse;\r\n  border-spacing: 0;\r\n}\r\n\r\ntd,\r\nth {\r\n  padding: 0;\r\n}\r\n```"
    },
    {
      "id": "/使用Git管理项目",
      "metadata": {
        "permalink": "/blog/使用Git管理项目",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/使用Git管理项目.md",
        "source": "@site/blog\\使用Git管理项目.md",
        "title": "使用Git管理项目",
        "description": "一、 在Github上建立仓库",
        "date": "2021-05-14T00:00:00.000Z",
        "formattedDate": "2021年5月14日",
        "tags": [
          {
            "label": "Git",
            "permalink": "/blog/tags/git"
          }
        ],
        "readingTime": 1.355,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "使用Git管理项目",
          "date": "2021-05-14T00:00:00.000Z",
          "categories": "Git",
          "tags": [
            "Git"
          ]
        },
        "prevItem": {
          "title": "重置PC端页面的CSS样式代码（reset.css）",
          "permalink": "/blog/重置PC端页面的CSS样式代码（reset.css）"
        },
        "nextItem": {
          "title": "剑指Offer——I.翻转单词顺序（JS实现）",
          "permalink": "/blog/剑指Offer——I.翻转单词顺序（JS实现）"
        }
      },
      "content": "## 一、 在Github上建立仓库\r\n![](https://img-blog.csdnimg.cn/img_convert/76b7886d64ef80971ac6ce7a24de04f6.png)\r\n\r\n## 二、在项目根目录创建.gitignore文件\r\n```\r\n# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.\r\n/.idea\r\n# dependencies\r\n/node_modules\r\n/.pnp\r\n.pnp.js\r\n\r\n# testing\r\n/coverage\r\n\r\n# production\r\n/build\r\n\r\n# misc\r\n.DS_Store\r\n.env.local\r\n.env.development.local\r\n.env.test.local\r\n.env.production.local\r\n\r\nnpm-debug.log*\r\nyarn-debug.log*\r\nyarn-error.log*\r\n\r\n```\r\n## 三、初始化git\r\n```\r\ngit init\r\n```\r\n## 四、将现有文件添加到暂存区\r\n```\r\ngit add .\r\n```\r\n## 五、提交到版本区\r\n```\r\ngit commit -m \"本次提交的信息\"\r\n```\r\n## 六、将本地仓库和远程仓库进行关联\r\n```\r\ngit remote add origin https://github.com/xxx.git \r\n```\r\n## 七、将本地分支推送到远程\r\n```\r\ngit push origin master\r\n```\r\n## 创建新分支（创建之前需要将原本的分支进行保存并提交）\r\n```\r\n# 创建dev分支\r\ngit checkout -b dev\r\n# 将新创建的dev分支推送到远程\r\ngit push origin dev\r\n```\r\n## 查看所有分支\r\n```\r\ngit branch -a\r\n```\r\n## 切换分支\r\n```\r\ngit checkout 分支名\r\n```\r\n## 通过克隆的方式获取远程分支\r\n```\r\n# 通过git clone获取的是master分支\r\n# 通过下面的这种方式可以获取远程的其他分支\r\ngit checkout -b dev origin/dev\r\n```\r\n## git pull 和 git push 的区别\r\n![](https://img-blog.csdnimg.cn/img_convert/6e970b51e71f464de8a663cbcb170ab1.png)"
    },
    {
      "id": "/剑指Offer——I.翻转单词顺序（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——I.翻转单词顺序（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——I.翻转单词顺序（JS实现）.md",
        "source": "@site/blog\\剑指Offer——I.翻转单词顺序（JS实现）.md",
        "title": "剑指Offer——I.翻转单词顺序（JS实现）",
        "description": "题目描述",
        "date": "2021-05-14T00:00:00.000Z",
        "formattedDate": "2021年5月14日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.26,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——I.翻转单词顺序（JS实现）",
          "date": "2021-05-14T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "使用Git管理项目",
          "permalink": "/blog/使用Git管理项目"
        },
        "nextItem": {
          "title": "项目中引入Ant Design",
          "permalink": "/blog/项目中引入Ant Design"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/21b446fec8f4a79a9857d3a8d784647a.png)\r\n\r\n## 解题思路（路径循环法）\r\n1. 去掉字符串两侧空格\r\n2. 以空格为基础分割，分割之后过滤掉中间的空格\r\n3. 将数组反转之后再连接即可\r\n\r\n## 解题代码\r\n```js\r\nvar reverseWords = function(s) {\r\n    // 去掉字符串两侧空格\r\n    s = s.trim();\r\n    // 以空格为基础分割，分割之后过滤掉中间的空格\r\n    const temp = s.split(' ').filter(value => value !== '')\r\n    // 将数组反转之后再连接即可\r\n    return temp.reverse().join(' ')\r\n};\r\n```\r\n\r\n## 总结（本题给我们的启示思路）\r\n* 启示一：学会使用trim去掉字符串两侧空格，这个函数不会对原字符串产生影响，因此需要自己进行赋值\r\n* 启示二：学会使用filter对数组进行过滤\r\n* 启示三：学会使用reverse对数组进行反转\r\n* 启示四：学会使用join连接数组为字符串\r\n* 本题思路较为简单，主要是要对常用API比较熟悉"
    },
    {
      "id": "/项目中引入Ant Design",
      "metadata": {
        "permalink": "/blog/项目中引入Ant Design",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/项目中引入Ant Design.md",
        "source": "@site/blog\\项目中引入Ant Design.md",
        "title": "项目中引入Ant Design",
        "description": "一、安装antd",
        "date": "2021-05-14T00:00:00.000Z",
        "formattedDate": "2021年5月14日",
        "tags": [
          {
            "label": "Ant Design",
            "permalink": "/blog/tags/ant-design"
          }
        ],
        "readingTime": 1.04,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "项目中引入Ant Design",
          "date": "2021-05-14T00:00:00.000Z",
          "categories": "Ant Design",
          "tags": [
            "Ant Design"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——I.翻转单词顺序（JS实现）",
          "permalink": "/blog/剑指Offer——I.翻转单词顺序（JS实现）"
        },
        "nextItem": {
          "title": "人生格言",
          "permalink": "/blog/人生格言"
        }
      },
      "content": "## 一、安装antd\r\n```\r\nnpm install antd\r\n```\r\n## 二、实现antd的按需打包\r\n* 为什么要实现按需打包？\r\n    * 因为直接引入antd，会引入很多我们不需要的包，造成空间上的浪费。\r\n1. 引入相关工具包\r\n```\r\nnpm install react-app-rewired customize-cra babel-plugin-import\r\n```\r\n2. 在项目根目录下创建一个配置文件（config-overrides.js）\r\n```js\r\nconst { override, fixBabelImports } = require('customize-cra');\r\nmodule.exports = override(\r\n    fixBabelImports('import', {\r\n        libraryName: 'antd',\r\n        libraryDirectory: 'es',\r\n        style: 'css',\r\n    })\r\n);\r\n```\r\n3. 修改package.json\r\n```json\r\n\"scripts\": {\r\n    \"start\": \"react-app-rewired start\",\r\n    \"build\": \"react-app-rewired build\",\r\n    \"test\": \"react-app-rewired test\",\r\n    \"eject\": \"react-scripts eject\"\r\n  },\r\n```\r\n## 三、实现antd自定义主题\r\n1. 下载工具包\r\n```\r\nnpm install less less-loader\r\nnpm install less-loader@7.3.0 --save-dev\r\n```\r\n2. 修改config-overrides.js\r\n```js\r\nconst { override, fixBabelImports, addLessLoader } = require('customize-cra');\r\nmodule.exports = override(\r\n    fixBabelImports('import', {\r\n        libraryName: 'antd',\r\n        libraryDirectory: 'es',\r\n        style: true,\r\n    }),\r\n    addLessLoader({\r\n        lessOptions: {\r\n            javascriptEnabled: true,\r\n            modifyVars: { '@primary-color': 'aqua' },\r\n        }\r\n    }),\r\n);\r\n```\r\n3. 下面的这句代码要注释掉\r\n![](https://img-blog.csdnimg.cn/img_convert/82d61367f3e8b2b2137a4894a54d6308.png)"
    },
    {
      "id": "/人生格言",
      "metadata": {
        "permalink": "/blog/人生格言",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/人生格言.md",
        "source": "@site/blog\\人生格言.md",
        "title": "人生格言",
        "description": "1：高度的自由来源于高度的自律。",
        "date": "2021-05-13T00:00:00.000Z",
        "formattedDate": "2021年5月13日",
        "tags": [
          {
            "label": "人生格言",
            "permalink": "/blog/tags/人生格言"
          }
        ],
        "readingTime": 0.905,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "人生格言",
          "date": "2021-05-13T00:00:00.000Z",
          "categories": "人生格言",
          "tags": [
            "人生格言"
          ]
        },
        "prevItem": {
          "title": "项目中引入Ant Design",
          "permalink": "/blog/项目中引入Ant Design"
        },
        "nextItem": {
          "title": "剑指Offer——顺时针打印矩阵（JS实现）",
          "permalink": "/blog/剑指Offer——顺时针打印矩阵（JS实现）"
        }
      },
      "content": "1：高度的自由来源于高度的自律。\r\n2：有的鱼是永远都关不住的，因为他们属于天空。\r\n3：没有深刻反思自己真正诉求的人，一定会后悔自己在重大时刻做出的每一个决定。一定要明白自己真正想要的是什么。\r\n4：此刻你选择做什么，决定了你的未来。把握当下，创造未来。\r\n5：以现在的角度看，种下理想的决心应该在十年前，但以未来的角度看，现在也是＂最好的年龄”启示我们不要被年龄和时间所拘束，追求梦想任何时间都不晚，当下就可以做准备。"
    },
    {
      "id": "/剑指Offer——顺时针打印矩阵（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——顺时针打印矩阵（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——顺时针打印矩阵（JS实现）.md",
        "source": "@site/blog\\剑指Offer——顺时针打印矩阵（JS实现）.md",
        "title": "剑指Offer——顺时针打印矩阵（JS实现）",
        "description": "题目描述",
        "date": "2021-05-13T00:00:00.000Z",
        "formattedDate": "2021年5月13日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.91,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——顺时针打印矩阵（JS实现）",
          "date": "2021-05-13T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "人生格言",
          "permalink": "/blog/人生格言"
        },
        "nextItem": {
          "title": "剑指Offer——I.滑动窗口的最大值（JS实现）",
          "permalink": "/blog/剑指Offer——I.滑动窗口的最大值（JS实现）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/c81b408628a3503f65ded286536a9471.png)\r\n\r\n## 解题思路（路径循环法）\r\n* 所谓的路径循环，就是路径本身存在一种循环，就是每一次顺时针是一次循环，每循环完一条边，就要修改想对应的边界条件，直到循环遍历完所有的节点。\r\n* 所谓一图胜千言，有时候很多描述不如一张图片来的清晰易懂。\r\n* 具体的思路来源于下面的这个题解\r\n![](https://img-blog.csdnimg.cn/img_convert/3dadb98cbc04519a90d8c5d80869f5d5.png)\r\n\r\n* [题解](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/mian-shi-ti-29-shun-shi-zhen-da-yin-ju-zhen-she-di/)\r\n\r\n## 解题代码\r\n```js\r\nvar spiralOrder = function(matrix) {\r\n    // !解题核心：本题存在一个路径上的循环：\r\n    // 循环（左 ——> 右，上 ——> 下，右 ——> 左，下 ——> 上）\r\n    // 如果是空数组\r\n    if (matrix.length === 0) return [];\r\n    // 定义四个指针\r\n    let top = 0;\r\n    let bottom = matrix.length - 1;\r\n    let left = 0;\r\n    let right = matrix[0].length - 1;\r\n    // 定义存储最终结果的数组\r\n    let res = [];\r\n    // 最外边的循环是控制 顺时针圈数的循环\r\n    while (1) {\r\n        // 左 ——> 右\r\n        for (let i = left; i <= right; i++) {\r\n            res.push(matrix[top][i]);\r\n        }\r\n        top++;\r\n        if (top > bottom) break;\r\n        // 上 ——> 下\r\n        for (let i = top; i <= bottom; i++) {\r\n            res.push(matrix[i][right]);\r\n        }\r\n        right--;\r\n        if (right < left) break;\r\n        // 右 ——> 左\r\n        for (let i = right; i >= left; i--) {\r\n            res.push(matrix[bottom][i]);\r\n        }\r\n        bottom--;\r\n        if (bottom < top) break;\r\n        // 下 ——> 上\r\n        for (let i = bottom; i >= top; i--) {\r\n            res.push(matrix[i][left]);\r\n        }\r\n        left++;\r\n        if (left > right) break;\r\n    }\r\n    return res\r\n};\r\n```\r\n## 总结（本题给我们的启示思路）\r\n* 启示一：学会给循环增加边界条件\r\n* 启示二：学会读懂题目中的隐藏循环条件"
    },
    {
      "id": "/剑指Offer——I.滑动窗口的最大值（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——I.滑动窗口的最大值（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——I.滑动窗口的最大值（JS实现）.md",
        "source": "@site/blog\\剑指Offer——I.滑动窗口的最大值（JS实现）.md",
        "title": "剑指Offer——I.滑动窗口的最大值（JS实现）",
        "description": "题目描述",
        "date": "2021-05-12T00:00:00.000Z",
        "formattedDate": "2021年5月12日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 3.835,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——I.滑动窗口的最大值（JS实现）",
          "date": "2021-05-12T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——顺时针打印矩阵（JS实现）",
          "permalink": "/blog/剑指Offer——顺时针打印矩阵（JS实现）"
        },
        "nextItem": {
          "title": "剑指Offer——II.0~n-1中缺失的数字（JS实现）",
          "permalink": "/blog/剑指Offer——II.0~n-1中缺失的数字（JS实现）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/4bacd57f017299480e802ae870cd728e.png)\r\n\r\n## 解题思路一（暴力法）\r\n* 暴力法就是定义一个滑动窗口，然后通过循环不断地去移动这个窗口，直到窗口走到最后，然后分别求出每一个窗口的最大值，存到最终结果数组中，最后返回\r\n* 虽然通过暴力法也能够通过，但是还是希望能够找到更优解。\r\n\r\n## 解题代码一（暴力法）\r\n```js\r\nvar maxSlidingWindow = function(nums, k) {\r\n    // ! 方法一：暴力解法\r\n    // 定义最终返回的结果数组\r\n    if (k === 0) return [];\r\n    const res = [];\r\n    // 开始循环遍历\r\n    for (let i = 0; i < nums.length - k + 1; i++) {\r\n        let temp = nums.slice(i,i+k);\r\n        res.push(Math.max(...temp));\r\n    }\r\n    return res;\r\n};\r\n```\r\n\r\n## 解题思路二（双端队列）\r\n* 首先我们要清楚什么是双端队列，传统的队列的特点是先进先出，也就是只有一个出口，双端队列是既可以从队头出，也可以从队尾出\r\n* 我们构造一个双端队列，用来辅助我们判断滑动窗口的最大值\r\n* 我们首先定义左右指针，左右指针都是从零开始的，当左指针移动到nums.length - k的时候，说明遍历完了，此时结束while循环\r\n* 右指针是我们判断时的关键指针，当右指针元素大于队尾的时候，我们要将队尾元素出队，因为我们要构造的是一个降序排列的双端队列\r\n* 当队尾元素为空，或者队尾元素大于右指针指向的元素时，我们将右指针指向的元素入队\r\n* 当右指针-左指针 === k的时候，首先记录队首元素，这就是滑动窗口当前的最大值，同时说明滑动窗口的长度已经大于k了，此时判断队首元素是否是左指针指向的元素，如果是的，将这个元素从队头去掉，然后左指针+1\r\n\r\n## 解题代码二（双端队列）\r\n```js\r\nvar maxSlidingWindow = function(nums, k) {\r\n    // ! 方法一：双端队列\r\n    // 定义最终返回的结果数组\r\n    if (k === 0) return [];\r\n    const res = [];\r\n    // 定义双端队列\r\n    const doubleQueue = [];\r\n    // 定义左右指针\r\n    let left = 0;\r\n    let right = 0;\r\n    // 当左指针移动到nums.length - k即可结束循环\r\n    while (left <= nums.length - k) {\r\n        if (doubleQueue.length > k) doubleQueue.shift();\r\n        // 如果滑动窗口的长度超过了k值，则将left向右移动一个，并将此时的双端队列的队头元素出队\r\n        if (right - left === k) {\r\n            res.push(doubleQueue[0]);\r\n            if (nums[left] === doubleQueue[0]) {\r\n                doubleQueue.shift();\r\n            }\r\n            left++;\r\n            continue;\r\n        }\r\n        // 如果双端队列为空，则将right指针指向的数字加入队列\r\n        if (doubleQueue.length === 0) {\r\n            doubleQueue.push(nums[right]);\r\n            right++;\r\n            continue;\r\n        }\r\n        if (nums[right] <= doubleQueue[doubleQueue.length - 1]) {\r\n            doubleQueue.push(nums[right]);\r\n            right++;\r\n            continue;\r\n        }\r\n        while (nums[right] > doubleQueue[doubleQueue.length - 1]) {\r\n            if (doubleQueue.length === 0) {\r\n                doubleQueue.push(nums[right]);\r\n                right++;\r\n            } else {\r\n                doubleQueue.pop();\r\n            }\r\n        }\r\n\r\n    }\r\n    return res;\r\n};\r\n```\r\n## 总结（本题给我们的启示思路）\r\n* 启示一：学会使用双端队列的方法来判断滑动窗口的最大值"
    },
    {
      "id": "/剑指Offer——II.0~n-1中缺失的数字（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——II.0~n-1中缺失的数字（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——II.0~n-1中缺失的数字（JS实现）.md",
        "source": "@site/blog\\剑指Offer——II.0~n-1中缺失的数字（JS实现）.md",
        "title": "剑指Offer——II.0~n-1中缺失的数字（JS实现）",
        "description": "题目描述",
        "date": "2021-05-12T00:00:00.000Z",
        "formattedDate": "2021年5月12日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.15,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——II.0~n-1中缺失的数字（JS实现）",
          "date": "2021-05-12T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——I.滑动窗口的最大值（JS实现）",
          "permalink": "/blog/剑指Offer——I.滑动窗口的最大值（JS实现）"
        },
        "nextItem": {
          "title": "剑指Offer——矩阵中的路径（JS实现）",
          "permalink": "/blog/剑指Offer——矩阵中的路径（JS实现）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/76f1ac58b928432fcb3f417018849289.png)\r\n\r\n## 解题思路\r\n* 本题采用的二分的思想\r\n* 本题关键是使用二分查找找出中位数的下标和元素值的关系\r\n\r\n## 解题代码\r\n```js\r\nvar missingNumber = function(nums) {\r\n    // !本题采用二分法的思想\r\n    // 定义左指针\r\n    let left = 0;\r\n    // 定义右指针\r\n    let right = nums.length - 1;\r\n    if (nums[right] !== nums.length) return nums.length;\r\n    if (nums[0] !== 0) return 0;\r\n    // 进入循环\r\n    while (left < right) {\r\n        // 找出中位数的下标\r\n        let mid = Math.floor((left + right) / 2);\r\n        if (nums[mid] === mid) {\r\n            // 如果中位数下标和元素值相同，说明缺失的值在中位数右边\r\n            // 让左指针移动到中位数右边\r\n            left = mid + 1\r\n        } else if (nums[mid] > mid) {\r\n            // 说明缺失的在中位数的左边\r\n            right = mid;\r\n        } \r\n    }\r\n    return left;\r\n};\r\n```\r\n## 总结（本题给我们的启示思路）\r\n* 启示一：学会使用二分查找"
    },
    {
      "id": "/剑指Offer——矩阵中的路径（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——矩阵中的路径（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——矩阵中的路径（JS实现）.md",
        "source": "@site/blog\\剑指Offer——矩阵中的路径（JS实现）.md",
        "title": "剑指Offer——矩阵中的路径（JS实现）",
        "description": "题目描述",
        "date": "2021-05-11T00:00:00.000Z",
        "formattedDate": "2021年5月11日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 2.445,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——矩阵中的路径（JS实现）",
          "date": "2021-05-11T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——II.0~n-1中缺失的数字（JS实现）",
          "permalink": "/blog/剑指Offer——II.0~n-1中缺失的数字（JS实现）"
        },
        "nextItem": {
          "title": "在线提取视频中的字幕（亲测有效）",
          "permalink": "/blog/在线提取视频中的字幕（亲测有效）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/25612918ad88fab8c6e285e720dad7a2.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/2b6103dbfc5e2de565a17d9e7a27d1d9.png)\r\n\r\n## 解题思路\r\n* 本题采用的DFS + 剪枝\r\n* 首先通过循环遍历二维数组，找到第一个和字符串的元素相同的元素，然后使用DFS开始遍历，知道遍历到字符串的最后一个元素都相同，则返回true,反之则返回false\r\n* 剪枝的作用在于在进行DFS遍历的时候，防止重复遍历\r\n\r\n## 解题代码\r\n```js\r\nvar exist = function(board, word) {\r\n    // ! 本题采用深度优先搜索DFS的算法思想\r\n    // 记录二维数组的行数\r\n    const row = board.length;\r\n    // 记录二维数组的列数\r\n    const col = board[0].length;\r\n    // 定义核心DFS函数\r\n    function dfs(i,j,board,index) {\r\n        // 如果下标越界或者元素不匹配则返回false\r\n        if (i < 0 || i >= row || j < 0 || j >= col || board[i][j] !== word[index]) return false;\r\n        // 经过上面的if语句，如果index走到最后一个下标，说明包含这个字符串，返回true\r\n        if (index === word.length - 1) return true;\r\n        // 因为前面的是起点，我们还要遍历起点之后的元素，先记录下当前元素\r\n        let temp = board[i][j];\r\n        // 让当前元素这个位置不能被重复参与\r\n        board[i][j] = '*';\r\n        // 定义一个元素的上下左右是否符合\r\n        let res = dfs(i-1,j,board,index+1) || dfs(i+1,j,board,index + 1) || dfs(i,j-1,board,index+1) || dfs(i,j+1,board,index+1);\r\n        // 恢复元素的原本值，让后续的遍历可以使用\r\n        board[i][j] = temp;\r\n        // 返回res\r\n        return res;\r\n    }\r\n    // 从board中寻找第一个和word[0]相同的元素，开始遍历\r\n    for (let i = 0; i < row; i++) {\r\n        for (let j = 0; j < col; j++) {\r\n            // 只要能遍历到一个true，则返回true\r\n            if (dfs(i,j,board,0)) return true;\r\n        }\r\n    }\r\n    // 如果遍历完，都没有true，说明没有，则返回false\r\n    return false;\r\n};\r\n```\r\n## 总结（本题给我们的启示思路）\r\n* 启示一：学会使用DFS + 剪枝的方法遍历二维数组中的有关路径"
    },
    {
      "id": "/在线提取视频中的字幕（亲测有效）",
      "metadata": {
        "permalink": "/blog/在线提取视频中的字幕（亲测有效）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/在线提取视频中的字幕（亲测有效）.md",
        "source": "@site/blog\\在线提取视频中的字幕（亲测有效）.md",
        "title": "在线提取视频中的字幕（亲测有效）",
        "description": "地址",
        "date": "2021-05-11T00:00:00.000Z",
        "formattedDate": "2021年5月11日",
        "tags": [
          {
            "label": "效率",
            "permalink": "/blog/tags/效率"
          }
        ],
        "readingTime": 0.065,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "在线提取视频中的字幕（亲测有效）",
          "date": "2021-05-11T00:00:00.000Z",
          "categories": "效率",
          "tags": [
            "效率"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——矩阵中的路径（JS实现）",
          "permalink": "/blog/剑指Offer——矩阵中的路径（JS实现）"
        },
        "nextItem": {
          "title": "React项目报错 Error Objects are not valid as a React child",
          "permalink": "/blog/React项目报错 Error Objects are not valid as a React child"
        }
      },
      "content": "## 地址\r\n[云猫转码](https://yunmaovideo.com/)\r\n\r\n## 效果图\r\n![](https://img-blog.csdnimg.cn/img_convert/109b42fe2526f32b5ee3a816b6064c18.png)"
    },
    {
      "id": "/React项目报错 Error Objects are not valid as a React child",
      "metadata": {
        "permalink": "/blog/React项目报错 Error Objects are not valid as a React child",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React项目报错 Error Objects are not valid as a React child.md",
        "source": "@site/blog\\React项目报错 Error Objects are not valid as a React child.md",
        "title": "React项目报错 Error Objects are not valid as a React child",
        "description": "报错",
        "date": "2021-05-10T00:00:00.000Z",
        "formattedDate": "2021年5月10日",
        "tags": [
          {
            "label": "debug",
            "permalink": "/blog/tags/debug"
          }
        ],
        "readingTime": 0.195,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React项目报错 Error Objects are not valid as a React child",
          "date": "2021-05-10T00:00:00.000Z",
          "categories": "debug",
          "tags": [
            "debug"
          ]
        },
        "prevItem": {
          "title": "在线提取视频中的字幕（亲测有效）",
          "permalink": "/blog/在线提取视频中的字幕（亲测有效）"
        },
        "nextItem": {
          "title": "React项目警告：Imported JSX component xxx must be in PascalCase or",
          "permalink": "/blog/React项目警告：Imported JSX component xxx must be in PascalCase or"
        }
      },
      "content": "## 报错\r\n![](https://img-blog.csdnimg.cn/img_convert/775530b89cad33b64883c5c1b8badccb.png)\r\n\r\n## 原因\r\n* React在传参的时候，出现错误，该传给count属性一个值的时候，传给了一个对象\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/bb0addc1adfe4412d7484580187a2301.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/6ac259cd7493e6bea02a75083a058813.png)"
    },
    {
      "id": "/React项目警告：Imported JSX component xxx must be in PascalCase or",
      "metadata": {
        "permalink": "/blog/React项目警告：Imported JSX component xxx must be in PascalCase or",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React项目警告：Imported JSX component xxx must be in PascalCase or.md",
        "source": "@site/blog\\React项目警告：Imported JSX component xxx must be in PascalCase or.md",
        "title": "React项目警告：Imported JSX component xxx must be in PascalCase or",
        "description": "问题描述",
        "date": "2021-05-10T00:00:00.000Z",
        "formattedDate": "2021年5月10日",
        "tags": [
          {
            "label": "debug",
            "permalink": "/blog/tags/debug"
          }
        ],
        "readingTime": 0.21,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React项目警告：Imported JSX component xxx must be in PascalCase or",
          "date": "2021-05-10T00:00:00.000Z",
          "categories": "debug",
          "tags": [
            "debug"
          ]
        },
        "prevItem": {
          "title": "React项目报错 Error Objects are not valid as a React child",
          "permalink": "/blog/React项目报错 Error Objects are not valid as a React child"
        },
        "nextItem": {
          "title": "剑指Offer——扑克牌中的顺子（JS实现）",
          "permalink": "/blog/剑指Offer——扑克牌中的顺子（JS实现）"
        }
      },
      "content": "## 问题描述\r\n![](https://img-blog.csdnimg.cn/img_convert/03e5f32d3053561217ff328f5c8b7abf.png)\r\n\r\n## 问题原因\r\n* React发现了带下划线的组件命名，将带下划线的组件命名改为驼峰命名即可"
    },
    {
      "id": "/剑指Offer——扑克牌中的顺子（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——扑克牌中的顺子（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——扑克牌中的顺子（JS实现）.md",
        "source": "@site/blog\\剑指Offer——扑克牌中的顺子（JS实现）.md",
        "title": "剑指Offer——扑克牌中的顺子（JS实现）",
        "description": "题目描述",
        "date": "2021-05-10T00:00:00.000Z",
        "formattedDate": "2021年5月10日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 2.045,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——扑克牌中的顺子（JS实现）",
          "date": "2021-05-10T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "React项目警告：Imported JSX component xxx must be in PascalCase or",
          "permalink": "/blog/React项目警告：Imported JSX component xxx must be in PascalCase or"
        },
        "nextItem": {
          "title": "剑指Offer——最长不含重复字符的子字符串（JS实现）",
          "permalink": "/blog/剑指Offer——最长不含重复字符的子字符串（JS实现）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/82daaac9d5c730ad50e5f5d1a34e7516.png)\r\n\r\n## 解题思路\r\n* 本题采用的是通过零数组来辅助判断是否是顺子\r\n* 具体的过程，代码注释中都有\r\n\r\n## 解题代码\r\n```js\r\nvar isStraight = function (nums) {\r\n    // 将nums数组中所有0元素放入下面的数组中\r\n    const zeroArr = [];\r\n    // 将数组从小到大进行排序\r\n    nums.sort((num1, num2) => num1 - num2);\r\n    // 将含零的元素添加到0的数组中\r\n    for (let i = 0; i < nums.length; i++) {\r\n        if (nums[i] === 0) {\r\n            zeroArr.push(nums[i]);\r\n        }\r\n    }\r\n    // 将nums数组中的0全部过滤掉\r\n    nums = nums.filter(value => value !== 0);\r\n    // 如果nums数组中含有重复元素，说明不是顺子，直接返回false\r\n    if ([...new Set(nums)].length !== nums.length) return false;\r\n    // 遍历nums的所有非零元素\r\n    for (let i = 1; i < nums.length; i++) {\r\n        // 如果后一个比前一个大一，说明属于顺子，继续判断\r\n        if (nums[i] - nums[i - 1] === 1) {\r\n            continue;\r\n        } else if (nums[i] - nums[i - 1] > 1) {\r\n            // 如果后一个比前一个大的多，首先判断0数组中是否有元素，没有则返回false\r\n            if (zeroArr.length === 0) return false;\r\n            // 如果有0元素，则判断零的个数是否能够填补空缺的数字\r\n            if (zeroArr.length >= nums[i] - nums[i - 1] - 1) {\r\n                for (let j = 0; j < nums[i] - nums[i - 1] - 1; j++) {\r\n                    zeroArr.pop();\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n};\r\n```\r\n## 总结（本题给我们的启示思路）\r\n* 启示一：学会使用辅助数组来判断目标元素\r\n* 启示二：学会通过集合给数组进行去重\r\n* 启示三：学会通过filter进行过滤数组"
    },
    {
      "id": "/剑指Offer——最长不含重复字符的子字符串（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——最长不含重复字符的子字符串（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——最长不含重复字符的子字符串（JS实现）.md",
        "source": "@site/blog\\剑指Offer——最长不含重复字符的子字符串（JS实现）.md",
        "title": "剑指Offer——最长不含重复字符的子字符串（JS实现）",
        "description": "题目描述",
        "date": "2021-05-09T00:00:00.000Z",
        "formattedDate": "2021年5月9日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 2.25,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——最长不含重复字符的子字符串（JS实现）",
          "date": "2021-05-09T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——扑克牌中的顺子（JS实现）",
          "permalink": "/blog/剑指Offer——扑克牌中的顺子（JS实现）"
        },
        "nextItem": {
          "title": "剑指Offer——树的子结构（JS实现）",
          "permalink": "/blog/剑指Offer——树的子结构（JS实现）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/db982a93dcab4e0d145d864ac3ea7bd5.png)\r\n\r\n## 解题思路\r\n* 本题采用哈希表 + 滑动窗口的思路\r\n* 哈希表用来存储每个字符出现的次数，当单个字符出现2次的时候，用以辅助我们移动滑动窗口\r\n* 首先定义一个左右指针，左指针和右指针初始时指向0，右指针不断右移作为判断循环的条件，当右指针移动到字符串长度的位置时，结束循环。\r\n* 具体过程看注释，注释很详细\r\n\r\n## 解题代码（模拟队列）\r\n```js\r\nvar lengthOfLongestSubstring = function (s) {\r\n    // !本题采用滑动窗口 + 哈希表的方法解决\r\n    // 定义滑动窗口，这个滑动窗口是一个哈希表，哈希表的键：单个字符 值：该字符出现的次数\r\n    const window = new Map();\r\n    // 定义左指针\r\n    let left = 0;\r\n    // 定义右指针\r\n    let right = 0;\r\n    // 定义不重复子串的最大长度\r\n    let res = 0;\r\n    // 右指针小于字符串的长度的时候，是进入循环的条件\r\n    while (right < s.length) {\r\n\r\n        // 因为我们移动的是右指针，所以要先判断哈希表中是否含有右指针指向的元素\r\n        if (window.has(s[right])) {\r\n            window.set(s[right],window.get(s[right]) + 1);\r\n        } else {\r\n            window.set(s[right],1);\r\n        }\r\n        // 判断右指针指向的元素是否出现重复\r\n        while (window.get(s[right]) > 1) {\r\n            // 左指针指向的元素出现的次数-1，然后左指针右移，直到出现重复的那个元素不再重复\r\n            window.set(s[left],window.get(s[left]) - 1);\r\n            left++;\r\n        }\r\n        right++;\r\n        res = Math.max(res,right - left);\r\n    }\r\n    return res;\r\n};\r\n```\r\n\r\n## 总结（本题给我们的启示思路）\r\n* 启示一：学会使用滑动窗口 + 哈希表\r\n* 启示二：学会使用双指针\r\n* 启示三：学会通过更新的方式获取到最大值"
    },
    {
      "id": "/剑指Offer——树的子结构（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——树的子结构（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——树的子结构（JS实现）.md",
        "source": "@site/blog\\剑指Offer——树的子结构（JS实现）.md",
        "title": "剑指Offer——树的子结构（JS实现）",
        "description": "题目描述",
        "date": "2021-05-09T00:00:00.000Z",
        "formattedDate": "2021年5月9日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 2.555,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——树的子结构（JS实现）",
          "date": "2021-05-09T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——最长不含重复字符的子字符串（JS实现）",
          "permalink": "/blog/剑指Offer——最长不含重复字符的子字符串（JS实现）"
        },
        "nextItem": {
          "title": "输入二叉树数组生成对应的二叉树数据结构（JavaScript）",
          "permalink": "/blog/输入二叉树数组生成对应的二叉树数据结构（JavaScript）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/cc6a1429b297d8533ff1049259fa4492.png)\r\n\r\n## 解题思路\r\n* 本题采用两个递归互相调用的方式进行求解\r\n* 一个树是否是另一个树的子结构，有3种情况\r\n* 情况一：子树和当前节点完全一致\r\n* 情况二：子树在左子树中\r\n* 情况三：子树在右子树中\r\n* 第一个递归用于控制发生的是哪一种情况\r\n* 第二个递归则用于进行遍历，如果A树为空，说明A数遍历完了都没有匹配到，说明B树不是子树，如果B树为空，说明B树遍历完了，说明B树是子树，如果A和B的值不相同，则返回false,此时也许会有疑问，那万一子结构在树的深部岂不是直接返回false了？这是第一个递归就开始发挥作用了。\r\n* 本题的难点在于：如果只有一个递归，当A和B的值不同时，若直接返回false，显然不合理，但是如果不返回false，后续很难进行\r\n\r\n## 解题代码\r\n```js\r\nvar isSubStructure = function(A, B) {\r\n    // 判断是否是树的子结构有两种情况\r\n    // 情况1：当前节点是子结构\r\n    // 情况2：当前节点的左右子树是子结构\r\n    // 如果A节点为空，或者B节点为空，都说明不是子树\r\n    if (!A || !B) {\r\n        return false;\r\n    }\r\n    return (dfs(A,B) || isSubStructure(A.left,B) || isSubStructure(A.right,B));\r\n\r\n    function dfs(A,B) {\r\n        // 如果B的节点为空，说明B已经遍历完了，说明此时B是A的子结构\r\n        if (!B) {\r\n            return true;\r\n        }\r\n        // 如果A都遍历完了，说明B不是子结构\r\n        if (!A) {\r\n            return false;\r\n        }\r\n        // 如果当前节点不同，则返回false\r\n        if (A.val !== B.val) {\r\n            return false;\r\n        }\r\n        // 当前节点相同，还要判断当前节点的左右子树是否都相同\r\n        return (dfs(A.left,B.left) && dfs(A.right,B.right));\r\n        \r\n    }\r\n};\r\n```\r\n## 总结（本题给我们的启示思路）\r\n* 启示一：学会使用两个递归进行互补计算\r\n* 启示二：多考虑边界条件"
    },
    {
      "id": "/输入二叉树数组生成对应的二叉树数据结构（JavaScript）",
      "metadata": {
        "permalink": "/blog/输入二叉树数组生成对应的二叉树数据结构（JavaScript）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/输入二叉树数组生成对应的二叉树数据结构（JavaScript）.md",
        "source": "@site/blog\\输入二叉树数组生成对应的二叉树数据结构（JavaScript）.md",
        "title": "输入二叉树数组生成对应的二叉树数据结构（JavaScript）",
        "description": "需求",
        "date": "2021-05-09T00:00:00.000Z",
        "formattedDate": "2021年5月9日",
        "tags": [
          {
            "label": "JavaScript常用API",
            "permalink": "/blog/tags/java-script常用-api"
          }
        ],
        "readingTime": 1.185,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "输入二叉树数组生成对应的二叉树数据结构（JavaScript）",
          "date": "2021-05-09T00:00:00.000Z",
          "categories": "JavaScript常用API",
          "tags": [
            "JavaScript常用API"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——树的子结构（JS实现）",
          "permalink": "/blog/剑指Offer——树的子结构（JS实现）"
        },
        "nextItem": {
          "title": "Redux原始版",
          "permalink": "/blog/Redux原始版"
        }
      },
      "content": "## 需求\r\n* 输入一个二叉树的数组，函数能够生成对应的二叉树的结构\r\n\r\n## 代码\r\n```js\r\nconst deserialize = (data) => {\r\n\r\n    let res = ''\r\n    for (let v of data) {\r\n        res = res + v + ',';\r\n    }\r\n    for (let i = 0; i <= data.length; i++) {\r\n        res = res + 'null' + ','\r\n    }\r\n    data = res;\r\n\r\n    function TreeNode(val) {\r\n        this.val = val;\r\n        this.left = null;\r\n        this.right = null;\r\n    }\r\n    if (data.length === 0) return null;\r\n    const list = data.split(',');   // split成数组\r\n    list.splice(list.length - 1);\r\n    let list_Pointer = 1;\r\n    let queue_pointer = 0;\r\n    const root = new TreeNode(list[0])\r\n    let queue = [root];\r\n\r\n    while (list_Pointer !== list.length) {\r\n        if (queue[0] === null) {\r\n            queue.shift();\r\n            queue_pointer++;\r\n            continue;\r\n        }\r\n        if (queue_pointer === list_Pointer) {\r\n            list_Pointer = list_Pointer + 2;\r\n        }\r\n        if (list[list_Pointer] === 'null') {\r\n            queue[0].left = null;\r\n        } else {\r\n            queue[0].left = new TreeNode(list[list_Pointer]);\r\n        }\r\n        if (list[list_Pointer + 1] === 'null') {\r\n            queue[0].right = null;\r\n        } else {\r\n            queue[0].right = new TreeNode(list[list_Pointer + 1]);\r\n        }\r\n        queue.push(queue[0].left);\r\n        queue.push(queue[0].right);\r\n        queue.shift();\r\n        queue_pointer++\r\n        list_Pointer = list_Pointer + 2;\r\n    }\r\n    return root\r\n};\r\n\r\nconst test2 = deserialize([1,2,3,4]);\r\n```\r\n\r\n## 注意事项\r\n`这里的二叉树的每一个节点的val值不是Number类型的，而是字符串类型的`"
    },
    {
      "id": "/Redux原始版",
      "metadata": {
        "permalink": "/blog/Redux原始版",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Redux原始版.md",
        "source": "@site/blog\\Redux原始版.md",
        "title": "Redux原始版",
        "description": "入口文件index.js",
        "date": "2021-05-08T00:00:00.000Z",
        "formattedDate": "2021年5月8日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 2.005,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Redux原始版",
          "date": "2021-05-08T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "输入二叉树数组生成对应的二叉树数据结构（JavaScript）",
          "permalink": "/blog/输入二叉树数组生成对应的二叉树数据结构（JavaScript）"
        },
        "nextItem": {
          "title": "看懂Redux的基础案例（无action实现加法）",
          "permalink": "/blog/看懂Redux的基础案例（无action实现加法）"
        }
      },
      "content": "## 入口文件index.js\r\n```js\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './App';\r\nimport store from './redux/store'\r\n\r\nReactDOM.render(<App store={store}/>,document.querySelector('#root'))\r\n\r\nstore.subscribe(() => {\r\n    ReactDOM.render(<App store={store}/>,document.querySelector('#root'))\r\n});\r\n```\r\n## 外壳文件App.js\r\n```js\r\nimport React, { Component } from 'react';\r\nimport {createIncrementAction,createDecrementAction} from './redux/action_Creater'\r\nclass App extends Component {\r\n\r\n    componentDidMount() {\r\n        console.log(this.props.store);\r\n    }\r\n    Increment = () => {\r\n        const {value} = this.selectNumber;\r\n        this.props.store.dispatch(createIncrementAction(value * 1))\r\n    };\r\n    Decrement = () => {\r\n        const {value} = this.selectNumber;\r\n        this.props.store.dispatch(createDecrementAction(value * 1))\r\n    }\r\n    IncrementIfOdd = () => {\r\n        const {value} = this.selectNumber;\r\n        const count = this.props.store.getState();\r\n        if (count % 2 !== 0) {\r\n            this.props.store.dispatch(createIncrementAction(value * 1));\r\n        }\r\n    }\r\n    IncrementAsync = () => {\r\n        const {value} = this.selectNumber;\r\n        setTimeout(() => {\r\n            this.props.store.dispatch(createIncrementAction(value * 1));\r\n        },1000)\r\n    }\r\n    render() {\r\n        const count = this.props.store.getState();\r\n        return (\r\n            <div>\r\n                <h1>当前求和为：{count}</h1>\r\n                <select ref={c => this.selectNumber = c}>\r\n                    <option value=\"1\">1</option>\r\n                    <option value=\"2\">2</option>\r\n                    <option value=\"3\">3</option>\r\n                </select>&nbsp;&nbsp;\r\n                <button onClick={this.Increment}>+</button>&nbsp;\r\n                <button onClick={this.Decrement}>-</button>&nbsp;\r\n                <button onClick={this.IncrementIfOdd}>奇数则+</button>&nbsp;\r\n                <button onClick={this.IncrementAsync}>异步+</button>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default App;\r\n```\r\n## action常量文件action_types.js\r\n```js\r\nexport const INCREMENT = 'increment';\r\nexport const DECREMENT = 'decrement';\r\n```\r\n## action文件（action_Creater.js）\r\n```js\r\nimport {INCREMENT,DECREMENT} from './action_types'\r\nexport const createIncrementAction = value => ({type: INCREMENT,data: value});\r\nexport const createDecrementAction = value => ({type: DECREMENT,data: value});\r\n```\r\n## reducer.js\r\n```js\r\nimport {INCREMENT,DECREMENT} from './action_types'\r\nlet initState = 0;\r\nexport default function operatorCount(preState = initState, action) {\r\n    // 规则：不能修改传递过来的preState\r\n    console.log('reducer被调用了');\r\n    const { type, data } = action;\r\n    let newState;\r\n    switch (type) {\r\n        case INCREMENT:\r\n            newState = preState + data;\r\n            return newState;\r\n        case DECREMENT:\r\n            newState = preState - data;\r\n            return newState;\r\n        default:\r\n            return preState;\r\n    }\r\n\r\n}\r\n```\r\n## store.js\r\n```js\r\nimport {createStore} from 'redux';\r\nimport reducer from './reducer'\r\nexport default(createStore(reducer))\r\n```\r\n# 总结\r\n1. store是核心\r\n2. store和reducer建立连接是通过`createStore(reducer)`建立联系的\r\n3. store和action建立联系是通过`store.dispatch(action对象)`\r\n4. store和组件建立联系是通过入口文件传入store这个props\r\n5. 组件获取状态是通过`this.props.store.getState()`\r\n6. 状态要想渲染到页面必须通过`store.subscribe()`"
    },
    {
      "id": "/看懂Redux的基础案例（无action实现加法）",
      "metadata": {
        "permalink": "/blog/看懂Redux的基础案例（无action实现加法）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/看懂Redux的基础案例（无action实现加法）.md",
        "source": "@site/blog\\看懂Redux的基础案例（无action实现加法）.md",
        "title": "看懂Redux的基础案例（无action实现加法）",
        "description": "实现效果",
        "date": "2021-05-08T00:00:00.000Z",
        "formattedDate": "2021年5月8日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 1.32,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "看懂Redux的基础案例（无action实现加法）",
          "date": "2021-05-08T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "Redux原始版",
          "permalink": "/blog/Redux原始版"
        },
        "nextItem": {
          "title": "Git——创建分支并切换到这个分支",
          "permalink": "/blog/Git——创建分支并切换到这个分支"
        }
      },
      "content": "## 实现效果\r\n![](https://img-blog.csdnimg.cn/img_convert/4c35a238e7f1d5219b1e6676516006f0.png)\r\n\r\n## 入口文件index.js\r\n```js\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './App';\r\nimport store from './redux/store'\r\n\r\nReactDOM.render(<App store={store}/>,document.querySelector('#root'))\r\n\r\nstore.subscribe(() => {\r\n    ReactDOM.render(<App store={store}/>,document.querySelector('#root'))\r\n});\r\n```\r\n## 外壳文件App.js\r\n```js\r\nimport React, { Component } from 'react';\r\n\r\nclass App extends Component {\r\n\r\n    componentDidMount() {\r\n        console.log(this.props.store);\r\n    }\r\n    Increment = () => {\r\n        const {value} = this.selectNumber;\r\n        this.props.store.dispatch({type: 'increment',data: value*1})\r\n    };\r\n    Decrement = () => {\r\n        const {value} = this.selectNumber;\r\n        this.props.store.dispatch({type: 'decrement',data: value*1})\r\n    }\r\n    IncrementIfOdd = () => {\r\n        const {value} = this.selectNumber;\r\n        const count = this.props.store.getState();\r\n        if (count % 2 !== 0) {\r\n            this.props.store.dispatch({type: 'increment',data: value*1});\r\n        }\r\n    }\r\n    IncrementAsync = () => {\r\n        const {value} = this.selectNumber;\r\n        setTimeout(() => {\r\n            this.props.store.dispatch({type: 'increment',data: value*1});\r\n        },1000)\r\n    }\r\n    render() {\r\n        const count = this.props.store.getState();\r\n        return (\r\n            <div>\r\n                <h1>当前求和为：{count}</h1>\r\n                <select ref={c => this.selectNumber = c}>\r\n                    <option value=\"1\">1</option>\r\n                    <option value=\"2\">2</option>\r\n                    <option value=\"3\">3</option>\r\n                </select>&nbsp;&nbsp;\r\n                <button onClick={this.Increment}>+</button>&nbsp;\r\n                <button onClick={this.Decrement}>-</button>&nbsp;\r\n                <button onClick={this.IncrementIfOdd}>奇数则+</button>&nbsp;\r\n                <button onClick={this.IncrementAsync}>异步+</button>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default App;\r\n```\r\n## reducer.js\r\n```js\r\nlet initState = 0;\r\nexport default function operatorCount(preState = initState, action) {\r\n    // 规则：不能修改传递过来的preState\r\n    console.log('reducer被调用了');\r\n    const { type, data } = action;\r\n    let newState;\r\n    switch (type) {\r\n        case 'increment':\r\n            newState = preState + data;\r\n            return newState;\r\n        case 'decrement':\r\n            newState = preState - data;\r\n            return newState;\r\n        default:\r\n            return preState;\r\n    }\r\n\r\n}\r\n```\r\n## store.js\r\n```js\r\nimport {createStore} from 'redux';\r\nimport reducer from './reducer'\r\nexport default(createStore(reducer))\r\n```"
    },
    {
      "id": "/Git——创建分支并切换到这个分支",
      "metadata": {
        "permalink": "/blog/Git——创建分支并切换到这个分支",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Git——创建分支并切换到这个分支.md",
        "source": "@site/blog\\Git——创建分支并切换到这个分支.md",
        "title": "Git——创建分支并切换到这个分支",
        "description": "代码（执行下面这段代码之前，原本分支一定要提交，不然会造成原本分支被覆盖）",
        "date": "2021-05-07T00:00:00.000Z",
        "formattedDate": "2021年5月7日",
        "tags": [
          {
            "label": "Git",
            "permalink": "/blog/tags/git"
          }
        ],
        "readingTime": 0.2,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Git——创建分支并切换到这个分支",
          "date": "2021-05-07T00:00:00.000Z",
          "categories": "Git",
          "tags": [
            "Git"
          ]
        },
        "prevItem": {
          "title": "看懂Redux的基础案例（无action实现加法）",
          "permalink": "/blog/看懂Redux的基础案例（无action实现加法）"
        },
        "nextItem": {
          "title": "剑指Offer——1~n整数中1出现的次数（JS实现）",
          "permalink": "/blog/剑指Offer——1~n整数中1出现的次数（JS实现）"
        }
      },
      "content": "## 代码（执行下面这段代码之前，原本分支一定要提交，不然会造成原本分支被覆盖）\r\n```\r\ngit checkout -b 分支名\r\n```"
    },
    {
      "id": "/剑指Offer——1~n整数中1出现的次数（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——1~n整数中1出现的次数（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——1~n整数中1出现的次数（JS实现）.md",
        "source": "@site/blog\\剑指Offer——1~n整数中1出现的次数（JS实现）.md",
        "title": "剑指Offer——1~n整数中1出现的次数（JS实现）",
        "description": "题目描述",
        "date": "2021-05-07T00:00:00.000Z",
        "formattedDate": "2021年5月7日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.96,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——1~n整数中1出现的次数（JS实现）",
          "date": "2021-05-07T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "Git——创建分支并切换到这个分支",
          "permalink": "/blog/Git——创建分支并切换到这个分支"
        },
        "nextItem": {
          "title": "剑指Offer——II. 队列的最大值（JS实现）",
          "permalink": "/blog/剑指Offer——II. 队列的最大值（JS实现）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/f6de1a0edef3f77efb9c2b39b4f5e537.png)\r\n\r\n## 解题思路\r\n* 本题如果采用暴力的方法一定会超时\r\n* 本题关键在于找规律\r\n* 规律如下图所示（cur>1,cur=1.cur<1三种情况）\r\n![](https://img-blog.csdnimg.cn/img_convert/f787574199ef1397406f49dd3fbb44b0.png)\r\n\r\n## 解题代码（模拟队列）\r\n```js\r\nvar countDigitOne = function(n) {\r\n    let flag = 0;\r\n\r\n    const TotalBase = Math.pow(10,(String(n).split('').length) - 1);\r\n    for (let i = 0; Math.pow(10,i) <= TotalBase; i++) {\r\n        let base = Math.pow(10,i);\r\n        let cur = Math.floor(n/base) % 10;\r\n        let a = Math.floor(Math.floor(n/base) / 10);\r\n        let b = n % base;\r\n        if (cur < 1) {\r\n            flag = flag + a * base;\r\n        } else if (cur > 1) {\r\n            flag = flag + (a + 1) * base;\r\n        } else {\r\n            flag = flag + a * base + b + 1;\r\n        }\r\n    }\r\n    return flag;\r\n\r\n};\r\n```\r\n## 精讲UP主\r\nhttps://www.bilibili.com/video/av458927963/\r\n## 总结（本题给我们的启示思路）\r\n* 启示一：学会通过数学规律的思想来解决本题"
    },
    {
      "id": "/剑指Offer——II. 队列的最大值（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——II. 队列的最大值（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——II. 队列的最大值（JS实现）.md",
        "source": "@site/blog\\剑指Offer——II. 队列的最大值（JS实现）.md",
        "title": "剑指Offer——II. 队列的最大值（JS实现）",
        "description": "题目描述",
        "date": "2021-05-07T00:00:00.000Z",
        "formattedDate": "2021年5月7日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.765,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——II. 队列的最大值（JS实现）",
          "date": "2021-05-07T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——1~n整数中1出现的次数（JS实现）",
          "permalink": "/blog/剑指Offer——1~n整数中1出现的次数（JS实现）"
        },
        "nextItem": {
          "title": "Ant Design对用户名和密码的验证（声明式验证与自定义验证）",
          "permalink": "/blog/Ant Design对用户名和密码的验证（声明式验证与自定义验证）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/f184a807719c1fecad7b5e83c6720e6c.png)\r\n\r\n## 解题思路\r\n* 本题采用的是模拟队列的思想\r\n* 难点：在于push的时候，要确保模拟队列中保持一个降序的顺序，头部始终是最大值，新加入的value放到最后面，所有比value小的pop掉\r\n* 最后返回模拟队列的头元素，就是最大值\r\n\r\n## 解题代码（模拟队列）\r\n```js\r\nvar MaxQueue = function() {\r\n    this.queue = [];\r\n    this.stack = [];\r\n};\r\n\r\nMaxQueue.prototype.max_value = function() {\r\n    if (this.stack.length !== 0) {\r\n        return this.stack[0]\r\n    } else {\r\n        return -1;\r\n    }\r\n};\r\n\r\n// ! 解题关键：模拟队列的首元素得是最大值\r\nMaxQueue.prototype.push_back = function(value) {\r\n    this.queue.push(value);\r\n    if (this.stack.length === 0) {\r\n        this.stack.push(value)\r\n    } else {\r\n        // 本题易错点：在下面这段代码，原因在于我们不仅要保证头元素是最大值，还要保证如果一旦头元素被pop之后，第二个元素也是相对于其他元素来说是最大的\r\n        // while循环确保stack中全是比value大的，然后把value放到最后，这样就形成了一个降序排列\r\n        while (this.stack[this.stack.length - 1] < value) {\r\n            this.stack.pop();\r\n        }\r\n        this.stack.push(value);\r\n    }\r\n};\r\n\r\nMaxQueue.prototype.pop_front = function() {\r\n\r\n    if (this.queue.length !== 0) {\r\n        if (this.queue[0] === this.stack[0]) {\r\n            this.stack.shift();\r\n        }\r\n        return this.queue.shift();\r\n    } else {\r\n        return -1;\r\n    }\r\n};\r\n```\r\n## 总结（本题给我们的启示思路）\r\n* 启示一：学会使用模拟队列\r\n* 启示二：模拟队列如何确保一个降序排列，且新加入的value要放在最后"
    },
    {
      "id": "/Ant Design对用户名和密码的验证（声明式验证与自定义验证）",
      "metadata": {
        "permalink": "/blog/Ant Design对用户名和密码的验证（声明式验证与自定义验证）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Ant Design对用户名和密码的验证（声明式验证与自定义验证）.md",
        "source": "@site/blog\\Ant Design对用户名和密码的验证（声明式验证与自定义验证）.md",
        "title": "Ant Design对用户名和密码的验证（声明式验证与自定义验证）",
        "description": "声明式验证",
        "date": "2021-05-06T00:00:00.000Z",
        "formattedDate": "2021年5月6日",
        "tags": [
          {
            "label": "Ant Design",
            "permalink": "/blog/tags/ant-design"
          }
        ],
        "readingTime": 0.105,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Ant Design对用户名和密码的验证（声明式验证与自定义验证）",
          "date": "2021-05-06T00:00:00.000Z",
          "categories": "Ant Design",
          "tags": [
            "Ant Design"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——II. 队列的最大值（JS实现）",
          "permalink": "/blog/剑指Offer——II. 队列的最大值（JS实现）"
        },
        "nextItem": {
          "title": "JS中求中位数的方法",
          "permalink": "/blog/JS中求中位数的方法"
        }
      },
      "content": "## 声明式验证\r\n![](https://img-blog.csdnimg.cn/img_convert/deafcdb51ac87e47baef6075e379368b.png)\r\n\r\n## 自定义验证\r\n![](https://img-blog.csdnimg.cn/img_convert/58e32f2338303ba61a4a2820c1c50963.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/5eedcbfaf7567f14676487cad0c82ded.png)\r\n\r\n## 实现效果\r\n![](https://img-blog.csdnimg.cn/img_convert/c7e736d9b692c2fd56352fd319033a95.png)"
    },
    {
      "id": "/JS中求中位数的方法",
      "metadata": {
        "permalink": "/blog/JS中求中位数的方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/JS中求中位数的方法.md",
        "source": "@site/blog\\JS中求中位数的方法.md",
        "title": "JS中求中位数的方法",
        "description": "方法一：通过零填充右移位",
        "date": "2021-05-06T00:00:00.000Z",
        "formattedDate": "2021年5月6日",
        "tags": [
          {
            "label": "JavaScript常用API",
            "permalink": "/blog/tags/java-script常用-api"
          }
        ],
        "readingTime": 0.195,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "JS中求中位数的方法",
          "date": "2021-05-06T00:00:00.000Z",
          "categories": "JavaScript常用API",
          "tags": [
            "JavaScript常用API"
          ]
        },
        "prevItem": {
          "title": "Ant Design对用户名和密码的验证（声明式验证与自定义验证）",
          "permalink": "/blog/Ant Design对用户名和密码的验证（声明式验证与自定义验证）"
        },
        "nextItem": {
          "title": "剑指Offer——数组中的逆序对（JS实现）",
          "permalink": "/blog/剑指Offer——数组中的逆序对（JS实现）"
        }
      },
      "content": "## 方法一：通过零填充右移位\r\n```js\r\nconst mid = left + right >>> 1;\r\n```\r\n## 方法二：通过Math.floor\r\n```js\r\nconst mid = Math.floor((left + right) / 2);\r\n```"
    },
    {
      "id": "/剑指Offer——数组中的逆序对（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——数组中的逆序对（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——数组中的逆序对（JS实现）.md",
        "source": "@site/blog\\剑指Offer——数组中的逆序对（JS实现）.md",
        "title": "剑指Offer——数组中的逆序对（JS实现）",
        "description": "题目描述",
        "date": "2021-05-06T00:00:00.000Z",
        "formattedDate": "2021年5月6日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 4.01,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——数组中的逆序对（JS实现）",
          "date": "2021-05-06T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "JS中求中位数的方法",
          "permalink": "/blog/JS中求中位数的方法"
        },
        "nextItem": {
          "title": "剑指Offer——旋转数组的最小数字（JS实现）",
          "permalink": "/blog/剑指Offer——旋转数组的最小数字（JS实现）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/257ad1f2d48c241c87aba8127ca74ccf.png)\r\n\r\n## 解题思路\r\n* 我刚开始看到本题，首先想到的是暴力解法，也就是通过for循环进行不断遍历，结果超时。\r\n* 看了题解才知道，解决逆序对的问题，往往通过归并排序\r\n* 本题考查的本质还是归并排序，只是在归并排序的基础上，增加了一行代码而已。\r\n* 归并排序使用的是分治法的思想，本题就是建立在还是合并的时候，进行统计计算，最终求出结果。\r\n\r\n## 解题代码一（暴力法：超时）\r\n```js\r\nvar reversePairs = function(nums) {\r\n    let flag = 0;\r\n    for (let i = 0; i < nums.length; i++) {\r\n        const temp = nums.slice(i+1);\r\n        for (let v of temp) {\r\n            if (v < nums[i]) {\r\n                flag++;\r\n            }\r\n        }\r\n    }\r\n    return flag;\r\n};\r\n```\r\n\r\n## 解题代码二（归并排序）\r\n```js\r\nvar reversePairs = function(nums) {\r\n    // !采用归并排序的思想\r\n    // 定义变量存储逆序对的数量\r\n    let sum = 0;\r\n    // 归并排序的返回结果赋值给sum\r\n    mergeSort(nums);\r\n    // 将最终结果进行返回\r\n    return sum;\r\n\r\n    // 归并排序函数\r\n    function mergeSort(nums) {\r\n        // 如果数组的长度小于2，说明只有一个元素的时候，我们返回这个数组，即递归的结束条件\r\n        if (nums.length < 2) return nums;\r\n        // 如果数组的长度不小于2，说明还没有分彻底 ，下面继续分\r\n        let mid = Math.floor(nums.length / 2);\r\n        // 左边的子数组\r\n        let left = nums.slice(0,mid);\r\n        // 右边的子数组\r\n        let right = nums.slice(mid);\r\n        // 将拆分好的左右子数组投入到合并函数中\r\n        return merge(mergeSort(left),mergeSort(right));\r\n    }\r\n\r\n    // 合并函数（用户将拆分好的子数组进行合并）\r\n    function merge(left,right) {\r\n        // 定义一个存储合并排好顺序的总数组（包含左右子数组的）\r\n        const res = [];\r\n        // 左子数组的长度\r\n        const leftLen = left.length;\r\n        //  右子数组的长度\r\n        const rightLen = right.length;\r\n        // 开始循环遍历，是以res的下标为基础进行遍历的(i是左子数组的下标，j是右子树组的下标，index是res的下标)\r\n        for (let i = 0,j = 0,index=0;index < leftLen + rightLen; index++) {\r\n            // 下面的判断应先对越界条件进行判断\r\n            if (i >= leftLen) {\r\n                // 如果i越界说明，左子数组已经遍历完，此时res直接添加右子数组的下标指向的元素即可\r\n                res.push(right[j++])\r\n            } else if (j >= rightLen) {\r\n                // 如果j越界，说明右子数组已经遍历完了，此时res直接添加左子数组下标指向的元素即可\r\n                res.push(left[i++]);\r\n            } else if (left[i] <= right[j]) {\r\n                // 如果左子数组下标指向的元素小于等于右子数组下标指向的元素，此时不存在逆序对，将左子数组对应的结果加到res数组即可\r\n                res.push(left[i++])\r\n            } else {\r\n                // 如果左子数组下标指向的元素大于右子数组下标指向的元素，此时是存在逆序对的\r\n                res.push(right[j++]);\r\n                sum = sum + leftLen - i\r\n            }\r\n        }\r\n        // 返回合并好的数组（此处易错）\r\n        return res; \r\n    }\r\n\r\n};\r\n```\r\n\r\n## 总结（本题给我们的启示思路）\r\n* 启示一：学会使用归并排序\r\n* 启示二：学会归并排序的分治思想"
    },
    {
      "id": "/剑指Offer——旋转数组的最小数字（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——旋转数组的最小数字（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——旋转数组的最小数字（JS实现）.md",
        "source": "@site/blog\\剑指Offer——旋转数组的最小数字（JS实现）.md",
        "title": "剑指Offer——旋转数组的最小数字（JS实现）",
        "description": "题目描述",
        "date": "2021-05-06T00:00:00.000Z",
        "formattedDate": "2021年5月6日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 2.06,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——旋转数组的最小数字（JS实现）",
          "date": "2021-05-06T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——数组中的逆序对（JS实现）",
          "permalink": "/blog/剑指Offer——数组中的逆序对（JS实现）"
        },
        "nextItem": {
          "title": "在线免费制作LOGO并发送到指定邮箱",
          "permalink": "/blog/在线免费制作LOGO并发送到指定邮箱"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/eb754efcae968f0e4d6a5a038e996d93.png)\r\n\r\n## 解题思路（序列化）\r\n* 我刚开始看到本题，我发现找到比数组第一个元素小的第一个元素返回不就行了，没找到就返回第一个，没想到竟然成功AC\r\n* 看了题解后，采用了二分查找的思想，第一个指针指向第一个元素，第二个指针指向最后一个元素，当中位数大于最右边的元素，说明目标元素还在中位数的右边，我们的目标元素就是最小的那个值，此时令left = mid + 1,如果中位数小于最右边的元素，那么这个中位数有可能为目标元素，令right = mid;如果中位数等于最右边的元素，令right--;\r\n* 循环结束，left下标对应的元素就应当是最小的元素，返回即可。\r\n\r\n## 序列化代码\r\n```js\r\nvar minArray = function(numbers) {\r\n    let left = 0;\r\n    let right = numbers.length - 1;\r\n    // ! 我们的目标：让左右指针都指向最小的那个元素，然后终止循环\r\n    while (left < right) {\r\n        const mid = left + right >>> 1;\r\n        if (numbers[mid] > numbers[right]) {\r\n            // 如果中位数比最右边的大，说明目标元素还在中位数右边\r\n            left = mid + 1;\r\n        } else if (numbers[mid] < numbers[right]) {\r\n            // 如果中位数比最右边的小\r\n            right = mid;\r\n        } else {\r\n            right--;\r\n        }\r\n    }\r\n    return numbers[left];\r\n};\r\n```\r\n\r\n## 总结（本题给我们的启示思路）\r\n* 启示一：学会使用零填充右移1位的方法来求中位数\r\n* 启示二：学会使用二分查找的思想来找到最小值"
    },
    {
      "id": "/在线免费制作LOGO并发送到指定邮箱",
      "metadata": {
        "permalink": "/blog/在线免费制作LOGO并发送到指定邮箱",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/在线免费制作LOGO并发送到指定邮箱.md",
        "source": "@site/blog\\在线免费制作LOGO并发送到指定邮箱.md",
        "title": "在线免费制作LOGO并发送到指定邮箱",
        "description": "网址",
        "date": "2021-05-06T00:00:00.000Z",
        "formattedDate": "2021年5月6日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 0.02,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "在线免费制作LOGO并发送到指定邮箱",
          "date": "2021-05-06T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——旋转数组的最小数字（JS实现）",
          "permalink": "/blog/剑指Offer——旋转数组的最小数字（JS实现）"
        },
        "nextItem": {
          "title": "剑指Offer——在排序数组中查找数字I（JS实现）",
          "permalink": "/blog/剑指Offer——在排序数组中查找数字I（JS实现）"
        }
      },
      "content": "## 网址\r\n[https://hatchful.shopify.com/](https://hatchful.shopify.com/)"
    },
    {
      "id": "/剑指Offer——在排序数组中查找数字I（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——在排序数组中查找数字I（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——在排序数组中查找数字I（JS实现）.md",
        "source": "@site/blog\\剑指Offer——在排序数组中查找数字I（JS实现）.md",
        "title": "剑指Offer——在排序数组中查找数字I（JS实现）",
        "description": "题目描述",
        "date": "2021-05-05T00:00:00.000Z",
        "formattedDate": "2021年5月5日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.945,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——在排序数组中查找数字I（JS实现）",
          "date": "2021-05-05T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "在线免费制作LOGO并发送到指定邮箱",
          "permalink": "/blog/在线免费制作LOGO并发送到指定邮箱"
        },
        "nextItem": {
          "title": "剑指Offer——机器人的运动范围（JS实现）",
          "permalink": "/blog/剑指Offer——机器人的运动范围（JS实现）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/f7c9c97c972d6e23d8dca59665304f61.png)\r\n\r\n## 解题思路（序列化）\r\n* 看到本题我首先想到的是二分查找\r\n* 初始化左指针指向下标0，右指针指向下标nums.length - 1;\r\n* 首先找到中位数下标，将中位数下标对应的值和target进行比较，如果比中位数大，right = mid - 1,如果比中位数小，left = mid + 1，如果中位数和target目标值相同则终止循环，并记录当前的中位数下标\r\n* 以中位数下标为flag，查找中位数左右两边和中位数相同的元素，并记录下标\r\n* 本题要求的就是下面的这个公式\r\n$右边界 - 左边界 + 1$\r\n* 注意有时候会有边界溢出的情况，比如右指针到达负数\r\n\r\n## 序列化代码\r\n```js\r\nvar search = function (nums, target) {\r\n    if (nums.length === 0) return 0;\r\n    // 定义初始化指针\r\n    let left = 0;\r\n    let right = nums.length - 1;\r\n    // 求中位数下标\r\n    let mid = Math.floor((left + right) / 2);\r\n    while (nums[mid] !== target) {\r\n        if (left === right) return 0;\r\n        if (nums[mid] < target) {\r\n            left = mid + 1;\r\n            if (left === nums.length) return 0;\r\n            mid = Math.floor((left + right) / 2);\r\n            continue;\r\n        }\r\n        if (nums[mid] > target) {\r\n            right = mid - 1;\r\n            if (right < 0) return 0;\r\n            mid = Math.floor((left + right) / 2);\r\n            continue;\r\n        }\r\n    }\r\n    let flag = mid;\r\n    let flag2 = mid;\r\n    let left_border,right_border;\r\n    while (nums[flag-1] === target) {\r\n        flag--;\r\n    }\r\n    left_border = flag;\r\n    while (nums[flag2+1] === target) {\r\n        flag2++;\r\n    }\r\n    right_border = flag2;\r\n    return right_border - left_border + 1;\r\n};\r\n```\r\n\r\n## 总结（本题给我们的启示思路）\r\n* 启示一：学会使用二分查找\r\n* 启示二：考虑边界条件"
    },
    {
      "id": "/剑指Offer——机器人的运动范围（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——机器人的运动范围（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——机器人的运动范围（JS实现）.md",
        "source": "@site/blog\\剑指Offer——机器人的运动范围（JS实现）.md",
        "title": "剑指Offer——机器人的运动范围（JS实现）",
        "description": "题目描述",
        "date": "2021-05-05T00:00:00.000Z",
        "formattedDate": "2021年5月5日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 3.085,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——机器人的运动范围（JS实现）",
          "date": "2021-05-05T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——在排序数组中查找数字I（JS实现）",
          "permalink": "/blog/剑指Offer——在排序数组中查找数字I（JS实现）"
        },
        "nextItem": {
          "title": "通过craco给antd进行自定义主题配置",
          "permalink": "/blog/通过craco给antd进行自定义主题配置"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/50893f841c3c529de707120b355d8541.png)\r\n\r\n## 解题思路（序列化）\r\n* 看到本题我首先想到的是两层嵌套循环，计算下标和与k的关系不就行了，果然不会那么简单，因为有的元素，虽然下标和符合条件，但是却不符合条件，原因是一个格子被访问到，周围必须得有其他被访问到的格子，以m = 15,n = 15 ,k = 2为例，虽然（10，10）的下标符合但是它不能被访问到。\r\n* 这里采用队列 + 方向数组的方法来遍历所有符合条件的元素\r\n* 本题还需要计算一个数位和，这里采用的是通过转换为字符串，再将字符串转化为数字的形式来进行计算\r\n* 同时本题还要考虑边界条件\r\n* 下面的注释很清晰，看懂了就理解了这道题目\r\n\r\n## 序列化代码\r\n```js\r\nvar movingCount = function (m, n, k) {\r\n    // 首先计算数位和\r\n    function getSum(x, y) {\r\n        const temp1 = String(x).split('');\r\n        const temp2 = String(y).split('');\r\n        const sumArr = [...temp1, ...temp2];\r\n        const sums = sumArr.reduce((pre, cur) => pre + Number(cur), 0);\r\n        return sums;\r\n    }\r\n    // 定义方向数组\r\n    const directionArr = [\r\n        // 向上\r\n        [-1,0],\r\n        // 向下\r\n        [1,0],\r\n        // 向左\r\n        [0,-1],\r\n        // 向右\r\n        [0,1]\r\n    ];\r\n\r\n    // 走过的坐标，不在重复计算，通过Set数据结构来实现\r\n    let set = new Set(['0,0']);\r\n    // 定义一个队列，这个队列存放的是下一个符合条件的，机器人可以走的坐标\r\n    const queue = [[0,0]];\r\n    // 当队列中没有元素的时候，说明符合条件的全都走一遍了，且都存储在集合中了，此时集合中的数量就是最终需要返回的结果\r\n    while (queue.length !== 0) {\r\n        // 获取队头元素的上下左右的元素\r\n        let [x,y] = queue.shift();\r\n\r\n        for (let i = 0; i < 4; i++) {\r\n            let offsetX = directionArr[i][0] + x;\r\n            let offsetY = directionArr[i][1] + y;\r\n            // 判断边界条件和是否已经走过\r\n            if (offsetX < 0 || offsetY < 0 || offsetX >= m || offsetY >= n || getSum(offsetX,offsetY) > k || set.has(`${offsetX},${offsetY}`)) {\r\n                continue;\r\n            }\r\n            set.add(`${offsetX},${offsetY}`);\r\n            queue.push([offsetX,offsetY]);\r\n        }\r\n    }\r\n    return set.size;\r\n};\r\n```\r\n\r\n## 总结（本题给我们的启示思路）\r\n* 启示一：学会使用方向数组，遍历一个元素的上下左右\r\n* 启示二：学会使用队列 + 方向数组的方式\r\n* 启示三：学会通过字符串和数字的转换来求数位和\r\n* 启示四：集合初始化时添加字符串的方式，是通过数组来实现的"
    },
    {
      "id": "/通过craco给antd进行自定义主题配置",
      "metadata": {
        "permalink": "/blog/通过craco给antd进行自定义主题配置",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/通过craco给antd进行自定义主题配置.md",
        "source": "@site/blog\\通过craco给antd进行自定义主题配置.md",
        "title": "通过craco给antd进行自定义主题配置",
        "description": "1. 安装craco插件",
        "date": "2021-05-05T00:00:00.000Z",
        "formattedDate": "2021年5月5日",
        "tags": [
          {
            "label": "Ant Design",
            "permalink": "/blog/tags/ant-design"
          }
        ],
        "readingTime": 0.575,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "通过craco给antd进行自定义主题配置",
          "date": "2021-05-05T00:00:00.000Z",
          "categories": "Ant Design",
          "tags": [
            "Ant Design"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——机器人的运动范围（JS实现）",
          "permalink": "/blog/剑指Offer——机器人的运动范围（JS实现）"
        },
        "nextItem": {
          "title": "剑指Offer——二叉搜索树的后序遍历序列（JS实现）",
          "permalink": "/blog/剑指Offer——二叉搜索树的后序遍历序列（JS实现）"
        }
      },
      "content": "## 1. 安装craco插件\r\n```\r\nnpm install @craco/craco\r\n```\r\n## 2. 修改package.json\r\n```\r\n\"scripts\": {\r\n    \"start\": \"craco start\",\r\n    \"build\": \"craco build\",\r\n    \"test\": \"craco test\",\r\n    \"eject\": \"react-scripts eject\"\r\n  },\r\n```\r\n## 3. 在项目根目录创建一个 craco.config.js 用于修改默认配置（按需引入）\r\n```\r\nconst CracoLessPlugin = require('craco-less');\r\n\r\n\r\nmodule.exports = {\r\n    babel: {\r\n        plugins: [\r\n           [\r\n               \"import\", \r\n               {\r\n                   \"libraryName\": \"antd\",\r\n                   \"libraryDirectory\": \"es\",\r\n                    \"style\": true //设置为true即是less\r\n                }\r\n            ]\r\n        ]\r\n    },\r\n    plugins: [\r\n        {\r\n            plugin: CracoLessPlugin,\r\n            options: {\r\n                lessLoaderOptions: {\r\n                    lessOptions: {\r\n                        modifyVars: { '@primary-color': '#1DA57A' },\r\n                        javascriptEnabled: true,\r\n                    },\r\n                },\r\n            },\r\n        },\r\n    ],\r\n};\r\n```"
    },
    {
      "id": "/剑指Offer——二叉搜索树的后序遍历序列（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——二叉搜索树的后序遍历序列（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——二叉搜索树的后序遍历序列（JS实现）.md",
        "source": "@site/blog\\剑指Offer——二叉搜索树的后序遍历序列（JS实现）.md",
        "title": "剑指Offer——二叉搜索树的后序遍历序列（JS实现）",
        "description": "题目描述",
        "date": "2021-05-04T00:00:00.000Z",
        "formattedDate": "2021年5月4日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.94,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——二叉搜索树的后序遍历序列（JS实现）",
          "date": "2021-05-04T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "通过craco给antd进行自定义主题配置",
          "permalink": "/blog/通过craco给antd进行自定义主题配置"
        },
        "nextItem": {
          "title": "剑指Offer——序列化二叉树（JS实现）",
          "permalink": "/blog/剑指Offer——序列化二叉树（JS实现）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/a01276b57fe499281b2aa85177df9630.png)\r\n\r\n## 解题思路\r\n* 本题关键点在于：二叉搜索树的后序遍历序列的最后一个元素是根节点，左子树均小于根节点，右子树均大于根节点\r\n* 使用递归是本题的解题方法\r\n* 本题需要额外考虑的情况在于有的序列是没有右子树的，如果没有右子树，那么分割左右子树的位置就是根节点所在的位置，默认右子树是一个空数组\r\n\r\n## 解题代码\r\n```js\r\nvar verifyPostorder = function(postorder) {\r\n    // !本题的解题关键：二叉搜索树的后序遍历，最后一个元素是根节点\r\n    // 如果输入的数组长度小于2，则返回true\r\n    let len = postorder.length;\r\n    if (len < 2) return true;\r\n    // 区分左右子树 \r\n    let flag = 0;\r\n    // 找到根节点\r\n    let root = postorder[len-1];\r\n    for (let i = 0; i < postorder.length;i++) {\r\n        if (postorder[i] > postorder[len-1]) {\r\n            flag = i;\r\n            break;\r\n        }\r\n        if (i === len-1) {\r\n            flag = i;\r\n        }\r\n    }\r\n    // 左子树\r\n    let leftTree = postorder.slice(0,flag);\r\n    // 右子树\r\n    let rightTree = postorder.slice(flag,len-1);\r\n\r\n    // 如果右子树的每一个节点都大于根节点，则继续递归判断，反之为false\r\n    if (rightTree.every((value) => value > root)) {\r\n        return verifyPostorder(leftTree) && verifyPostorder(rightTree);\r\n    } else {\r\n        return false;\r\n    }\r\n};\r\n```\r\n\r\n## 总结（本题给我们的启示思路）\r\n* 启示一：学会使用递归求解\r\n* 启示二：知道二叉搜索树的后序遍历序列的最后一个节点是根节点\r\n* 启示三：知道没有右子树的序列，按照空数组来进行处理"
    },
    {
      "id": "/剑指Offer——序列化二叉树（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——序列化二叉树（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——序列化二叉树（JS实现）.md",
        "source": "@site/blog\\剑指Offer——序列化二叉树（JS实现）.md",
        "title": "剑指Offer——序列化二叉树（JS实现）",
        "description": "题目描述",
        "date": "2021-05-04T00:00:00.000Z",
        "formattedDate": "2021年5月4日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 3.165,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——序列化二叉树（JS实现）",
          "date": "2021-05-04T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——二叉搜索树的后序遍历序列（JS实现）",
          "permalink": "/blog/剑指Offer——二叉搜索树的后序遍历序列（JS实现）"
        },
        "nextItem": {
          "title": "剑指Offer——把数字翻译成字符串（JS实现）",
          "permalink": "/blog/剑指Offer——把数字翻译成字符串（JS实现）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/c61187b2b0e02888aae834aa4665122b.png)\r\n\r\n## 解题思路（序列化）\r\n* 本题分为两个部分：一是序列化二叉树，二是反序列化二叉树。\r\n* 序列化二叉树：将以可二叉树，变成一个字符串，这个字符串本人刚开始以为是按照题目给的例子得是层序遍历才行，后来看了题解才知道，原来前序遍历也可以，下面的解法是采用的层序遍历，层序遍历使用的是数组存储每一层的下一层元素，然后将这个数组变成循环的条件，知道数组为空\r\n\r\n## 序列化代码\r\n```js\r\nconst serialize = (root) => {\r\n    if (!root) return [];\r\n    let queue = [root];\r\n    const res = [];\r\n    while (queue.length !== 0) {\r\n        const temp = [];\r\n        for (let v of queue) {\r\n            res.push(v);\r\n            if (v === 'null') continue;\r\n            if (v.left !== null) {\r\n                temp.push(v.left);            \r\n            } else {\r\n                temp.push('null');\r\n            }\r\n            if (v.right !== null) {\r\n                temp.push(v.right);\r\n            } else {\r\n                temp.push('null');\r\n            }\r\n        }\r\n        queue = temp;    \r\n    }\r\n    let resString = ''\r\n    for (let v of res) {\r\n        if (v instanceof Object) {\r\n            resString = resString + v.val + ',';\r\n        } else {\r\n            resString = resString + v + ',';\r\n        }\r\n    }\r\n    return resString;\r\n};\r\n```\r\n\r\n## 解题思路（反序列化）\r\n* 反序列化是本题的难点，下面的代码，以后可以作为一个常用函数，输入二叉树的层序遍历的字符串，即可生成二叉树的数据结构\r\n* 反序列化采用的是队列 + 多指针的思想\r\n* 采用一号指针指向队头指针指向原数组的位置\r\n* 采用二号指针指向队头指针的left和right指向原数组的位置\r\n* 初始时，二号指针指向下标1，一号指针指向下标0\r\n* 队头遍历完之后，将左右指针域的元素入队\r\n* 直至所有元素遍历完，结束循环，返回头指针\r\n\r\n## 反序列化代码\r\n```js\r\nconst deserialize = (data) => {\r\n    if (data.length === 0) return null;\r\n    const list = data.split(',');   // split成数组\r\n    list.splice(list.length-1);\r\n    let list_Pointer = 1;\r\n    let queue_pointer = 0;\r\n    const root = new TreeNode(list[0])\r\n    let queue = [root];\r\n\r\n    while (list_Pointer !== list.length) {\r\n        if (queue[0] === null) {\r\n            queue.shift();\r\n            queue_pointer++;\r\n            continue;\r\n        }\r\n        if (queue_pointer === list_Pointer) {\r\n            list_Pointer = list_Pointer + 2;\r\n        }\r\n        if (list[list_Pointer] === 'null') {\r\n            queue[0].left = null;\r\n        } else {\r\n            queue[0].left = new TreeNode(list[list_Pointer]);\r\n        }\r\n        if (list[list_Pointer + 1] === 'null') {\r\n            queue[0].right = null;\r\n        } else {\r\n            queue[0].right = new TreeNode(list[list_Pointer + 1]);\r\n        }\r\n        queue.push(queue[0].left);\r\n        queue.push(queue[0].right);\r\n        queue.shift();\r\n        queue_pointer++\r\n        list_Pointer = list_Pointer + 2;\r\n    }\r\n    return root\r\n};\r\n```\r\n\r\n## 总结（本题给我们的启示思路）\r\n* 启示一：学会使用队列+数组进行二叉树的层序遍历\r\n* 启示二：学会使用队列+多指针将一个字符串生成二叉树JS的数据结构"
    },
    {
      "id": "/剑指Offer——把数字翻译成字符串（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——把数字翻译成字符串（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——把数字翻译成字符串（JS实现）.md",
        "source": "@site/blog\\剑指Offer——把数字翻译成字符串（JS实现）.md",
        "title": "剑指Offer——把数字翻译成字符串（JS实现）",
        "description": "题目描述",
        "date": "2021-05-04T00:00:00.000Z",
        "formattedDate": "2021年5月4日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.385,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——把数字翻译成字符串（JS实现）",
          "date": "2021-05-04T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——序列化二叉树（JS实现）",
          "permalink": "/blog/剑指Offer——序列化二叉树（JS实现）"
        },
        "nextItem": {
          "title": "空数组调用every方法",
          "permalink": "/blog/空数组调用every方法"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/518e4b3f70a5d2be6bba99a28be2630f.png)\r\n\r\n## 解题思路\r\n* 本题关键点在于：使用递归的思想。\r\n* 考虑两种情况：1. 单个的数字（可以翻译） 2.连续的两个数字组成的数字在0-25之间。（可以翻译）\r\n* 递归的结束条件是字符串的长度达到了输入数字的长度\r\n* 千言万语其实就是下面这个图的思想（来自于LeetCode题解: https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/solution/shou-hui-tu-jie-dfsdi-gui-ji-yi-hua-di-gui-dong-ta/）\r\n![](https://img-blog.csdnimg.cn/img_convert/b73c1aca0e2d636280c82e3af02dab19.png)\r\n* 有时候无法理解递归的过程的时候，可以通过手画下面的递归图来帮助我们理解递归\r\n![](https://img-blog.csdnimg.cn/img_convert/c3350a4d8363eb9ecbdfa319d7e5072a.png)\r\n\r\n## 解题代码\r\n```js\r\nvar translateNum = function(num) {\r\n    let result = 0;\r\n    const strLen = num.toString().length;\r\n    num = num.toString();\r\n    function dfs(str,pointer) {\r\n        if (str.length === strLen) {\r\n            result++;\r\n            return;\r\n        }\r\n        if (Number(num[pointer]) * 10 + Number(num[pointer + 1]) >= 10 && Number(num[pointer]) * 10 + Number(num[pointer + 1]) < 26) {\r\n            dfs(str + num[pointer],pointer+1);\r\n            dfs(str + num[pointer] + num[pointer+1],pointer+2);\r\n        } else {\r\n            dfs(str + num[pointer],pointer+1);\r\n        }\r\n    }\r\n    dfs('',0)\r\n    return result;\r\n};\r\n```\r\n\r\n## 总结（本题给我们的启示思路）\r\n* 启示一：学会使用递归求解\r\n* 启示二：学会画递归图\r\n* 启示三：知道每一层递归返回到哪里了，心里要有数"
    },
    {
      "id": "/空数组调用every方法",
      "metadata": {
        "permalink": "/blog/空数组调用every方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/空数组调用every方法.md",
        "source": "@site/blog\\空数组调用every方法.md",
        "title": "空数组调用every方法",
        "description": "空数组调用every方法，直接返回true",
        "date": "2021-05-04T00:00:00.000Z",
        "formattedDate": "2021年5月4日",
        "tags": [
          {
            "label": "JavaScript常用API",
            "permalink": "/blog/tags/java-script常用-api"
          }
        ],
        "readingTime": 0.105,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "空数组调用every方法",
          "date": "2021-05-04T00:00:00.000Z",
          "categories": "JavaScript常用API",
          "tags": [
            "JavaScript常用API"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——把数字翻译成字符串（JS实现）",
          "permalink": "/blog/剑指Offer——把数字翻译成字符串（JS实现）"
        },
        "nextItem": {
          "title": "修改VScode编辑器默认注释的颜色",
          "permalink": "/blog/修改VScode编辑器默认注释的颜色"
        }
      },
      "content": "## 空数组调用every方法，直接返回true\r\n![](https://img-blog.csdnimg.cn/img_convert/d0244adbf03357f2f73de619c1da9ca3.png)\r\n\r\n## 参考文献\r\n![](https://img-blog.csdnimg.cn/img_convert/a4c3941edc68abf9d8c5f4bc647fa817.png)"
    },
    {
      "id": "/修改VScode编辑器默认注释的颜色",
      "metadata": {
        "permalink": "/blog/修改VScode编辑器默认注释的颜色",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/修改VScode编辑器默认注释的颜色.md",
        "source": "@site/blog\\修改VScode编辑器默认注释的颜色.md",
        "title": "修改VScode编辑器默认注释的颜色",
        "description": "为什么要修改？",
        "date": "2021-05-03T00:00:00.000Z",
        "formattedDate": "2021年5月3日",
        "tags": [
          {
            "label": "VSCode",
            "permalink": "/blog/tags/vs-code"
          }
        ],
        "readingTime": 0.46,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "修改VScode编辑器默认注释的颜色",
          "date": "2021-05-03T00:00:00.000Z",
          "categories": "VSCode",
          "tags": [
            "VSCode"
          ]
        },
        "prevItem": {
          "title": "空数组调用every方法",
          "permalink": "/blog/空数组调用every方法"
        },
        "nextItem": {
          "title": "剑指Offer——n个骰子的点数（JS实现）",
          "permalink": "/blog/剑指Offer——n个骰子的点数（JS实现）"
        }
      },
      "content": "## 为什么要修改？\r\nVscode默认的注释颜色是灰色的，在有的主题下，比较暗淡，影响视觉体验。\r\n## 修改方法\r\n1. Ctrl + Shift + P  输入settings\r\n![](https://img-blog.csdnimg.cn/img_convert/3a36c079c8121a7736ee539f6118f170.png)\r\n\r\n2. 添加以下代码并保存\r\n```\r\n//改变注释颜色\r\n    \"editor.tokenColorCustomizations\": {\r\n        \"comments\": \"#009933\" // 注释\r\n    }, //如果后面还加内容，记得块末用逗号隔开\r\n    // \"editor.insertSpaces\": false\r\n```"
    },
    {
      "id": "/剑指Offer——n个骰子的点数（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——n个骰子的点数（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——n个骰子的点数（JS实现）.md",
        "source": "@site/blog\\剑指Offer——n个骰子的点数（JS实现）.md",
        "title": "剑指Offer——n个骰子的点数（JS实现）",
        "description": "题目描述",
        "date": "2021-05-03T00:00:00.000Z",
        "formattedDate": "2021年5月3日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 2.255,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——n个骰子的点数（JS实现）",
          "date": "2021-05-03T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "修改VScode编辑器默认注释的颜色",
          "permalink": "/blog/修改VScode编辑器默认注释的颜色"
        },
        "nextItem": {
          "title": "剑指Offer——把数组排成最小的数（JS实现）",
          "permalink": "/blog/剑指Offer——把数组排成最小的数（JS实现）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/315c0fa35847c55cad64c3df5940ae6f.png)\r\n\r\n## 解题思路\r\n* 本题可以通过递归的形式进行解决，也可以采用动态规划\r\n* 核心就在于理解题意，找到骰子数和这些骰子数和的关系\r\n\r\n## 核心公式（这个不好解释，关键在于理解代码）\r\n$n个骰子的所有结果的总数 = （这个骰子是1 - 6） + (n-1)个骰子是（和-（1-6））的所有结果的和$\r\n\r\n## 解题代码\r\n```js\r\nvar dicesProbability = function (n) {\r\n    // n个骰子的点数之和的范围是[n,6n]\r\n    // 返回的最终结果数组的分母是6的n次方\r\n    const total = Math.pow(6, n);\r\n    const result = [];\r\n    // 创建一个哈希表，用来存储第n个骰子前一个骰子 目标和 的总数\r\n    const m = new Map();\r\n    for (let i = n; i <= 6 * n; i++) {\r\n        // 下面的s指的是\r\n        const denominator = helper(i, n);\r\n        // 将每一个结果分别加到最终的结果中\r\n        result.push(denominator / total);\r\n    }\r\n\r\n    function helper(count, n) {\r\n        // 首先判断哈希表中是否有记录 n-1 个骰子目标和的总数\r\n        let key = `和：${count}-骰子数：${n}`;\r\n        if (m.has(key)) {\r\n            return m.get(key);\r\n        }\r\n\r\n        if (count < n || count > 6*n) {\r\n            return 0;\r\n        }\r\n        if (n === 1) {\r\n            return 1;\r\n        }\r\n        let res = 0;\r\n        // 递归求解：求目标骰子数指定和的可能值的数量，就是求目标骰子数-1，当前和减去1-6的所有的可能性 然后进行求和\r\n        for (let i = 1; i <= 6; i++) {\r\n            res = res + helper(count - i,n-1,m);\r\n        }\r\n        m.set(key,res);\r\n        return res;\r\n    }\r\n    return result;\r\n};\r\n```\r\n## 总结（本题给我们的启示思路）\r\n* 启示一：学会使用递归求解\r\n* 启示二：准确理解骰子数和前一个骰子数与和之间的关系，是解题关键\r\n* 启示三：学会运用哈希表"
    },
    {
      "id": "/剑指Offer——把数组排成最小的数（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——把数组排成最小的数（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——把数组排成最小的数（JS实现）.md",
        "source": "@site/blog\\剑指Offer——把数组排成最小的数（JS实现）.md",
        "title": "剑指Offer——把数组排成最小的数（JS实现）",
        "description": "题目描述",
        "date": "2021-05-03T00:00:00.000Z",
        "formattedDate": "2021年5月3日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.785,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——把数组排成最小的数（JS实现）",
          "date": "2021-05-03T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——n个骰子的点数（JS实现）",
          "permalink": "/blog/剑指Offer——n个骰子的点数（JS实现）"
        },
        "nextItem": {
          "title": "Webpack-01：Webpack简介",
          "permalink": "/blog/Webpack-01：Webpack简介"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/33772630209994c58e911a78753e37ea.png)\r\n\r\n## 解题思路\r\n* 首先想到了使用DFS进行全排列，然后使用sort进行排序，发现超时，所以全排列DFS的方法行不通。\r\n* 最后还是通过JS自带的sort函数进行比较a+b和b+a来进行排序，最终通过了AC\r\n\r\n## 解题代码\r\n```js\r\nvar minNumber = function(nums) {\r\n    \r\n    for (let i = 0; i < nums.length;i++) {\r\n        nums[i] = String(nums[i])\r\n    }\r\n    nums.sort((num1,num2) => (num1 + num2) - (num2 + num1));\r\n    return nums.join('')\r\n\r\n};\r\n```\r\n## 实现效果\r\n![](https://img-blog.csdnimg.cn/img_convert/54963efd81dd0026228c06e723ef4e2e.png)\r\n\r\n## 总结（本题给我们的启示思路）\r\n* 启示一：学会使用sort传参\r\n* 启示二：最好能够手写快排"
    },
    {
      "id": "/Webpack-01：Webpack简介",
      "metadata": {
        "permalink": "/blog/Webpack-01：Webpack简介",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Webpack-01：Webpack简介.md",
        "source": "@site/blog\\Webpack-01：Webpack简介.md",
        "title": "Webpack-01：Webpack简介",
        "description": "Webpack是什么？",
        "date": "2021-05-02T00:00:00.000Z",
        "formattedDate": "2021年5月2日",
        "tags": [
          {
            "label": "Webpack",
            "permalink": "/blog/tags/webpack"
          }
        ],
        "readingTime": 0.605,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Webpack-01：Webpack简介",
          "date": "2021-05-02T00:00:00.000Z",
          "categories": "Webpack",
          "tags": [
            "Webpack"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——把数组排成最小的数（JS实现）",
          "permalink": "/blog/剑指Offer——把数组排成最小的数（JS实现）"
        },
        "nextItem": {
          "title": "剑指Offer——剪绳子（JS实现）",
          "permalink": "/blog/剑指Offer——剪绳子（JS实现）"
        }
      },
      "content": "## Webpack是什么？\r\n* Webpack是一种前端资源构建工具，是一个静态模块打包器，从Webpack的角度看，前端的所有资源文件都会作为模块处理，它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源。\r\n* 浏览器有时候无法解析某些资源文件，通过Webpack可以将这些资源文件进行统一打包，例如下面的less文件\r\n![](https://img-blog.csdnimg.cn/img_convert/ab5404c33684b51d72044847000e5709.png)"
    },
    {
      "id": "/剑指Offer——剪绳子（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——剪绳子（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——剪绳子（JS实现）.md",
        "source": "@site/blog\\剑指Offer——剪绳子（JS实现）.md",
        "title": "剑指Offer——剪绳子（JS实现）",
        "description": "题目描述",
        "date": "2021-05-02T00:00:00.000Z",
        "formattedDate": "2021年5月2日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 3.225,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——剪绳子（JS实现）",
          "date": "2021-05-02T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "Webpack-01：Webpack简介",
          "permalink": "/blog/Webpack-01：Webpack简介"
        },
        "nextItem": {
          "title": "剑指Offer——字符串的排列（JS实现）",
          "permalink": "/blog/剑指Offer——字符串的排列（JS实现）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/4fbf274672cd00c9e7843393dfda6066.png)\r\n\r\n## 解题思路\r\n* 这道题在JS题解中一般给出了两种解法，一是动态规划，二是贪心算法\r\n* 本次采用的是动态规划，主要是想强化自己在这方面的学习\r\n* 贪心的思想是构造3，尽可能多的3相乘会使得乘积最大，通过对3取余的三种情况来分别推导最后的乘积\r\n* 动态规划的思想则是首先构造一个长度为n+1的全1数组，这里的n代表的是绳子的总长度，之所以要进行+1，是因为我们操作的始终是数组的下标，dp[i]代表什么含义，是我们必须要好好理解的，dp[i]代表的是长度为i的绳子被剪成n段后的最大乘积\r\n* 动态规划的结束条件是dp[2]=1,因为2米的绳子可以拆成1+1，最后的乘积是1\r\n* 动态规划的一般方程是dp[i] = Max(dp[i],j * (i-j),j * dp[i-j])\r\n* 理解上面的一般方程是解题关键，dp[i]则是不断给修改的长度为i的绳子被剪成n段后的最大乘积，这里的i是从3开始遍历的，j则是从1开始遍历的，i-j代表的是如果一段绳子被拆成两段，另一段的长度，但是j * (i-j)只是判断了一段绳子被剪成两段后的所有结果，但是有时候最大乘积是3个或者更多数字的乘积，比如绳子的长度是8，则可以拆成3*3*2 = 18，所以动态规划的第三个方程就很关键了，j是从1开始遍历的，此时第1个i-j就是7，所以i 和 i-j的和始终是8，当i=2,i-j等于6的时候就会出现 2 * 3 * 3就是我们要求的最大乘积，通过j * dp[i-j]会无形中引入更短的数字乘积，而不只是两两相乘。\r\n\r\n## 解题代码\r\n```js\r\nvar cuttingRope = function(n) {\r\n    // 本题可以采用动态规划的思想\r\n    // 动态规划的结束条件是dp[2] = 1  代表的含义是长度为2的绳子剪成几段后最大乘积是1\r\n    const dp = new Array(n + 1);\r\n    dp.fill(1);\r\n    for (let i = 3; i < dp.length;i++) {\r\n        for (let j = 1; j < i;j++) {\r\n            dp[i] = Math.max(dp[i],j*(i-j),j*dp[i-j])\r\n        }\r\n    }\r\n    return dp[n]\r\n};\r\n```\r\n## 总结（本题给我们的启示思路）\r\n* 启示一：学会使动态规划\r\n* 启示二：学会如何遍历值为x的两个元素"
    },
    {
      "id": "/剑指Offer——字符串的排列（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——字符串的排列（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——字符串的排列（JS实现）.md",
        "source": "@site/blog\\剑指Offer——字符串的排列（JS实现）.md",
        "title": "剑指Offer——字符串的排列（JS实现）",
        "description": "题目描述",
        "date": "2021-05-02T00:00:00.000Z",
        "formattedDate": "2021年5月2日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.5,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——字符串的排列（JS实现）",
          "date": "2021-05-02T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——剪绳子（JS实现）",
          "permalink": "/blog/剑指Offer——剪绳子（JS实现）"
        },
        "nextItem": {
          "title": "React-61：错误边界",
          "permalink": "/blog/React-61：错误边界"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/9e2e8e9cb30f9a13424bac26b6ccc3f8.png)\r\n\r\n## 解题思路\r\n* 这道题属于考查DFS（深度优先遍历）\r\n* 和本道题几乎完全一样的有全排列问题，都是在考查DFS\r\n* DFS的本质就是递归\r\n* 本题通过设置一个和字符串长度一致的一维数组，用来表示该元素是否被遍历过，初始值全为false表示都没有被遍历过\r\n * 当dfs收到的参数的长度和输入s的长度一致时，说明一条路径已经遍历完了，然后开始存储并返回\r\n\r\n## 解题代码\r\n```js\r\nvar permutation = function(s) {\r\n    const trace = [];\r\n    const res = [];\r\n    for (let i = 0; i < s.length;i++) {\r\n        trace[i] = false;\r\n    }\r\n\r\n    function dfs(str) {\r\n        if (str.length === s.length) {\r\n            res.push(str);\r\n            return;\r\n        }\r\n        for (let i = 0;i < s.length;i++) {\r\n            if (trace[i] === true) continue;\r\n            trace[i] = true;\r\n            dfs(str + s[i]);\r\n            trace[i] = false;\r\n        } \r\n    }\r\n    dfs('');\r\n    return [...new Set(res)];\r\n};\r\n```\r\n## 实现效果\r\n![](https://img-blog.csdnimg.cn/img_convert/18d4c2a4eeb239d2d20c2ae8d7cff9c3.png)\r\n\r\n## 总结（本题给我们的启示思路）\r\n* 启示一：学会使用DFS\r\n* 启示二：通过设置一个同纬度的布尔值数组来表示该位置的元素是否被遍历过\r\n* 启示三；学会通过集合对数组重复元素进行去重"
    },
    {
      "id": "/React-61：错误边界",
      "metadata": {
        "permalink": "/blog/React-61：错误边界",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-61：错误边界.md",
        "source": "@site/blog\\React-61：错误边界.md",
        "title": "React-61：错误边界",
        "description": "什么是错误边界？",
        "date": "2021-05-01T00:00:00.000Z",
        "formattedDate": "2021年5月1日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.495,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-61：错误边界",
          "date": "2021-05-01T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——字符串的排列（JS实现）",
          "permalink": "/blog/剑指Offer——字符串的排列（JS实现）"
        },
        "nextItem": {
          "title": "React-62：组件间通信方式总结",
          "permalink": "/blog/React-62：组件间通信方式总结"
        }
      },
      "content": "## 什么是错误边界？\r\n* 所谓的错误边界，就是将错误控制在一定的范围内，例如子组件出现了错误，不能影响父组件的显示。将错误控制在子组件内。\r\n\r\n## 控制可能出现的组件错误，是在该组件的父组件中进行监控\r\n>### 通过getDerivedStateFromError\r\n![](https://img-blog.csdnimg.cn/img_convert/ffcc587d5afaec79c46c46e19daffbb2.png)\r\n\r\n>### 通过componentDidCatch进行统计错误\r\n![](https://img-blog.csdnimg.cn/img_convert/82199704431c9642686d5bb2c81fee25.png)"
    },
    {
      "id": "/React-62：组件间通信方式总结",
      "metadata": {
        "permalink": "/blog/React-62：组件间通信方式总结",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-62：组件间通信方式总结.md",
        "source": "@site/blog\\React-62：组件间通信方式总结.md",
        "title": "React-62：组件间通信方式总结",
        "description": "几种通信方式",
        "date": "2021-05-01T00:00:00.000Z",
        "formattedDate": "2021年5月1日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.52,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-62：组件间通信方式总结",
          "date": "2021-05-01T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-61：错误边界",
          "permalink": "/blog/React-61：错误边界"
        },
        "nextItem": {
          "title": "React-59：PureComponent",
          "permalink": "/blog/React-59：PureComponent"
        }
      },
      "content": "## 几种通信方式\r\n1. props\r\n（1）：children props\r\n（2）：render props\r\n2. 消息订阅与发布\r\n3. 集中式管理\r\nredux.dva等\r\n4. conText\r\n生产者消费者模式\r\n\r\n## 建议的搭配方式\r\n|组件关系| 使用工具 |\r\n|--|--|\r\n| 父子组件 | props |\r\n| 兄弟组件 | 消息订阅-发布、集中式管理 |\r\n| 祖孙组件 | 消息订阅-发布、集中式管理、conText（开发用的少，封装插件用的多） |"
    },
    {
      "id": "/React-59：PureComponent",
      "metadata": {
        "permalink": "/blog/React-59：PureComponent",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-59：PureComponent.md",
        "source": "@site/blog\\React-59：PureComponent.md",
        "title": "React-59：PureComponent",
        "description": "React中的component存在两个问题",
        "date": "2021-04-30T00:00:00.000Z",
        "formattedDate": "2021年4月30日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.81,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-59：PureComponent",
          "date": "2021-04-30T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-62：组件间通信方式总结",
          "permalink": "/blog/React-62：组件间通信方式总结"
        },
        "nextItem": {
          "title": "React-60：render props",
          "permalink": "/blog/React-60：render props"
        }
      },
      "content": "## React中的component存在两个问题\r\n* 只要执行setState()，即使不改变状态数据，组件也会重新render()\r\n* 当前组件重新render()，就会自动重新render子组件，如果子组件并没有用到父组件的任何东西，这样就会使得效率低。\r\n\r\n## 造成上述问题的原因\r\n* shouldComponentUpdate()总是返回true\r\n\r\n## 效率高的做法\r\n* 只有当组件的state或props数据发生改变时才重新render\r\n\r\n>## 解决问题的方法\r\n\r\n1. 通过手动判断shouldComponentUpdate来决定是否render\r\n![](https://img-blog.csdnimg.cn/img_convert/c4df7016662d629ee16258d9a2491ef4.png)\r\n\r\n2. 将从React中引入的Component改为PureComponent（父子组件都得改）\r\n![](https://img-blog.csdnimg.cn/img_convert/59081042e068265011d8fee31d741c87.png)"
    },
    {
      "id": "/React-60：render props",
      "metadata": {
        "permalink": "/blog/React-60：render props",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-60：render props.md",
        "source": "@site/blog\\React-60：render props.md",
        "title": "React-60：render props",
        "description": "组件间包含的内容是什么？",
        "date": "2021-04-30T00:00:00.000Z",
        "formattedDate": "2021年4月30日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.515,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-60：render props",
          "date": "2021-04-30T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-59：PureComponent",
          "permalink": "/blog/React-59：PureComponent"
        },
        "nextItem": {
          "title": "React中setState不起作用的情况",
          "permalink": "/blog/React中setState不起作用的情况"
        }
      },
      "content": "## 组件间包含的内容是什么？\r\n![](https://img-blog.csdnimg.cn/img_convert/55409785ddaba33da78abbe29730bb69.png)\r\n\r\n* 包含的内容是传递给A组件的信息，A组件通过this.props.children可以获得\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/07e381921c9f01a209ec04d67ed6bd35.png)\r\n\r\n## 形成父子组件的两种形式\r\n>### 第一种：直接嵌套\r\n![](https://img-blog.csdnimg.cn/img_convert/fb9c18d3d342c4213596876134438f20.png)\r\nA组件通过this.props.children调用B组件\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/3b86e4750bdf69955c434bf5c27dcb1a.png)\r\n\r\n>### 第二种：A组件中调用B组件\r\n![](https://img-blog.csdnimg.cn/img_convert/4e4992135ad87c6e530dac696fd09de5.png)\r\n\r\n## 通过renderProps向一个组件的子组件传递props\r\n![](https://img-blog.csdnimg.cn/img_convert/bec6b76c21297c91098f3286d1a59bca.png)"
    },
    {
      "id": "/React中setState不起作用的情况",
      "metadata": {
        "permalink": "/blog/React中setState不起作用的情况",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React中setState不起作用的情况.md",
        "source": "@site/blog\\React中setState不起作用的情况.md",
        "title": "React中setState不起作用的情况",
        "description": "看下面这个案例",
        "date": "2021-04-30T00:00:00.000Z",
        "formattedDate": "2021年4月30日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.465,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React中setState不起作用的情况",
          "date": "2021-04-30T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-60：render props",
          "permalink": "/blog/React-60：render props"
        },
        "nextItem": {
          "title": "React报错：Element type is invali expected a string or a class",
          "permalink": "/blog/React报错：Element type is invali expected a string or a class"
        }
      },
      "content": "## 看下面这个案例\r\n![](https://img-blog.csdnimg.cn/img_convert/9d171aaaf847a55d3b30584710f2d0d7.png)\r\n\r\n## 不起作用的原因\r\n* 上述案例中的setState函数接收到的对象只是原有state地址的引用和原地址一样，所以不起作用\r\n\r\n## 正确的使用方式\r\n![](https://img-blog.csdnimg.cn/img_convert/2b1d184768241ff7b338a2b84fa6adb9.png)\r\n* 必须得传入一个新的对象，React经过对比以为发生了变化，才会去渲染，去render"
    },
    {
      "id": "/React报错：Element type is invali expected a string or a class",
      "metadata": {
        "permalink": "/blog/React报错：Element type is invali expected a string or a class",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React报错：Element type is invali expected a string or a class.md",
        "source": "@site/blog\\React报错：Element type is invali expected a string or a class.md",
        "title": "React报错：Element type is invali expected a string or a class",
        "description": "错误原因",
        "date": "2021-04-30T00:00:00.000Z",
        "formattedDate": "2021年4月30日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.185,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React报错：Element type is invali expected a string or a class",
          "date": "2021-04-30T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "React中setState不起作用的情况",
          "permalink": "/blog/React中setState不起作用的情况"
        },
        "nextItem": {
          "title": "剑指Offer——最小的K个数（JS实现）",
          "permalink": "/blog/剑指Offer——最小的K个数（JS实现）"
        }
      },
      "content": "## 错误原因\r\n* 大概是导入模块的时候出现了错误，可以尝试定位到import看看是否导入错误\r\n![](https://img-blog.csdnimg.cn/img_convert/08a8ad5524203f69846563450696af8f.png)"
    },
    {
      "id": "/剑指Offer——最小的K个数（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——最小的K个数（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——最小的K个数（JS实现）.md",
        "source": "@site/blog\\剑指Offer——最小的K个数（JS实现）.md",
        "title": "剑指Offer——最小的K个数（JS实现）",
        "description": "题目描述",
        "date": "2021-04-30T00:00:00.000Z",
        "formattedDate": "2021年4月30日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.69,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——最小的K个数（JS实现）",
          "date": "2021-04-30T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "React报错：Element type is invali expected a string or a class",
          "permalink": "/blog/React报错：Element type is invali expected a string or a class"
        },
        "nextItem": {
          "title": "React-57：Fragment（让函数式组件能够使用ref）",
          "permalink": "/blog/React-57：Fragment（让函数式组件能够使用ref）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/4d10b114775cfad8a2b3e14a3740148e.png)\r\n\r\n## 解题思路\r\n* 这道题属于考查排序的问题\r\n* 我们只需要将输入的整数数组按照升序进行排列\r\n* 然后返回前k个数字即可，这里采用JS自带的sort方法\r\n* 截取前k个数字采用slice方法\r\n\r\n## 解题代码\r\n```js\r\nvar getLeastNumbers = function(arr, k) {\r\n    arr.sort((num1,num2) => num1 - num2);\r\n    return arr.slice(0,k)\r\n};\r\n```\r\n## 总结（本题给我们的启示思路）\r\n* 启示一：学会使用slice进行截取\r\n* 启示二：学会使用sort对数组进行排序"
    },
    {
      "id": "/React-57：Fragment（让函数式组件能够使用ref）",
      "metadata": {
        "permalink": "/blog/React-57：Fragment（让函数式组件能够使用ref）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-57：Fragment（让函数式组件能够使用ref）.md",
        "source": "@site/blog\\React-57：Fragment（让函数式组件能够使用ref）.md",
        "title": "React-57：Fragment（让函数式组件能够使用ref）",
        "description": "为什么要使用Fragment？",
        "date": "2021-04-29T00:00:00.000Z",
        "formattedDate": "2021年4月29日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.36,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-57：Fragment（让函数式组件能够使用ref）",
          "date": "2021-04-29T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——最小的K个数（JS实现）",
          "permalink": "/blog/剑指Offer——最小的K个数（JS实现）"
        },
        "nextItem": {
          "title": "React-58：Context（组件间进行通信）",
          "permalink": "/blog/React-58：Context（组件间进行通信）"
        }
      },
      "content": "## 为什么要使用Fragment？\r\n* 通过React进行开发的时候，有时候会产生很多无用的包裹标签\r\n![](https://img-blog.csdnimg.cn/img_convert/ffd296bfb4a806ce1087a1b783835692.png)\r\n\r\n## Fragment标签的效果\r\n* 在React进行解析的时候，会将Fragment丢掉，可以有效的防止标签包裹无效冗余。\r\n![](https://img-blog.csdnimg.cn/img_convert/c085d08d6d2bf123e87af299db915e01.png)"
    },
    {
      "id": "/React-58：Context（组件间进行通信）",
      "metadata": {
        "permalink": "/blog/React-58：Context（组件间进行通信）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-58：Context（组件间进行通信）.md",
        "source": "@site/blog\\React-58：Context（组件间进行通信）.md",
        "title": "React-58：Context（组件间进行通信）",
        "description": "context的主要使用场景",
        "date": "2021-04-29T00:00:00.000Z",
        "formattedDate": "2021年4月29日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.855,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-58：Context（组件间进行通信）",
          "date": "2021-04-29T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-57：Fragment（让函数式组件能够使用ref）",
          "permalink": "/blog/React-57：Fragment（让函数式组件能够使用ref）"
        },
        "nextItem": {
          "title": "剑指Offer——数据流中的中位数（JS实现）",
          "permalink": "/blog/剑指Offer——数据流中的中位数（JS实现）"
        }
      },
      "content": "## context的主要使用场景\r\n* 适用于下面的A组件和C组件或者A组件和D组件进行通信，至于A组件和B组件进行通信，可以使用props\r\n![](https://img-blog.csdnimg.cn/img_convert/7970321d900ed24a880ae00bedd21f99.png)\r\n\r\n## Context使用步骤（下面的这个只适用于类式组件）\r\n1. 构造Context容器对象（这个对象要放在父子孙都能访问到的区域）\r\n![](https://img-blog.csdnimg.cn/img_convert/2ab1c6b886806cb4e8cbc2ed66e78aa6.png)\r\n\r\n2. 通过第一步创建的容器对象调用Provider属性进行包裹（下面的value关键字不能用其他关键字替代）\r\n![](https://img-blog.csdnimg.cn/img_convert/f9c089ccecc21eae1d27a7a7c47dc154.png)\r\n\r\n3. 需要接收的组件进行声明接收\r\n![](https://img-blog.csdnimg.cn/img_convert/6a35b0716863ede712b21ffe52315d79.png)\r\n\r\n## 函数式组件和类式组件通用写法\r\n![](https://img-blog.csdnimg.cn/img_convert/c209e6ed7bef54fd4b2b8d22545d0e2f.png)"
    },
    {
      "id": "/剑指Offer——数据流中的中位数（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——数据流中的中位数（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——数据流中的中位数（JS实现）.md",
        "source": "@site/blog\\剑指Offer——数据流中的中位数（JS实现）.md",
        "title": "剑指Offer——数据流中的中位数（JS实现）",
        "description": "题目描述",
        "date": "2021-04-29T00:00:00.000Z",
        "formattedDate": "2021年4月29日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 2.4,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——数据流中的中位数（JS实现）",
          "date": "2021-04-29T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "React-58：Context（组件间进行通信）",
          "permalink": "/blog/React-58：Context（组件间进行通信）"
        },
        "nextItem": {
          "title": "React-52：setState的两种更新状态的方式",
          "permalink": "/blog/React-52：setState的两种更新状态的方式"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/68223e508ef06ffdd90e32a8391a29bf.png)\r\n\r\n## 解题思路\r\n* 这道题属于考查二分查找\r\n* 本题如果直接采用JS中自带的排序肯定是要超时的，要不然LeetCode也不会将这道题归为困难\r\n* 二分查找的思路定义两个指针，一个指针指向的是数组元素的第一个下标，另一个指针指向的是数组元素的最后一个元素的下标。\r\n* 中位数下标指的是通过四舍五入的方法，左边指针的下标 + 右边指针的下标 / 2然后进行四舍五入，得到的就是中位数下标\r\n* 如果要添加的值大于中位数下标对应的值，左边的指针移动到中位数指针+1的位置。如果要添加的值小于中位数下标对应的值，右边的指针移动到中位数指针-1的位置，如果相等则直接添加导致中位数下标的位置，其余元素后移。\r\n* 循环的结束条件是左指针＞右指针\r\n\r\n## 解题代码\r\n```js\r\nvar MedianFinder = function() {\r\n    this.stack = [];\r\n};\r\nMedianFinder.prototype.addNum = function(num) {\r\n    if (this.stack.length === 0) {\r\n       this.stack.push(num);\r\n       return; \r\n    }\r\n    // 定义左指针和右指针 注意：这里的指针指的都是下标\r\n    let left = 0;\r\n    let right = this.stack.length - 1;\r\n    while (left <= right) {\r\n        // 找到中位数的下标\r\n        let mid = Math.floor((left + right)/2);\r\n        if (num === this.stack[mid]) {\r\n            this.stack.splice(mid,0,num);\r\n            return;\r\n        } else if (num < this.stack[mid]) {\r\n            right = mid - 1;\r\n        } else {\r\n            left = mid + 1;\r\n        }\r\n    }\r\n    this.stack.splice(right+1,0,num);\r\n};\r\n\r\nMedianFinder.prototype.findMedian = function() {\r\n    if (this.stack.length === 0) {\r\n        return [];\r\n    }\r\n    if (this.stack.length % 2 === 0) {\r\n        let len = this.stack.length;\r\n        return (this.stack[len/2] + this.stack[len/2 -1]) / 2\r\n    } else {\r\n        let mid = Math.floor(this.stack.length/2);\r\n        return this.stack[mid];\r\n    }\r\n};\r\n```\r\n## 总结（本题给我们的启示思路）\r\n* 启示一：学会使用二分查找\r\n* 启示二：学会使用splice插入元素\r\n* 启示三：通过Math.floor进行四舍五入来求中位数下标\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/ffa1ec9122505bd51b8cd34c1864a5c1.png)"
    },
    {
      "id": "/React-52：setState的两种更新状态的方式",
      "metadata": {
        "permalink": "/blog/React-52：setState的两种更新状态的方式",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-52：setState的两种更新状态的方式.md",
        "source": "@site/blog\\React-52：setState的两种更新状态的方式.md",
        "title": "React-52：setState的两种更新状态的方式",
        "description": "方式1：对象式的setState",
        "date": "2021-04-28T00:00:00.000Z",
        "formattedDate": "2021年4月28日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.29,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-52：setState的两种更新状态的方式",
          "date": "2021-04-28T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——数据流中的中位数（JS实现）",
          "permalink": "/blog/剑指Offer——数据流中的中位数（JS实现）"
        },
        "nextItem": {
          "title": "React-53：懒加载的使用",
          "permalink": "/blog/React-53：懒加载的使用"
        }
      },
      "content": "## 方式1：对象式的setState\r\n![](https://img-blog.csdnimg.cn/img_convert/0c675dd92ebfb849592901c9bd6408bc.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/1112846bc4d975ed408f742b34998636.png)\r\n\r\n* 回调的方式\r\n![](https://img-blog.csdnimg.cn/img_convert/784c9a7b3956c979dc4d0d92064143db.png)\r\n\r\n## 方式2：函数式的setState\r\n* 通过函数式的setState，该函数能够接收到两个参数，一个是state，另一个则是props\r\n![](https://img-blog.csdnimg.cn/img_convert/c25f4fe03a1edc6ece7eac77630c6b39.png)"
    },
    {
      "id": "/React-53：懒加载的使用",
      "metadata": {
        "permalink": "/blog/React-53：懒加载的使用",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-53：懒加载的使用.md",
        "source": "@site/blog\\React-53：懒加载的使用.md",
        "title": "React-53：懒加载的使用",
        "description": "1.  从react中导入lazy和Suspense",
        "date": "2021-04-28T00:00:00.000Z",
        "formattedDate": "2021年4月28日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.555,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-53：懒加载的使用",
          "date": "2021-04-28T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-52：setState的两种更新状态的方式",
          "permalink": "/blog/React-52：setState的两种更新状态的方式"
        },
        "nextItem": {
          "title": "React-54：stateHook（让函数式组件能够使用state）",
          "permalink": "/blog/React-54：stateHook（让函数式组件能够使用state）"
        }
      },
      "content": "## 1.  从react中导入lazy和Suspense\r\n![](https://img-blog.csdnimg.cn/img_convert/6bc236a1031f041224650fa6bd1f9766.png)\r\n\r\n## 2.  使用lazy函数导入要使用懒加载的组件\r\n![](https://img-blog.csdnimg.cn/img_convert/5eb4e223c19cd08ed8f24b28efd594da.png)\r\n\r\n## 3. 使用Suspense + fallback的形式包裹路由组件\r\n![](https://img-blog.csdnimg.cn/img_convert/faf4fb17388c898852a73e7b1c6716df.png)\r\n\r\n* 注意fallback包裹的组件是当懒加载组件无法显示的时候，显示的组件，所以Loading组件不能够使用懒加载的方式。\r\n\r\n>测试懒加载可以通过放慢浏览器的访问速度\r\n![](https://img-blog.csdnimg.cn/img_convert/d17296c43231cac7710ef61244ea3d6e.png)"
    },
    {
      "id": "/React-54：stateHook（让函数式组件能够使用state）",
      "metadata": {
        "permalink": "/blog/React-54：stateHook（让函数式组件能够使用state）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-54：stateHook（让函数式组件能够使用state）.md",
        "source": "@site/blog\\React-54：stateHook（让函数式组件能够使用state）.md",
        "title": "React-54：stateHook（让函数式组件能够使用state）",
        "description": "什么是Hook?",
        "date": "2021-04-28T00:00:00.000Z",
        "formattedDate": "2021年4月28日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.495,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-54：stateHook（让函数式组件能够使用state）",
          "date": "2021-04-28T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-53：懒加载的使用",
          "permalink": "/blog/React-53：懒加载的使用"
        },
        "nextItem": {
          "title": "React-55：EffectHook（让函数式组件能够使用生命周期钩子）",
          "permalink": "/blog/React-55：EffectHook（让函数式组件能够使用生命周期钩子）"
        }
      },
      "content": "## 什么是Hook?\r\n* Hook是React 16.8.0版本新增的新语法\r\n* 可以让使用者在函数组件中使用state以及其他的react特性\r\n\r\n## 使用useState\r\n* 使用数组的解构赋值，数组的解构赋值不需要和原本的名字一致\r\n![](https://img-blog.csdnimg.cn/img_convert/33bab22e41ec3e3a9507ed92f0a77f27.png)\r\n* 0,'xidian'是我们的初始化状态，setXxx则是方法\r\n\r\n## 两种改变状态的写法\r\n![](https://img-blog.csdnimg.cn/img_convert/5a1f1e2d4b8c03f3da687e33951ac67f.png)"
    },
    {
      "id": "/React-55：EffectHook（让函数式组件能够使用生命周期钩子）",
      "metadata": {
        "permalink": "/blog/React-55：EffectHook（让函数式组件能够使用生命周期钩子）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-55：EffectHook（让函数式组件能够使用生命周期钩子）.md",
        "source": "@site/blog\\React-55：EffectHook（让函数式组件能够使用生命周期钩子）.md",
        "title": "React-55：EffectHook（让函数式组件能够使用生命周期钩子）",
        "description": "为什么要使用EffectHook?",
        "date": "2021-04-28T00:00:00.000Z",
        "formattedDate": "2021年4月28日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 1.175,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-55：EffectHook（让函数式组件能够使用生命周期钩子）",
          "date": "2021-04-28T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-54：stateHook（让函数式组件能够使用state）",
          "permalink": "/blog/React-54：stateHook（让函数式组件能够使用state）"
        },
        "nextItem": {
          "title": "React-56：RefHook（让函数式组件能够使用ref）",
          "permalink": "/blog/React-56：RefHook（让函数式组件能够使用ref）"
        }
      },
      "content": "## 为什么要使用EffectHook?\r\n* 因为在函数式组件中无法使用生命周期钩子的，例如：componentDidMount这个生命周期钩子，通过这个Hook可以让我们在函数式组件中使用生命周期钩子。\r\n\r\n## 核心函数：useEffect（接收两个参数）\r\n* 第一个参数：是一个回调函数\r\n这个回调函数相当于是componentDidMount，这个回调函数可以返回一个回调函数，返回的这个回调函数则是相当于componentWillUnmount。\r\n* 第二个参数代表着监控谁，一旦监控的对象发生了变化，则要调用第一个参数里的回调函数，第二个参数不写代表监控所有的状态，写谁代表监控谁，所以在下面的案例中，传入的是一个空数组，代表谁也不监控，这就实现了第一个回调函数的componentDidMount的作用。\r\n![](https://img-blog.csdnimg.cn/img_convert/43d6129389fa3d402bd0b73896d77fe4.png)"
    },
    {
      "id": "/React-56：RefHook（让函数式组件能够使用ref）",
      "metadata": {
        "permalink": "/blog/React-56：RefHook（让函数式组件能够使用ref）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-56：RefHook（让函数式组件能够使用ref）.md",
        "source": "@site/blog\\React-56：RefHook（让函数式组件能够使用ref）.md",
        "title": "React-56：RefHook（让函数式组件能够使用ref）",
        "description": "创建ref",
        "date": "2021-04-28T00:00:00.000Z",
        "formattedDate": "2021年4月28日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.055,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-56：RefHook（让函数式组件能够使用ref）",
          "date": "2021-04-28T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-55：EffectHook（让函数式组件能够使用生命周期钩子）",
          "permalink": "/blog/React-55：EffectHook（让函数式组件能够使用生命周期钩子）"
        },
        "nextItem": {
          "title": "JS中import时什么时候允许自定义命名，什么时候不允许自定义命名",
          "permalink": "/blog/JS中import时什么时候允许自定义命名，什么时候不允许自定义命名"
        }
      },
      "content": "## 创建ref\r\n![](https://img-blog.csdnimg.cn/img_convert/08e411d5c8e9cb2ced3b7c5a7451009a.png)\r\n\r\n## 使用ref\r\n![](https://img-blog.csdnimg.cn/img_convert/56d1a32c1705bb1678f0ba3994af3a2a.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/4af93d907edb7c87de5f89f907c4e2ab.png)"
    },
    {
      "id": "/JS中import时什么时候允许自定义命名，什么时候不允许自定义命名",
      "metadata": {
        "permalink": "/blog/JS中import时什么时候允许自定义命名，什么时候不允许自定义命名",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/JS中import时什么时候允许自定义命名，什么时候不允许自定义命名.md",
        "source": "@site/blog\\JS中import时什么时候允许自定义命名，什么时候不允许自定义命名.md",
        "title": "JS中import时什么时候允许自定义命名，什么时候不允许自定义命名",
        "description": "分别暴露的时候，不能自定义命名，必须和暴露的名字一致",
        "date": "2021-04-27T00:00:00.000Z",
        "formattedDate": "2021年4月27日",
        "tags": [
          {
            "label": "JS模块化",
            "permalink": "/blog/tags/js模块化"
          }
        ],
        "readingTime": 0.33,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "JS中import时什么时候允许自定义命名，什么时候不允许自定义命名",
          "date": "2021-04-27T00:00:00.000Z",
          "categories": "JS模块化",
          "tags": [
            "JS模块化"
          ]
        },
        "prevItem": {
          "title": "React-56：RefHook（让函数式组件能够使用ref）",
          "permalink": "/blog/React-56：RefHook（让函数式组件能够使用ref）"
        },
        "nextItem": {
          "title": "React-49：纯函数概念",
          "permalink": "/blog/React-49：纯函数概念"
        }
      },
      "content": "## 分别暴露的时候，不能自定义命名，必须和暴露的名字一致\r\n![](https://img-blog.csdnimg.cn/img_convert/7ea9ac30b595bd8e0dec62fd328ed091.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/a9be805e5368e99ac9d74264710ae9ce.png)\r\n\r\n## 默认暴露的时候，由于只暴露了一个，所以允许自定义命名，且导入的时候不用加大括号\r\n![](https://img-blog.csdnimg.cn/img_convert/457e307ce0b9dcb55372ea3abb131c69.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/b845967333a154179fd1ecafa23d0397.png)"
    },
    {
      "id": "/React-49：纯函数概念",
      "metadata": {
        "permalink": "/blog/React-49：纯函数概念",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-49：纯函数概念.md",
        "source": "@site/blog\\React-49：纯函数概念.md",
        "title": "React-49：纯函数概念",
        "description": "纯函数的几个条件：",
        "date": "2021-04-27T00:00:00.000Z",
        "formattedDate": "2021年4月27日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.565,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-49：纯函数概念",
          "date": "2021-04-27T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "JS中import时什么时候允许自定义命名，什么时候不允许自定义命名",
          "permalink": "/blog/JS中import时什么时候允许自定义命名，什么时候不允许自定义命名"
        },
        "nextItem": {
          "title": "React-50：一文学会redux开发者工具的基本使用",
          "permalink": "/blog/React-50：一文学会redux开发者工具的基本使用"
        }
      },
      "content": "## 纯函数的几个条件：\r\n1. 同样的输入，必须是同样的输出。\r\n2. 函数中不能改写参数的值。\r\n3. 不会产生任何副作用，不能有网络请求和输入输出设备。\r\n4. 不能调用Date.now()和Math.random()等不纯的方法。\r\n\r\n## redux的reducer必须是一个纯函数\r\n* 详情可以参考这篇文章[React-48：为什么redux中的reducer返回状态时不能用unshift等API？](https://blog.csdn.net/sinat_41696687/article/details/115874658)"
    },
    {
      "id": "/React-50：一文学会redux开发者工具的基本使用",
      "metadata": {
        "permalink": "/blog/React-50：一文学会redux开发者工具的基本使用",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-50：一文学会redux开发者工具的基本使用.md",
        "source": "@site/blog\\React-50：一文学会redux开发者工具的基本使用.md",
        "title": "React-50：一文学会redux开发者工具的基本使用",
        "description": "安装方法",
        "date": "2021-04-27T00:00:00.000Z",
        "formattedDate": "2021年4月27日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.465,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-50：一文学会redux开发者工具的基本使用",
          "date": "2021-04-27T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-49：纯函数概念",
          "permalink": "/blog/React-49：纯函数概念"
        },
        "nextItem": {
          "title": "React-51：React项目打包运行",
          "permalink": "/blog/React-51：React项目打包运行"
        }
      },
      "content": "## 安装方法\r\n```\r\nnpm install redux-devtools-extension\r\n```\r\n## 使用方法\r\n* 有异步action的情况\r\n![](https://img-blog.csdnimg.cn/img_convert/de0c4434b7be066569527a80e9482ad0.png)\r\n\r\n* 没有异步action的情况\r\n![](https://img-blog.csdnimg.cn/img_convert/0b89d58f917d100210660e6eb26fd85c.png)\r\n\r\n## redux-devtools-extension介绍\r\n* action区域\r\n![](https://img-blog.csdnimg.cn/img_convert/fd289165f05d07a26ae5361e468f5e5e.png)\r\n\r\n* 查看action对象的type和data\r\n![](https://img-blog.csdnimg.cn/img_convert/0e7af51929dc52d8a38b858468000e08.png)\r\n\r\n* 查看redux帮我们保存的总的状态对象\r\n![](https://img-blog.csdnimg.cn/img_convert/6b027850d5e899492047d56c90046e6a.png)\r\n\r\n* 查看状态的比较变化\r\n![](https://img-blog.csdnimg.cn/img_convert/e0a45e6835d611910856eb5bfbc47333.png)\r\n\r\n* 回放状态的变化\r\n![](https://img-blog.csdnimg.cn/img_convert/f2e812c63e4793a49313a4a4a3b279e5.gif)\r\n\r\n* 临时dispatch\r\n![](https://img-blog.csdnimg.cn/img_convert/6f55b975192e4d01d0f644c6ce3a428f.png)"
    },
    {
      "id": "/React-51：React项目打包运行",
      "metadata": {
        "permalink": "/blog/React-51：React项目打包运行",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-51：React项目打包运行.md",
        "source": "@site/blog\\React-51：React项目打包运行.md",
        "title": "React-51：React项目打包运行",
        "description": "1. build创建",
        "date": "2021-04-27T00:00:00.000Z",
        "formattedDate": "2021年4月27日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.2,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-51：React项目打包运行",
          "date": "2021-04-27T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-50：一文学会redux开发者工具的基本使用",
          "permalink": "/blog/React-50：一文学会redux开发者工具的基本使用"
        },
        "nextItem": {
          "title": "剑指Offer——包含min函数的栈（JS实现）",
          "permalink": "/blog/剑指Offer——包含min函数的栈（JS实现）"
        }
      },
      "content": "## 1. build创建\r\n```\r\nnpm run build\r\n```\r\n## 2. 全局安装serve库\r\n```\r\nnpm i serve -g\r\n```\r\n## 3. 以build文件夹为服务器的根目录\r\n```\r\nserve build\r\n```"
    },
    {
      "id": "/剑指Offer——包含min函数的栈（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——包含min函数的栈（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——包含min函数的栈（JS实现）.md",
        "source": "@site/blog\\剑指Offer——包含min函数的栈（JS实现）.md",
        "title": "剑指Offer——包含min函数的栈（JS实现）",
        "description": "题目描述",
        "date": "2021-04-27T00:00:00.000Z",
        "formattedDate": "2021年4月27日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.58,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——包含min函数的栈（JS实现）",
          "date": "2021-04-27T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "React-51：React项目打包运行",
          "permalink": "/blog/React-51：React项目打包运行"
        },
        "nextItem": {
          "title": "React-45：mapDispatchToProps的简写方法",
          "permalink": "/blog/React-45：mapDispatchToProps的简写方法"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/20f3ac40b5cc220e05407e5f61d990e1.png)\r\n\r\n## 解题思路\r\n* 这道题属于栈的相关问题\r\n* 本题的核心思路是采用模拟栈的方法\r\n* 模拟栈是一种很重要的思路，主要是定义两个数组，一个数组和真实的栈的pushpop方法一致，另一个数组则是用来存储最小值的栈，只有push的元素比最小值栈小或相等的时候，才将该元素push进最小值栈。\r\n* top方法只需将真实栈的栈顶元素返回即可\r\n* 在进行pop方法的时候，真实栈直接pop即可，最小值栈则要判断是否pop的是自己的栈顶，是则pop，不是则不用pop\r\n\r\n## 解题代码\r\n```js\r\nvar MinStack = function () {\r\n    this.stack = [];\r\n    this.minStack = [];\r\n};\r\n\r\nMinStack.prototype.push = function (x) {\r\n    this.stack.push(x);\r\n    if (this.minStack.length === 0 || x <= this.minStack[this.minStack.length - 1]) {\r\n        this.minStack.push(x);\r\n    }\r\n};\r\n\r\nMinStack.prototype.pop = function () {\r\n    if (this.stack[this.stack.length - 1] === this.minStack[this.minStack.length - 1]) {\r\n        this.minStack.pop();\r\n        this.stack.pop();\r\n    } else {\r\n        this.stack.pop();\r\n    }\r\n};\r\n\r\nMinStack.prototype.top = function () {\r\n    return this.stack[this.stack.length - 1];\r\n};\r\n\r\nMinStack.prototype.min = function () {\r\n    return this.minStack[this.minStack.length - 1];\r\n};\r\n```\r\n## 总结（本题给我们的启示思路）\r\n* 启示一：学会使用模拟栈\r\n* 启示二：模拟min栈什么时候进行push,什么时候进行pop是本题的核心和关键"
    },
    {
      "id": "/React-45：mapDispatchToProps的简写方法",
      "metadata": {
        "permalink": "/blog/React-45：mapDispatchToProps的简写方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-45：mapDispatchToProps的简写方法.md",
        "source": "@site/blog\\React-45：mapDispatchToProps的简写方法.md",
        "title": "React-45：mapDispatchToProps的简写方法",
        "description": "简写形式",
        "date": "2021-04-26T00:00:00.000Z",
        "formattedDate": "2021年4月26日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.07,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-45：mapDispatchToProps的简写方法",
          "date": "2021-04-26T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——包含min函数的栈（JS实现）",
          "permalink": "/blog/剑指Offer——包含min函数的栈（JS实现）"
        },
        "nextItem": {
          "title": "React-46：Provider组件的使用",
          "permalink": "/blog/React-46：Provider组件的使用"
        }
      },
      "content": "## 简写形式\r\n* 对象：键值对的形式\r\n![](https://img-blog.csdnimg.cn/img_convert/a24a130f9a36ef6ea20b2a196ae60078.png)"
    },
    {
      "id": "/React-46：Provider组件的使用",
      "metadata": {
        "permalink": "/blog/React-46：Provider组件的使用",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-46：Provider组件的使用.md",
        "source": "@site/blog\\React-46：Provider组件的使用.md",
        "title": "React-46：Provider组件的使用",
        "description": "在入口文件中引入Provider",
        "date": "2021-04-26T00:00:00.000Z",
        "formattedDate": "2021年4月26日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.235,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-46：Provider组件的使用",
          "date": "2021-04-26T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-45：mapDispatchToProps的简写方法",
          "permalink": "/blog/React-45：mapDispatchToProps的简写方法"
        },
        "nextItem": {
          "title": "React-47：一张图看懂react-redux的基本流程",
          "permalink": "/blog/React-47：一张图看懂react-redux的基本流程"
        }
      },
      "content": "## 在入口文件中引入Provider\r\n* 通过给Provider传递store，就不用通过给每一个容器组件传递store了\r\n* 别忘了在入口文件引入store\r\n![](https://img-blog.csdnimg.cn/img_convert/fe25453f1f37bd89e983352384d91e8d.png)"
    },
    {
      "id": "/React-47：一张图看懂react-redux的基本流程",
      "metadata": {
        "permalink": "/blog/React-47：一张图看懂react-redux的基本流程",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-47：一张图看懂react-redux的基本流程.md",
        "source": "@site/blog\\React-47：一张图看懂react-redux的基本流程.md",
        "title": "React-47：一张图看懂react-redux的基本流程",
        "description": "react-redux基本流程图",
        "date": "2021-04-26T00:00:00.000Z",
        "formattedDate": "2021年4月26日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.27,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-47：一张图看懂react-redux的基本流程",
          "date": "2021-04-26T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-46：Provider组件的使用",
          "permalink": "/blog/React-46：Provider组件的使用"
        },
        "nextItem": {
          "title": "React-48：为什么redux中的reducer返回状态时不能用unshift等API？",
          "permalink": "/blog/React-48：为什么redux中的reducer返回状态时不能用unshift等API？"
        }
      },
      "content": "## react-redux基本流程图\r\n* 请耐心看完，看完后定会对react-redux的基本流程有更加深入的认识，同时会对react-redux每一个模块的作用有更加深入的了解。\r\n![](https://img-blog.csdnimg.cn/img_convert/927f5a01a56e8450e089df00c8a8c281.png)"
    },
    {
      "id": "/React-48：为什么redux中的reducer返回状态时不能用unshift等API？",
      "metadata": {
        "permalink": "/blog/React-48：为什么redux中的reducer返回状态时不能用unshift等API？",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-48：为什么redux中的reducer返回状态时不能用unshift等API？.md",
        "source": "@site/blog\\React-48：为什么redux中的reducer返回状态时不能用unshift等API？.md",
        "title": "React-48：为什么redux中的reducer返回状态时不能用unshift等API？",
        "description": "先说结论：使用unshift是不起作用的",
        "date": "2021-04-26T00:00:00.000Z",
        "formattedDate": "2021年4月26日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.52,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-48：为什么redux中的reducer返回状态时不能用unshift等API？",
          "date": "2021-04-26T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-47：一张图看懂react-redux的基本流程",
          "permalink": "/blog/React-47：一张图看懂react-redux的基本流程"
        },
        "nextItem": {
          "title": "剑指Offer——不用加减乘除做加法（JS实现）",
          "permalink": "/blog/剑指Offer——不用加减乘除做加法（JS实现）"
        }
      },
      "content": "## 先说结论：使用unshift是不起作用的\r\n## 原因\r\n* redux的底层会比较preState的地址是否发生了变化，如果没有发生变化，就不会更新页面，只有发生了变化才会更新页面。\r\n* 下面这种就是地址没有发生变化\r\n![](https://img-blog.csdnimg.cn/img_convert/b0cd9d04d9ee2d03d44a513094aee7c5.png)\r\n\r\n## 解决办法（reducer必须是一个纯函数）\r\n* 采用下面这种方法进行返回\r\n![](https://img-blog.csdnimg.cn/img_convert/a01a0747d833ef2807cab651f5abb999.png)"
    },
    {
      "id": "/剑指Offer——不用加减乘除做加法（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——不用加减乘除做加法（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——不用加减乘除做加法（JS实现）.md",
        "source": "@site/blog\\剑指Offer——不用加减乘除做加法（JS实现）.md",
        "title": "剑指Offer——不用加减乘除做加法（JS实现）",
        "description": "题目描述",
        "date": "2021-04-26T00:00:00.000Z",
        "formattedDate": "2021年4月26日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.655,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——不用加减乘除做加法（JS实现）",
          "date": "2021-04-26T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "React-48：为什么redux中的reducer返回状态时不能用unshift等API？",
          "permalink": "/blog/React-48：为什么redux中的reducer返回状态时不能用unshift等API？"
        },
        "nextItem": {
          "title": "剑指Offer——二叉树中和为某一值的路径（JS实现）",
          "permalink": "/blog/剑指Offer——二叉树中和为某一值的路径（JS实现）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/95e7a26558dc977f957443b2e54b7f9c.png)\r\n\r\n## 解题思路\r\n* 这道题属于考查位运算的问题\r\n* 位运算从某种程度上来说思路较为难以理解\r\n* 本题考查的就是加法 = 进位 + 非进位\r\n\r\n## 解题代码\r\n```js\r\nvar add = function(a, b) {\r\n    while (b) {\r\n        let c = (a&b) << 1;\r\n        a = a^b;\r\n        b = c;\r\n    }\r\n    return a;\r\n};\r\n```\r\n## 总结（本题给我们的启示思路）\r\n* 思路一：位运算是如何完成加法操作的。\r\n* 思路二：位运算的加法 = 进位 + 非进位"
    },
    {
      "id": "/剑指Offer——二叉树中和为某一值的路径（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——二叉树中和为某一值的路径（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——二叉树中和为某一值的路径（JS实现）.md",
        "source": "@site/blog\\剑指Offer——二叉树中和为某一值的路径（JS实现）.md",
        "title": "剑指Offer——二叉树中和为某一值的路径（JS实现）",
        "description": "题目描述",
        "date": "2021-04-26T00:00:00.000Z",
        "formattedDate": "2021年4月26日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.805,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——二叉树中和为某一值的路径（JS实现）",
          "date": "2021-04-26T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——不用加减乘除做加法（JS实现）",
          "permalink": "/blog/剑指Offer——不用加减乘除做加法（JS实现）"
        },
        "nextItem": {
          "title": "React-43：redux基础用法",
          "permalink": "/blog/React-43：redux基础用法"
        }
      },
      "content": "## 题目描述\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ed5150791f445fe8f8bbdd018eaa008~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 解题思路\r\n* 这道题属于二叉树的深度优先遍历\r\n* 首先我们要了解DFS的遍历过程\r\n* 当root节点走到null的时候，说明该条路径已经遍历完毕\r\n* 当一条路径遍历完毕之后，我们使用浅拷贝的方式将一条路径拷贝进res最终结果数组中\r\n* 然后开始返回，每次返回都要将stack数组的最后一个元素清空，这是本题的核心点，刚开始被这个问题困扰了很久。\r\n\r\n## 解题代码\r\n```js\r\nvar pathSum = function (root, target) {\r\n    const res = [];\r\n    let stack = [];\r\n    function dfs(node) {\r\n        if (!node) return null;\r\n        stack.push(node.val)\r\n        let l = dfs(node.left);\r\n        let r = dfs(node.right);\r\n        if (l === null && r === null) {\r\n            res.push([...stack]);\r\n        }\r\n        stack.pop();\r\n        return;\r\n    }\r\n    dfs(root)\r\n    const temp = res.filter((value) => {\r\n        return value.reduce((pre, cur) => pre + cur, 0) === target;\r\n    })\r\n    return temp;\r\n};\r\n```\r\n\r\n## 更优解\r\n> 通过DFS求解路径。\r\n\r\n```js\r\nvar pathSum = function(root, targetSum) {\r\n    // 路径总和II 是经典的DFS问题\r\n    if (!root) return [];\r\n    const res = [];\r\n    function dfs(root,sum,temp) {\r\n        temp.push(root.val);\r\n        if (root.val === sum && !root.left && !root.right) {\r\n            res.push(temp);\r\n            return;    \r\n        }\r\n        if (root.left) dfs(root.left,sum - root.val,temp.slice());\r\n        if (root.right) dfs(root.right,sum - root.val,temp.slice());\r\n    }\r\n    dfs(root,targetSum,[]);\r\n    return res;\r\n};\r\n```\r\n\r\n## 总结（本题给我们的启示思路）\r\n* 思路一：如何使用DFS算法遍历二叉树。\r\n* 思路二：在进行遍历的时候，该返回什么?什么时候进行存储才是本题的核心，才应当是我们应该多加练习的地方。"
    },
    {
      "id": "/React-43：redux基础用法",
      "metadata": {
        "permalink": "/blog/React-43：redux基础用法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-43：redux基础用法.md",
        "source": "@site/blog\\React-43：redux基础用法.md",
        "title": "React-43：redux基础用法",
        "description": "1. 安装redux",
        "date": "2021-04-24T00:00:00.000Z",
        "formattedDate": "2021年4月24日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.56,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-43：redux基础用法",
          "date": "2021-04-24T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——二叉树中和为某一值的路径（JS实现）",
          "permalink": "/blog/剑指Offer——二叉树中和为某一值的路径（JS实现）"
        },
        "nextItem": {
          "title": "React-44：异步action的写法",
          "permalink": "/blog/React-44：异步action的写法"
        }
      },
      "content": "## 1. 安装redux\r\n```\r\nnpm install redux\r\n```\r\n## 2. 创建redux文件夹（专门用来存放redux相关文件）\r\n![](https://img-blog.csdnimg.cn/img_convert/796d7f1cc6d3b8b85fd150c23a5ed7ac.png)\r\n\r\n## 3. 在store.js文件中引入createStore,组件reducer,并暴露\r\n![](https://img-blog.csdnimg.cn/img_convert/45c71d3e48706114ee68ef7c7970f05e.png)\r\n\r\n## 4.  状态reducer文件\r\n![](https://img-blog.csdnimg.cn/img_convert/1637841d6249a9e3988fd33913857d6e.png)\r\n\r\n## 5. 在组件中调用redux的API\r\n* 获取状态\r\n![](https://img-blog.csdnimg.cn/img_convert/8cb11c842537579a6c93ccd24724a647.png)\r\n\r\n* 让store执行对状态的操作\r\n![](https://img-blog.csdnimg.cn/img_convert/fb9b90ad9fd68a6e7a6ceae9409521bd.png)\r\n\r\n* 组件挂载后不断检测redux中的状态变化，并驱动页面数据的更新\r\n![](https://img-blog.csdnimg.cn/img_convert/a2d3037dc6a2ce3e23103fa68241bd63.png)"
    },
    {
      "id": "/React-44：异步action的写法",
      "metadata": {
        "permalink": "/blog/React-44：异步action的写法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-44：异步action的写法.md",
        "source": "@site/blog\\React-44：异步action的写法.md",
        "title": "React-44：异步action的写法",
        "description": "安装react-thunk",
        "date": "2021-04-24T00:00:00.000Z",
        "formattedDate": "2021年4月24日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.28,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-44：异步action的写法",
          "date": "2021-04-24T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-43：redux基础用法",
          "permalink": "/blog/React-43：redux基础用法"
        },
        "nextItem": {
          "title": "React报错：TypeError Cannot call a class as a function",
          "permalink": "/blog/React报错：TypeError Cannot call a class as a function"
        }
      },
      "content": "## 安装react-thunk\r\n```\r\nnpm install react-thunk\r\n```\r\n## 在store中引入thunk\r\n```\r\nimport thunk from 'redux-thunk'\r\n```\r\n## 从redux中引入中间件库applyMiddleware\r\n```\r\nimport {applyMiddleware, createStore} from 'redux';\r\n```\r\n## 修改createStore的参数\r\n![](https://img-blog.csdnimg.cn/img_convert/30353ec95d1d182228b7f536a3cde489.png)\r\n\r\n## 异步action的写法\r\n![](https://img-blog.csdnimg.cn/img_convert/4bc63292102ec4951a0361c71513a24e.png)"
    },
    {
      "id": "/React报错：TypeError Cannot call a class as a function",
      "metadata": {
        "permalink": "/blog/React报错：TypeError Cannot call a class as a function",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React报错：TypeError Cannot call a class as a function.md",
        "source": "@site/blog\\React报错：TypeError Cannot call a class as a function.md",
        "title": "React报错：TypeError Cannot call a class as a function",
        "description": "错误描述",
        "date": "2021-04-24T00:00:00.000Z",
        "formattedDate": "2021年4月24日",
        "tags": [
          {
            "label": "debug",
            "permalink": "/blog/tags/debug"
          }
        ],
        "readingTime": 0.15,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React报错：TypeError Cannot call a class as a function",
          "date": "2021-04-24T00:00:00.000Z",
          "categories": "debug",
          "tags": [
            "debug"
          ]
        },
        "prevItem": {
          "title": "React-44：异步action的写法",
          "permalink": "/blog/React-44：异步action的写法"
        },
        "nextItem": {
          "title": "剑指Offer——II.平衡二叉树（JS实现）",
          "permalink": "/blog/剑指Offer——II.平衡二叉树（JS实现）"
        }
      },
      "content": "## 错误描述\r\nTypeError: Cannot call a class as a function\r\n\r\n## 错误原因\r\n* 错将redux-thunk写成react-thunk\r\n\r\n## 解决办法\r\n![](https://img-blog.csdnimg.cn/img_convert/523194f4072c24ca4f5a8b53dc95a219.png)"
    },
    {
      "id": "/剑指Offer——II.平衡二叉树（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——II.平衡二叉树（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——II.平衡二叉树（JS实现）.md",
        "source": "@site/blog\\剑指Offer——II.平衡二叉树（JS实现）.md",
        "title": "剑指Offer——II.平衡二叉树（JS实现）",
        "description": "题目描述",
        "date": "2021-04-24T00:00:00.000Z",
        "formattedDate": "2021年4月24日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.86,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——II.平衡二叉树（JS实现）",
          "date": "2021-04-24T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "React报错：TypeError Cannot call a class as a function",
          "permalink": "/blog/React报错：TypeError Cannot call a class as a function"
        },
        "nextItem": {
          "title": "React-40：antd样式的按需引入",
          "permalink": "/blog/React-40：antd样式的按需引入"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/592d2f408b11526e1e85b5a9ce589285.png)\r\n\r\n## 解题思路\r\n* 这道题属于二叉树考查深度的问题\r\n* 本题的核心在于知道二叉树的深度怎么求：二叉树的深度 = 左子树的深度与右子树的深度中的最大值 + 1，这是核心解题点\r\n\r\n## 解题代码\r\n```js\r\nvar isBalanced = function(root) {\r\n    let flag = true;\r\n    dfs(root);\r\n    return flag;\r\n    function dfs(root) {\r\n        if (!root) return 0;\r\n        let l = dfs(root.left);\r\n        let r = dfs(root.right);\r\n        if (Math.abs(l - r) > 1) {\r\n            flag = false;\r\n        }\r\n        return Math.max(l,r) + 1;\r\n    }\r\n};\r\n```\r\n## 总结\r\n* 本题给我们的启示就是二叉树的深度怎么求：\r\n* 左子树与右子树中选最大的那个+1就是目标节点的深度。"
    },
    {
      "id": "/React-40：antd样式的按需引入",
      "metadata": {
        "permalink": "/blog/React-40：antd样式的按需引入",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-40：antd样式的按需引入.md",
        "source": "@site/blog\\React-40：antd样式的按需引入.md",
        "title": "React-40：antd样式的按需引入",
        "description": "为什么要按需引入？",
        "date": "2021-04-23T00:00:00.000Z",
        "formattedDate": "2021年4月23日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.88,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-40：antd样式的按需引入",
          "date": "2021-04-23T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——II.平衡二叉树（JS实现）",
          "permalink": "/blog/剑指Offer——II.平衡二叉树（JS实现）"
        },
        "nextItem": {
          "title": "React-41：antd自定义主题",
          "permalink": "/blog/React-41：antd自定义主题"
        }
      },
      "content": "> 为什么要按需引入？\r\n* 像下面这种将全部样式都引入，会造成内存消耗过大，因为我们引入了很多我们并不使用的样式\r\n![](https://img-blog.csdnimg.cn/img_convert/bbbab9180a82160751642daa28e9663a.png)\r\n\r\n## 第一步：安装工具包\r\n```\r\nnpm install react-app-rewired customize-cra\r\n```\r\n## 第二步：将项目文件中的package.json中的文件进行下面的修改\r\n![](https://img-blog.csdnimg.cn/img_convert/784e6dbc996c528e874c3ad521a55a02.png)\r\n\r\n## 第三步：项目根目录创建一个 config-overrides.js 用于修改默认配置\r\n```js\r\nconst { override, fixBabelImports } = require('customize-cra');\r\nmodule.exports = override(\r\n    fixBabelImports('import', {\r\n        libraryName: 'antd',\r\n        libraryDirectory: 'es',\r\n        style: 'css',\r\n    }),\r\n);\r\n```\r\n## 第四步：安装babel-plugin-import\r\n```\r\nnpm install babel-plugin-import\r\n```\r\n## 到这列，我们就可以将最开始的那个语句删掉了。\r\n* 样式正常\r\n![](https://img-blog.csdnimg.cn/img_convert/2eb3c94f810f22b1505e2563ec908138.png)\r\n\r\n## 参考文献\r\nhttps://3x.ant.design/docs/react/use-with-create-react-app-cn"
    },
    {
      "id": "/React-41：antd自定义主题",
      "metadata": {
        "permalink": "/blog/React-41：antd自定义主题",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-41：antd自定义主题.md",
        "source": "@site/blog\\React-41：antd自定义主题.md",
        "title": "React-41：antd自定义主题",
        "description": "1. 安装工具包",
        "date": "2021-04-23T00:00:00.000Z",
        "formattedDate": "2021年4月23日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.3,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-41：antd自定义主题",
          "date": "2021-04-23T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-40：antd样式的按需引入",
          "permalink": "/blog/React-40：antd样式的按需引入"
        },
        "nextItem": {
          "title": "React-42：redux简介",
          "permalink": "/blog/React-42：redux简介"
        }
      },
      "content": "## 1. 安装工具包\r\n```\r\nnpm install less-loader@7.3.0 --save-dev\r\n```\r\n## 2. 修改 config-overrides.js文件\r\n```js\r\nconst { override, fixBabelImports, addLessLoader } = require('customize-cra');\r\nmodule.exports = override(\r\n    fixBabelImports('import', {\r\n        libraryName: 'antd',\r\n        libraryDirectory: 'es',\r\n        style: true,\r\n    }),\r\n    addLessLoader({\r\n        lessOptions: {\r\n            javascriptEnabled: true,\r\n            modifyVars: { '@primary-color': 'aqua' },\r\n        }\r\n    }),\r\n);\r\n```\r\n## 3. npm start即可"
    },
    {
      "id": "/React-42：redux简介",
      "metadata": {
        "permalink": "/blog/React-42：redux简介",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-42：redux简介.md",
        "source": "@site/blog\\React-42：redux简介.md",
        "title": "React-42：redux简介",
        "description": "1. redux是什么？",
        "date": "2021-04-23T00:00:00.000Z",
        "formattedDate": "2021年4月23日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.365,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-42：redux简介",
          "date": "2021-04-23T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-41：antd自定义主题",
          "permalink": "/blog/React-41：antd自定义主题"
        },
        "nextItem": {
          "title": "React脚手架报错 Cannot create a project named ““ because of npm naming restrictions",
          "permalink": "/blog/React脚手架报错 Cannot create a project named ““ because of npm naming restrictions"
        }
      },
      "content": "## 1. redux是什么？\r\n答：一个专门用来做管理状态的JS库。\r\n## 2. 什么情况下使用redux\r\n* 某个组件的状态，需要让其他组件可以随时拿到。\r\n* 一个组件需要改变另一个组件的状态。\r\n\r\n## 3. redux原理图\r\n![](https://img-blog.csdnimg.cn/img_convert/89492a04f432c1e27d5cfb548aa2a74c.png)"
    },
    {
      "id": "/React脚手架报错 Cannot create a project named ““ because of npm naming restrictions",
      "metadata": {
        "permalink": "/blog/React脚手架报错 Cannot create a project named ““ because of npm naming restrictions",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React脚手架报错 Cannot create a project named ““ because of npm naming restrictions.md",
        "source": "@site/blog\\React脚手架报错 Cannot create a project named ““ because of npm naming restrictions.md",
        "title": "React脚手架报错 Cannot create a project named ““ because of npm naming restrictions",
        "description": "问题描述",
        "date": "2021-04-23T00:00:00.000Z",
        "formattedDate": "2021年4月23日",
        "tags": [
          {
            "label": "debug",
            "permalink": "/blog/tags/debug"
          }
        ],
        "readingTime": 0.215,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React脚手架报错 Cannot create a project named ““ because of npm naming restrictions",
          "date": "2021-04-23T00:00:00.000Z",
          "categories": "debug",
          "tags": [
            "debug"
          ]
        },
        "prevItem": {
          "title": "React-42：redux简介",
          "permalink": "/blog/React-42：redux简介"
        },
        "nextItem": {
          "title": "剑指Offer——从上到下打印二叉树III（JS实现）",
          "permalink": "/blog/剑指Offer——从上到下打印二叉树III（JS实现）"
        }
      },
      "content": "## 问题描述\r\n![](https://img-blog.csdnimg.cn/img_convert/d41bc20d92dad3b903527d4867599fef.png)\r\n\r\n## 问题原因\r\n* 创建的脚手架项目名中含有大写字母\r\n\r\n## 解决办法\r\n* 将大写字母换成其他即可\r\n![](https://img-blog.csdnimg.cn/img_convert/482a4c3bd62101f446a869ab8a717bbf.png)"
    },
    {
      "id": "/剑指Offer——从上到下打印二叉树III（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——从上到下打印二叉树III（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——从上到下打印二叉树III（JS实现）.md",
        "source": "@site/blog\\剑指Offer——从上到下打印二叉树III（JS实现）.md",
        "title": "剑指Offer——从上到下打印二叉树III（JS实现）",
        "description": "题目描述",
        "date": "2021-04-23T00:00:00.000Z",
        "formattedDate": "2021年4月23日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.715,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——从上到下打印二叉树III（JS实现）",
          "date": "2021-04-23T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "React脚手架报错 Cannot create a project named ““ because of npm naming restrictions",
          "permalink": "/blog/React脚手架报错 Cannot create a project named ““ because of npm naming restrictions"
        },
        "nextItem": {
          "title": "通过npm暴露React项目配置",
          "permalink": "/blog/通过npm暴露React项目配置"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/b174fe4dd4c944a085edfbefa6c3942b.png)\r\n\r\n## 解题思路\r\n* 这道题属于二叉树的层次遍历问题\r\n* 首先定义三个数组\r\n* 数组queue用来存放当前层的所有元素指针\r\n* 数组temp充当临时数组，用来存放当前元素所有指针的左右孩子指针\r\n* 数组test用来存放每一层元素的值\r\n* 当test存储完一层的元素后，就将queue置为空，然后遍历temp将每个元素的左右孩子节点继续放入queue，继续下次循环\r\n\r\n## 解题代码\r\n```js\r\nvar levelOrder = function (root) {\r\n    // 使用队列的方式进行二叉树的层次遍历\r\n    if (root === null) return [];\r\n    let queue = [];\r\n    const result = [];\r\n    queue.push(root);\r\n    while (queue.length !== 0) {\r\n        const temp = [];\r\n        const test = [];\r\n        for (let v of queue) {\r\n            temp.push(v);\r\n            test.push(v.val);\r\n        }\r\n        result.push(test);\r\n        queue = [];\r\n        for (let v of temp) {\r\n            if (v.left !== null) {\r\n                queue.push(v.left)\r\n            }\r\n            if (v.right !== null) {\r\n                queue.push(v.right)\r\n            }\r\n        }\r\n\r\n    }\r\n    for (let i = 0; i < result.length;i++) {\r\n        if (i % 2 !== 0) {\r\n            result[i] = result[i].reverse()\r\n        }\r\n    }\r\n    return result;\r\n};\r\n```\r\n## 总结\r\n* 本题乍一看不难，大家也都容易想到一定的思路，但是难就难层次的遍历上\r\n* 本题可以采用一个数组来记录当前层，另一个数组来记录当前层的所有子节点，然后将当前层清空，使用所有子节点的层继续遍历。"
    },
    {
      "id": "/通过npm暴露React项目配置",
      "metadata": {
        "permalink": "/blog/通过npm暴露React项目配置",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/通过npm暴露React项目配置.md",
        "source": "@site/blog\\通过npm暴露React项目配置.md",
        "title": "通过npm暴露React项目配置",
        "description": "直接输入下面的命令",
        "date": "2021-04-23T00:00:00.000Z",
        "formattedDate": "2021年4月23日",
        "tags": [
          {
            "label": "npm",
            "permalink": "/blog/tags/npm"
          }
        ],
        "readingTime": 0.17,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "通过npm暴露React项目配置",
          "date": "2021-04-23T00:00:00.000Z",
          "categories": "npm",
          "tags": [
            "npm"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——从上到下打印二叉树III（JS实现）",
          "permalink": "/blog/剑指Offer——从上到下打印二叉树III（JS实现）"
        },
        "nextItem": {
          "title": "React-36：编程式路由导航",
          "permalink": "/blog/React-36：编程式路由导航"
        }
      },
      "content": "## 直接输入下面的命令\r\n```\r\nnpm run eject\r\n```\r\n## 暴露配置成功的标志\r\n* 多了下面两个文件夹\r\n![](https://img-blog.csdnimg.cn/img_convert/121d825a5039d59c108d709ca6e73c13.png)"
    },
    {
      "id": "/React-36：编程式路由导航",
      "metadata": {
        "permalink": "/blog/React-36：编程式路由导航",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-36：编程式路由导航.md",
        "source": "@site/blog\\React-36：编程式路由导航.md",
        "title": "React-36：编程式路由导航",
        "description": "函数格式",
        "date": "2021-04-22T00:00:00.000Z",
        "formattedDate": "2021年4月22日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.31,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-36：编程式路由导航",
          "date": "2021-04-22T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "通过npm暴露React项目配置",
          "permalink": "/blog/通过npm暴露React项目配置"
        },
        "nextItem": {
          "title": "React-37：withRouter的使用",
          "permalink": "/blog/React-37：withRouter的使用"
        }
      },
      "content": "## 函数格式\r\n![](https://img-blog.csdnimg.cn/img_convert/f66dd72f36e85482732218ce802ed84c.png)\r\n\r\n## 路由传参的三种形式\r\n![](https://img-blog.csdnimg.cn/img_convert/359615ab4672670cdff1d3511f88eaea.png)\r\n接收的时候，根据对应方式进行接收，详情参考前几个博客\r\n\r\n## goForward与goBack\r\n![](https://img-blog.csdnimg.cn/img_convert/195350e3721a53ad105a7c0c9ca0bf21.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/f36fc8d71cfa338f1d9a6369cd5f050c.png)\r\n\r\n## go\r\n* 正数代表前进，负数代表后退\r\n![](https://img-blog.csdnimg.cn/img_convert/1b773fed670300e4f92bf5f9be14fc8c.png)"
    },
    {
      "id": "/React-37：withRouter的使用",
      "metadata": {
        "permalink": "/blog/React-37：withRouter的使用",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-37：withRouter的使用.md",
        "source": "@site/blog\\React-37：withRouter的使用.md",
        "title": "React-37：withRouter的使用",
        "description": "使用场景",
        "date": "2021-04-22T00:00:00.000Z",
        "formattedDate": "2021年4月22日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.355,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-37：withRouter的使用",
          "date": "2021-04-22T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-36：编程式路由导航",
          "permalink": "/blog/React-36：编程式路由导航"
        },
        "nextItem": {
          "title": "React-38：BrowserRouter与HashRouter的区别",
          "permalink": "/blog/React-38：BrowserRouter与HashRouter的区别"
        }
      },
      "content": "## 使用场景\r\n* 使得一般组件能够像路由组件一样使用history等路由组件才具有的API\r\n\r\n## 第一步：引入\r\n* 在一般组件中引入withRouter\r\n![](https://img-blog.csdnimg.cn/img_convert/06ee2524f670c991dec0f7b44e8f2ab1.png)\r\n\r\n## 第二步：布置函数\r\n![](https://img-blog.csdnimg.cn/img_convert/9bc24aa7f7e68772d353540e954964bd.png)\r\n\r\n## 第三步：暴露封装好的组件\r\n![](https://img-blog.csdnimg.cn/img_convert/b7f28d7332e31e2b07a9d3830ec9d04b.png)"
    },
    {
      "id": "/React-38：BrowserRouter与HashRouter的区别",
      "metadata": {
        "permalink": "/blog/React-38：BrowserRouter与HashRouter的区别",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-38：BrowserRouter与HashRouter的区别.md",
        "source": "@site/blog\\React-38：BrowserRouter与HashRouter的区别.md",
        "title": "React-38：BrowserRouter与HashRouter的区别",
        "description": "区别一：底层原理不同",
        "date": "2021-04-22T00:00:00.000Z",
        "formattedDate": "2021年4月22日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.565,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-38：BrowserRouter与HashRouter的区别",
          "date": "2021-04-22T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-37：withRouter的使用",
          "permalink": "/blog/React-37：withRouter的使用"
        },
        "nextItem": {
          "title": "React-39：antd的基本使用",
          "permalink": "/blog/React-39：antd的基本使用"
        }
      },
      "content": "## 区别一：底层原理不同\r\n* BrowserRouter使用的是H5的history API，不兼容IE9及以下版本。\r\n* HashRouter使用的是URL的哈希值。\r\n\r\n## 区别二：URL表现形式不一样\r\n* BrowserRouter的路径中没有#\r\n* HashRouter的路径中包含#\r\n\r\n## 区别三：刷新后对路由state参数的影响\r\n* 刷新后BrowserRouter没有任何影响，因为state保存在history对象中。\r\n* HashRouter刷新后会导致路由state参数的丢失。"
    },
    {
      "id": "/React-39：antd的基本使用",
      "metadata": {
        "permalink": "/blog/React-39：antd的基本使用",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-39：antd的基本使用.md",
        "source": "@site/blog\\React-39：antd的基本使用.md",
        "title": "React-39：antd的基本使用",
        "description": "第一步：安装Ant Design",
        "date": "2021-04-22T00:00:00.000Z",
        "formattedDate": "2021年4月22日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.5,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-39：antd的基本使用",
          "date": "2021-04-22T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-38：BrowserRouter与HashRouter的区别",
          "permalink": "/blog/React-38：BrowserRouter与HashRouter的区别"
        },
        "nextItem": {
          "title": "剑指Offer——构建乘积数组（JS实现）",
          "permalink": "/blog/剑指Offer——构建乘积数组（JS实现）"
        }
      },
      "content": "## 第一步：安装Ant Design\r\n```\r\nnpm install and\r\n```\r\n## 第二步：找到想要使用的组件，并查看源代码\r\n![](https://img-blog.csdnimg.cn/img_convert/d91debe827109bd21781e0ae7597ab5c.png)\r\n\r\n## 第三步：引入相关组件，并使用提供的代码\r\n![](https://img-blog.csdnimg.cn/img_convert/a86d0b1c554028b9fd7f4bfcb6dcfbe0.png)\r\n\r\n* 如果想查看更多样式，可以通过点击API进行查看\r\n![](https://img-blog.csdnimg.cn/img_convert/03878cade666507348235d1b6f2c5709.png)\r\n\r\n### 引入图标示例\r\n* 官方代码\r\n![](https://img-blog.csdnimg.cn/img_convert/f982b034607e15e82fe7c646393c51be.png)\r\n\r\n* 我们的代码应该借鉴的地方\r\n![](https://img-blog.csdnimg.cn/img_convert/5b8b7299414079626457646a04f20747.png)"
    },
    {
      "id": "/剑指Offer——构建乘积数组（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——构建乘积数组（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——构建乘积数组（JS实现）.md",
        "source": "@site/blog\\剑指Offer——构建乘积数组（JS实现）.md",
        "title": "剑指Offer——构建乘积数组（JS实现）",
        "description": "题目描述",
        "date": "2021-04-22T00:00:00.000Z",
        "formattedDate": "2021年4月22日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 3.03,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——构建乘积数组（JS实现）",
          "date": "2021-04-22T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "React-39：antd的基本使用",
          "permalink": "/blog/React-39：antd的基本使用"
        },
        "nextItem": {
          "title": "React-31：Redirect的使用",
          "permalink": "/blog/React-31：Redirect的使用"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/d4488acbf205bd905aa62044e6fef281.png)\r\n\r\n## 解题思路\r\n* 遇到这道题，我首先使用使用双指针，左右遍历\r\n* 遇到第i个元素则停止遍历，然后进行求乘积\r\n* 但是结果超时\r\n* 最终通过对称遍历的方式成功解决问题\r\n\r\n## 解题代码一：暴力双指针（超时）\r\n```js\r\nvar constructArr = function (a) {\r\n    // 使用左右指针两边遍历的方法\r\n    const result = [];\r\n    let l = 0;\r\n    let r = a.length - 1;\r\n    let temp = 1;\r\n    let temp2 = 1;\r\n    for (let i = 0; i < a.length; i++) {\r\n\r\n        while (l !== i) {\r\n            temp = temp * a[l];\r\n            l++;\r\n        }\r\n        while (r !== i) {\r\n            temp2 = temp2 * a[r];\r\n            r--;\r\n        }\r\n        l = 0;\r\n        r = a.length - 1;\r\n        result.push(temp * temp2)\r\n        temp = 1;\r\n        temp2 = 1;\r\n    }\r\n    return result;\r\n};\r\n```\r\n## 超时原因\r\n* 涉及到多个循环，时间复杂度太高，必须改进时间复杂度。\r\n\r\n## 解题代码二：使用截取除i个元素之外的所有元素（超时）\r\n```js\r\nvar constructArr = function (a) {\r\n\r\n    const result = [];\r\n    let testarr = [];\r\n    let l = 0;\r\n    let r = a.length - 1;\r\n    let temp = 1;\r\n    let temp2 = 1;\r\n    for (let i = 0; i < a.length; i++) {\r\n        testarr.push(...a.slice(0,i),...a.slice(i+1))\r\n        result.push(testarr.reduce((pre,cur) => pre * cur,1));\r\n        testarr = [];\r\n    }\r\n    return result;\r\n};\r\n```\r\n## 超时原因\r\n* 还是时间复杂度太高。\r\n\r\n## 解题代码三：使用对称遍历（成功AC）\r\n```js\r\nvar constructArr = function (a) {\r\n\r\n    let right = [];\r\n    let left = [];\r\n    const result = [];\r\n    for (let i = 0; i < a.length; i++) {\r\n        if (i === 0) {\r\n            left[i] = a[0];\r\n            right[i] = a[a.length - 1];\r\n        } else {\r\n            left[i] = left[i-1] * a[i];\r\n            right[i] = right[i-1] * a[a.length-1-i];\r\n        }\r\n    }\r\n    \r\n    for (let i = 0; i < a.length;i++) {\r\n        if (i === a.length - 1) {\r\n            result.push(left[left.length-2]);\r\n            break;\r\n        }\r\n        if (i === 0) {\r\n            result.push(right[right.length-2])\r\n        } else {\r\n            result.push(right[right.length-1-i-1] * left[i-1])\r\n        }\r\n    }\r\n    return result;\r\n};\r\n```\r\n## 总结\r\n* 本题乍一看不难，大家也都容易想到一定的思路，但是难就难在时间复杂度的问题上\r\n* 只有比较低的时间复杂度才能够通过\r\n* 本题给我们的启示就是对称遍历\r\n* 这里的对称遍历刚开始是包好第i个元素的，并不是说将第i个元素去掉，这是我思维上的误区，就是一直想在刚开始就将第i个元素去掉，实际上通过对称遍历,存储左边的数组和存储右边的数组，刚开始都是全部遍历完的，之后再从结果中去取我们想要的结果。\r\n* 路漫漫其修远兮，吾将上下而求索。加油！"
    },
    {
      "id": "/React-31：Redirect的使用",
      "metadata": {
        "permalink": "/blog/React-31：Redirect的使用",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-31：Redirect的使用.md",
        "source": "@site/blog\\React-31：Redirect的使用.md",
        "title": "React-31：Redirect的使用",
        "description": "使用场景",
        "date": "2021-04-21T00:00:00.000Z",
        "formattedDate": "2021年4月21日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.13,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-31：Redirect的使用",
          "date": "2021-04-21T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——构建乘积数组（JS实现）",
          "permalink": "/blog/剑指Offer——构建乘积数组（JS实现）"
        },
        "nextItem": {
          "title": "React-31：嵌套路由的使用",
          "permalink": "/blog/React-31：嵌套路由的使用"
        }
      },
      "content": "## 使用场景\r\n* 当路由没有被匹配到的时候，则通过Redirect进行跳转\r\n![](https://img-blog.csdnimg.cn/img_convert/5b5864c3068cdd0eddab3d57b9ce7e00.png)"
    },
    {
      "id": "/React-31：嵌套路由的使用",
      "metadata": {
        "permalink": "/blog/React-31：嵌套路由的使用",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-31：嵌套路由的使用.md",
        "source": "@site/blog\\React-31：嵌套路由的使用.md",
        "title": "React-31：嵌套路由的使用",
        "description": "基本使用",
        "date": "2021-04-21T00:00:00.000Z",
        "formattedDate": "2021年4月21日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.1,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-31：嵌套路由的使用",
          "date": "2021-04-21T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-31：Redirect的使用",
          "permalink": "/blog/React-31：Redirect的使用"
        },
        "nextItem": {
          "title": "React-32：向路由组件传递params参数",
          "permalink": "/blog/React-32：向路由组件传递params参数"
        }
      },
      "content": "## 基本使用\r\n![](https://img-blog.csdnimg.cn/img_convert/fa145897c3157931dc74284a9558698c.png)\r\n\r\n## 第一级路由不能加严格模式\r\n![](https://img-blog.csdnimg.cn/img_convert/8043207b9d233110242872e5aa217e21.png)"
    },
    {
      "id": "/React-32：向路由组件传递params参数",
      "metadata": {
        "permalink": "/blog/React-32：向路由组件传递params参数",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-32：向路由组件传递params参数.md",
        "source": "@site/blog\\React-32：向路由组件传递params参数.md",
        "title": "React-32：向路由组件传递params参数",
        "description": "通过模板字符串的形式传递参数",
        "date": "2021-04-21T00:00:00.000Z",
        "formattedDate": "2021年4月21日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.195,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-32：向路由组件传递params参数",
          "date": "2021-04-21T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-31：嵌套路由的使用",
          "permalink": "/blog/React-31：嵌套路由的使用"
        },
        "nextItem": {
          "title": "React-33：向路由组件传递search参数",
          "permalink": "/blog/React-33：向路由组件传递search参数"
        }
      },
      "content": "## 通过模板字符串的形式传递参数\r\n![](https://img-blog.csdnimg.cn/img_convert/9fc88fec954e8236dc1617cc1006ac02.png)\r\n\r\n## 声明接收\r\n![](https://img-blog.csdnimg.cn/img_convert/34095cc8ea99bd844116a91a4c2362ed.png)\r\n\r\n## 解构收到的参数\r\n![](https://img-blog.csdnimg.cn/img_convert/0caaf77c7756027dbfde915eeaac2d29.png)\r\n\r\n## 解构后即可使用"
    },
    {
      "id": "/React-33：向路由组件传递search参数",
      "metadata": {
        "permalink": "/blog/React-33：向路由组件传递search参数",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-33：向路由组件传递search参数.md",
        "source": "@site/blog\\React-33：向路由组件传递search参数.md",
        "title": "React-33：向路由组件传递search参数",
        "description": "Link的形式",
        "date": "2021-04-21T00:00:00.000Z",
        "formattedDate": "2021年4月21日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.255,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-33：向路由组件传递search参数",
          "date": "2021-04-21T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-32：向路由组件传递params参数",
          "permalink": "/blog/React-32：向路由组件传递params参数"
        },
        "nextItem": {
          "title": "React-34：向路由组件传递state参数",
          "permalink": "/blog/React-34：向路由组件传递state参数"
        }
      },
      "content": "## Link的形式\r\n![](https://img-blog.csdnimg.cn/img_convert/94eaa642fc1ba2f95ffce73b7de6d6c9.png)\r\n\r\n## 路由无需声明，自动接收\r\n![](https://img-blog.csdnimg.cn/img_convert/bd55e951103967479d9e816907803f4f.png)\r\n\r\n## 通过querystring库将查询字符转换为对象\r\n![](https://img-blog.csdnimg.cn/img_convert/5fa565bf9d5e000433681e0f9ec5e338.png)\r\n\r\n## 解构赋值，并将查询字符的问号去掉\r\n![](https://img-blog.csdnimg.cn/img_convert/100df162c3301642c48b858f790f2df7.png)"
    },
    {
      "id": "/React-34：向路由组件传递state参数",
      "metadata": {
        "permalink": "/blog/React-34：向路由组件传递state参数",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-34：向路由组件传递state参数.md",
        "source": "@site/blog\\React-34：向路由组件传递state参数.md",
        "title": "React-34：向路由组件传递state参数",
        "description": "通过state参数传递的特点",
        "date": "2021-04-21T00:00:00.000Z",
        "formattedDate": "2021年4月21日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.215,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-34：向路由组件传递state参数",
          "date": "2021-04-21T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-33：向路由组件传递search参数",
          "permalink": "/blog/React-33：向路由组件传递search参数"
        },
        "nextItem": {
          "title": "React-35：路由的push与replace",
          "permalink": "/blog/React-35：路由的push与replace"
        }
      },
      "content": "## 通过state参数传递的特点\r\n* 通过state参数传递不会显示在地址栏中。\r\n\r\n## Link形式\r\n![](https://img-blog.csdnimg.cn/img_convert/27f12e682871f90c358bcb132a7e7aac.png)\r\n\r\n## 路由形式\r\n![](https://img-blog.csdnimg.cn/img_convert/3d76c46b685642b49b9657ed711cd469.png)\r\n\r\n## 接收形式\r\n![](https://img-blog.csdnimg.cn/img_convert/7ac5c59af976b237bfb0206f304e0730.png)"
    },
    {
      "id": "/React-35：路由的push与replace",
      "metadata": {
        "permalink": "/blog/React-35：路由的push与replace",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-35：路由的push与replace.md",
        "source": "@site/blog\\React-35：路由的push与replace.md",
        "title": "React-35：路由的push与replace",
        "description": "push模式是栈的常规模式",
        "date": "2021-04-21T00:00:00.000Z",
        "formattedDate": "2021年4月21日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.225,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-35：路由的push与replace",
          "date": "2021-04-21T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-34：向路由组件传递state参数",
          "permalink": "/blog/React-34：向路由组件传递state参数"
        },
        "nextItem": {
          "title": "剑指Offer——连续子数组的最大和（JS实现）",
          "permalink": "/blog/剑指Offer——连续子数组的最大和（JS实现）"
        }
      },
      "content": "## push模式是栈的常规模式\r\n* 从news到message，然后message返回到news\r\n\r\n## replace模式是替换模式，会替换掉栈顶的路由\r\n* 开启方法\r\n![](https://img-blog.csdnimg.cn/img_convert/5fc5f345626e311b3c88c5035ca1bb6d.png)"
    },
    {
      "id": "/剑指Offer——连续子数组的最大和（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——连续子数组的最大和（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——连续子数组的最大和（JS实现）.md",
        "source": "@site/blog\\剑指Offer——连续子数组的最大和（JS实现）.md",
        "title": "剑指Offer——连续子数组的最大和（JS实现）",
        "description": "题目描述",
        "date": "2021-04-21T00:00:00.000Z",
        "formattedDate": "2021年4月21日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.425,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——连续子数组的最大和（JS实现）",
          "date": "2021-04-21T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "React-35：路由的push与replace",
          "permalink": "/blog/React-35：路由的push与replace"
        },
        "nextItem": {
          "title": "React-28：使用Switch匹配路由",
          "permalink": "/blog/React-28：使用Switch匹配路由"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/ada93af42de5ff6fa643a9c5959c3462.png)\r\n\r\n## 解题思路\r\n* 本题的思想在于想到动态规划\r\n* 首先定义一个和nums同纬度的数组\r\n* dp数组的第一个元素和nums的第一个元素的值相同\r\n* 这里的dp[i]的含义是解题关键：代表着当前元素在内的所有前面的子数组的和的最大值\r\n* 从nums的第二个元素开始遍历，如果dp[i-1]>0,dp[i]则等于dp[i-1]+nums[i],反之则等于nums[i]\r\n\r\n## 解题代码\r\n```js\r\nvar maxSubArray = function (nums) {\r\n    // 本题核心是：动态规划的思想\r\n    // dp[i]：代表着第i个元素之前的所有子数组的和的最大值\r\n    // 当dp[i-1] 大于0的时候，加上i此时的值，才是包含第i个元素的所有子数组的最大值\r\n    let dp = new Array(nums.length);\r\n    dp[0] = nums[0];\r\n    for (let i = 1; i < nums.length; i++) {\r\n        dp[i] = dp[i-1] > 0 ? dp[i-1] + nums[i] : nums[i];\r\n    }\r\n\r\n    dp.sort((num1,num2) => num2 - num1);\r\n    return dp[0];\r\n\r\n};\r\n```\r\n## 总结\r\n* 本题关键在于想到动态规划的思想\r\n* 截止到当前元素之前的所有子数组的最大和为dp[i-1]和nums[i]的关系"
    },
    {
      "id": "/React-28：使用Switch匹配路由",
      "metadata": {
        "permalink": "/blog/React-28：使用Switch匹配路由",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-28：使用Switch匹配路由.md",
        "source": "@site/blog\\React-28：使用Switch匹配路由.md",
        "title": "React-28：使用Switch匹配路由",
        "description": "解构Switch",
        "date": "2021-04-20T00:00:00.000Z",
        "formattedDate": "2021年4月20日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.15,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-28：使用Switch匹配路由",
          "date": "2021-04-20T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——连续子数组的最大和（JS实现）",
          "permalink": "/blog/剑指Offer——连续子数组的最大和（JS实现）"
        },
        "nextItem": {
          "title": "React-29：解决多级路由样式丢失的问题",
          "permalink": "/blog/React-29：解决多级路由样式丢失的问题"
        }
      },
      "content": "## 解构Switch\r\n![](https://img-blog.csdnimg.cn/img_convert/346fff52f7bf849259e546ab094e690e.png)\r\n\r\n## 使用Switch包裹的路由，匹配到即停止匹配后面的同名路由\r\n![](https://img-blog.csdnimg.cn/img_convert/f70f5e5703b416ba2e3860ab100a340c.png)"
    },
    {
      "id": "/React-29：解决多级路由样式丢失的问题",
      "metadata": {
        "permalink": "/blog/React-29：解决多级路由样式丢失的问题",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-29：解决多级路由样式丢失的问题.md",
        "source": "@site/blog\\React-29：解决多级路由样式丢失的问题.md",
        "title": "React-29：解决多级路由样式丢失的问题",
        "description": "问题描述",
        "date": "2021-04-20T00:00:00.000Z",
        "formattedDate": "2021年4月20日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.39,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-29：解决多级路由样式丢失的问题",
          "date": "2021-04-20T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-28：使用Switch匹配路由",
          "permalink": "/blog/React-28：使用Switch匹配路由"
        },
        "nextItem": {
          "title": "React-30：路由的模糊匹配和严格匹配",
          "permalink": "/blog/React-30：路由的模糊匹配和严格匹配"
        }
      },
      "content": "## 问题描述\r\n`\r\n给React加上多级路由之后，刷新页面有时候会造成样式的丢失。\r\n`\r\n![](https://img-blog.csdnimg.cn/img_convert/b53312eb1b167907ec8e49d76c890008.png)\r\n\r\n## 解决方法一\r\n* 去掉相对路径的点\r\n![](https://img-blog.csdnimg.cn/img_convert/4c22ae5c70b04c616c96b935197d5848.png)\r\n\r\n## 解决方法二\r\n* 在样式文件的路径前面加上%PUBLIC_URL%\r\n![](https://img-blog.csdnimg.cn/img_convert/ab5d679148d452857e2c40fd406886f0.png)\r\n\r\n## 解决方法三\r\n* 将BrowserRouter改为HashRouter\r\n![](https://img-blog.csdnimg.cn/img_convert/82a5df58cbb222cdc536a61079962c75.png)"
    },
    {
      "id": "/React-30：路由的模糊匹配和严格匹配",
      "metadata": {
        "permalink": "/blog/React-30：路由的模糊匹配和严格匹配",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-30：路由的模糊匹配和严格匹配.md",
        "source": "@site/blog\\React-30：路由的模糊匹配和严格匹配.md",
        "title": "React-30：路由的模糊匹配和严格匹配",
        "description": "模糊匹配",
        "date": "2021-04-20T00:00:00.000Z",
        "formattedDate": "2021年4月20日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.065,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-30：路由的模糊匹配和严格匹配",
          "date": "2021-04-20T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-29：解决多级路由样式丢失的问题",
          "permalink": "/blog/React-29：解决多级路由样式丢失的问题"
        },
        "nextItem": {
          "title": "剑指Offer——栈的压入、弹出序列（JS实现）",
          "permalink": "/blog/剑指Offer——栈的压入、弹出序列（JS实现）"
        }
      },
      "content": "## 模糊匹配\r\n![](https://img-blog.csdnimg.cn/img_convert/c294da6d0ec593591bdb77b3f03473d4.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/4ff32a838ae52e7da03c98ce4824a427.png)\r\n\r\n## 严格匹配\r\n![](https://img-blog.csdnimg.cn/img_convert/cb199ce00e26e24431de302abfdc86b3.png)"
    },
    {
      "id": "/剑指Offer——栈的压入、弹出序列（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——栈的压入、弹出序列（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——栈的压入、弹出序列（JS实现）.md",
        "source": "@site/blog\\剑指Offer——栈的压入、弹出序列（JS实现）.md",
        "title": "剑指Offer——栈的压入、弹出序列（JS实现）",
        "description": "题目描述",
        "date": "2021-04-20T00:00:00.000Z",
        "formattedDate": "2021年4月20日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.58,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——栈的压入、弹出序列（JS实现）",
          "date": "2021-04-20T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "React-30：路由的模糊匹配和严格匹配",
          "permalink": "/blog/React-30：路由的模糊匹配和严格匹配"
        },
        "nextItem": {
          "title": "React-24：React中使用fetch发送请求的两种方式",
          "permalink": "/blog/React-24：React中使用fetch发送请求的两种方式"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/0b44be93fbf8e93686649f1fbeb39b44.png)\r\n\r\n## 解题思路\r\n* 本题的思想在于想到模拟栈\r\n* 我们首先定义一个数组用来模拟栈\r\n* 从pushed数组的第一个元素开始进行入栈，如果该元素在popped数组的第一个元素，我们就将入栈的元素出栈，然后继续判断栈顶元素是否和popped数组指针指向的元素相同，相同则出栈。\r\n* 如果最后模拟栈的元素个数为零，则说明是栈的压入和弹出序列，反之则不是。\r\n\r\n## 解题代码\r\n```js\r\nvar validateStackSequences = function (pushed, popped) {\r\n\r\n    // 本题使用模拟栈的写法\r\n    const stack = [];\r\n    // 定义一个指向popped元素的指针\r\n    let pointer = 0;\r\n\r\n    for (let i = 0; i < pushed.length; i++) {\r\n        stack.push(pushed[i]);\r\n        if (popped[pointer] === pushed[i]) {\r\n            stack.pop();\r\n            pointer++;\r\n        }\r\n        if (pointer === popped.length) break;\r\n        while (stack[stack.length-1] === popped[pointer]) {\r\n            stack.pop();\r\n            pointer++;\r\n            if (pointer === popped.length) return true;\r\n        }\r\n    }\r\n    \r\n    while (stack.length !== 0) {\r\n        if(stack[stack.length - 1] === popped[pointer]) {\r\n            stack.pop();\r\n            pointer++;\r\n        } else {\r\n            return false;\r\n        }  \r\n    }\r\n\r\n    return true;\r\n};\r\n```\r\n## 总结\r\n* 本题属于栈类型的问题。\r\n* 核心思路在于想到模拟栈的压入和弹出去对比popped的指针指向的元素，最后通过判断栈是否为空，来判断是否属于栈的压入和弹出。"
    },
    {
      "id": "/React-24：React中使用fetch发送请求的两种方式",
      "metadata": {
        "permalink": "/blog/React-24：React中使用fetch发送请求的两种方式",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-24：React中使用fetch发送请求的两种方式.md",
        "source": "@site/blog\\React-24：React中使用fetch发送请求的两种方式.md",
        "title": "React-24：React中使用fetch发送请求的两种方式",
        "description": "方式1：使用promise的方式",
        "date": "2021-04-19T00:00:00.000Z",
        "formattedDate": "2021年4月19日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.54,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-24：React中使用fetch发送请求的两种方式",
          "date": "2021-04-19T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——栈的压入、弹出序列（JS实现）",
          "permalink": "/blog/剑指Offer——栈的压入、弹出序列（JS实现）"
        },
        "nextItem": {
          "title": "React-25：React中路由的基本使用",
          "permalink": "/blog/React-25：React中路由的基本使用"
        }
      },
      "content": "## 方式1：使用promise的方式\r\n```js\r\nfetch(`http://localhost:3000/api1/search/users2?q=${this.input1.value}`).then(\r\n            response => {\r\n                console.log('成功联系到服务器');\r\n                return response.json();\r\n            },\r\n        ).then(\r\n            response => {\r\n                console.log(\"成功获取到数据\", response);\r\n            },\r\n        ).catch(\r\n            error => {\r\n                console.log(\"请求出错\",error);\r\n            }\r\n        )\r\n```\r\n## 方式2：使用await async\r\n```js\r\ntry {\r\n            const response = await fetch(`http://localhost:3000/api1/search/users2?q=${this.input1.value}`);\r\n            const data = await response.json();\r\n            PubSub.publish('Item', { isLoading: false, isFirst: false,users: data.items });\r\n            console.log(data);\r\n        } catch (error) {\r\n            PubSub.publish('Item', { isLoading:false,err:error.message });\r\n\r\n        }\r\n```\r\n* 别忘了在函数的开头加上async\r\n![](https://img-blog.csdnimg.cn/img_convert/7a8aa43b55f5f5574d7ae0b02a880828.png)"
    },
    {
      "id": "/React-25：React中路由的基本使用",
      "metadata": {
        "permalink": "/blog/React-25：React中路由的基本使用",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-25：React中路由的基本使用.md",
        "source": "@site/blog\\React-25：React中路由的基本使用.md",
        "title": "React-25：React中路由的基本使用",
        "description": "1：安装react-router-dom",
        "date": "2021-04-19T00:00:00.000Z",
        "formattedDate": "2021年4月19日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.405,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-25：React中路由的基本使用",
          "date": "2021-04-19T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-24：React中使用fetch发送请求的两种方式",
          "permalink": "/blog/React-24：React中使用fetch发送请求的两种方式"
        },
        "nextItem": {
          "title": "React-26：React中路由组件和一般组件的区别",
          "permalink": "/blog/React-26：React中路由组件和一般组件的区别"
        }
      },
      "content": "## 1：安装react-router-dom\r\n```\r\nnpm install react-router-dom\r\n```\r\n## 2：引入Link,作为跳转指向\r\n![](https://img-blog.csdnimg.cn/img_convert/caa5714fefe10473a289ec8b0006550f.png)\r\n* 这里往往用于导航\r\n\r\n## 3：引入Route\r\n* 让React知道跳转到哪个组件\r\n![](https://img-blog.csdnimg.cn/img_convert/66f8ed34147b34ac9d8871b58819c4de.png)\r\n\r\n## 4：Route和Link必须在一个路由器下，可以将整个App包含在一个路由器下\r\n![](https://img-blog.csdnimg.cn/img_convert/de8437b3ff31b46b67c2662ea7950627.png)\r\n\r\n## 总结\r\n![](https://img-blog.csdnimg.cn/img_convert/1d57372e42eda82627803ff80e59a25d.png)"
    },
    {
      "id": "/React-26：React中路由组件和一般组件的区别",
      "metadata": {
        "permalink": "/blog/React-26：React中路由组件和一般组件的区别",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-26：React中路由组件和一般组件的区别.md",
        "source": "@site/blog\\React-26：React中路由组件和一般组件的区别.md",
        "title": "React-26：React中路由组件和一般组件的区别",
        "description": "区别一",
        "date": "2021-04-19T00:00:00.000Z",
        "formattedDate": "2021年4月19日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.275,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-26：React中路由组件和一般组件的区别",
          "date": "2021-04-19T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-25：React中路由的基本使用",
          "permalink": "/blog/React-25：React中路由的基本使用"
        },
        "nextItem": {
          "title": "React-27：NavLink的基本使用",
          "permalink": "/blog/React-27：NavLink的基本使用"
        }
      },
      "content": "## 区别一\r\n* 一般组件写在components文件夹下,路由组件写在pages文件夹下\r\n![](https://img-blog.csdnimg.cn/img_convert/40069eca644f41bd356d1971409980a4.png)\r\n\r\n## 区别二\r\n* 路由组件会收到路由传递过来的props，而普通组件则不会\r\n![](https://img-blog.csdnimg.cn/img_convert/6beda444426fe6464e019af432ffddf6.png)"
    },
    {
      "id": "/React-27：NavLink的基本使用",
      "metadata": {
        "permalink": "/blog/React-27：NavLink的基本使用",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-27：NavLink的基本使用.md",
        "source": "@site/blog\\React-27：NavLink的基本使用.md",
        "title": "React-27：NavLink的基本使用",
        "description": "通过NavLink可以给Link添加类名，从而实现修改样式",
        "date": "2021-04-19T00:00:00.000Z",
        "formattedDate": "2021年4月19日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.565,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-27：NavLink的基本使用",
          "date": "2021-04-19T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-26：React中路由组件和一般组件的区别",
          "permalink": "/blog/React-26：React中路由组件和一般组件的区别"
        },
        "nextItem": {
          "title": "剑指Offer——股票的最大利润（JS实现）",
          "permalink": "/blog/剑指Offer——股票的最大利润（JS实现）"
        }
      },
      "content": "## 通过NavLink可以给Link添加类名，从而实现修改样式\r\n![](https://img-blog.csdnimg.cn/img_convert/1d8998ddbf2b7d0a189e08cf7e913105.png)\r\n\r\n## 封装NavLink\r\n* 自定义组件MyNavLink\r\n* 引入自定义组件\r\n```\r\nimport MyNavLink from './components/MyNavLink';\r\n```\r\n* 向自定义组件传to属性，值为路由信息\r\n![](https://img-blog.csdnimg.cn/img_convert/cda9b2f407fe0915185fab147dbe3288.png)\r\n\r\n* 在自定义组件中，返回NavLink\r\n![](https://img-blog.csdnimg.cn/img_convert/ac545fed84fac203fb53e46832f429dc.png)\r\n\r\n* 使用拓展运算符解构对象是关键，因为上面的MyNavLink中间的值作为children属性传递给了封装的NavLink"
    },
    {
      "id": "/剑指Offer——股票的最大利润（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——股票的最大利润（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——股票的最大利润（JS实现）.md",
        "source": "@site/blog\\剑指Offer——股票的最大利润（JS实现）.md",
        "title": "剑指Offer——股票的最大利润（JS实现）",
        "description": "题目描述",
        "date": "2021-04-19T00:00:00.000Z",
        "formattedDate": "2021年4月19日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.29,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——股票的最大利润（JS实现）",
          "date": "2021-04-19T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "React-27：NavLink的基本使用",
          "permalink": "/blog/React-27：NavLink的基本使用"
        },
        "nextItem": {
          "title": "React-23：React兄弟组件直接通信的方法（消息订阅-发布机制）",
          "permalink": "/blog/React-23：React兄弟组件直接通信的方法（消息订阅-发布机制）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/dc0317bb42e5f662a2ba8f1235c4cce8.png)\r\n\r\n## 解题思路\r\n* 首先定义一个数组用来存储当天之后股票的价格-今天的价格的最大值\r\n* 遍历每一个元素的同时，取出剩余元素\r\n* 使用JS自带的sort方法，将剩余元素的最大值取出来，然后存到结果数组中\r\n* 使用sort方法将结果数组中的最大值进行返回即可\r\n\r\n## 解题代码\r\n```js\r\nvar maxProfit = function (prices) {\r\n    if (prices.length === 0) return 0;\r\n    const result = [];\r\n    for (let i = 0; i < prices.length; i++) {\r\n        const remain = prices.slice(i + 1);\r\n        const remainMax = remain.sort((num1,num2) => num2 - num1)[0];\r\n        if (remainMax === undefined) {\r\n            result.push(0);\r\n        } else {\r\n            result.push(remainMax - prices[i]);\r\n        }\r\n        \r\n    };\r\n    result.sort((num1,num2) => num2 - num1);\r\n\r\n    return result[0];\r\n\r\n};\r\n```\r\n## 总结\r\n* 本题属于较为简单动态规划问题\r\n* 最容易出错的地方在于超时了\r\n* 本题给出的不是最优解，只是作者的个人思路\r\n* 本题可以通过在遍历每个元素的时候，不断更新最大值和最小值的方法，来求解"
    },
    {
      "id": "/React-23：React兄弟组件直接通信的方法（消息订阅-发布机制）",
      "metadata": {
        "permalink": "/blog/React-23：React兄弟组件直接通信的方法（消息订阅-发布机制）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-23：React兄弟组件直接通信的方法（消息订阅-发布机制）.md",
        "source": "@site/blog\\React-23：React兄弟组件直接通信的方法（消息订阅-发布机制）.md",
        "title": "React-23：React兄弟组件直接通信的方法（消息订阅-发布机制）",
        "description": "1：安装pubsub-js",
        "date": "2021-04-18T00:00:00.000Z",
        "formattedDate": "2021年4月18日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.175,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-23：React兄弟组件直接通信的方法（消息订阅-发布机制）",
          "date": "2021-04-18T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——股票的最大利润（JS实现）",
          "permalink": "/blog/剑指Offer——股票的最大利润（JS实现）"
        },
        "nextItem": {
          "title": "剑指Offer——两个链表的第一个公共节点（JS实现）",
          "permalink": "/blog/剑指Offer——两个链表的第一个公共节点（JS实现）"
        }
      },
      "content": "## 1：安装pubsub-js\r\n```\r\nnpm install pubsub-js\r\n```\r\n## 2：引入pubsub库\r\n```\r\nimport PubSub from 'pubsub-js';\r\n```\r\n## 3：发布消息\r\n![](https://img-blog.csdnimg.cn/img_convert/108396af3d6e6ade6e2298aaf2488d55.png)\r\n\r\n## 4：订阅消息\r\n![](https://img-blog.csdnimg.cn/img_convert/b3976b55ae600816fbc8b87f95d84092.png)"
    },
    {
      "id": "/剑指Offer——两个链表的第一个公共节点（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——两个链表的第一个公共节点（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——两个链表的第一个公共节点（JS实现）.md",
        "source": "@site/blog\\剑指Offer——两个链表的第一个公共节点（JS实现）.md",
        "title": "剑指Offer——两个链表的第一个公共节点（JS实现）",
        "description": "题目描述",
        "date": "2021-04-18T00:00:00.000Z",
        "formattedDate": "2021年4月18日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.295,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——两个链表的第一个公共节点（JS实现）",
          "date": "2021-04-18T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "React-23：React兄弟组件直接通信的方法（消息订阅-发布机制）",
          "permalink": "/blog/React-23：React兄弟组件直接通信的方法（消息订阅-发布机制）"
        },
        "nextItem": {
          "title": "剑指Offer——从上到下打印二叉树（JS实现）",
          "permalink": "/blog/剑指Offer——从上到下打印二叉树（JS实现）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/33292c4242dcc20a1622ccb475a9563f.png)\r\n\r\n## 解题思路\r\n* 首先遍历两个链表。\r\n* 在遍历的时候，使用临时节点去遍历，而不要使用系统给的头节点，因为如果使用系统给的头节点，遍历到最后，不好找到头节点，但是系统却要我们返回头节点。\r\n* 使用两个集合分别用来存储每一个链表。\r\n* 然后遍历其中一个链表的元素，如果该元素同时出现在第二个链表中，将该元素返回即可。\r\n\r\n## 解题代码\r\n```js\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let nodeA = headA;\r\n    let nodeB = headB;\r\n    const setA = new Set();\r\n    const setB = new Set();\r\n    while (nodeA) {\r\n        setA.add(nodeA);\r\n        nodeA = nodeA.next;\r\n    }\r\n    while (nodeB) {\r\n        setB.add(nodeB);\r\n        nodeB = nodeB.next;\r\n    }\r\n    for (let v of setA) {\r\n        if (setB.has(v)) {\r\n            return v;\r\n        }\r\n    }\r\n};\r\n```\r\n## 总结\r\n* 本题属于较为简单的循环遍历即可解决的问题。\r\n* 本题的关键在于判断一个元素是否在另一个链表中，所以可以通过循环+集合的方式来解决。"
    },
    {
      "id": "/剑指Offer——从上到下打印二叉树（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——从上到下打印二叉树（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——从上到下打印二叉树（JS实现）.md",
        "source": "@site/blog\\剑指Offer——从上到下打印二叉树（JS实现）.md",
        "title": "剑指Offer——从上到下打印二叉树（JS实现）",
        "description": "题目描述",
        "date": "2021-04-18T00:00:00.000Z",
        "formattedDate": "2021年4月18日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.835,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——从上到下打印二叉树（JS实现）",
          "date": "2021-04-18T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——两个链表的第一个公共节点（JS实现）",
          "permalink": "/blog/剑指Offer——两个链表的第一个公共节点（JS实现）"
        },
        "nextItem": {
          "title": "剑指Offer——调整数组顺序使奇数位于偶数前面（JS实现）",
          "permalink": "/blog/剑指Offer——调整数组顺序使奇数位于偶数前面（JS实现）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/c61588b43272861e11906e0a5ce8c202.png)\r\n\r\n## 解题思路\r\n* 使用队列的思想来进行层次遍历\r\n* 数组队列存储当前节点的左右指针，然后将队头清除，知道队列中的所有元素都被清空。\r\n\r\n## 解题代码\r\n```js\r\nvar levelOrder = function (root) {\r\n    if (root === null) return [];\r\n    const result = [];\r\n    const pointer = [root];\r\n    while (pointer.length !== 0) {\r\n\r\n        result.push(pointer[0].val);\r\n        if (pointer[0].left !== null) {\r\n            pointer.push(pointer[0].left);\r\n        }\r\n        if (pointer[0].right !== null) {\r\n            pointer.push(pointer[0].right);\r\n        }\r\n        pointer.shift();\r\n    }\r\n    return result;\r\n};\r\n```\r\n## 总结\r\n* 本题属于二叉树的层次遍历问题\r\n* 核心点在于使用队列来存储当前节点的左右子节点。\r\n* 队列的判断条件是队头元素是否存在。"
    },
    {
      "id": "/剑指Offer——调整数组顺序使奇数位于偶数前面（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——调整数组顺序使奇数位于偶数前面（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——调整数组顺序使奇数位于偶数前面（JS实现）.md",
        "source": "@site/blog\\剑指Offer——调整数组顺序使奇数位于偶数前面（JS实现）.md",
        "title": "剑指Offer——调整数组顺序使奇数位于偶数前面（JS实现）",
        "description": "题目描述",
        "date": "2021-04-18T00:00:00.000Z",
        "formattedDate": "2021年4月18日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.22,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——调整数组顺序使奇数位于偶数前面（JS实现）",
          "date": "2021-04-18T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——从上到下打印二叉树（JS实现）",
          "permalink": "/blog/剑指Offer——从上到下打印二叉树（JS实现）"
        },
        "nextItem": {
          "title": "JS中的for in循环中的变量指的是什么？",
          "permalink": "/blog/JS中的for in循环中的变量指的是什么？"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/a0b5bbb4018d3a98c263c11bcd032727.png)\r\n\r\n## 解题思路\r\n* 使用两个数组分别用来存储奇数和偶数\r\n* 使用for循环遍历输入数组的每一个元素\r\n* 当目标元素对2取余为0，说明该元素为偶数，偶数则加入偶数数组，反之则加入奇数数组\r\n* 最后使用ES6中的拓展运算符将两个数组合并为一个进行返回，即是最后的答案\r\n\r\n## 解题代码\r\n```js\r\nvar exchange = function(nums) {\r\n    const arr1 = [];\r\n    const arr2 = [];\r\n    for (let v of nums) {\r\n        if (v % 2 === 0) {\r\n            arr2.push(v);\r\n        } else {\r\n            arr1.push(v);\r\n        }\r\n    };\r\n    return [...arr1,...arr2];\r\n};\r\n```\r\n## 总结\r\n* 本题属于较为简单的循环遍历即可解决的问题。\r\n* 本题的关键在于想到使用两个数组分别用来存储奇数和偶数。\r\n* 知道如何把奇数和偶数判断出来。\r\n* 知道使用拓展字符的方法合并数组，是我们要学习的地方。"
    },
    {
      "id": "/JS中的for in循环中的变量指的是什么？",
      "metadata": {
        "permalink": "/blog/JS中的for in循环中的变量指的是什么？",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/JS中的for in循环中的变量指的是什么？.md",
        "source": "@site/blog\\JS中的for in循环中的变量指的是什么？.md",
        "title": "JS中的for in循环中的变量指的是什么？",
        "description": "很多人以为这里的i是下标，其实不是，而是下标的字符串形式？",
        "date": "2021-04-17T00:00:00.000Z",
        "formattedDate": "2021年4月17日",
        "tags": [
          {
            "label": "JavaScript常用API",
            "permalink": "/blog/tags/java-script常用-api"
          }
        ],
        "readingTime": 0.14,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "JS中的for in循环中的变量指的是什么？",
          "date": "2021-04-17T00:00:00.000Z",
          "categories": "JavaScript常用API",
          "tags": [
            "JavaScript常用API"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——调整数组顺序使奇数位于偶数前面（JS实现）",
          "permalink": "/blog/剑指Offer——调整数组顺序使奇数位于偶数前面（JS实现）"
        },
        "nextItem": {
          "title": "剑指Offer——丑数（JS实现）",
          "permalink": "/blog/剑指Offer——丑数（JS实现）"
        }
      },
      "content": "## 很多人以为这里的i是下标，其实不是，而是下标的字符串形式？\r\n![](https://img-blog.csdnimg.cn/img_convert/f68fd1315796c4a6415f12e10eb2f6ec.png)"
    },
    {
      "id": "/剑指Offer——丑数（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——丑数（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——丑数（JS实现）.md",
        "source": "@site/blog\\剑指Offer——丑数（JS实现）.md",
        "title": "剑指Offer——丑数（JS实现）",
        "description": "题目描述",
        "date": "2021-04-17T00:00:00.000Z",
        "formattedDate": "2021年4月17日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.97,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——丑数（JS实现）",
          "date": "2021-04-17T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "JS中的for in循环中的变量指的是什么？",
          "permalink": "/blog/JS中的for in循环中的变量指的是什么？"
        },
        "nextItem": {
          "title": "剑指Offer——二叉搜索树与双向链表（JS实现）",
          "permalink": "/blog/剑指Offer——二叉搜索树与双向链表（JS实现）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/f8674d5e6aef8545f243de2003b59b1e.png)\r\n\r\n## 解题思路\r\n* 一个丑数一定是其前面的丑数中的某个丑数*2，*3，*5的结果\r\n* 第一个丑数是1\r\n* 定义三个指向丑数的指针，初始位置为0\r\n* 如果一个丑数是哪个指针乘积的结果，那么这个丑数指针向后移，因为这个丑数乘以对应指针也不可能达到最新的丑数的大小。\r\n\r\n## 实现代码\r\n```js\r\nvar nthUglyNumber = function(n) {\r\n    const arr = [1];\r\n    if (n === 1) return arr[0];\r\n    let ptr2 = ptr3 = ptr5 = 0;\r\n    for (let i = 1; i <= Number.MAX_VALUE;i++) {\r\n        arr.push(Math.min(arr[ptr2] * 2,arr[ptr3] * 3,arr[ptr5] * 5));\r\n        if (arr[arr.length-1] === arr[ptr2] * 2) {\r\n            ptr2++;\r\n        }\r\n        if (arr[arr.length-1] === arr[ptr3] * 3) {\r\n            ptr3++;\r\n        }\r\n        if (arr[arr.length-1] === arr[ptr5] * 5) {\r\n            ptr5++;\r\n        }\r\n        if (arr.length === n) break;\r\n    }\r\n    return arr[arr.length-1];\r\n};\r\n```"
    },
    {
      "id": "/剑指Offer——二叉搜索树与双向链表（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——二叉搜索树与双向链表（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——二叉搜索树与双向链表（JS实现）.md",
        "source": "@site/blog\\剑指Offer——二叉搜索树与双向链表（JS实现）.md",
        "title": "剑指Offer——二叉搜索树与双向链表（JS实现）",
        "description": "题目描述",
        "date": "2021-04-17T00:00:00.000Z",
        "formattedDate": "2021年4月17日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.67,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——二叉搜索树与双向链表（JS实现）",
          "date": "2021-04-17T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——丑数（JS实现）",
          "permalink": "/blog/剑指Offer——丑数（JS实现）"
        },
        "nextItem": {
          "title": "剑指Offer——圆圈中最后剩下的数字（JS实现）",
          "permalink": "/blog/剑指Offer——圆圈中最后剩下的数字（JS实现）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/75fb0e7a16f1c5a91bef85b2918cdfe1.png)\r\n\r\n## 解题思路\r\n* 使用二叉树的中序遍历，将每一个节点存到一个数组中\r\n* 使用for循环改变每个节点的left，right指针域\r\n\r\n## 实现代码\r\n```js\r\nvar treeToDoublyList = function (root) {\r\n    const temp = [];\r\n    function dfs(root) {\r\n        if (!root) return null;\r\n\r\n        dfs(root.left);\r\n        temp.push(root)\r\n        dfs(root.right);\r\n        return null;\r\n    }\r\n    dfs(root);\r\n    const len = temp.length;\r\n    for (let i = 0; i < temp.length; i++) {\r\n        if (i !== 0) {\r\n            temp[i].left = temp[i - 1];\r\n        } else {\r\n            temp[i].left = temp[len-1];\r\n        }\r\n        if (i !== len - 1) {\r\n            temp[i].right = temp[i + 1];\r\n        } else {\r\n            temp[i].right = temp[0];\r\n        }\r\n    }\r\n    return temp[0];\r\n};\r\n```"
    },
    {
      "id": "/剑指Offer——圆圈中最后剩下的数字（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——圆圈中最后剩下的数字（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——圆圈中最后剩下的数字（JS实现）.md",
        "source": "@site/blog\\剑指Offer——圆圈中最后剩下的数字（JS实现）.md",
        "title": "剑指Offer——圆圈中最后剩下的数字（JS实现）",
        "description": "题目描述",
        "date": "2021-04-17T00:00:00.000Z",
        "formattedDate": "2021年4月17日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.57,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——圆圈中最后剩下的数字（JS实现）",
          "date": "2021-04-17T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——二叉搜索树与双向链表（JS实现）",
          "permalink": "/blog/剑指Offer——二叉搜索树与双向链表（JS实现）"
        },
        "nextItem": {
          "title": "将一句英文的每个单词首字母大写其余字母小写",
          "permalink": "/blog/将一句英文的每个单词首字母大写其余字母小写"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/7ef251b919b2446fb322800344d40dd9.png)\r\n\r\n## 解题思路\r\n* 本题属于约瑟夫环问题，属于经典的数学问题\r\n* 解题的核心思路在于：定义一个下标指针，在于下面的这个式子：\r\n* head = （head + m - 1）% arr.length;\r\n\r\n## 实现代码\r\n```js\r\nvar lastRemaining = function(n, m) {\r\n    let arr = []\r\n    for (let i = 0;i < n;i++) {\r\n        arr.push(i);\r\n    }\r\n    let flag = 0;\r\n    while (arr.length !== 1) {\r\n        flag = (flag + m - 1) % arr.length;\r\n        arr.splice(flag,1);\r\n    }\r\n    \r\n    return arr[0];\r\n};\r\n```"
    },
    {
      "id": "/将一句英文的每个单词首字母大写其余字母小写",
      "metadata": {
        "permalink": "/blog/将一句英文的每个单词首字母大写其余字母小写",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/将一句英文的每个单词首字母大写其余字母小写.md",
        "source": "@site/blog\\将一句英文的每个单词首字母大写其余字母小写.md",
        "title": "将一句英文的每个单词首字母大写其余字母小写",
        "description": "灵活使用toUpperCase和toLowerCase",
        "date": "2021-04-17T00:00:00.000Z",
        "formattedDate": "2021年4月17日",
        "tags": [
          {
            "label": "JavaScript常用API",
            "permalink": "/blog/tags/java-script常用-api"
          }
        ],
        "readingTime": 0.33,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "将一句英文的每个单词首字母大写其余字母小写",
          "date": "2021-04-17T00:00:00.000Z",
          "categories": "JavaScript常用API",
          "tags": [
            "JavaScript常用API"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——圆圈中最后剩下的数字（JS实现）",
          "permalink": "/blog/剑指Offer——圆圈中最后剩下的数字（JS实现）"
        },
        "nextItem": {
          "title": "JS中判断一个值是否为布尔类型的值",
          "permalink": "/blog/JS中判断一个值是否为布尔类型的值"
        }
      },
      "content": "## 灵活使用toUpperCase和toLowerCase\r\n## 注意修改的是字面量还是变量\r\n```js\r\nfunction titleCase(str) {\r\n    const result = str.split(' ');\r\n    for (let i in result) {\r\n        result[i] = result[i][0].toUpperCase() + result[i].slice(1,result[i].length).toLowerCase(); \r\n    }\r\n    result\r\n    const test = result.reduce((pre,value) => {\r\n        return pre + ' ' + value;\r\n    })\r\n    \r\n    return test;\r\n}\r\n\r\nconsole.log(titleCase(\"sHoRt AnD sToUt\"));\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/5bb9a650deeec68424d2a99f28b5402d.png)"
    },
    {
      "id": "/JS中判断一个值是否为布尔类型的值",
      "metadata": {
        "permalink": "/blog/JS中判断一个值是否为布尔类型的值",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/JS中判断一个值是否为布尔类型的值.md",
        "source": "@site/blog\\JS中判断一个值是否为布尔类型的值.md",
        "title": "JS中判断一个值是否为布尔类型的值",
        "description": "注意：是字符串",
        "date": "2021-04-16T00:00:00.000Z",
        "formattedDate": "2021年4月16日",
        "tags": [
          {
            "label": "JavaScript常用API",
            "permalink": "/blog/tags/java-script常用-api"
          }
        ],
        "readingTime": 0.04,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "JS中判断一个值是否为布尔类型的值",
          "date": "2021-04-16T00:00:00.000Z",
          "categories": "JavaScript常用API",
          "tags": [
            "JavaScript常用API"
          ]
        },
        "prevItem": {
          "title": "将一句英文的每个单词首字母大写其余字母小写",
          "permalink": "/blog/将一句英文的每个单词首字母大写其余字母小写"
        },
        "nextItem": {
          "title": "React-22：React脚手架配置axios代理",
          "permalink": "/blog/React-22：React脚手架配置axios代理"
        }
      },
      "content": "## 注意：是字符串\r\n![](https://img-blog.csdnimg.cn/img_convert/38b5e48ad999a59d6b57eb875a4ef12b.png)"
    },
    {
      "id": "/React-22：React脚手架配置axios代理",
      "metadata": {
        "permalink": "/blog/React-22：React脚手架配置axios代理",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-22：React脚手架配置axios代理.md",
        "source": "@site/blog\\React-22：React脚手架配置axios代理.md",
        "title": "React-22：React脚手架配置axios代理",
        "description": "1：给项目安装axios",
        "date": "2021-04-16T00:00:00.000Z",
        "formattedDate": "2021年4月16日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 1.05,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-22：React脚手架配置axios代理",
          "date": "2021-04-16T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "JS中判断一个值是否为布尔类型的值",
          "permalink": "/blog/JS中判断一个值是否为布尔类型的值"
        },
        "nextItem": {
          "title": "剑指Offer——和为S的两个数字（JS实现）",
          "permalink": "/blog/剑指Offer——和为S的两个数字（JS实现）"
        }
      },
      "content": "## 1：给项目安装axios\r\n```\r\nnpm install axios\r\n```\r\n## 2：导入axios工具包\r\n```\r\nimport axios from 'axios';\r\n```\r\n## 3：给React脚手架添加中间代理实现跨域（方法一）\r\n* 在项目的package.json文件中添加下面的一句话\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/87d564072fba939285871702f26e9329.png)\r\n\r\n* 将请求修改为React脚手架对应的端口\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/9d076dc9838d439cd31060ee2fbf3ac2.png)\r\n\r\n* 注意事项：并不是配置了代理，所有的请求都会通过代理，而是本地端口没有的请求才会询问代理端口。\r\n\r\n## 4：给React脚手架实现跨域请求（方法二）\r\n* 配置多个代理\r\n1. 在src文件中添加setupProxy.js文件\r\n2. setupProxy.js中写的是common.js语法\r\n3. setupProxy.js中的文件内容\r\n\r\n```js\r\nconst proxy = require('http-proxy-middleware');\r\n\r\nmodule.exports = function(app) {\r\n    app.use(\r\n        proxy('/api1',{\r\n            target: 'http://localhost:5000',\r\n            changeOrigin: true,\r\n            pathRewrite: {'^/api1':''}\r\n        }),\r\n        proxy('/api2',{\r\n            target: 'http://localhost:5001',\r\n            changeOrigin: true,\r\n            pathRewrite: {'^/api2':''}\r\n        })\r\n    )\r\n}\r\n```\r\n\r\n4. 修改axios请求路径\r\n![](https://img-blog.csdnimg.cn/img_convert/8d52c6ef82f13c6508663282bf1d64ce.png)"
    },
    {
      "id": "/剑指Offer——和为S的两个数字（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——和为S的两个数字（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——和为S的两个数字（JS实现）.md",
        "source": "@site/blog\\剑指Offer——和为S的两个数字（JS实现）.md",
        "title": "剑指Offer——和为S的两个数字（JS实现）",
        "description": "题目描述",
        "date": "2021-04-16T00:00:00.000Z",
        "formattedDate": "2021年4月16日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.51,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——和为S的两个数字（JS实现）",
          "date": "2021-04-16T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "React-22：React脚手架配置axios代理",
          "permalink": "/blog/React-22：React脚手架配置axios代理"
        },
        "nextItem": {
          "title": "剑指Offer——数组中出现次数超过一半的数字（JS实现）",
          "permalink": "/blog/剑指Offer——数组中出现次数超过一半的数字（JS实现）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/2ab8ec98f53bb5fa8e53446af07a9f56.png)\r\n\r\n## 解题思路\r\n* 使用双指针\r\n* 一个指针指向最左端\r\n* 一个指针指向最右端\r\n* 大了最右端的往左移\r\n* 小了最左端的往右移\r\n\r\n## 实现代码\r\n```js\r\nvar twoSum = function (nums, target) {\r\n    let l = 0;\r\n    let r = nums.length-1;\r\n    while (nums[l] + nums[r] !== target) {\r\n        if (nums[l] + nums[r] < target) {\r\n            l++;\r\n        }\r\n        if (nums[l] + nums[r] > target) {\r\n            r--;\r\n        }\r\n    }\r\n    return [nums[l],nums[r]]\r\n\r\n};\r\n```"
    },
    {
      "id": "/剑指Offer——数组中出现次数超过一半的数字（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——数组中出现次数超过一半的数字（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——数组中出现次数超过一半的数字（JS实现）.md",
        "source": "@site/blog\\剑指Offer——数组中出现次数超过一半的数字（JS实现）.md",
        "title": "剑指Offer——数组中出现次数超过一半的数字（JS实现）",
        "description": "题目描述",
        "date": "2021-04-16T00:00:00.000Z",
        "formattedDate": "2021年4月16日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.62,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——数组中出现次数超过一半的数字（JS实现）",
          "date": "2021-04-16T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——和为S的两个数字（JS实现）",
          "permalink": "/blog/剑指Offer——和为S的两个数字（JS实现）"
        },
        "nextItem": {
          "title": "剑指Offer——数组中重复的数字（JS实现）",
          "permalink": "/blog/剑指Offer——数组中重复的数字（JS实现）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/c2afef4e921806d51952ea7f59ec4b08.png)\r\n\r\n## 解题思路\r\n* 使用哈希Map的键存放数组的元素\r\n* 使用哈希Map的值存放该元素出现的次数\r\n* 找出出现次数大于长度一半的元素，返回即可\r\n\r\n## 实现代码\r\n```js\r\nvar majorityElement = function(nums) {\r\n    // 存储数组的长度的一半\r\n    let len = nums.length/2;\r\n    const m = new Map();\r\n    for (let v of nums) {\r\n        if (m.has(v)) {\r\n            m.set(v,m.get(v)+1);\r\n        } else {\r\n            m.set(v,1);\r\n        }\r\n    };\r\n    for (let v of m) {\r\n        if (v[1] > len) {\r\n            return v[0];\r\n        }\r\n    }\r\n};\r\n```"
    },
    {
      "id": "/剑指Offer——数组中重复的数字（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——数组中重复的数字（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——数组中重复的数字（JS实现）.md",
        "source": "@site/blog\\剑指Offer——数组中重复的数字（JS实现）.md",
        "title": "剑指Offer——数组中重复的数字（JS实现）",
        "description": "题目描述",
        "date": "2021-04-16T00:00:00.000Z",
        "formattedDate": "2021年4月16日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.375,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——数组中重复的数字（JS实现）",
          "date": "2021-04-16T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——数组中出现次数超过一半的数字（JS实现）",
          "permalink": "/blog/剑指Offer——数组中出现次数超过一半的数字（JS实现）"
        },
        "nextItem": {
          "title": "Hexo Nunjucks Error 问题原因",
          "permalink": "/blog/Hexo Nunjucks Error 问题原因"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/3eec1eba0d8b236c3aa01b8b12450aae.png)\r\n\r\n## 解题思路\r\n* 使用Map数据结构键存储元素，值存储出现的次数\r\n* 只要出现重复，直接返回\r\n\r\n## 实现代码\r\n```js\r\nvar findRepeatNumber = function(nums) {\r\n    const m = new Map();\r\n    for (let v of nums) {\r\n        if (m.has(v)) {\r\n            return v;\r\n        } else {\r\n            m.set(v,1);\r\n        }\r\n    }\r\n};\r\n```"
    },
    {
      "id": "/Hexo Nunjucks Error 问题原因",
      "metadata": {
        "permalink": "/blog/Hexo Nunjucks Error 问题原因",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Hexo Nunjucks Error 问题原因.md",
        "source": "@site/blog\\Hexo Nunjucks Error 问题原因.md",
        "title": "Hexo Nunjucks Error 问题原因",
        "description": "出现这个问题的原因，是因为你的博客中出现下面的内容",
        "date": "2021-04-15T00:00:00.000Z",
        "formattedDate": "2021年4月15日",
        "tags": [
          {
            "label": "debug",
            "permalink": "/blog/tags/debug"
          }
        ],
        "readingTime": 0.24,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Hexo Nunjucks Error 问题原因",
          "date": "2021-04-15T00:00:00.000Z",
          "categories": "debug",
          "tags": [
            "debug"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——数组中重复的数字（JS实现）",
          "permalink": "/blog/剑指Offer——数组中重复的数字（JS实现）"
        },
        "nextItem": {
          "title": "JS中filter方法",
          "permalink": "/blog/JS中filter方法"
        }
      },
      "content": "## 出现这个问题的原因，是因为你的博客中出现下面的内容\r\n* 这样的内容，无论在标题中还是正文中都不允许出现\r\n![](https://img-blog.csdnimg.cn/img_convert/690cd697a8e9aa25db2b99c3140ab0f2.png)"
    },
    {
      "id": "/JS中filter方法",
      "metadata": {
        "permalink": "/blog/JS中filter方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/JS中filter方法.md",
        "source": "@site/blog\\JS中filter方法.md",
        "title": "JS中filter方法",
        "description": "filter方法的应用场景",
        "date": "2021-04-15T00:00:00.000Z",
        "formattedDate": "2021年4月15日",
        "tags": [
          {
            "label": "JavaScript常用API",
            "permalink": "/blog/tags/java-script常用-api"
          }
        ],
        "readingTime": 0.27,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "JS中filter方法",
          "date": "2021-04-15T00:00:00.000Z",
          "categories": "JavaScript常用API",
          "tags": [
            "JavaScript常用API"
          ]
        },
        "prevItem": {
          "title": "Hexo Nunjucks Error 问题原因",
          "permalink": "/blog/Hexo Nunjucks Error 问题原因"
        },
        "nextItem": {
          "title": "JS中的小数四舍五入之（toFixed方法）",
          "permalink": "/blog/JS中的小数四舍五入之（toFixed方法）"
        }
      },
      "content": "## filter方法的应用场景\r\n* filter方法和map方法的区别是：map方法返回的数组的元素数和原数组的元素数是一样的，但是filter会修改元素数\r\n![](https://img-blog.csdnimg.cn/img_convert/3fe9b13e5797e9d8f070c2a93aae3106.png)"
    },
    {
      "id": "/JS中的小数四舍五入之（toFixed方法）",
      "metadata": {
        "permalink": "/blog/JS中的小数四舍五入之（toFixed方法）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/JS中的小数四舍五入之（toFixed方法）.md",
        "source": "@site/blog\\JS中的小数四舍五入之（toFixed方法）.md",
        "title": "JS中的小数四舍五入之（toFixed方法）",
        "description": "使用toFixed方法",
        "date": "2021-04-15T00:00:00.000Z",
        "formattedDate": "2021年4月15日",
        "tags": [
          {
            "label": "JavaScript常用API",
            "permalink": "/blog/tags/java-script常用-api"
          }
        ],
        "readingTime": 0.035,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "JS中的小数四舍五入之（toFixed方法）",
          "date": "2021-04-15T00:00:00.000Z",
          "categories": "JavaScript常用API",
          "tags": [
            "JavaScript常用API"
          ]
        },
        "prevItem": {
          "title": "JS中filter方法",
          "permalink": "/blog/JS中filter方法"
        },
        "nextItem": {
          "title": "一行代码反转字符串",
          "permalink": "/blog/一行代码反转字符串"
        }
      },
      "content": "## 使用toFixed方法\r\n![](https://img-blog.csdnimg.cn/img_convert/511c7d276153817df7fd66fda2ff05ba.png)"
    },
    {
      "id": "/一行代码反转字符串",
      "metadata": {
        "permalink": "/blog/一行代码反转字符串",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/一行代码反转字符串.md",
        "source": "@site/blog\\一行代码反转字符串.md",
        "title": "一行代码反转字符串",
        "description": "代码如下",
        "date": "2021-04-15T00:00:00.000Z",
        "formattedDate": "2021年4月15日",
        "tags": [
          {
            "label": "JavaScript常用API",
            "permalink": "/blog/tags/java-script常用-api"
          }
        ],
        "readingTime": 0.055,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "一行代码反转字符串",
          "date": "2021-04-15T00:00:00.000Z",
          "categories": "JavaScript常用API",
          "tags": [
            "JavaScript常用API"
          ]
        },
        "prevItem": {
          "title": "JS中的小数四舍五入之（toFixed方法）",
          "permalink": "/blog/JS中的小数四舍五入之（toFixed方法）"
        },
        "nextItem": {
          "title": "剑指Offer——从上到下打印二叉树II（JS实现）",
          "permalink": "/blog/剑指Offer——从上到下打印二叉树II（JS实现）"
        }
      },
      "content": "## 代码如下\r\n```js\r\nstr = str.split('').reverse().join('')\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/978f63aaf46e43d4b33d47ba8f8fa65f.png)"
    },
    {
      "id": "/剑指Offer——从上到下打印二叉树II（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——从上到下打印二叉树II（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——从上到下打印二叉树II（JS实现）.md",
        "source": "@site/blog\\剑指Offer——从上到下打印二叉树II（JS实现）.md",
        "title": "剑指Offer——从上到下打印二叉树II（JS实现）",
        "description": "题目描述",
        "date": "2021-04-15T00:00:00.000Z",
        "formattedDate": "2021年4月15日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.195,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——从上到下打印二叉树II（JS实现）",
          "date": "2021-04-15T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "一行代码反转字符串",
          "permalink": "/blog/一行代码反转字符串"
        },
        "nextItem": {
          "title": "查找字符串中最长的单词",
          "permalink": "/blog/查找字符串中最长的单词"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/b4a610aff767441c1478980774813aad.png)\r\n\r\n## 解题思路\r\n* 使用队列来存储同一层的元素\r\n* 使用数组1来存放同一层元素的所有值\r\n* 使用数组2来存放用一层元素的所有指针\r\n* 将数组1放进结果列表\r\n* 将数组2所有元素的左右孩子放进队列，当队列的长度不为零的时候继续循环。\r\n\r\n## 实现代码\r\n```js\r\nvar levelOrder = function (root) {\r\n    // 如果系统给的根元素为空，直接返回\r\n    if (!root) return [];\r\n    // 定义一个队列用于存放同一层的元素\r\n    let queue = [];\r\n    // 首先让根元素入队\r\n    queue.push(root);\r\n    // 只要队中有元素就进入循环\r\n    // 定义最终结果数组\r\n    const res = [];\r\n    while (queue.length !== 0) {\r\n        // res.push([...queue]);\r\n        const temp = [];\r\n        const temp2 = []\r\n        // 队列首元素出队\r\n        while (queue[0]) {\r\n            temp2.push(queue[0].val);\r\n            temp.push(queue.shift())\r\n        }\r\n        res.push(temp2);\r\n        while (temp[0]) {\r\n            if (temp[0].left !== null) queue.push(temp[0].left);\r\n            if (temp[0].right !== null) queue.push(temp[0].right);\r\n            temp.shift();\r\n        }\r\n    }\r\n    return res;\r\n};\r\n```"
    },
    {
      "id": "/查找字符串中最长的单词",
      "metadata": {
        "permalink": "/blog/查找字符串中最长的单词",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/查找字符串中最长的单词.md",
        "source": "@site/blog\\查找字符串中最长的单词.md",
        "title": "查找字符串中最长的单词",
        "description": "",
        "date": "2021-04-15T00:00:00.000Z",
        "formattedDate": "2021年4月15日",
        "tags": [
          {
            "label": "数据结构与算法",
            "permalink": "/blog/tags/数据结构与算法"
          }
        ],
        "readingTime": 0.005,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "查找字符串中最长的单词",
          "date": "2021-04-15T00:00:00.000Z",
          "categories": "数据结构与算法",
          "tags": [
            "数据结构与算法"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——从上到下打印二叉树II（JS实现）",
          "permalink": "/blog/剑指Offer——从上到下打印二叉树II（JS实现）"
        },
        "nextItem": {
          "title": "JS中reduce方法",
          "permalink": "/blog/JS中reduce方法"
        }
      },
      "content": "![](https://img-blog.csdnimg.cn/img_convert/01bbea74d2985ac2afaf91fc85332bb4.png)"
    },
    {
      "id": "/JS中reduce方法",
      "metadata": {
        "permalink": "/blog/JS中reduce方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/JS中reduce方法.md",
        "source": "@site/blog\\JS中reduce方法.md",
        "title": "JS中reduce方法",
        "description": "reduce方法可以用来求一个数组的累计和",
        "date": "2021-04-14T00:00:00.000Z",
        "formattedDate": "2021年4月14日",
        "tags": [
          {
            "label": "JavaScript常用API",
            "permalink": "/blog/tags/java-script常用-api"
          }
        ],
        "readingTime": 0.36,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "JS中reduce方法",
          "date": "2021-04-14T00:00:00.000Z",
          "categories": "JavaScript常用API",
          "tags": [
            "JavaScript常用API"
          ]
        },
        "prevItem": {
          "title": "查找字符串中最长的单词",
          "permalink": "/blog/查找字符串中最长的单词"
        },
        "nextItem": {
          "title": "JS中的map方法",
          "permalink": "/blog/JS中的map方法"
        }
      },
      "content": "## reduce方法可以用来求一个数组的累计和\r\n![](https://img-blog.csdnimg.cn/img_convert/288c197ea9426cf7eff98c6fd86b51bf.png)\r\n* pre代表前面所有的加一起的累积值\r\n* 0代表的是默认的pre值\r\n* index代表的是下标\r\n\r\n## reduce方法将数组中的元素连接成一个长的字符串\r\n![](https://img-blog.csdnimg.cn/img_convert/c6ed865df0cbf755b17409eaf5e704a2.png)"
    },
    {
      "id": "/JS中的map方法",
      "metadata": {
        "permalink": "/blog/JS中的map方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/JS中的map方法.md",
        "source": "@site/blog\\JS中的map方法.md",
        "title": "JS中的map方法",
        "description": "map的使用场景",
        "date": "2021-04-14T00:00:00.000Z",
        "formattedDate": "2021年4月14日",
        "tags": [
          {
            "label": "JavaScript常用API",
            "permalink": "/blog/tags/java-script常用-api"
          }
        ],
        "readingTime": 0.27,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "JS中的map方法",
          "date": "2021-04-14T00:00:00.000Z",
          "categories": "JavaScript常用API",
          "tags": [
            "JavaScript常用API"
          ]
        },
        "prevItem": {
          "title": "JS中reduce方法",
          "permalink": "/blog/JS中reduce方法"
        },
        "nextItem": {
          "title": "python——提取漏洞描述中有争议的数据",
          "permalink": "/blog/python——提取漏洞描述中有争议的数据"
        }
      },
      "content": "## map的使用场景\r\n* 当想对数组中的每个元素进行修改的时候，返回的元素数目不变还是这些，但是内容发生了变化的情况，使用map\r\n![](https://img-blog.csdnimg.cn/img_convert/42c0436512f2902ac56f1580d5f5cde7.png)"
    },
    {
      "id": "/python——提取漏洞描述中有争议的数据",
      "metadata": {
        "permalink": "/blog/python——提取漏洞描述中有争议的数据",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/python——提取漏洞描述中有争议的数据.md",
        "source": "@site/blog\\python——提取漏洞描述中有争议的数据.md",
        "title": "python——提取漏洞描述中有争议的数据",
        "description": "1. 提取数据",
        "date": "2021-04-14T00:00:00.000Z",
        "formattedDate": "2021年4月14日",
        "tags": [
          {
            "label": "python",
            "permalink": "/blog/tags/python"
          }
        ],
        "readingTime": 1.985,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "python——提取漏洞描述中有争议的数据",
          "date": "2021-04-14T00:00:00.000Z",
          "categories": "python",
          "tags": [
            "python"
          ]
        },
        "prevItem": {
          "title": "JS中的map方法",
          "permalink": "/blog/JS中的map方法"
        },
        "nextItem": {
          "title": "React-20：对props进行限制",
          "permalink": "/blog/React-20：对props进行限制"
        }
      },
      "content": "## 1. 提取数据\r\n```python\r\n# @time :2020-5-12\r\nimport openpyxl\r\nimport re\r\n\r\n# 创建一个excel workbook对象\r\nbook = openpyxl.Workbook()\r\n# 产生一个sheet\r\nsh = book.active\r\n# 修改当前sheet标题为 漏洞数据信息表\r\nsh.title = '特殊文本信息表'\r\n# 根据名称获取某个sheet对象\r\nsh = book['特殊文本信息表']\r\n\r\n# 标记\r\nflag = 1\r\n\r\n# 导入我们的xlsx文件\r\nwb = openpyxl.load_workbook(\"vig_all.xlsx\")\r\n\r\n# 打开具体的某一个表\r\nws = wb.get_sheet_by_name(\"Sheet\")\r\n\r\n# cve列\r\ncve_column = ws['C']\r\n\r\n# desciprtion列\r\ndes_column = ws['G']\r\n\r\n# 遍历每一个CVE编号\r\nfor i in range(len(cve_column)):\r\n    # print(cve_column[i].value)\r\n    try:\r\n        if bool(re.search(r\"\\** REJECT \\**\",des_column[i].value)):\r\n            print(des_column[i].value)\r\n            sh['A' + str(flag)] = cve_column[i].value\r\n            sh['B' + str(flag)] = des_column[i].value\r\n            flag = flag + 1\r\n    except Exception :\r\n        pass\r\n\r\n\r\nbook.save(\"特殊文本.xlsx\")\r\n\r\n\r\n\r\n\r\nprint(\"---运行结束---\")\r\n```\r\n## 2. 数据去重\r\n```pyhton\r\n# @time :2020-5-12\r\nimport openpyxl\r\nimport re\r\n\r\n# 创建一个excel workbook对象\r\nbook = openpyxl.Workbook()\r\n# 产生一个sheet\r\nsh = book.active\r\n# 修改当前sheet标题为 漏洞数据信息表\r\nsh.title = '特殊文本信息表'\r\n# 根据名称获取某个sheet对象\r\nsh = book['特殊文本信息表']\r\n\r\n# 标记\r\nflag = 1\r\n# 导入我们的xlsx文件\r\nwb = openpyxl.load_workbook(\"特殊文本.xlsx\")\r\n\r\n# 打开具体的某一个表\r\nws = wb.get_sheet_by_name(\"特殊文本信息表\")\r\n\r\n# cve列\r\ncve_column = ws['A']\r\n\r\n# 特殊文本列\r\ndes_column = ws['B']\r\n\r\n# 定义一个字典\r\nnew_dic = dict()\r\n\r\n# 将excel文件中的每一对数据都放到字典中\r\nfor i in range(len(cve_column)):\r\n    new_dic[str(cve_column[i].value)] = des_column[i].value\r\n\r\n\r\nvalues=set()\r\nfor key in list(new_dic.keys()):\r\n    val = new_dic[key]\r\n    if val in values: \r\n        del new_dic[key]\r\n    else:\r\n        values.add(val)\r\n\r\nfor key,value in new_dic.items():\r\n    sh['A' + str(flag)] = key\r\n    sh['B' + str(flag)] = value\r\n    flag = flag + 1\r\n\r\n\r\nbook.save(\"已去重Cnvd特殊文本.xlsx\")\r\nprint(\"---运行结束---\")\r\n```"
    },
    {
      "id": "/React-20：对props进行限制",
      "metadata": {
        "permalink": "/blog/React-20：对props进行限制",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-20：对props进行限制.md",
        "source": "@site/blog\\React-20：对props进行限制.md",
        "title": "React-20：对props进行限制",
        "description": "1：使用npm安装prop-types包",
        "date": "2021-04-14T00:00:00.000Z",
        "formattedDate": "2021年4月14日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.24,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-20：对props进行限制",
          "date": "2021-04-14T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "python——提取漏洞描述中有争议的数据",
          "permalink": "/blog/python——提取漏洞描述中有争议的数据"
        },
        "nextItem": {
          "title": "React-21：React中关于修改state方法的核心一句话",
          "permalink": "/blog/React-21：React中关于修改state方法的核心一句话"
        }
      },
      "content": "## 1：使用npm安装prop-types包\r\n`\r\nnpm install prop-types\r\n`\r\n## 2：导入工具包\r\n```\r\nimport PropTypes from 'prop-types';\r\n```\r\n## 3：对传入的props进行限制（这个是写在被传入的位置）\r\n![](https://img-blog.csdnimg.cn/img_convert/577095bb2b50f647d3e5fd35b0d5ffd1.png)"
    },
    {
      "id": "/React-21：React中关于修改state方法的核心一句话",
      "metadata": {
        "permalink": "/blog/React-21：React中关于修改state方法的核心一句话",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-21：React中关于修改state方法的核心一句话.md",
        "source": "@site/blog\\React-21：React中关于修改state方法的核心一句话.md",
        "title": "React-21：React中关于修改state方法的核心一句话",
        "description": "state在哪里，修改state的方法就应该在哪里",
        "date": "2021-04-14T00:00:00.000Z",
        "formattedDate": "2021年4月14日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.09,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-21：React中关于修改state方法的核心一句话",
          "date": "2021-04-14T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-20：对props进行限制",
          "permalink": "/blog/React-20：对props进行限制"
        },
        "nextItem": {
          "title": "剑指Offer——二叉搜索树的最近公共祖先（JS实现）",
          "permalink": "/blog/剑指Offer——二叉搜索树的最近公共祖先（JS实现）"
        }
      },
      "content": "## state在哪里，修改state的方法就应该在哪里\r\n![](https://img-blog.csdnimg.cn/img_convert/23d1411f0de0f507231dc1c1ebbd6951.png)"
    },
    {
      "id": "/剑指Offer——二叉搜索树的最近公共祖先（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——二叉搜索树的最近公共祖先（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——二叉搜索树的最近公共祖先（JS实现）.md",
        "source": "@site/blog\\剑指Offer——二叉搜索树的最近公共祖先（JS实现）.md",
        "title": "剑指Offer——二叉搜索树的最近公共祖先（JS实现）",
        "description": "题目描述",
        "date": "2021-04-14T00:00:00.000Z",
        "formattedDate": "2021年4月14日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.08,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——二叉搜索树的最近公共祖先（JS实现）",
          "date": "2021-04-14T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "React-21：React中关于修改state方法的核心一句话",
          "permalink": "/blog/React-21：React中关于修改state方法的核心一句话"
        },
        "nextItem": {
          "title": "剑指Offer——礼物的最大价值（JS实现）",
          "permalink": "/blog/剑指Offer——礼物的最大价值（JS实现）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/545c2aa0bd97eab3bd16648be84aacff.png)\r\n\r\n## 解题思路\r\n* 使用DFS的遍历思想，遍历二叉树。\r\n* 递归的结束条件是：当前节点为null或为q,或为p则返回。\r\n* 判断获得的左右子树返回的结果，如果右子树为空，返回左子树，左子树为空返回右子树，左右子树都不为空，返回当前节点node\r\n\r\n## 实现代码\r\n```js\r\n// 二叉搜索树的特点：左子树 < 根节点 < 右子树\r\nvar lowestCommonAncestor = function (root, p, q) {\r\n    if (root === null || root === p || root === q) {\r\n        return root;\r\n    }\r\n    let l = lowestCommonAncestor(root.left, p, q);\r\n    let r = lowestCommonAncestor(root.right, p, q);\r\n    if (l === null && r === null) {\r\n        return null;\r\n    }\r\n    if (l !== null && l.val < root.val && r === null) {\r\n        return l;\r\n    }\r\n    if (l === null && r !== null && r.val > root.val) {\r\n        return r;\r\n    }\r\n    if (l.val < root.val && r.val > root.val) {\r\n        return root;\r\n    }\r\n\r\n};\r\n```"
    },
    {
      "id": "/剑指Offer——礼物的最大价值（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——礼物的最大价值（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——礼物的最大价值（JS实现）.md",
        "source": "@site/blog\\剑指Offer——礼物的最大价值（JS实现）.md",
        "title": "剑指Offer——礼物的最大价值（JS实现）",
        "description": "题目描述",
        "date": "2021-04-14T00:00:00.000Z",
        "formattedDate": "2021年4月14日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 1.94,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——礼物的最大价值（JS实现）",
          "date": "2021-04-14T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——二叉搜索树的最近公共祖先（JS实现）",
          "permalink": "/blog/剑指Offer——二叉搜索树的最近公共祖先（JS实现）"
        },
        "nextItem": {
          "title": "数据结构基础——链表（JS实现）",
          "permalink": "/blog/数据结构基础——链表（JS实现）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/364dd1db6c40fff22a9a36d17ab94ff9.png)\r\n\r\n## 解题思路\r\n* 本题考查动态规划\r\n* 首先构造一个和原数组维度一摸一样的全零数组dp\r\n* dp的值首先将第一行和第一列构造为原数组向右、向下的价值和\r\n* 然后使用for循环遍历填写剩余的dp值\r\n* 方程dp[i][j]=grid[i][j] + Math.max(dp[i][j-1],dp[i-1][j])\r\n\r\n## 实现代码\r\n````js\r\nvar maxValue = function(grid) {\r\n    // 首先构造一个和grid矩阵维度一致的矩阵\r\n    const dp = [];\r\n    const rowNum = grid.length;\r\n    const cowNum = grid[0].length;\r\n    for (let i = 0; i < rowNum;i++) {\r\n        dp[i] = [];\r\n        for (let j = 0;j < cowNum;j++) {\r\n            dp[i][j] = 0;\r\n        }\r\n    }\r\n    // 函数走到这里dp已经变成和grid维度完全一致的全零数组\r\n    // 我们首先要做的是将dp的第一行和第一列全部填写为从初始位置出发走到目标位置所需的距离\r\n    dp[0][0] = grid[0][0];\r\n    for (let i = 1; i < rowNum;i++) {\r\n        dp[i][0] = grid[i][0] + dp[i-1][0];\r\n    }\r\n    for (let j = 1; j < cowNum;j++) {\r\n        dp[0][j] = grid[0][j] + dp[0][j-1]\r\n    }\r\n    // 通过上面两个循环我们已经将grid的第一行和第一列需要的价值和写到了dp数组中的第一列和第二列\r\n    // 接下来遍历grid的其余数组即可\r\n    for (let i = 1; i < rowNum;i++) {\r\n        for (let j = 1;j < cowNum;j++) {\r\n            dp[i][j] = grid[i][j] + Math.max(dp[i-1][j],dp[i][j-1]);\r\n        }\r\n    }\r\n    // 走到这里dp数组的每一个值我们应该理解为grid数组路径的价值和\r\n    // dp数组的最后一个值就应该是价值的最大值\r\n    return dp[rowNum-1][cowNum-1]\r\n};\r\n```"
    },
    {
      "id": "/数据结构基础——链表（JS实现）",
      "metadata": {
        "permalink": "/blog/数据结构基础——链表（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/数据结构基础——链表（JS实现）.md",
        "source": "@site/blog\\数据结构基础——链表（JS实现）.md",
        "title": "数据结构基础——链表（JS实现）",
        "description": "链表的基本形式",
        "date": "2021-04-14T00:00:00.000Z",
        "formattedDate": "2021年4月14日",
        "tags": [
          {
            "label": "数据结构",
            "permalink": "/blog/tags/数据结构"
          }
        ],
        "readingTime": 0.23,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "数据结构基础——链表（JS实现）",
          "date": "2021-04-14T00:00:00.000Z",
          "categories": "数据结构",
          "tags": [
            "数据结构"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——礼物的最大价值（JS实现）",
          "permalink": "/blog/剑指Offer——礼物的最大价值（JS实现）"
        },
        "nextItem": {
          "title": "JS中every()方法",
          "permalink": "/blog/JS中every()方法"
        }
      },
      "content": "## 链表的基本形式\r\n![](https://img-blog.csdnimg.cn/img_convert/e7f10c4c668a560432481aa30229e9ff.png)\r\n\r\n## 遍历链表\r\n* 遍历链表前先让一个指针指向头结点\r\n![](https://img-blog.csdnimg.cn/img_convert/30071dcdd628bcafe76079635ac9d6e7.png)\r\n\r\n## 链表中插入元素\r\n![](https://img-blog.csdnimg.cn/img_convert/4a3aa0acd94327bd7342ec5f10a80c14.png)\r\n\r\n## 删除元素\r\n![](https://img-blog.csdnimg.cn/img_convert/0e7910b41580b5a8b87a16865ea9970e.png)"
    },
    {
      "id": "/JS中every()方法",
      "metadata": {
        "permalink": "/blog/JS中every()方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/JS中every()方法.md",
        "source": "@site/blog\\JS中every()方法.md",
        "title": "JS中every()方法",
        "description": "every()方法的返回值是一个布尔类型的值",
        "date": "2021-04-13T00:00:00.000Z",
        "formattedDate": "2021年4月13日",
        "tags": [
          {
            "label": "JavaScript常用API",
            "permalink": "/blog/tags/java-script常用-api"
          }
        ],
        "readingTime": 0.335,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "JS中every()方法",
          "date": "2021-04-13T00:00:00.000Z",
          "categories": "JavaScript常用API",
          "tags": [
            "JavaScript常用API"
          ]
        },
        "prevItem": {
          "title": "数据结构基础——链表（JS实现）",
          "permalink": "/blog/数据结构基础——链表（JS实现）"
        },
        "nextItem": {
          "title": "JS中some()方法",
          "permalink": "/blog/JS中some()方法"
        }
      },
      "content": "## every()方法的返回值是一个布尔类型的值\r\n![](https://img-blog.csdnimg.cn/img_convert/94cbfa908a7896404c1de0ed4d1e0804.png)\r\n\r\n## every()方法接收的是一个回调函数\r\n## every()方法存在的意义是什么？\r\n* 检验数组中的每个元素是否符合要求，只要都符合，返回true"
    },
    {
      "id": "/JS中some()方法",
      "metadata": {
        "permalink": "/blog/JS中some()方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/JS中some()方法.md",
        "source": "@site/blog\\JS中some()方法.md",
        "title": "JS中some()方法",
        "description": "some()方法接收一个回调函数，只要其中有一个元素返回的是true，总体返回的是true",
        "date": "2021-04-13T00:00:00.000Z",
        "formattedDate": "2021年4月13日",
        "tags": [
          {
            "label": "JavaScript常用API",
            "permalink": "/blog/tags/java-script常用-api"
          }
        ],
        "readingTime": 0.25,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "JS中some()方法",
          "date": "2021-04-13T00:00:00.000Z",
          "categories": "JavaScript常用API",
          "tags": [
            "JavaScript常用API"
          ]
        },
        "prevItem": {
          "title": "JS中every()方法",
          "permalink": "/blog/JS中every()方法"
        },
        "nextItem": {
          "title": "JS中使数组倒序排列",
          "permalink": "/blog/JS中使数组倒序排列"
        }
      },
      "content": "## some()方法接收一个回调函数，只要其中有一个元素返回的是true，总体返回的是true\r\n![](https://img-blog.csdnimg.cn/img_convert/2f5c9c8b915ab5aa173a2f4c39aaa02e.png)\r\n\r\n## return会终止some循环，return不会终止forEach循环"
    },
    {
      "id": "/JS中使数组倒序排列",
      "metadata": {
        "permalink": "/blog/JS中使数组倒序排列",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/JS中使数组倒序排列.md",
        "source": "@site/blog\\JS中使数组倒序排列.md",
        "title": "JS中使数组倒序排列",
        "description": "使用reverse方法",
        "date": "2021-04-13T00:00:00.000Z",
        "formattedDate": "2021年4月13日",
        "tags": [
          {
            "label": "JavaScript常用API",
            "permalink": "/blog/tags/java-script常用-api"
          }
        ],
        "readingTime": 0.115,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "JS中使数组倒序排列",
          "date": "2021-04-13T00:00:00.000Z",
          "categories": "JavaScript常用API",
          "tags": [
            "JavaScript常用API"
          ]
        },
        "prevItem": {
          "title": "JS中some()方法",
          "permalink": "/blog/JS中some()方法"
        },
        "nextItem": {
          "title": "JS中对数组进行排序（sort）",
          "permalink": "/blog/JS中对数组进行排序（sort）"
        }
      },
      "content": "## 使用reverse方法\r\n![](https://img-blog.csdnimg.cn/img_convert/88e5015d4ed640f218b7d1f8a5ffe080.png)\r\n\r\n## 注意：reverse方法会使得原数组发生变化"
    },
    {
      "id": "/JS中对数组进行排序（sort）",
      "metadata": {
        "permalink": "/blog/JS中对数组进行排序（sort）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/JS中对数组进行排序（sort）.md",
        "source": "@site/blog\\JS中对数组进行排序（sort）.md",
        "title": "JS中对数组进行排序（sort）",
        "description": "使用sort方法对字符串数组进行排序",
        "date": "2021-04-13T00:00:00.000Z",
        "formattedDate": "2021年4月13日",
        "tags": [
          {
            "label": "JavaScript常用API",
            "permalink": "/blog/tags/java-script常用-api"
          }
        ],
        "readingTime": 0.35,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "JS中对数组进行排序（sort）",
          "date": "2021-04-13T00:00:00.000Z",
          "categories": "JavaScript常用API",
          "tags": [
            "JavaScript常用API"
          ]
        },
        "prevItem": {
          "title": "JS中使数组倒序排列",
          "permalink": "/blog/JS中使数组倒序排列"
        },
        "nextItem": {
          "title": "JS中给数组中间添加元素的方法",
          "permalink": "/blog/JS中给数组中间添加元素的方法"
        }
      },
      "content": "## 使用sort方法对字符串数组进行排序\r\n![](https://img-blog.csdnimg.cn/img_convert/d236509e79092289109d5c01a9092b97.png)\r\n\r\n## 不推荐使用sort方法直接对全部是数字的数组进行排序\r\n![](https://img-blog.csdnimg.cn/img_convert/13f7382125534d14ef2fb573a9c9fcad.png)\r\n\r\n## 通过给sort传递回调函数可以使得sort方法对数字数组进行排序\r\n![](https://img-blog.csdnimg.cn/img_convert/c867387cc5922a07c12f2468874447b1.png)"
    },
    {
      "id": "/JS中给数组中间添加元素的方法",
      "metadata": {
        "permalink": "/blog/JS中给数组中间添加元素的方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/JS中给数组中间添加元素的方法.md",
        "source": "@site/blog\\JS中给数组中间添加元素的方法.md",
        "title": "JS中给数组中间添加元素的方法",
        "description": "使用拓展运算符结合splice方法",
        "date": "2021-04-13T00:00:00.000Z",
        "formattedDate": "2021年4月13日",
        "tags": [
          {
            "label": "JavaScript常用API",
            "permalink": "/blog/tags/java-script常用-api"
          }
        ],
        "readingTime": 0.075,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "JS中给数组中间添加元素的方法",
          "date": "2021-04-13T00:00:00.000Z",
          "categories": "JavaScript常用API",
          "tags": [
            "JavaScript常用API"
          ]
        },
        "prevItem": {
          "title": "JS中对数组进行排序（sort）",
          "permalink": "/blog/JS中对数组进行排序（sort）"
        },
        "nextItem": {
          "title": "javascript中的splice方法与slice方法的区别",
          "permalink": "/blog/javascript中的splice方法与slice方法的区别"
        }
      },
      "content": "## 使用拓展运算符结合splice方法\r\n![](https://img-blog.csdnimg.cn/img_convert/b6bde236964663312ac30e1c14e71778.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/a6dd7bf3569ca187cae5a7232dda6b60.png)"
    },
    {
      "id": "/javascript中的splice方法与slice方法的区别",
      "metadata": {
        "permalink": "/blog/javascript中的splice方法与slice方法的区别",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/javascript中的splice方法与slice方法的区别.md",
        "source": "@site/blog\\javascript中的splice方法与slice方法的区别.md",
        "title": "javascript中的splice方法与slice方法的区别",
        "description": "区别1：splice方法会对原数组产生修改，slice方法不会",
        "date": "2021-04-12T00:00:00.000Z",
        "formattedDate": "2021年4月12日",
        "tags": [
          {
            "label": "JavaScript常用API",
            "permalink": "/blog/tags/java-script常用-api"
          }
        ],
        "readingTime": 0.31,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "javascript中的splice方法与slice方法的区别",
          "date": "2021-04-12T00:00:00.000Z",
          "categories": "JavaScript常用API",
          "tags": [
            "JavaScript常用API"
          ]
        },
        "prevItem": {
          "title": "JS中给数组中间添加元素的方法",
          "permalink": "/blog/JS中给数组中间添加元素的方法"
        },
        "nextItem": {
          "title": "React中使用nanoid生成唯一的id",
          "permalink": "/blog/React中使用nanoid生成唯一的id"
        }
      },
      "content": "## 区别1：splice方法会对原数组产生修改，slice方法不会\r\n![](https://img-blog.csdnimg.cn/img_convert/74962f02c1fd0f4cbf560556a2ee2833.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/e812337b12120b37e12156dcb9380e40.png)\r\n\r\n## 区别2：splice的第二个参数代表的是个数，但是slice的第二个参数代表的是区间（包含左边不包含右边）"
    },
    {
      "id": "/React中使用nanoid生成唯一的id",
      "metadata": {
        "permalink": "/blog/React中使用nanoid生成唯一的id",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React中使用nanoid生成唯一的id.md",
        "source": "@site/blog\\React中使用nanoid生成唯一的id.md",
        "title": "React中使用nanoid生成唯一的id",
        "description": "安装nanoid工具包",
        "date": "2021-04-12T00:00:00.000Z",
        "formattedDate": "2021年4月12日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.16,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React中使用nanoid生成唯一的id",
          "date": "2021-04-12T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "javascript中的splice方法与slice方法的区别",
          "permalink": "/blog/javascript中的splice方法与slice方法的区别"
        },
        "nextItem": {
          "title": "剑指Offer——重建二叉树（JS实现）",
          "permalink": "/blog/剑指Offer——重建二叉树（JS实现）"
        }
      },
      "content": "## 安装nanoid工具包\r\n`\r\nnpm i nanoid\r\n`\r\n## 导入模块\r\nimport {nanoid} from 'nanoid';\r\n\r\n## 使用nanoid生成不重复的id\r\n![](https://img-blog.csdnimg.cn/img_convert/3d9bc760bd2f7b12123e13a18d16d6ad.png)"
    },
    {
      "id": "/剑指Offer——重建二叉树（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——重建二叉树（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——重建二叉树（JS实现）.md",
        "source": "@site/blog\\剑指Offer——重建二叉树（JS实现）.md",
        "title": "剑指Offer——重建二叉树（JS实现）",
        "description": "题目描述",
        "date": "2021-04-12T00:00:00.000Z",
        "formattedDate": "2021年4月12日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.085,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——重建二叉树（JS实现）",
          "date": "2021-04-12T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "React中使用nanoid生成唯一的id",
          "permalink": "/blog/React中使用nanoid生成唯一的id"
        },
        "nextItem": {
          "title": "数据结构基础——队列",
          "permalink": "/blog/数据结构基础——队列"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/28e0b7455f40ae12495741b4cc2d4868.png)\r\n\r\n## 解题思路\r\n* 首先我们要明白遍历规则。\r\n* 前序遍历指的是根>左>右\r\n* 中序遍历指的是左>根>右\r\n* 使用递归遍历的思想，首先定义递归结束条件，如果输入的列表只有一个元素，则直接返回这个树节点。\r\n* 让前序遍历数组的第一个元素作为根节点。\r\n* 定义变量i用来分割中序遍历数组中的左右子树，这个i就是根节点在中序遍历数组中的下标。\r\n* 两个参数，可以分别理解为子树的前序遍历和中序遍历\r\n\r\n## 实现代码\r\n```js\r\nvar buildTree = function (preorder, inorder) {\r\n    if (preorder.length === 0 || inorder.length === 0) {\r\n        return null;\r\n    }\r\n    if (preorder.length === 1) {\r\n        return new TreeNode(preorder[0]);\r\n    }\r\n    let root = new TreeNode(preorder[0]);\r\n    let i = inorder.indexOf(preorder[0]);\r\n    root.left = buildTree(preorder.slice(1,i+1),inorder.slice(0,i));\r\n    root.right = buildTree(preorder.slice(i+1),inorder.slice(i+1));\r\n\r\n    return root;\r\n};\r\n```"
    },
    {
      "id": "/数据结构基础——队列",
      "metadata": {
        "permalink": "/blog/数据结构基础——队列",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/数据结构基础——队列.md",
        "source": "@site/blog\\数据结构基础——队列.md",
        "title": "数据结构基础——队列",
        "description": "队列的特点",
        "date": "2021-04-12T00:00:00.000Z",
        "formattedDate": "2021年4月12日",
        "tags": [
          {
            "label": "数据结构与算法",
            "permalink": "/blog/tags/数据结构与算法"
          }
        ],
        "readingTime": 0.53,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "数据结构基础——队列",
          "date": "2021-04-12T00:00:00.000Z",
          "categories": "数据结构与算法",
          "tags": [
            "数据结构与算法"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——重建二叉树（JS实现）",
          "permalink": "/blog/剑指Offer——重建二叉树（JS实现）"
        },
        "nextItem": {
          "title": "React-19：初始化React脚手架",
          "permalink": "/blog/React-19：初始化React脚手架"
        }
      },
      "content": "## 队列的特点\r\n* 先进先出\r\n\r\n## 在JavaScript中使用数组来模拟队列\r\n![](https://img-blog.csdnimg.cn/img_convert/19f44b1208081d6f31faeb0ba6416527.png)\r\n\r\n## 使用队列的场景\r\n* JS异步中的任务队列\r\n![](https://img-blog.csdnimg.cn/img_convert/5cec78a65850bdd1397b83c1ddb665c5.png)\r\n* 计算最近请求次数\r\n![](https://img-blog.csdnimg.cn/img_convert/a17293e47aefb19695c221d7db5bf17f.png)\r\n\r\n## 队列的典型习题\r\n![](https://img-blog.csdnimg.cn/img_convert/ee258559a08366adaf338a98231984fc.png)\r\n\r\n## 实现代码\r\n```js\r\nvar RecentCounter = function () {\r\n    this.arr = [];\r\n    this.result = [];\r\n};\r\n\r\n\r\nRecentCounter.prototype.ping = function (t) {\r\n\r\n    // 新ping的元素入队\r\n    this.arr.push(t);\r\n    while (this.arr[0] < t - 3000) {\r\n        this.arr.shift();\r\n    }\r\n\r\n    return this.arr.length;\r\n};\r\n```"
    },
    {
      "id": "/React-19：初始化React脚手架",
      "metadata": {
        "permalink": "/blog/React-19：初始化React脚手架",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-19：初始化React脚手架.md",
        "source": "@site/blog\\React-19：初始化React脚手架.md",
        "title": "React-19：初始化React脚手架",
        "description": "安装流程",
        "date": "2021-04-11T00:00:00.000Z",
        "formattedDate": "2021年4月11日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.805,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-19：初始化React脚手架",
          "date": "2021-04-11T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "数据结构基础——队列",
          "permalink": "/blog/数据结构基础——队列"
        },
        "nextItem": {
          "title": "剑指Offer——二叉树的最近公共祖先（JS实现）",
          "permalink": "/blog/剑指Offer——二叉树的最近公共祖先（JS实现）"
        }
      },
      "content": "## 安装流程\r\n1. npm i -g create-react-app\r\n2. create-react-app react_staging  （名字可以自己起）\r\n3. npm start (开启项目)\r\n\r\n## 使用React脚手架实现Hello组件\r\n### public下的index.html\r\n* 这个文件主要是一个id为root的容器，用来存放React渲染的组件。\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/cb46e325c6a7b8d6020b2974c1443e39.png)\r\n\r\n### 入口文件index.js\r\n* 这个文件是一个入口文件，这个文件主要负责，引入React核心库，React-dom库，以及引入App.js文件\r\n* App.js是所有组件的外壳。\r\n* 在index.js文件下可以直接通过DOM操作public下的index.html文件，因为底层React已经帮我们实现。\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/7b40936f56240f01ecf80b43eb368b48.png)\r\n\r\n### 外壳文件App.js\r\n![](https://img-blog.csdnimg.cn/img_convert/7baa7111e19c2c1f4438b15b447bde7c.png)"
    },
    {
      "id": "/剑指Offer——二叉树的最近公共祖先（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——二叉树的最近公共祖先（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——二叉树的最近公共祖先（JS实现）.md",
        "source": "@site/blog\\剑指Offer——二叉树的最近公共祖先（JS实现）.md",
        "title": "剑指Offer——二叉树的最近公共祖先（JS实现）",
        "description": "题目描述",
        "date": "2021-04-11T00:00:00.000Z",
        "formattedDate": "2021年4月11日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.75,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——二叉树的最近公共祖先（JS实现）",
          "date": "2021-04-11T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "React-19：初始化React脚手架",
          "permalink": "/blog/React-19：初始化React脚手架"
        },
        "nextItem": {
          "title": "剑指Offer——和为S的连续正数序列（JS实现）",
          "permalink": "/blog/剑指Offer——和为S的连续正数序列（JS实现）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/f856687e8f17daf96eb8ddb3f6110d3e.png)\r\n\r\n## 解题思路\r\n* 使用DFS的遍历思想进行遍历二叉树\r\n* 如果为空节点或p节点或q节点，直接返回该节点\r\n* 遍历的时候，看返回值，如果p和q都存在就返回当前的root节点，如果只有一个存在就反返回不为空的节点。\r\n\r\n## 实现代码\r\n```js\r\nvar lowestCommonAncestor = function(root, p, q) {\r\n    if (root === null || root === p || root === q) {\r\n        return root;\r\n    }\r\n\r\n    let x = lowestCommonAncestor(root.left,p,q);\r\n    let y = lowestCommonAncestor(root.right,p,q);\r\n\r\n    if (x && y) {\r\n        return root;\r\n    } else {\r\n        return x || y;   // 返回存在的那一个\r\n    }\r\n};\r\n```"
    },
    {
      "id": "/剑指Offer——和为S的连续正数序列（JS实现）",
      "metadata": {
        "permalink": "/blog/剑指Offer——和为S的连续正数序列（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/剑指Offer——和为S的连续正数序列（JS实现）.md",
        "source": "@site/blog\\剑指Offer——和为S的连续正数序列（JS实现）.md",
        "title": "剑指Offer——和为S的连续正数序列（JS实现）",
        "description": "题目描述",
        "date": "2021-04-11T00:00:00.000Z",
        "formattedDate": "2021年4月11日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.27,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "剑指Offer——和为S的连续正数序列（JS实现）",
          "date": "2021-04-11T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——二叉树的最近公共祖先（JS实现）",
          "permalink": "/blog/剑指Offer——二叉树的最近公共祖先（JS实现）"
        },
        "nextItem": {
          "title": "数据结构基础——栈",
          "permalink": "/blog/数据结构基础——栈"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/e6cd56aed76951447dcf0c5c0bb76bd8.png)\r\n\r\n## 解题思路\r\n* 使用left和right两个变量来代替滑动窗口的左边界和右边界。\r\n* 核心while循环的条件是：只要左边界 小于 目标值的一半就要进入循环，只要不小于循环结束，说明此时已经找到完了。\r\n* 定义temp变量，用来存放滑动窗口中的所有元素的和。\r\n* 当temp小于target的值的时候，右边界向右扩一个。\r\n* 当temp大于target的时候，左边向右一个\r\n\r\n## 实现代码\r\n```js\r\nvar findContinuousSequence = function(target) {\r\n    let left = 1;\r\n    let right = 1;\r\n    let arr = [];\r\n    let temp = 0;\r\n    // 下面的这个result数组是用来返回的\r\n    let result = [];\r\n    // 核心判断条件是当 left >= target/2 的时候 left + tight >= target\r\n    while (left < (target/2)) {\r\n        while (temp < target) {\r\n            temp = temp + right;\r\n            arr.push(right);\r\n            right += 1;\r\n        }\r\n        while (temp > target) {\r\n            temp = temp - left;\r\n            arr.shift();\r\n            left += 1;\r\n        }\r\n        if (target === temp) {\r\n            temp = temp - left;\r\n            left++;\r\n            result.push([...arr]);\r\n            arr.shift();\r\n        }\r\n    }\r\n    return result;\r\n};\r\n```"
    },
    {
      "id": "/数据结构基础——栈",
      "metadata": {
        "permalink": "/blog/数据结构基础——栈",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/数据结构基础——栈.md",
        "source": "@site/blog\\数据结构基础——栈.md",
        "title": "数据结构基础——栈",
        "description": "栈的特点",
        "date": "2021-04-11T00:00:00.000Z",
        "formattedDate": "2021年4月11日",
        "tags": [
          {
            "label": "数据结构与算法",
            "permalink": "/blog/tags/数据结构与算法"
          }
        ],
        "readingTime": 0.585,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "数据结构基础——栈",
          "date": "2021-04-11T00:00:00.000Z",
          "categories": "数据结构与算法",
          "tags": [
            "数据结构与算法"
          ]
        },
        "prevItem": {
          "title": "剑指Offer——和为S的连续正数序列（JS实现）",
          "permalink": "/blog/剑指Offer——和为S的连续正数序列（JS实现）"
        },
        "nextItem": {
          "title": "LeetCode——数组中数字出现的次数（JS实现）",
          "permalink": "/blog/LeetCode——数组中数字出现的次数（JS实现）"
        }
      },
      "content": "## 栈的特点\r\n* 先进后出\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/88fb3fe8f8fe9e9c2ed4dd2c5c94fee0.png)\r\n\r\n## JS中使用数组模拟栈\r\n```js\r\n// 栈——数据结构\r\n// 在JS中使用数组来模拟栈\r\nconst stack = [];\r\n// 入栈使用push\r\nstack.push(1);   // 1比2先入栈\r\nstack.push(2);\r\n// 出栈使用pop()\r\nconst item1 = stack.pop();\r\nconst item2 = stack.pop();\r\n\r\n```\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/1b274931231023ed40ee98de2efb1011.png)\r\n## 栈的应用场景\r\n* 函数调用栈：最后被调用的函数反而最先被执行。\r\n* LeetCode：有效的括号，栈空说明是有效的括号。"
    },
    {
      "id": "/LeetCode——数组中数字出现的次数（JS实现）",
      "metadata": {
        "permalink": "/blog/LeetCode——数组中数字出现的次数（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——数组中数字出现的次数（JS实现）.md",
        "source": "@site/blog\\LeetCode——数组中数字出现的次数（JS实现）.md",
        "title": "LeetCode——数组中数字出现的次数（JS实现）",
        "description": "题目描述",
        "date": "2021-04-10T00:00:00.000Z",
        "formattedDate": "2021年4月10日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 3.775,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "LeetCode——数组中数字出现的次数（JS实现）",
          "date": "2021-04-10T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "数据结构基础——栈",
          "permalink": "/blog/数据结构基础——栈"
        },
        "nextItem": {
          "title": "React-18：DOM的diffing算法",
          "permalink": "/blog/React-18：DOM的diffing算法"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/9ba47653d6d34345db5420b0183acb61.png)\r\n\r\n## 解题思路\r\n### 思路一：使用哈希表（空间复杂度不满足）\r\n* 将键表示为数组的元素，值表示为出现的次数\r\n\r\n```js\r\n// 方法1：使用Map数据结构\r\nvar singleNumbers = function(nums) {\r\n    const m = new Map();\r\n    for (let v of nums) {\r\n        if (m.has(v)) {\r\n            m.set(v,m.get(v) + 1)\r\n        } else {\r\n            m.set(v,1);\r\n        }\r\n    }\r\n    result = [];\r\n    for (let v of m) {\r\n        if (v[1] === 1) {\r\n            result.push(v[0])\r\n        }\r\n    }\r\n    console.log(result);\r\n    return result;\r\n};\r\n```\r\n### 思路2：使用位运算（多个for循环：不满足空间复杂度的要求）\r\n* 因为题目中说了除了两个数字出现一次外，其余数字都出现了两次，凡是出现了两次，做异或运算都为0，所以全部进行遍历异或得到的值一定是那两个只出现一次的数字。\r\n* 我们根据全部遍历异或的到的结果比如是0111，从最后一位1可以看出，这两个只出现1次的数字的最后一位一定是不同的，所以我们根据这个特征来进行分组。\r\n* 最后一位为1的分为1组，为0的分为1组。\r\n* 两个组分别进行异或，得到的值然后返回就是最终的结果。可以在纸上演算下。\r\n\r\n```js\r\n// 使用位运算的方法\r\nvar singleNumbers = function(nums) {\r\n    let temp = 0;\r\n    let temp2 = 0;\r\n    let temp3 = 0;\r\n    for (let v of nums) {\r\n        temp = temp ^ v;\r\n    }\r\n    let temp1 = temp.toString(2);\r\n    let flag = 1;\r\n    for (let i = temp1.length-1;i >= 0;i--) {\r\n        console.log(temp1[i]);\r\n        if (temp1[i] === '0') {\r\n            flag = flag + 1;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    // 遍历每个数组，将数组中的值转为二进制\r\n    const result = []\r\n    for (let v of nums) {\r\n        result.push(v.toString(2));\r\n    }\r\n    console.log(result);\r\n    let arr1 = [];\r\n    let arr2 = [];\r\n    for (let v of result) {\r\n        if (v[v.length-flag] === '1') {\r\n            arr1.push(v);\r\n        } else {\r\n            arr2.push(v);\r\n        }\r\n    }\r\n    console.log(flag);\r\n    console.log(arr1);\r\n    console.log(arr2);\r\n    for (let i in arr1) {\r\n        arr1[i] = parseInt(arr1[i],2)\r\n    }\r\n    for (let i in arr2) {\r\n        arr2[i] = parseInt(arr2[i],2)\r\n    }\r\n    console.log(arr1);\r\n    console.log(arr2);\r\n    for (let v of arr1) {\r\n        temp2 = temp2 ^ v;\r\n    }\r\n    for (let v of arr2) {\r\n        temp3 = temp3 ^ v;\r\n    }\r\n    console.log(temp2,temp3);\r\n    return [temp2,temp3];\r\n};\r\n```\r\n## 最终解决方案（符合题目要求）\r\n* 使用位运算\r\n\r\n1. 首先让数组的所有元素依次进行异或运算，得到的值从右往左第一个1的位置就是两个只出现1次元素的不同的位置。\r\n2. 使用变量记录从右往左第一个1的位置。\r\n3. 将第二步得到的变量与数组中的每个元素进行与运算，可以将上述的数组分为两组\r\n4. 这两组分别进行全体异或，得到两个值然后返回就是题目要的只出现一次的数字。\r\n\r\n## 代码\r\n```js\r\nvar singleNumbers = function(nums) {\r\n    let temp = 0;\r\n    let a = 0;\r\n    let b = 0;\r\n    for (let v of nums) {\r\n        temp = temp ^ v;\r\n    }\r\n    console.log(temp);\r\n    // 判断从右往左第几位是1\r\n    let One_Location = 1;\r\n    while ((temp & One_Location) === 0) {\r\n        One_Location = One_Location << 1;\r\n    }\r\n    for (let v of nums) {\r\n        if ((One_Location & v) === 0) {\r\n            a = a ^ v;\r\n        } else {\r\n            b = b ^ v;\r\n        }\r\n    };\r\n    return [a,b];\r\n};\r\n```"
    },
    {
      "id": "/React-18：DOM的diffing算法",
      "metadata": {
        "permalink": "/blog/React-18：DOM的diffing算法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-18：DOM的diffing算法.md",
        "source": "@site/blog\\React-18：DOM的diffing算法.md",
        "title": "React-18：DOM的diffing算法",
        "description": "DOM的diffing算法只渲染更新的部分",
        "date": "2021-04-10T00:00:00.000Z",
        "formattedDate": "2021年4月10日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.145,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-18：DOM的diffing算法",
          "date": "2021-04-10T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "LeetCode——数组中数字出现的次数（JS实现）",
          "permalink": "/blog/LeetCode——数组中数字出现的次数（JS实现）"
        },
        "nextItem": {
          "title": "VSCode中快速打开命令行终端的快捷键",
          "permalink": "/blog/VSCode中快速打开命令行终端的快捷键"
        }
      },
      "content": "## DOM的diffing算法只渲染更新的部分\r\n![](https://img-blog.csdnimg.cn/img_convert/15b5df3f716de4405c43a9cf6695ea44.png)\r\n\r\n## 使用index索引值作为key的弊端\r\n![](https://img-blog.csdnimg.cn/img_convert/8bc8d62afcb0630a78aebe8e7a0f6197.png)"
    },
    {
      "id": "/VSCode中快速打开命令行终端的快捷键",
      "metadata": {
        "permalink": "/blog/VSCode中快速打开命令行终端的快捷键",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/VSCode中快速打开命令行终端的快捷键.md",
        "source": "@site/blog\\VSCode中快速打开命令行终端的快捷键.md",
        "title": "VSCode中快速打开命令行终端的快捷键",
        "description": "快捷键",
        "date": "2021-04-10T00:00:00.000Z",
        "formattedDate": "2021年4月10日",
        "tags": [
          {
            "label": "VSCode",
            "permalink": "/blog/tags/vs-code"
          }
        ],
        "readingTime": 0.165,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "VSCode中快速打开命令行终端的快捷键",
          "date": "2021-04-10T00:00:00.000Z",
          "categories": "VSCode",
          "tags": [
            "VSCode"
          ]
        },
        "prevItem": {
          "title": "React-18：DOM的diffing算法",
          "permalink": "/blog/React-18：DOM的diffing算法"
        },
        "nextItem": {
          "title": "给npm换成国内源，提高creat-react-app的安装速度",
          "permalink": "/blog/给npm换成国内源，提高creat-react-app的安装速度"
        }
      },
      "content": "## 快捷键\r\n` Ctrl+ Tab键上面的那个模板字符串用的 `\r\n![](https://img-blog.csdnimg.cn/img_convert/acfbe102c2c5ccc7d439a7bbe44e6d96.png)\r\n\r\n## 实现快速打开VSCode终端命令行"
    },
    {
      "id": "/给npm换成国内源，提高creat-react-app的安装速度",
      "metadata": {
        "permalink": "/blog/给npm换成国内源，提高creat-react-app的安装速度",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/给npm换成国内源，提高creat-react-app的安装速度.md",
        "source": "@site/blog\\给npm换成国内源，提高creat-react-app的安装速度.md",
        "title": "给npm换成国内源，提高creat-react-app的安装速度",
        "description": "通过命令行输入下面代码",
        "date": "2021-04-10T00:00:00.000Z",
        "formattedDate": "2021年4月10日",
        "tags": [
          {
            "label": "npm",
            "permalink": "/blog/tags/npm"
          }
        ],
        "readingTime": 0.265,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "给npm换成国内源，提高creat-react-app的安装速度",
          "date": "2021-04-10T00:00:00.000Z",
          "categories": "npm",
          "tags": [
            "npm"
          ]
        },
        "prevItem": {
          "title": "VSCode中快速打开命令行终端的快捷键",
          "permalink": "/blog/VSCode中快速打开命令行终端的快捷键"
        },
        "nextItem": {
          "title": "LeetCode——合并两个排序的链表（JS实现）",
          "permalink": "/blog/LeetCode——合并两个排序的链表（JS实现）"
        }
      },
      "content": "## 通过命令行输入下面代码\r\n```\r\nnpm config set registry https://registry.npm.taobao.org\r\n-- 配置后可通过下面方式来验证是否成功\r\nnpm config get registry\r\n```\r\n## 参考文献\r\n[create-react-app慢的解决方法](https://www.jianshu.com/p/cffd2d6aa72e)"
    },
    {
      "id": "/LeetCode——合并两个排序的链表（JS实现）",
      "metadata": {
        "permalink": "/blog/LeetCode——合并两个排序的链表（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——合并两个排序的链表（JS实现）.md",
        "source": "@site/blog\\LeetCode——合并两个排序的链表（JS实现）.md",
        "title": "LeetCode——合并两个排序的链表（JS实现）",
        "description": "题目描述",
        "date": "2021-04-09T00:00:00.000Z",
        "formattedDate": "2021年4月9日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.18,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "LeetCode——合并两个排序的链表（JS实现）",
          "date": "2021-04-09T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "给npm换成国内源，提高creat-react-app的安装速度",
          "permalink": "/blog/给npm换成国内源，提高creat-react-app的安装速度"
        },
        "nextItem": {
          "title": "LeetCode——复杂链表的复制（JS实现）",
          "permalink": "/blog/LeetCode——复杂链表的复制（JS实现）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/615bcca73cd8341eb6a92718d15c9128.png)\r\n\r\n## 解题思路\r\n* 创建一个新的链表节点newNode\r\n* 指定一个临时指针h指向这个新的节点newNode\r\n* 使用while循环，在条件为L1和L2都不为空的条件下遍历，如果L1当前数据域的值小，就让newNode指向L1，反之指向L2\r\n* while循环遍历完之后，如果L1和L2谁还有剩余，谁就加到newNode的尾部。\r\n* 最后返回的是h临时指针的next域，因为h临时指针刚开始指向的是我们新创建的节点。\r\n\r\n## 实现代码\r\n```js\r\nvar mergeTwoLists = function(l1, l2) {\r\n    // 首先创建一个新的节点\r\n    let newNode = new ListNode();\r\n    const h = newNode;\r\n    // 循环遍历两个列表\r\n    while (l1 && l2) {\r\n        if (l1.val < l2.val) {\r\n            newNode.next = l1;\r\n            l1 = l1.next;\r\n            newNode = newNode.next;\r\n        } else {\r\n            newNode.next = l2;\r\n            l2 = l2.next;\r\n            newNode = newNode.next;\r\n        }\r\n    } \r\n    if (l1) newNode.next = l1;\r\n    if (l2) newNode.next = l2;\r\n    return h.next;\r\n};\r\n```"
    },
    {
      "id": "/LeetCode——复杂链表的复制（JS实现）",
      "metadata": {
        "permalink": "/blog/LeetCode——复杂链表的复制（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——复杂链表的复制（JS实现）.md",
        "source": "@site/blog\\LeetCode——复杂链表的复制（JS实现）.md",
        "title": "LeetCode——复杂链表的复制（JS实现）",
        "description": "题目描述",
        "date": "2021-04-09T00:00:00.000Z",
        "formattedDate": "2021年4月9日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.305,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "LeetCode——复杂链表的复制（JS实现）",
          "date": "2021-04-09T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "LeetCode——合并两个排序的链表（JS实现）",
          "permalink": "/blog/LeetCode——合并两个排序的链表（JS实现）"
        },
        "nextItem": {
          "title": "LeetCode——用两个栈实现队列（JS实现）",
          "permalink": "/blog/LeetCode——用两个栈实现队列（JS实现）"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/7c662a149351fdfcc552b7753e3b9c36.png)\r\n\r\n## 解题思路\r\n* 使用Map数据结构来进行赋值\r\n* 键存放指向节点的指针\r\n* 值存放new Node\r\n* 第一次循环构建Map数据结构\r\n* 第二次循环给值的next域和random域进行赋值\r\n* 记住一点：这里的值的next域和random域不能指向node的节点，只能指向map数据结构中的值的节点\r\n\r\n## 实现代码\r\n```js\r\nvar copyRandomList = function(head) {\r\n\r\n    // 首先创建一个Map，键用来存储head指针域，值用来存储复制的节点\r\n    let node = head;\r\n    const m = new Map();\r\n\r\n    // 遍历现有链表\r\n    while (node) {\r\n        m.set(node,new Node(node.val));\r\n        node = node.next;\r\n    }\r\n    // 到这里，链表的键已经存放的是指针，值存放的是next域和random域为空，值为指针所指的val\r\n    // 让node重新指向head\r\n    node = head;\r\n    // 第二次遍历，给Map数据结构中的值，添加上next域和random域\r\n    while (node) {\r\n        m.get(node).next = node.next ? m.get(node.next):null;\r\n        m.get(node).random = node.random ? m.get(node.random):null;\r\n        node = node.next;\r\n    }\r\n    node = head;\r\n    return m.get(node);\r\n\r\n};\r\n```"
    },
    {
      "id": "/LeetCode——用两个栈实现队列（JS实现）",
      "metadata": {
        "permalink": "/blog/LeetCode——用两个栈实现队列（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——用两个栈实现队列（JS实现）.md",
        "source": "@site/blog\\LeetCode——用两个栈实现队列（JS实现）.md",
        "title": "LeetCode——用两个栈实现队列（JS实现）",
        "description": "题目描述",
        "date": "2021-04-09T00:00:00.000Z",
        "formattedDate": "2021年4月9日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.24,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "LeetCode——用两个栈实现队列（JS实现）",
          "date": "2021-04-09T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "LeetCode——复杂链表的复制（JS实现）",
          "permalink": "/blog/LeetCode——复杂链表的复制（JS实现）"
        },
        "nextItem": {
          "title": "React-16：函数柯里化",
          "permalink": "/blog/React-16：函数柯里化"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/de018b5a8df68917469193e598483a3a.png)\r\n\r\n## 解题思路\r\n* \t使用两个数组进行初始化\r\n* 一个数组存储入队操作\r\n* 一个数组存储出队操作\r\n* 入队函数将系统输入的值push进A数组\r\n* 出队函数首先判断出队数组中是否有元素，如果有则将其pop出\r\n* 如果没有，则将A数组中的元素倒序push进B数组，然后再pop出\r\n\r\n## 实现代码\r\n```js\r\nvar CQueue = function() {\r\n    // 模拟入队\r\n    this.stackA = [];\r\n    // 模拟出队\r\n    this.stackB = [];\r\n};\r\n\r\nCQueue.prototype.appendTail = function(value) {\r\n    console.log(\"系统输入的数据：\",value);\r\n    this.stackA.push(value);\r\n};\r\n\r\nCQueue.prototype.deleteHead = function() {\r\n    // 首先判断出队栈中是否有元素，有则出栈\r\n    if (this.stackB.length) {\r\n        return this.stackB.pop();\r\n    } else {\r\n        // 如果出队栈中没有元素，则判断入队栈中是否有元素\r\n        while (this.stackA.length) {\r\n            // 如果入队栈中有元素，则将入队栈倒序加入到出队栈\r\n            this.stackB.push(this.stackA.pop());\r\n        }\r\n        if (this.stackB.length === 0) {\r\n            return -1;\r\n        } else {\r\n            return this.stackB.pop();\r\n        }\r\n    }\r\n\r\n};\r\n```"
    },
    {
      "id": "/React-16：函数柯里化",
      "metadata": {
        "permalink": "/blog/React-16：函数柯里化",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-16：函数柯里化.md",
        "source": "@site/blog\\React-16：函数柯里化.md",
        "title": "React-16：函数柯里化",
        "description": "对象中调用变量要加[]",
        "date": "2021-04-09T00:00:00.000Z",
        "formattedDate": "2021年4月9日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.42,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-16：函数柯里化",
          "date": "2021-04-09T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "LeetCode——用两个栈实现队列（JS实现）",
          "permalink": "/blog/LeetCode——用两个栈实现队列（JS实现）"
        },
        "nextItem": {
          "title": "React-17：组件的生命周期",
          "permalink": "/blog/React-17：组件的生命周期"
        }
      },
      "content": "## 对象中调用变量要加[]\r\n![](https://img-blog.csdnimg.cn/img_convert/30e9ee3ceb2f1dc6eddc9744bb762029.png)\r\n\r\n## 函数柯里化的概念\r\n* 通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式。\r\n\r\n## 函数柯里化的案例\r\n![](https://img-blog.csdnimg.cn/img_convert/de2da94a95be5c23d75c7df17f467fb4.png)\r\n\r\n## 不使用函数柯里化实现form表单的state更新\r\n![](https://img-blog.csdnimg.cn/img_convert/bce2e6fd24614620626bc468fd3629c6.png)"
    },
    {
      "id": "/React-17：组件的生命周期",
      "metadata": {
        "permalink": "/blog/React-17：组件的生命周期",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-17：组件的生命周期.md",
        "source": "@site/blog\\React-17：组件的生命周期.md",
        "title": "React-17：组件的生命周期",
        "description": "卸载组件",
        "date": "2021-04-09T00:00:00.000Z",
        "formattedDate": "2021年4月9日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 2.995,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-17：组件的生命周期",
          "date": "2021-04-09T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-16：函数柯里化",
          "permalink": "/blog/React-16：函数柯里化"
        },
        "nextItem": {
          "title": "LeetCode——二进制中1的个数（JS实现）",
          "permalink": "/blog/LeetCode——二进制中1的个数（JS实现）"
        }
      },
      "content": "## 卸载组件\r\n```js\r\n ReactDOM.unmountComponentAtNode(document.querySelector('.test'));\r\n```\r\n## 组件挂载完毕\r\n```js\r\ncomponentDidMount() {\r\n    this.timer = setInterval(() => {\r\n        let {opacity} = this.state;\r\n        opacity = opacity - 0.1;\r\n        if (opacity <= 0) opacity = 1;\r\n        this.setState({opacity:opacity})\r\n    },200)\r\n}\r\n```\r\n## 组件将要被卸载\r\n```js\r\n// 组件将要被卸载\r\ncomponentWillUnmount() {\r\n    clearInterval(this.timer)\r\n}\r\n```\r\n## 循环定时器\r\n```js\r\nthis.timer = setInterval(() => {\r\n    let {opacity} = this.state;\r\n    opacity = opacity - 0.1;\r\n    if (opacity <= 0) opacity = 1;\r\n    this.setState({opacity:opacity})\r\n},200)\r\n```\r\n## 组件挂载流程\r\n1. 构造器\r\n2. 将要挂载\r\n3. render\r\n4. 挂载完毕\r\n![](https://img-blog.csdnimg.cn/img_convert/abc12e7762cdc1e82053cbc66a81b9dc.png)\r\n\r\n## setState更新流程\r\n![](https://img-blog.csdnimg.cn/img_convert/5496d2254e0a0f039c98c07182ba144b.png)\r\n\r\n## forceUpdate流程\r\n* 强制更新是不受shouldComponentUpdate这个阀门的限制的，因为不走这个函数过。\r\n![](https://img-blog.csdnimg.cn/img_convert/4cbda59025680ee5d1234793ba69311a.png)\r\n\r\n## 父组件render流程\r\n* componentWillReceiveProps（组件将要接收新的参数的钩子函数），这个钩子函数当传入默认参数的时候不会被触发，只有传入新的参数的时候才会被触发。\r\n![](https://img-blog.csdnimg.cn/img_convert/4ccd10e71b0e4abbffe4875af30ced86.png)\r\n\r\n## 组件的生命周期（旧）\r\n![](https://img-blog.csdnimg.cn/img_convert/e5f381b461e58bb972b53f7700645b91.png)\r\n\r\n## 在新版本中除了componentWillUnmount之外，其余都需要加上UNSAFE_\r\n![](https://img-blog.csdnimg.cn/img_convert/3b8a9fcadcbee05f440cca7a094b19b0.png)\r\n\r\n## 组件的生命周期（新）\r\n![](https://img-blog.csdnimg.cn/img_convert/adc9c46e04bb683ee8d4fe1d4344d865.png)\r\n\r\n## 新旧生命周期的区别在哪里？\r\n* 在新的生命周期中，废弃了旧版本的3个带will的钩子，新提出了2个钩子。\r\n\r\n## getDerivedStateFromProps\r\n* 这个函数前面应加static，因为是静态的。\r\n* 通过这个钩子修改的state，state任何时候都取决于props，其他的函数无法进行修改。\r\n* 只要这个钩子拦着，所有的状态都得听props的。\r\n\r\n## getSnapshotBeforeUpdate与componentDidUpdate协同\r\n![](https://img-blog.csdnimg.cn/img_convert/480a3f1b7385ec00653817e9c5c7c66c.png)\r\n\r\n## getSnapshotBeforeUpdate的使用场景\r\n### 需求：制作新闻滚动盒子，新渲染的新闻始终在上面，滚动条停在一个位置，这个位置的新闻固定不动展示给用户。\r\n* 首先明确两个概念：scroolHeight指的是当前滚动盒子的总高度，scrollTop指的是从盒子的**最底部**出发，向上跳多少高度。\r\n\r\n```js\r\nclass NewsList extends React.Component {\r\n    state = { newsArr: [] };\r\n\r\n    componentDidMount() {\r\n        setInterval(() => {\r\n            const { newsArr } = this.state;\r\n            const news = \"新闻\" + (newsArr.length + 1);\r\n            this.setState({ newsArr: [news, ...newsArr] });\r\n        }, 900)\r\n    }\r\n    getSnapshotBeforeUpdate() {\r\n        // 返回当前list盒子的高度\r\n        return this.refs.list.scrollHeight;\r\n    }\r\n    componentDidUpdate(preProps,preState,height) {\r\n        this.refs.list.scrollTop += this.refs.list.scrollHeight - height;\r\n    }\r\n    render() {\r\n        return (\r\n            <div className=\"list\" ref=\"list\">\r\n                {\r\n                    this.state.newsArr.map((value,index) => {\r\n                        return (\r\n                            <div key={index} className=\"news\">{value}</div>\r\n                        )\r\n                    })\r\n                }\r\n            </div>\r\n        )\r\n    }\r\n}\r\nReactDOM.render(<NewsList />, document.querySelector('.test'));\r\n```\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/4821594351eb411aad0372060c7f2568.gif)\r\n\r\n# 总结：组件的声明周期\r\n* 组件的生命周期，关键还是看懂新的组件生命周期那张图里的流程顺序。"
    },
    {
      "id": "/LeetCode——二进制中1的个数（JS实现）",
      "metadata": {
        "permalink": "/blog/LeetCode——二进制中1的个数（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——二进制中1的个数（JS实现）.md",
        "source": "@site/blog\\LeetCode——二进制中1的个数（JS实现）.md",
        "title": "LeetCode——二进制中1的个数（JS实现）",
        "description": "题目描述",
        "date": "2021-04-08T00:00:00.000Z",
        "formattedDate": "2021年4月8日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.43,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "LeetCode——二进制中1的个数（JS实现）",
          "date": "2021-04-08T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "React-17：组件的生命周期",
          "permalink": "/blog/React-17：组件的生命周期"
        },
        "nextItem": {
          "title": "React-13：组件实例的三大核心属性之refs",
          "permalink": "/blog/React-13：组件实例的三大核心属性之refs"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/0d27a90fe2d1103451628819e6772388.png)\r\n\r\n## 解题思路\r\n* 将输入的二进制串转换为二进制字符串\r\n* 使用for循环，遍历其中1的个数\r\n* 返回1的个数。\r\n\r\n## 实现代码\r\n```js\r\nvar hammingWeight = function(n) {\r\n\r\n    let str = n.toString(2)\r\n    let flag = 0;\r\n    for (let v of str) {\r\n        if (v === '1') {\r\n            flag += 1;\r\n        }\r\n    }\r\n    console.log(flag);\r\n    return flag;\r\n};\r\n```"
    },
    {
      "id": "/React-13：组件实例的三大核心属性之refs",
      "metadata": {
        "permalink": "/blog/React-13：组件实例的三大核心属性之refs",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-13：组件实例的三大核心属性之refs.md",
        "source": "@site/blog\\React-13：组件实例的三大核心属性之refs.md",
        "title": "React-13：组件实例的三大核心属性之refs",
        "description": "refs有什么作用？",
        "date": "2021-04-08T00:00:00.000Z",
        "formattedDate": "2021年4月8日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 1.155,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-13：组件实例的三大核心属性之refs",
          "date": "2021-04-08T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "LeetCode——二进制中1的个数（JS实现）",
          "permalink": "/blog/LeetCode——二进制中1的个数（JS实现）"
        },
        "nextItem": {
          "title": "React-14：React中的事件处理",
          "permalink": "/blog/React-14：React中的事件处理"
        }
      },
      "content": "## refs有什么作用？\r\n* 可以理解为充当JSX用法标签中的标识符，为了区分和定位JSX标签用的。\r\n![](https://img-blog.csdnimg.cn/img_convert/9a9e87d18e7f646349202a0a6a1d6b9e.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/7943419efc083c0ec15ecb5a2c4ad25e.png)\r\n\r\n## 回调形式的ref\r\n* 注意：通过回调形式的ref，标识符是直接添加到类的实例对象上的，而不是refs\r\n![](https://img-blog.csdnimg.cn/img_convert/7fdb4451db77254b877da751a9052045.png)\r\n\r\n## ref中的回调函数执行的次数\r\n* 如果ref中的回调函数是内联函数的形式的话，当更新状态时，这个函数会被执行两次，第一次传入null,第二次才回传入当前节点的信息。\r\n![](https://img-blog.csdnimg.cn/img_convert/c0159cd4daac7a0ed163cccae0e7b67d.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/9b61005a2e7e7b1657ea5928e8be2ba3.png)\r\n\r\n## JSX语法中如何进行注释？\r\n* 通过{/*    */}的方法进行注释\r\n\r\n## 类绑定中的ref回调只在初始化的时候执行一次\r\n![](https://img-blog.csdnimg.cn/img_convert/6874a729dee0bfbe7adf94cca60c65e2.png)\r\n\r\n## 使用React.createRef创建ref\r\n* 使用这个API创建的ref容器中，只能存放一个标签，新标签会覆盖原有的。\r\n* 基础用法\r\n![](https://img-blog.csdnimg.cn/img_convert/1da7398a0637bdbbb8eafddd2e214cd1.png)"
    },
    {
      "id": "/React-14：React中的事件处理",
      "metadata": {
        "permalink": "/blog/React-14：React中的事件处理",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-14：React中的事件处理.md",
        "source": "@site/blog\\React-14：React中的事件处理.md",
        "title": "React-14：React中的事件处理",
        "description": "通过onXxx指定事件处理函数",
        "date": "2021-04-08T00:00:00.000Z",
        "formattedDate": "2021年4月8日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.26,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-14：React中的事件处理",
          "date": "2021-04-08T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-13：组件实例的三大核心属性之refs",
          "permalink": "/blog/React-13：组件实例的三大核心属性之refs"
        },
        "nextItem": {
          "title": "React-15：受控组件与非受控组件",
          "permalink": "/blog/React-15：受控组件与非受控组件"
        }
      },
      "content": "## 通过onXxx指定事件处理函数\r\n* 注意：React重新封装了类似于点击等onClick函数，注意大小写\r\n![](https://img-blog.csdnimg.cn/img_convert/e39a617ad17de1711fedab3b6b3e89b7.png)\r\n\r\n## 通过event.target得到发生事件的DOM元素对象\r\n![](https://img-blog.csdnimg.cn/img_convert/94e4933e080d819f010c0706409fe35a.png)"
    },
    {
      "id": "/React-15：受控组件与非受控组件",
      "metadata": {
        "permalink": "/blog/React-15：受控组件与非受控组件",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-15：受控组件与非受控组件.md",
        "source": "@site/blog\\React-15：受控组件与非受控组件.md",
        "title": "React-15：受控组件与非受控组件",
        "description": "阻止默认表单事件",
        "date": "2021-04-08T00:00:00.000Z",
        "formattedDate": "2021年4月8日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.55,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-15：受控组件与非受控组件",
          "date": "2021-04-08T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-14：React中的事件处理",
          "permalink": "/blog/React-14：React中的事件处理"
        },
        "nextItem": {
          "title": "LeetCode——翻转链表（JS实现）",
          "permalink": "/blog/LeetCode——翻转链表（JS实现）"
        }
      },
      "content": "## 阻止默认表单事件\r\n![](https://img-blog.csdnimg.cn/img_convert/62cd4181913ae94e8e87eb775b6ccf74.png)\r\n\r\n## 什么是非受控组件？\r\n* 组件中，所有的输入型DOM输入的值是随用随取的，就叫做非受控组件。\r\n\r\n## 一个非受控组件的例子\r\n![](https://img-blog.csdnimg.cn/img_convert/366dcce68cd15ba1bbbda2b95d8c4945.png)\r\n\r\n## 什么是受控组件？\r\n* 输入型DOM，随着输入，直接存入组件的state中，用的时候，再取出来，这样的组件叫做受控组件\r\n\r\n## 受控组件的例子\r\n![](https://img-blog.csdnimg.cn/img_convert/c36cd1646f9ff1a573eb6d22d597ad28.png)"
    },
    {
      "id": "/LeetCode——翻转链表（JS实现）",
      "metadata": {
        "permalink": "/blog/LeetCode——翻转链表（JS实现）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——翻转链表（JS实现）.md",
        "source": "@site/blog\\LeetCode——翻转链表（JS实现）.md",
        "title": "LeetCode——翻转链表（JS实现）",
        "description": "题目描述",
        "date": "2021-04-07T00:00:00.000Z",
        "formattedDate": "2021年4月7日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.74,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "LeetCode——翻转链表（JS实现）",
          "date": "2021-04-07T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "React-15：受控组件与非受控组件",
          "permalink": "/blog/React-15：受控组件与非受控组件"
        },
        "nextItem": {
          "title": "React-11：setState的使用",
          "permalink": "/blog/React-11：setState的使用"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/6a1b744eaee685ba71a813a35418ef9d.png)\r\n\r\n## 解题思路\r\n* 首先使用一个node指针记录头指针\r\n* 使用while循环遍历链表，将链表中的每个值保存在一个数组中。\r\n* 然后使用result指针记录头指针，node指针开始往后遍历\r\n* node指针每遍历一次，将数据域修改为数组.pop\r\n* 最后返回result指针\r\n\r\n## 实现代码\r\n```js\r\nvar reverseList = function(head) {\r\n    // 首先遍历这个链表\r\n    let arr = [];\r\n    let node = head;\r\n    while(head) {\r\n        arr.push(head.val);\r\n        head = head.next;\r\n    }\r\n    let result = node;\r\n    while(node) {\r\n        node.val = arr.pop();\r\n        node = node.next;\r\n    }\r\n    return result;\r\n};\r\n```"
    },
    {
      "id": "/React-11：setState的使用",
      "metadata": {
        "permalink": "/blog/React-11：setState的使用",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-11：setState的使用.md",
        "source": "@site/blog\\React-11：setState的使用.md",
        "title": "React-11：setState的使用",
        "description": "状态不可直接更改",
        "date": "2021-04-07T00:00:00.000Z",
        "formattedDate": "2021年4月7日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.105,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-11：setState的使用",
          "date": "2021-04-07T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "LeetCode——翻转链表（JS实现）",
          "permalink": "/blog/LeetCode——翻转链表（JS实现）"
        },
        "nextItem": {
          "title": "React-12：组件实例的三大核心属性之props",
          "permalink": "/blog/React-12：组件实例的三大核心属性之props"
        }
      },
      "content": "## 状态不可直接更改\r\n![](https://img-blog.csdnimg.cn/img_convert/197d0c51ad6a122cf3c7a21052366324.png)\r\n\r\n## 状态必须通过setState修改\r\n![](https://img-blog.csdnimg.cn/img_convert/5c3a08045dbd1297af4fc3c9806075e8.png)"
    },
    {
      "id": "/React-12：组件实例的三大核心属性之props",
      "metadata": {
        "permalink": "/blog/React-12：组件实例的三大核心属性之props",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-12：组件实例的三大核心属性之props.md",
        "source": "@site/blog\\React-12：组件实例的三大核心属性之props.md",
        "title": "React-12：组件实例的三大核心属性之props",
        "description": "props有什么用？",
        "date": "2021-04-07T00:00:00.000Z",
        "formattedDate": "2021年4月7日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.69,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-12：组件实例的三大核心属性之props",
          "date": "2021-04-07T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-11：setState的使用",
          "permalink": "/blog/React-11：setState的使用"
        },
        "nextItem": {
          "title": "使用拓展运算符拷贝对象，只能拷贝一层，属于浅拷贝",
          "permalink": "/blog/使用拓展运算符拷贝对象，只能拷贝一层，属于浅拷贝"
        }
      },
      "content": "## props有什么用？\r\n* 通过props属性可以在渲染类组件的时候，给类传参。\r\n![](https://img-blog.csdnimg.cn/img_convert/31a1dc58d27b76886e0c051fc4696eaa.png)\r\n\r\n## 批量传递props\r\n* 通过{...p}的形式\r\n![](https://img-blog.csdnimg.cn/img_convert/042dd6ab99593c1f3643b4970a6174d1.png)\r\n\r\n## 对props进行限制\r\n* 对props的类型和必要性进行限制\r\n* 使用这个限制之前需要引入prop-type.js这个文件\r\n![](https://img-blog.csdnimg.cn/img_convert/c0eae039de722a2e728fd3978ffe7502.png)\r\n* 对props的值给初始值\r\n![](https://img-blog.csdnimg.cn/img_convert/c966171e84052689b841878682464636.png)\r\n\r\n## props是只读的，不能修改\r\n![](https://img-blog.csdnimg.cn/img_convert/9b78480bc4de1b41b5d64eae7fdffcae.png)\r\n\r\n## props的简写方式\r\n* 将props的一些属性，通过静态的方式添加到类身上\r\n![](https://img-blog.csdnimg.cn/img_convert/3d83a01052be256506a5ad024ad3fcb9.png)\r\n\r\n## 函数式组件使用props\r\n![](https://img-blog.csdnimg.cn/img_convert/437360b1db848b8e7e28fb11265f3692.png)"
    },
    {
      "id": "/使用拓展运算符拷贝对象，只能拷贝一层，属于浅拷贝",
      "metadata": {
        "permalink": "/blog/使用拓展运算符拷贝对象，只能拷贝一层，属于浅拷贝",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/使用拓展运算符拷贝对象，只能拷贝一层，属于浅拷贝.md",
        "source": "@site/blog\\使用拓展运算符拷贝对象，只能拷贝一层，属于浅拷贝.md",
        "title": "使用拓展运算符拷贝对象，只能拷贝一层，属于浅拷贝",
        "description": "拓展运算符拷贝对象属于浅拷贝",
        "date": "2021-04-07T00:00:00.000Z",
        "formattedDate": "2021年4月7日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.08,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "使用拓展运算符拷贝对象，只能拷贝一层，属于浅拷贝",
          "date": "2021-04-07T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "React-12：组件实例的三大核心属性之props",
          "permalink": "/blog/React-12：组件实例的三大核心属性之props"
        },
        "nextItem": {
          "title": "练习正则表达式的好方法推荐",
          "permalink": "/blog/练习正则表达式的好方法推荐"
        }
      },
      "content": "## 拓展运算符拷贝对象属于浅拷贝\r\n![](https://img-blog.csdnimg.cn/img_convert/3eead2445a448138939f1ba59ccf5d2e.png)"
    },
    {
      "id": "/练习正则表达式的好方法推荐",
      "metadata": {
        "permalink": "/blog/练习正则表达式的好方法推荐",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/练习正则表达式的好方法推荐.md",
        "source": "@site/blog\\练习正则表达式的好方法推荐.md",
        "title": "练习正则表达式的好方法推荐",
        "description": "推荐在FreeCodeCamp中的正则专题",
        "date": "2021-04-07T00:00:00.000Z",
        "formattedDate": "2021年4月7日",
        "tags": [
          {
            "label": "正则表达式",
            "permalink": "/blog/tags/正则表达式"
          }
        ],
        "readingTime": 0.185,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "练习正则表达式的好方法推荐",
          "date": "2021-04-07T00:00:00.000Z",
          "categories": "正则表达式",
          "tags": [
            "正则表达式"
          ]
        },
        "prevItem": {
          "title": "使用拓展运算符拷贝对象，只能拷贝一层，属于浅拷贝",
          "permalink": "/blog/使用拓展运算符拷贝对象，只能拷贝一层，属于浅拷贝"
        },
        "nextItem": {
          "title": "React-08：组件实例的三大核心属性之state",
          "permalink": "/blog/React-08：组件实例的三大核心属性之state"
        }
      },
      "content": "## 推荐在FreeCodeCamp中的正则专题\r\n* 刷完这个专题，你将对正则有基本的认知与了解。\r\n[FreeCodeCamp正则专题](https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/#regular-expressions)"
    },
    {
      "id": "/React-08：组件实例的三大核心属性之state",
      "metadata": {
        "permalink": "/blog/React-08：组件实例的三大核心属性之state",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-08：组件实例的三大核心属性之state.md",
        "source": "@site/blog\\React-08：组件实例的三大核心属性之state.md",
        "title": "React-08：组件实例的三大核心属性之state",
        "description": "准确区分什么是简单组件与复杂组件",
        "date": "2021-04-06T00:00:00.000Z",
        "formattedDate": "2021年4月6日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.505,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-08：组件实例的三大核心属性之state",
          "date": "2021-04-06T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "练习正则表达式的好方法推荐",
          "permalink": "/blog/练习正则表达式的好方法推荐"
        },
        "nextItem": {
          "title": "React-09：React中的事件绑定",
          "permalink": "/blog/React-09：React中的事件绑定"
        }
      },
      "content": "## 准确区分什么是简单组件与复杂组件\r\n* 简单组件无state\r\n* 复杂组件有state\r\n\r\n## 初始化state\r\n* 在组件类的构造器中修改\r\n* 先给构造器传参数props，这个参数是React自动给我们传的。\r\n* 调用super()\r\n* 初始化state\r\n* 这里的this指的是组件的实例对象\r\n![](https://img-blog.csdnimg.cn/img_convert/8d2525c98893df8d6a26e3808e0f95e6.png)\r\n\r\n## state的一般简写\r\n![](https://img-blog.csdnimg.cn/img_convert/64ab1fa6810cb20b345deee225f224a5.png)"
    },
    {
      "id": "/React-09：React中的事件绑定",
      "metadata": {
        "permalink": "/blog/React-09：React中的事件绑定",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-09：React中的事件绑定.md",
        "source": "@site/blog\\React-09：React中的事件绑定.md",
        "title": "React-09：React中的事件绑定",
        "description": "React中的点击事件",
        "date": "2021-04-06T00:00:00.000Z",
        "formattedDate": "2021年4月6日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.215,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-09：React中的事件绑定",
          "date": "2021-04-06T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-08：组件实例的三大核心属性之state",
          "permalink": "/blog/React-08：组件实例的三大核心属性之state"
        },
        "nextItem": {
          "title": "React-10：React类中自定义方法的this指向",
          "permalink": "/blog/React-10：React类中自定义方法的this指向"
        }
      },
      "content": "## React中的点击事件\r\n* 在JSX语法的行内添加点击事件\r\n* onClick中的C要大写\r\n* 使用{}包裹函数，函数后面不要加上()\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/5fe90330c15e83505c543192b0475b8b.png)"
    },
    {
      "id": "/React-10：React类中自定义方法的this指向",
      "metadata": {
        "permalink": "/blog/React-10：React类中自定义方法的this指向",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-10：React类中自定义方法的this指向.md",
        "source": "@site/blog\\React-10：React类中自定义方法的this指向.md",
        "title": "React-10：React类中自定义方法的this指向",
        "description": "类中自定义方法的this指向",
        "date": "2021-04-06T00:00:00.000Z",
        "formattedDate": "2021年4月6日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.82,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-10：React类中自定义方法的this指向",
          "date": "2021-04-06T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-09：React中的事件绑定",
          "permalink": "/blog/React-09：React中的事件绑定"
        },
        "nextItem": {
          "title": "ERROR-Command `Install ‘code‘ command in PATH` exited with status code 1",
          "permalink": "/blog/ERROR-Command `Install ‘code‘ command in PATH` exited with status code 1"
        }
      },
      "content": "## 类中自定义方法的this指向\r\n![](https://img-blog.csdnimg.cn/img_convert/c984e5c8f231324cb1bf1abe0c6971cc.png)\r\n\r\n## bind方法不仅仅修改了this指向，同时将修改完this指向的函数进行了返回，即返回的是一个函数\r\n* 注意：类中的方法是放在原型对象上的\r\n![](https://img-blog.csdnimg.cn/img_convert/9e4fe20c0c42ccfeb6d1389242b88aa2.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/33e8900a79205f27c5584d07790d12e7.png)\r\n\r\n## 类中赋值形式的属性是写到实例对象上的，而方法则是直接写到原型对象中的\r\n* 下面两种写法，state和demo都是直接写到实例对象中的。\r\n![](https://img-blog.csdnimg.cn/img_convert/47b7750c8b6096f09293a5483f648621.png)\r\n\r\n## 解决组件类中自定义方法的this指向的两种方法\r\n* 使用bind进行重新绑定this\r\n* 使用箭头函数"
    },
    {
      "id": "/ERROR-Command `Install ‘code‘ command in PATH` exited with status code 1",
      "metadata": {
        "permalink": "/blog/ERROR-Command `Install ‘code‘ command in PATH` exited with status code 1",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ERROR-Command `Install ‘code‘ command in PATH` exited with status code 1.md",
        "source": "@site/blog\\ERROR-Command `Install ‘code‘ command in PATH` exited with status code 1.md",
        "title": "ERROR-Command `Install ‘code‘ command in PATH` exited with status code 1",
        "description": "报错提示",
        "date": "2021-04-05T00:00:00.000Z",
        "formattedDate": "2021年4月5日",
        "tags": [
          {
            "label": "debug",
            "permalink": "/blog/tags/debug"
          }
        ],
        "readingTime": 0.39,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ERROR-Command `Install ‘code‘ command in PATH` exited with status code 1",
          "date": "2021-04-05T00:00:00.000Z",
          "categories": "debug",
          "tags": [
            "debug"
          ]
        },
        "prevItem": {
          "title": "React-10：React类中自定义方法的this指向",
          "permalink": "/blog/React-10：React类中自定义方法的this指向"
        },
        "nextItem": {
          "title": "LeetCode——二叉搜索树的第K大的节点",
          "permalink": "/blog/LeetCode——二叉搜索树的第K大的节点"
        }
      },
      "content": "## 报错提示\r\nERROR: Command `Install 'code' command in PATH` exited with status code 1.\r\n\r\n## 原因\r\n* 在Windows系统中，我们想通过shell命令工具，添加code快捷指令，但是windows系统不存在这个指令。\r\n\r\n## 解决办法\r\n`在系统的环境变量中将VScode的bin目录加进去`\r\n![](https://img-blog.csdnimg.cn/img_convert/151c37ca06a1614fade0b7a61b0ff376.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/a155bacfaee469d3a0e60c7f0996f99f.png)"
    },
    {
      "id": "/LeetCode——二叉搜索树的第K大的节点",
      "metadata": {
        "permalink": "/blog/LeetCode——二叉搜索树的第K大的节点",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——二叉搜索树的第K大的节点.md",
        "source": "@site/blog\\LeetCode——二叉搜索树的第K大的节点.md",
        "title": "LeetCode——二叉搜索树的第K大的节点",
        "description": "题目描述",
        "date": "2021-04-05T00:00:00.000Z",
        "formattedDate": "2021年4月5日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.705,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "LeetCode——二叉搜索树的第K大的节点",
          "date": "2021-04-05T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "ERROR-Command `Install ‘code‘ command in PATH` exited with status code 1",
          "permalink": "/blog/ERROR-Command `Install ‘code‘ command in PATH` exited with status code 1"
        },
        "nextItem": {
          "title": "React-06：函数式组件",
          "permalink": "/blog/React-06：函数式组件"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/385b4bb94b1d322da577b788c6022680.png)\r\n\r\n## 解题思路\r\n* 首先构建一个集合用来存储遍历的所有元素。\r\n* 使用DFS遍历二叉树，并将结果存到集合中。\r\n* 将集合转化为数组\r\n* 通过sort方法进行降序排序\r\n* 排好序的数组的下标为[k-1]的元素即为二叉搜索树的第K大的元素\r\n\r\n## 实现代码\r\n```js\r\nvar kthLargest = function(root, k) {\r\n\r\n    const set = new Set();\r\n    const dfs = function(node) {\r\n        if (node === null) {\r\n            return;\r\n        }\r\n\r\n        set.add(node.val);\r\n        dfs(node.left);\r\n        dfs(node.right);\r\n    }\r\n    dfs(root);\r\n    const arr = [...set];\r\n    arr.sort((a,b) => {\r\n        return b-a;\r\n    });\r\n\r\n    return arr[k-1];\r\n\r\n};\r\n```"
    },
    {
      "id": "/React-06：函数式组件",
      "metadata": {
        "permalink": "/blog/React-06：函数式组件",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-06：函数式组件.md",
        "source": "@site/blog\\React-06：函数式组件.md",
        "title": "React-06：函数式组件",
        "description": "创建函数式组件的步骤",
        "date": "2021-04-05T00:00:00.000Z",
        "formattedDate": "2021年4月5日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.49,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-06：函数式组件",
          "date": "2021-04-05T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "LeetCode——二叉搜索树的第K大的节点",
          "permalink": "/blog/LeetCode——二叉搜索树的第K大的节点"
        },
        "nextItem": {
          "title": "React-07：类式组件",
          "permalink": "/blog/React-07：类式组件"
        }
      },
      "content": "## 创建函数式组件的步骤\r\n1. `创建函数式组件`\r\n2. `渲染函数式组件到页面`\r\n\r\n注意：\r\n* 组件的标签名首字母要大写\r\n* 标签名在渲染的时候，最后要加/\r\n![](https://img-blog.csdnimg.cn/img_convert/22ffe20c08a7f36a6bcf27c5ff970eaa.png)\r\n\r\n## 函数式组件中的this指向的是谁？\r\n`undefined`\r\n* 因为babel开启了严格模式，所以自定义的函数指向了undefined"
    },
    {
      "id": "/React-07：类式组件",
      "metadata": {
        "permalink": "/blog/React-07：类式组件",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-07：类式组件.md",
        "source": "@site/blog\\React-07：类式组件.md",
        "title": "React-07：类式组件",
        "description": "创建类组件",
        "date": "2021-04-05T00:00:00.000Z",
        "formattedDate": "2021年4月5日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.4,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-07：类式组件",
          "date": "2021-04-05T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-06：函数式组件",
          "permalink": "/blog/React-06：函数式组件"
        },
        "nextItem": {
          "title": "JS文件通过Node运行和HTML文件的script标签运行不一致的原因",
          "permalink": "/blog/JS文件通过Node运行和HTML文件的script标签运行不一致的原因"
        }
      },
      "content": "## 创建类组件\r\n* 类组件必须继承React.Component\r\n* 必须有render函数\r\n* render函数中必须有return\r\n![](https://img-blog.csdnimg.cn/img_convert/c5321911639db9590003d5039727b11d.png)\r\n\r\n## 渲染类组件到页面\r\n* 第一个参数是标签\r\n![](https://img-blog.csdnimg.cn/img_convert/e02766799a357ee12f0cc476201de6bf.png)\r\n\r\n## 类组件中的this指向的是谁？\r\n* 类组件中的this指的是这个类组件的实例对象\r\n![](https://img-blog.csdnimg.cn/img_convert/96b38af6bc32f0d8aca0211f5fc4bf1e.png)"
    },
    {
      "id": "/JS文件通过Node运行和HTML文件的script标签运行不一致的原因",
      "metadata": {
        "permalink": "/blog/JS文件通过Node运行和HTML文件的script标签运行不一致的原因",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/JS文件通过Node运行和HTML文件的script标签运行不一致的原因.md",
        "source": "@site/blog\\JS文件通过Node运行和HTML文件的script标签运行不一致的原因.md",
        "title": "JS文件通过Node运行和HTML文件的script标签运行不一致的原因",
        "description": "问题描述",
        "date": "2021-04-04T00:00:00.000Z",
        "formattedDate": "2021年4月4日",
        "tags": [
          {
            "label": "debug",
            "permalink": "/blog/tags/debug"
          }
        ],
        "readingTime": 0.245,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "JS文件通过Node运行和HTML文件的script标签运行不一致的原因",
          "date": "2021-04-04T00:00:00.000Z",
          "categories": "debug",
          "tags": [
            "debug"
          ]
        },
        "prevItem": {
          "title": "React-07：类式组件",
          "permalink": "/blog/React-07：类式组件"
        },
        "nextItem": {
          "title": "React-06：模块与组件的理解",
          "permalink": "/blog/React-06：模块与组件的理解"
        }
      },
      "content": "## 问题描述\r\n* 在Node中输出的是Undefined\r\n![](https://img-blog.csdnimg.cn/img_convert/3faff311637be58c42c45538828c5337.png)\r\n* 在HTML中输出的是 not awesome\r\n![](https://img-blog.csdnimg.cn/img_convert/25af9f2ed66a9f96b915941089515ff8.png)\r\n\r\n## 原因\r\n* 在Html中this指向的是window,但是在node中this指的是空对象。"
    },
    {
      "id": "/React-06：模块与组件的理解",
      "metadata": {
        "permalink": "/blog/React-06：模块与组件的理解",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-06：模块与组件的理解.md",
        "source": "@site/blog\\React-06：模块与组件的理解.md",
        "title": "React-06：模块与组件的理解",
        "description": "什么是模块？",
        "date": "2021-04-04T00:00:00.000Z",
        "formattedDate": "2021年4月4日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.835,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-06：模块与组件的理解",
          "date": "2021-04-04T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "JS文件通过Node运行和HTML文件的script标签运行不一致的原因",
          "permalink": "/blog/JS文件通过Node运行和HTML文件的script标签运行不一致的原因"
        },
        "nextItem": {
          "title": "「注解」《你不知道的JavaScript（上卷）》第五章：作用域闭包",
          "permalink": "/blog/「注解」《你不知道的JavaScript（上卷）》第五章：作用域闭包"
        }
      },
      "content": "## 什么是模块？\r\n* 模块是对JS文件的一个拆分，使得一个复杂的JS文件被拆分为拥有很多不同功能的模块。\r\n\r\n## 什么是组件？\r\n* 组件是用来实现局部功能效果的所有资源的一个集合。\r\n* 举个例子：下面的这个就是一个组件（将header的全部资源进行集中）\r\n![](https://img-blog.csdnimg.cn/img_convert/c6acc24caa84e1b7a041527f506277a4.png)\r\n\r\n## 什么是模块化？\r\n* 当应用的js文件都以模块来编写的，这个应用就是一个模块化的应用。\r\n\r\n## 什么是组件化？\r\n* 当应用是以多组件的方式实现，这个应用就是一个组件化的应用。"
    },
    {
      "id": "/「注解」《你不知道的JavaScript（上卷）》第五章：作用域闭包",
      "metadata": {
        "permalink": "/blog/「注解」《你不知道的JavaScript（上卷）》第五章：作用域闭包",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/「注解」《你不知道的JavaScript（上卷）》第五章：作用域闭包.md",
        "source": "@site/blog\\「注解」《你不知道的JavaScript（上卷）》第五章：作用域闭包.md",
        "title": "「注解」《你不知道的JavaScript（上卷）》第五章：作用域闭包",
        "description": "启示",
        "date": "2021-04-04T00:00:00.000Z",
        "formattedDate": "2021年4月4日",
        "tags": [
          {
            "label": "《你不知道的JavaScript》",
            "permalink": "/blog/tags/《你不知道的-java-script》"
          }
        ],
        "readingTime": 1.44,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "「注解」《你不知道的JavaScript（上卷）》第五章：作用域闭包",
          "date": "2021-04-04T00:00:00.000Z",
          "categories": "《你不知道的JavaScript》",
          "tags": [
            "《你不知道的JavaScript》"
          ]
        },
        "prevItem": {
          "title": "React-06：模块与组件的理解",
          "permalink": "/blog/React-06：模块与组件的理解"
        },
        "nextItem": {
          "title": "React-02：虚拟DOM的两种创建方式",
          "permalink": "/blog/React-02：虚拟DOM的两种创建方式"
        }
      },
      "content": "## 启示\r\n* 理解闭包可以看做是某种意义上的重生。\r\n* 掌握闭包将会功力大增。\r\n* JavaScript中闭包无处不在。\r\n![](https://img-blog.csdnimg.cn/img_convert/c137969a1654989be08c9f99e33cb49d.png)\r\n\r\n## 实质问题\r\n![](https://img-blog.csdnimg.cn/img_convert/98dff911963aa88cb251689d20766a57.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/9d2e1c7ad5bd0c8fa3aed1cd09f72307.png)\r\n\r\n* 闭包使得函数可以继续访问定义时的词法作用域。\r\n![](https://img-blog.csdnimg.cn/img_convert/c74e9e04238fdfa804db7673a204306b.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/852f792f33f4d27e1bfcff1f03b32d0e.png)\r\n\r\n## 现在我懂了\r\n![](https://img-blog.csdnimg.cn/img_convert/bc93bb1a1d9dde31fd4802842a9e17d7.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/58704f9f8a0b36ee48d67d7fab8cb014.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/9c01c4806569982aaf9655d2334dfec8.png)\r\n\r\n## 循环和闭包\r\n* 在看懂for循环中的闭包问题时，我们首先要知道一点，那就是延迟函数的回调通常是在循环结束的时候才执行，即使setTimeout的第二个参数是0.\r\n![](https://img-blog.csdnimg.cn/img_convert/9708817c6bc3334ce885a3f473ebb46f.png)\r\n\r\n* 所以下面的循环回输出5个6\r\n![](https://img-blog.csdnimg.cn/img_convert/44f24facad46a11aed1ef04b2821f6d7.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/6ee54b88205c960a7cb5f0d3161dfffb.png)\r\n\r\n* 尝试通过立即执行函数来解决这个问题\r\n* 尝试1\r\n![](https://img-blog.csdnimg.cn/img_convert/e0f9d9603f874288e5fe184ef6e6a2cf.png)\r\n\r\n* 尝试2\r\n![](https://img-blog.csdnimg.cn/img_convert/552e0901780d589d80e459f8f04bc3be.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/575f89727cb7173370a1070f9e4fbfc9.png)\r\n\r\n### 重返块作用域\r\n![](https://img-blog.csdnimg.cn/img_convert/74cebdb3a909628fc719ea3958e8b78b.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/b9f9177a845c40dbca69d9ee950de838.png)\r\n\r\n## 模块\r\n* 模块模式要具备两个必要条件\r\n![](https://img-blog.csdnimg.cn/img_convert/f1ce33a1e17d715234c2bdb47b9cb126.png)\r\n* 通过模块模式可以构造一个API对象\r\n![](https://img-blog.csdnimg.cn/img_convert/dc3551fbfa9f5aded03e24d638a2e136.png)\r\n\r\n### 现代的模块机制\r\n* 本小节主要讲了模块define的源码，不做深入讨论。\r\n\r\n### 未来的模块机制\r\n* 关于模块化的内容，请参考这个文档\r\n[ES6—49：模块化](https://blog.csdn.net/sinat_41696687/article/details/114517025?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161624253116780255275278%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=161624253116780255275278&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v1~rank_blog_v1-1-114517025.pc_v1_rank_blog_v1&utm_term=%E6%A8%A1%E5%9D%97)\r\n\r\n## 小结\r\n![](https://img-blog.csdnimg.cn/img_convert/4c916820df07b226dd1e9281246214e0.png)"
    },
    {
      "id": "/React-02：虚拟DOM的两种创建方式",
      "metadata": {
        "permalink": "/blog/React-02：虚拟DOM的两种创建方式",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-02：虚拟DOM的两种创建方式.md",
        "source": "@site/blog\\React-02：虚拟DOM的两种创建方式.md",
        "title": "React-02：虚拟DOM的两种创建方式",
        "description": "实现如下DOM结构",
        "date": "2021-04-02T00:00:00.000Z",
        "formattedDate": "2021年4月2日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.185,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-02：虚拟DOM的两种创建方式",
          "date": "2021-04-02T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "「注解」《你不知道的JavaScript（上卷）》第五章：作用域闭包",
          "permalink": "/blog/「注解」《你不知道的JavaScript（上卷）》第五章：作用域闭包"
        },
        "nextItem": {
          "title": "React-03：虚拟DOM与真实DOM",
          "permalink": "/blog/React-03：虚拟DOM与真实DOM"
        }
      },
      "content": "## 实现如下DOM结构\r\n![](https://img-blog.csdnimg.cn/img_convert/8b2cf81d85abd024b4a4306eb9ab6556.png)\r\n\r\n## 使用传统的js\r\n![](https://img-blog.csdnimg.cn/img_convert/4a79fda35c1473c01552a243c0c5558b.png)\r\n\r\n## 使用JSX\r\n![](https://img-blog.csdnimg.cn/img_convert/eb12e60b36e2c646c784af33346196b8.png)\r\n\r\n## 总结：推荐使用JSX的方式写虚拟DOM"
    },
    {
      "id": "/React-03：虚拟DOM与真实DOM",
      "metadata": {
        "permalink": "/blog/React-03：虚拟DOM与真实DOM",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-03：虚拟DOM与真实DOM.md",
        "source": "@site/blog\\React-03：虚拟DOM与真实DOM.md",
        "title": "React-03：虚拟DOM与真实DOM",
        "description": "虚拟DOM的几个特点",
        "date": "2021-04-02T00:00:00.000Z",
        "formattedDate": "2021年4月2日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.29,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-03：虚拟DOM与真实DOM",
          "date": "2021-04-02T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-02：虚拟DOM的两种创建方式",
          "permalink": "/blog/React-02：虚拟DOM的两种创建方式"
        },
        "nextItem": {
          "title": "React-04：JSX语法规则",
          "permalink": "/blog/React-04：JSX语法规则"
        }
      },
      "content": "## 虚拟DOM的几个特点\r\n* 虚拟DOM是Object类型的对象\r\n* 虚拟DOM的属性比较少，真实DOM的属性比较多。\r\n* 虚拟DOM最终会被React转化为真实DOM，并呈现在页面上。"
    },
    {
      "id": "/React-04：JSX语法规则",
      "metadata": {
        "permalink": "/blog/React-04：JSX语法规则",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-04：JSX语法规则.md",
        "source": "@site/blog\\React-04：JSX语法规则.md",
        "title": "React-04：JSX语法规则",
        "description": "定义虚拟DOM的时候不要加引号",
        "date": "2021-04-02T00:00:00.000Z",
        "formattedDate": "2021年4月2日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.915,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-04：JSX语法规则",
          "date": "2021-04-02T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-03：虚拟DOM与真实DOM",
          "permalink": "/blog/React-03：虚拟DOM与真实DOM"
        },
        "nextItem": {
          "title": "React-05：虚拟DOM中只能写JS的表达式",
          "permalink": "/blog/React-05：虚拟DOM中只能写JS的表达式"
        }
      },
      "content": "## 定义虚拟DOM的时候不要加引号\r\n![](https://img-blog.csdnimg.cn/img_convert/1ee16a8f9d26758c45cc1f2e8fc1df71.png)\r\n\r\n## 读取来自变量的数据需要加上大括号\r\n![](https://img-blog.csdnimg.cn/img_convert/ea78246d27cf0b3841857be68f102dd2.png)\r\n\r\n## 虚拟DOM中的类名不是class而是className\r\n![](https://img-blog.csdnimg.cn/img_convert/9e30612b0b457dbff83516851a41634f.png)\r\n\r\n## 虚拟DOM的内联样式\r\n'style写法应是'\r\n![](https://img-blog.csdnimg.cn/img_convert/d69f0fae946e58b3e58249f5d008ea12.png)\r\n\r\n## 内联样式的变量名要使用小驼峰命名\r\n![](https://img-blog.csdnimg.cn/img_convert/4b7f344c31f8eaec270846c57e7387fe.png)\r\n\r\n## 虚拟DOM中只能有一个根标签\r\n![](https://img-blog.csdnimg.cn/img_convert/396fc8e9c147a106daa875986346c1a3.png)\r\n\r\n## 标签必须闭合，单标签手动加/\r\n![](https://img-blog.csdnimg.cn/img_convert/26c70ff385d084efe2fa037729df3296.png)\r\n\r\n## 虚拟DOM中的标签首字母\r\n* 若标签的首字母为小写字母，则将其转化为HTML标签对应的标签，没有则报错。\r\n* 若标签的首字母为大写字母，React就去渲染对应的组件，若组件没有定义则报错。"
    },
    {
      "id": "/React-05：虚拟DOM中只能写JS的表达式",
      "metadata": {
        "permalink": "/blog/React-05：虚拟DOM中只能写JS的表达式",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-05：虚拟DOM中只能写JS的表达式.md",
        "source": "@site/blog\\React-05：虚拟DOM中只能写JS的表达式.md",
        "title": "React-05：虚拟DOM中只能写JS的表达式",
        "description": "首先区分什么是表达式和语句",
        "date": "2021-04-02T00:00:00.000Z",
        "formattedDate": "2021年4月2日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 0.235,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-05：虚拟DOM中只能写JS的表达式",
          "date": "2021-04-02T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "React-04：JSX语法规则",
          "permalink": "/blog/React-04：JSX语法规则"
        },
        "nextItem": {
          "title": "LeetCode——从尾到头打印链表",
          "permalink": "/blog/LeetCode——从尾到头打印链表"
        }
      },
      "content": "## 首先区分什么是表达式和语句\r\n* 表达式会有一个返回值。\r\n* 语句没有返回值\r\n* for循环，if语句，switch都属于语句\r\n\r\n## 案例\r\n![](https://img-blog.csdnimg.cn/img_convert/77e50bcefd964d740594dbd4ffd4db85.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/64601bea880e71412539ae017b36c10c.png)"
    },
    {
      "id": "/LeetCode——从尾到头打印链表",
      "metadata": {
        "permalink": "/blog/LeetCode——从尾到头打印链表",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——从尾到头打印链表.md",
        "source": "@site/blog\\LeetCode——从尾到头打印链表.md",
        "title": "LeetCode——从尾到头打印链表",
        "description": "题目描述",
        "date": "2021-04-01T00:00:00.000Z",
        "formattedDate": "2021年4月1日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.465,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "LeetCode——从尾到头打印链表",
          "date": "2021-04-01T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "React-05：虚拟DOM中只能写JS的表达式",
          "permalink": "/blog/React-05：虚拟DOM中只能写JS的表达式"
        },
        "nextItem": {
          "title": "npm安装指定版本的包",
          "permalink": "/blog/npm安装指定版本的包"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/6ab0084ce5457baede1a65c26ac210c8.png)\r\n\r\n## 解题思路\r\n* 首先遍历链表，将链表中的每一个值都存在一个数组中。\r\n* 然后倒叙遍历这个数组，最后返回\r\n\r\n## 实现代码\r\n```js\r\nvar reversePrint = function(head) {\r\n    const arr = [];\r\n    while (head) {\r\n        arr.push(head.val);\r\n        head = head.next;\r\n    }\r\n\r\n    const result = [];\r\n    const len = arr.length;\r\n    for (let i = 0; i < len;i++) {\r\n        result.push(arr.pop());\r\n    }\r\n\r\n    return result;\r\n\r\n};\r\n```"
    },
    {
      "id": "/npm安装指定版本的包",
      "metadata": {
        "permalink": "/blog/npm安装指定版本的包",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/npm安装指定版本的包.md",
        "source": "@site/blog\\npm安装指定版本的包.md",
        "title": "npm安装指定版本的包",
        "description": "安装指定版本的jquery-1.11.2",
        "date": "2021-04-01T00:00:00.000Z",
        "formattedDate": "2021年4月1日",
        "tags": [
          {
            "label": "npm",
            "permalink": "/blog/tags/npm"
          }
        ],
        "readingTime": 0.24,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "npm安装指定版本的包",
          "date": "2021-04-01T00:00:00.000Z",
          "categories": "npm",
          "tags": [
            "npm"
          ]
        },
        "prevItem": {
          "title": "LeetCode——从尾到头打印链表",
          "permalink": "/blog/LeetCode——从尾到头打印链表"
        },
        "nextItem": {
          "title": "React-01：React介绍",
          "permalink": "/blog/React-01：React介绍"
        }
      },
      "content": "## 安装指定版本的jquery-1.11.2\r\n```\r\nnpm install jquery@1.11.0\r\n```\r\n## 安装1.0中的最新版本\r\n```\r\nnpm install jquery@1\r\n```\r\n## 安装2.0版本中的最新版本\r\n```\r\nnpm install jquery@2\r\n```\r\n依次类推"
    },
    {
      "id": "/React-01：React介绍",
      "metadata": {
        "permalink": "/blog/React-01：React介绍",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/React-01：React介绍.md",
        "source": "@site/blog\\React-01：React介绍.md",
        "title": "React-01：React介绍",
        "description": "React是什么？",
        "date": "2021-04-01T00:00:00.000Z",
        "formattedDate": "2021年4月1日",
        "tags": [
          {
            "label": "React",
            "permalink": "/blog/tags/react"
          }
        ],
        "readingTime": 1.67,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "React-01：React介绍",
          "date": "2021-04-01T00:00:00.000Z",
          "categories": "React",
          "tags": [
            "React"
          ]
        },
        "prevItem": {
          "title": "npm安装指定版本的包",
          "permalink": "/blog/npm安装指定版本的包"
        },
        "nextItem": {
          "title": "解决Hexo博客的Next主题中阅读全文没有auto_excerpt的问题",
          "permalink": "/blog/解决Hexo博客的Next主题中阅读全文没有auto_excerpt的问题"
        }
      },
      "content": "## React是什么？\r\nReact是一个将数据渲染成HTML视图的开源JavaScript库。\r\n## 为什么要学React?\r\n* 原生JS操作DOM繁琐，效率低。\r\n* 使用JS直接操作DOM，浏览器会进行大量的重排和重绘。\r\n* 原生JS没有组件化的编码方案，代码复用率低。\r\n\r\n## React的特点\r\n* 采用组件化的模式，声明式编码，提高开发效率和组件复用率。\r\n* 在React Native中可以使用React语法进行移动端开发。\r\n* 使用虚拟DOM+优秀的Diffing算法，尽量减少与真实DOM的交互。\r\n\r\n## babel的另一功能\r\n* 一般情况下，我们知道babel具有将ES6的代码转换为ES5，其实babel还具有将jsx转换为js的功能。\r\n## Hello,React案例\r\n* 引入库的顺序\r\n1. 先引入react核心库\r\n2. 再引入react-dom库\r\n3. 最后引入babel\r\n\r\n* 将自定以的script标签的类型改为babel\r\n* 在自定义标签中创建虚拟DOM\r\n* 虚拟DOM是不用加引号的\r\n* 渲染虚拟DOM到页面\r\n* 只要添加了react核心库和react-dom库，就会多了个ReactDOM对象\r\n```js\r\n<div class=\"test\"></div>\r\n<script src=\"../js/react.development.js\"></script>\r\n<script src=\"../js/react-dom.development.js\"></script>\r\n<script src=\"../js/babel.min.js\"></script>\r\n<!-- 将script标签的类型改为babel -->\r\n<script type=\"text/babel\">\r\n    // 创建虚拟DOM\r\n    const VDOM = <h1>Hello,React!</h1>;\r\n    // 渲染虚拟DOM到页面\r\n    ReactDOM.render(VDOM,document.querySelector('.test'));\r\n</script>\r\n```"
    },
    {
      "id": "/解决Hexo博客的Next主题中阅读全文没有auto_excerpt的问题",
      "metadata": {
        "permalink": "/blog/解决Hexo博客的Next主题中阅读全文没有auto_excerpt的问题",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/解决Hexo博客的Next主题中阅读全文没有auto_excerpt的问题.md",
        "source": "@site/blog\\解决Hexo博客的Next主题中阅读全文没有auto_excerpt的问题.md",
        "title": "解决Hexo博客的Next主题中阅读全文没有auto_excerpt的问题",
        "description": "1：使用npm安装hexo-excerpt",
        "date": "2021-04-01T00:00:00.000Z",
        "formattedDate": "2021年4月1日",
        "tags": [
          {
            "label": "Hexo",
            "permalink": "/blog/tags/hexo"
          }
        ],
        "readingTime": 0.18,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "解决Hexo博客的Next主题中阅读全文没有auto_excerpt的问题",
          "date": "2021-04-01T00:00:00.000Z",
          "categories": "Hexo",
          "tags": [
            "Hexo"
          ]
        },
        "prevItem": {
          "title": "React-01：React介绍",
          "permalink": "/blog/React-01：React介绍"
        },
        "nextItem": {
          "title": "JS模块化（三）：CMD规范",
          "permalink": "/blog/JS模块化（三）：CMD规范"
        }
      },
      "content": "## 1：使用npm安装hexo-excerpt\r\n```\r\nnpm install hexo-excerpt --save\r\n```\r\n## 2：在站点配置文件中添加\r\n```\r\nexcerpt:\r\n  depth: 5  \r\n  excerpt_excludes: []\r\n  more_excludes: []\r\n  hideWholePostExcerpts: true\r\n```"
    },
    {
      "id": "/JS模块化（三）：CMD规范",
      "metadata": {
        "permalink": "/blog/JS模块化（三）：CMD规范",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/JS模块化（三）：CMD规范.md",
        "source": "@site/blog\\JS模块化（三）：CMD规范.md",
        "title": "JS模块化（三）：CMD规范",
        "description": "目录结构",
        "date": "2021-03-31T00:00:00.000Z",
        "formattedDate": "2021年3月31日",
        "tags": [
          {
            "label": "JS模块化",
            "permalink": "/blog/tags/js模块化"
          }
        ],
        "readingTime": 0.94,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "JS模块化（三）：CMD规范",
          "date": "2021-03-31T00:00:00.000Z",
          "categories": "JS模块化",
          "tags": [
            "JS模块化"
          ]
        },
        "prevItem": {
          "title": "解决Hexo博客的Next主题中阅读全文没有auto_excerpt的问题",
          "permalink": "/blog/解决Hexo博客的Next主题中阅读全文没有auto_excerpt的问题"
        },
        "nextItem": {
          "title": "JS模块化（四）：ES6规范",
          "permalink": "/blog/JS模块化（四）：ES6规范"
        }
      },
      "content": "## 目录结构\r\n![](https://img-blog.csdnimg.cn/img_convert/2260a8eeb6c39e2f73c0055c1b4c97f3.png)\r\n\r\n## module1：（没有依赖的模块）\r\n```js\r\n// 这是没有依赖的模块\r\ndefine(function(require,exports,module) {\r\n    let msg = 'module1';\r\n    function foo() {\r\n        return msg;\r\n    }\r\n    // 暴露模块\r\n    module.exports = {foo};\r\n})\r\n```\r\n## module2：（没有依赖的模块）\r\n```js\r\ndefine(function(require,exports,module){\r\n    let msg = 'module2';\r\n    function bar() {\r\n        console.log(msg);\r\n    }\r\n    module.exports = bar;\r\n})\r\n```\r\n## module3：（没有依赖的模块）\r\n```js\r\ndefine(function(require,exports,module) {\r\n    let data = 'module3';\r\n    function fun() {\r\n        console.log(data);\r\n    }\r\n    // exports.module3 = {fun};\r\n    module.exports = {fun};\r\n})\r\n```\r\n## module4：（有依赖的模块）\r\n```js\r\n// 这是一个有依赖的模块\r\ndefine(function(require,exports,module) {\r\n    let msg = 'module4';\r\n    // 同步引入\r\n    let module2 = require('./module2');\r\n    module2();\r\n    // 异步引入\r\n    require.async('./module3',function(module3) {\r\n        // module3.module3.fun();\r\n        module3.fun();\r\n    })\r\n    function fun2() {\r\n        console.log(msg);\r\n    }\r\n    exports.fun2 = fun2;\r\n})\r\n```\r\n## 主函数：main.js\r\n```js\r\ndefine(function(require) {\r\n    let module1 = require('./module1');\r\n    console.log(module1.foo()); \r\n    let module4 = require('./module4');\r\n    module4.fun2();\r\n})\r\n```\r\n## 浏览器端使用\r\n![](https://img-blog.csdnimg.cn/img_convert/3e8e2521f599d94e56892ed1408d8f0c.png)"
    },
    {
      "id": "/JS模块化（四）：ES6规范",
      "metadata": {
        "permalink": "/blog/JS模块化（四）：ES6规范",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/JS模块化（四）：ES6规范.md",
        "source": "@site/blog\\JS模块化（四）：ES6规范.md",
        "title": "JS模块化（四）：ES6规范",
        "description": "1：初始化package.json",
        "date": "2021-03-31T00:00:00.000Z",
        "formattedDate": "2021年3月31日",
        "tags": [
          {
            "label": "JS模块化",
            "permalink": "/blog/tags/js模块化"
          }
        ],
        "readingTime": 0.665,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "JS模块化（四）：ES6规范",
          "date": "2021-03-31T00:00:00.000Z",
          "categories": "JS模块化",
          "tags": [
            "JS模块化"
          ]
        },
        "prevItem": {
          "title": "JS模块化（三）：CMD规范",
          "permalink": "/blog/JS模块化（三）：CMD规范"
        },
        "nextItem": {
          "title": "LeetCode——替换空格",
          "permalink": "/blog/LeetCode——替换空格"
        }
      },
      "content": "## 1：初始化package.json\r\n```\r\nnpm init\r\n```\r\n## 2：安装babel-preset-es2015（在生产环境中）\r\n```\r\nnpm install babel-preset-es2015 --save-dev\r\n```\r\n## 3：在package.json的同级目录增加.babelrc文件\r\n* 并将下面的内容添加进去\r\n```json\r\n{\r\n    \"presets\": [\"es2015\"]\r\n}\r\n```\r\n>如果需要全局安装babel:\r\n>npm install --global babel-cli\r\n## 4：将ES6转化为ES5\r\n```js\r\nbabel js/src -d js/build\r\n```\r\n## 5：使用browserify进行打包\r\n* 注意：打包的是ES5文件\r\n```\r\nbrowserify js/build/main.js -o js/dist/bundle.js\r\n```\r\n## 6：引入bundle.js文件\r\n![](https://img-blog.csdnimg.cn/img_convert/79a283f56a4badc7672efc35e28b404f.png)\r\n\r\n# 这篇文章是对本文的补充：\r\n[ES6—49：模块化](https://blog.csdn.net/sinat_41696687/article/details/114517025?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161613176716780269827058%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=161613176716780269827058&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v1~rank_blog_v1-1-114517025.pc_v1_rank_blog_v1&utm_term=%E6%A8%A1%E5%9D%97%E5%8C%96)"
    },
    {
      "id": "/LeetCode——替换空格",
      "metadata": {
        "permalink": "/blog/LeetCode——替换空格",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——替换空格.md",
        "source": "@site/blog\\LeetCode——替换空格.md",
        "title": "LeetCode——替换空格",
        "description": "题目描述",
        "date": "2021-03-31T00:00:00.000Z",
        "formattedDate": "2021年3月31日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.5,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "LeetCode——替换空格",
          "date": "2021-03-31T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "JS模块化（四）：ES6规范",
          "permalink": "/blog/JS模块化（四）：ES6规范"
        },
        "nextItem": {
          "title": "解决OBS录屏软件窗口采集不全的问题",
          "permalink": "/blog/解决OBS录屏软件窗口采集不全的问题"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/c9cfce9e62c3078059f7d2542f8404b0.png)\r\n\r\n## 解题思路1：使用js中的replace方法\r\n* 使用replace方法，配合正则全局匹配\r\n\r\n## 实现代码\r\n```js\r\nvar replaceSpace = function(s) {\r\n    s = s.replace(/ /g,'%20');\r\n    return s;\r\n};\r\n```\r\n## 解题思路2：使用js中的split+join\r\n* split(' ')将字符串根据空格，划分为字符数组\r\n* join('%20') 将字符数组进行组合成字符串\r\n\r\n## 实现代码\r\n![](https://img-blog.csdnimg.cn/img_convert/c7e00418832a7b397099513a90100690.png)"
    },
    {
      "id": "/解决OBS录屏软件窗口采集不全的问题",
      "metadata": {
        "permalink": "/blog/解决OBS录屏软件窗口采集不全的问题",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/解决OBS录屏软件窗口采集不全的问题.md",
        "source": "@site/blog\\解决OBS录屏软件窗口采集不全的问题.md",
        "title": "解决OBS录屏软件窗口采集不全的问题",
        "description": "问题描述",
        "date": "2021-03-31T00:00:00.000Z",
        "formattedDate": "2021年3月31日",
        "tags": [
          {
            "label": "debug",
            "permalink": "/blog/tags/debug"
          }
        ],
        "readingTime": 0.26,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "解决OBS录屏软件窗口采集不全的问题",
          "date": "2021-03-31T00:00:00.000Z",
          "categories": "debug",
          "tags": [
            "debug"
          ]
        },
        "prevItem": {
          "title": "LeetCode——替换空格",
          "permalink": "/blog/LeetCode——替换空格"
        },
        "nextItem": {
          "title": "axios基础（六）：axios取消请求",
          "permalink": "/blog/axios基础（六）：axios取消请求"
        }
      },
      "content": "## 问题描述\r\n* 使用OBS录屏软件的窗口采集功能的时候，有时候窗口对象只能捕获到一部分，不能全屏都是目标对象。\r\n\r\n## 解决办法\r\n![](https://img-blog.csdnimg.cn/img_convert/25d79e5dacf65d63f941f72b75839a91.png)"
    },
    {
      "id": "/axios基础（六）：axios取消请求",
      "metadata": {
        "permalink": "/blog/axios基础（六）：axios取消请求",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/axios基础（六）：axios取消请求.md",
        "source": "@site/blog\\axios基础（六）：axios取消请求.md",
        "title": "axios基础（六）：axios取消请求",
        "description": "为了测试取消请求的效果，我们需要将json-server服务具有延时响应的效果。",
        "date": "2021-03-30T00:00:00.000Z",
        "formattedDate": "2021年3月30日",
        "tags": [
          {
            "label": "Axios",
            "permalink": "/blog/tags/axios"
          }
        ],
        "readingTime": 1.045,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "axios基础（六）：axios取消请求",
          "date": "2021-03-30T00:00:00.000Z",
          "categories": "Axios",
          "tags": [
            "Axios"
          ]
        },
        "prevItem": {
          "title": "解决OBS录屏软件窗口采集不全的问题",
          "permalink": "/blog/解决OBS录屏软件窗口采集不全的问题"
        },
        "nextItem": {
          "title": "JS模块化（一）：Commonjs",
          "permalink": "/blog/JS模块化（一）：Commonjs"
        }
      },
      "content": ">为了测试取消请求的效果，我们需要将json-server服务具有延时响应的效果。\r\n## 实现json-server延时响应的启动方式\r\n```\r\njson-server --watch db.json -d 2000   \r\n```\r\n上面的2000就代表延时2s，再响应服务\r\n## 实现axios取消请求的方法\r\n* 声明一个全局变量cancel\r\n* 在axios请求的时候，配置一个cancelToken属性，这个属性的值是一个CancelToken对象，对象的参数是一个回调函数。\r\n* 取消的时候，只需要调用cancel函数即可。\r\n\r\n## 实现代码\r\n```js\r\n// 申明全局变量\r\nlet cancel = null;\r\n// 第一个事件：发送请求\r\nbtns[0].onclick = function() {\r\n    axios({\r\n        method: 'GET',\r\n        url: 'http://localhost:3000/posts',\r\n        // 添加配置对象的属性\r\n        cancelToken: new axios.CancelToken(function(c) {\r\n            cancel = c;\r\n        })\r\n    }).then(response => {console.log(response);})\r\n}\r\n// 第二个事件：取消请求\r\nbtns[1].onclick = function() {\r\n    cancel();\r\n}\r\n```"
    },
    {
      "id": "/JS模块化（一）：Commonjs",
      "metadata": {
        "permalink": "/blog/JS模块化（一）：Commonjs",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/JS模块化（一）：Commonjs.md",
        "source": "@site/blog\\JS模块化（一）：Commonjs.md",
        "title": "JS模块化（一）：Commonjs",
        "description": "什么是模块化？",
        "date": "2021-03-30T00:00:00.000Z",
        "formattedDate": "2021年3月30日",
        "tags": [
          {
            "label": "JS模块化",
            "permalink": "/blog/tags/js模块化"
          }
        ],
        "readingTime": 1.91,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "JS模块化（一）：Commonjs",
          "date": "2021-03-30T00:00:00.000Z",
          "categories": "JS模块化",
          "tags": [
            "JS模块化"
          ]
        },
        "prevItem": {
          "title": "axios基础（六）：axios取消请求",
          "permalink": "/blog/axios基础（六）：axios取消请求"
        },
        "nextItem": {
          "title": "JS模块化（二）：AMD规范（require.js）",
          "permalink": "/blog/JS模块化（二）：AMD规范（require.js）"
        }
      },
      "content": "## 什么是模块化？\r\n答：将一个复杂的程序依据一定的规则封装成几个块，并进行组合在一起，其内部数据是私有的，只是向外部暴露一些接口与外部其它模块进行通信。\r\n## 为什么要模块化？\r\n* 降低复杂度\r\n* 部署方便\r\n* 降低耦合\r\n* 避免命名冲突\r\n## Commonjs模块化规范\r\n* 这个文件有两个是必须的，一是包名，二是版本号。\r\n* 包名不能含有大写和中文。\r\n* 自动生成package.json文件\r\n```\r\nnpm init\r\n```\r\n* 安装uniq\r\n```\r\nnpm install uniq\r\n```\r\n*  --save是什么含义？\r\n这个的意思是说，添加到package.json中\r\n## commonjs模块暴露的三种方式\r\n### 1：module.exports = {}\r\n![](https://img-blog.csdnimg.cn/img_convert/3a05af3c8b0c4256ac190284b924aa32.png)\r\n\r\n### 2：module.exports = function()\r\n* 这种写法是覆盖方式的，后面的会覆盖前面的，不建议\r\n![](https://img-blog.csdnimg.cn/img_convert/624df4b69744c4dfa15a0d832e2359e8.png)\r\n\r\n### 3：exports.属性\r\n* 这种是通过给exports添加属性的形式，推荐使用\r\n![](https://img-blog.csdnimg.cn/img_convert/f3aaa617b6c753ea7e61425bbbbc1db8.png)\r\n\r\n### 4：通过npm安装\r\n* 以uniq这个包为例，这个包可以筛选出数组中独一无二的元素。\r\n1. npm install uniq\r\n2. 导入 const uniq = require('uniq');\r\n3. 使用 const result = uniq(arr);\r\n![](https://img-blog.csdnimg.cn/img_convert/52545a9c8e2699ae7eb8b8e624a6a6c8.png)\r\n\r\n## commonjs基于浏览器端应用\r\n* 首先全局安装并且同时需要局部安装browserify\r\n```\r\nnpm install browserify -g\r\nnpm install browserify --save-dev\r\n```\r\n* 浏览器端是无法准确识别require方法的\r\n![](https://img-blog.csdnimg.cn/img_convert/00396192c76bbb0dc1f94b8adb5e16b3.png)\r\n* 需要使用browserify进行打包处理\r\n![](https://img-blog.csdnimg.cn/img_convert/181058462da4d06905a4a65c55d6d141.png)\r\n* 浏览器运行的不是我们的源文件，而是打包好的文件\r\n* 此时运行成功\r\n![](https://img-blog.csdnimg.cn/img_convert/625e65724abf61baece1413a85fdc93b.png)"
    },
    {
      "id": "/JS模块化（二）：AMD规范（require.js）",
      "metadata": {
        "permalink": "/blog/JS模块化（二）：AMD规范（require.js）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/JS模块化（二）：AMD规范（require.js）.md",
        "source": "@site/blog\\JS模块化（二）：AMD规范（require.js）.md",
        "title": "JS模块化（二）：AMD规范（require.js）",
        "description": "AMD规范也可以称之为require.js",
        "date": "2021-03-30T00:00:00.000Z",
        "formattedDate": "2021年3月30日",
        "tags": [
          {
            "label": "JS模块化",
            "permalink": "/blog/tags/js模块化"
          }
        ],
        "readingTime": 1.145,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "JS模块化（二）：AMD规范（require.js）",
          "date": "2021-03-30T00:00:00.000Z",
          "categories": "JS模块化",
          "tags": [
            "JS模块化"
          ]
        },
        "prevItem": {
          "title": "JS模块化（一）：Commonjs",
          "permalink": "/blog/JS模块化（一）：Commonjs"
        },
        "nextItem": {
          "title": "LeetCode——链表中倒数第k个节点",
          "permalink": "/blog/LeetCode——链表中倒数第k个节点"
        }
      },
      "content": ">AMD规范也可以称之为require.js\r\n## 目录结构\r\n![](https://img-blog.csdnimg.cn/img_convert/ad2d597039f9ae457f8072d1a1a6da7a.png)\r\n\r\n## 无依赖模块写法\r\n```js\r\n// 这是一个没有依赖的模块\r\ndefine(function() {\r\n    let name = '这是没有依赖的模块';\r\n    function getName() {\r\n        return name;\r\n    }\r\n    // 暴露模块\r\n    return {getName};\r\n})\r\n```\r\n## 有依赖模块的写法\r\n```js\r\n// 下面的是有依赖的模块\r\ndefine(['dataService'],function(dataService) {\r\n    let msg = \"alert.js\";\r\n    function showMsg() {\r\n        console.log(msg,dataService.getName());\r\n    };\r\n\r\n    // 暴露模块\r\n    return {showMsg};\r\n})\r\n```\r\n## 主函数（汇总模块）\r\n```js\r\n(function() {\r\n    requirejs.config({\r\n\r\n        baseUrl: './js',\r\n\r\n        paths: {\r\n            dataService: './modules/dataService',\r\n            alerter: './modules/alerter'\r\n        }\r\n    });\r\n    requirejs(['alerter'],function(alerter) {\r\n        alerter.showMsg();\r\n    })\r\n})()\r\n```\r\n## 浏览器执行网页\r\n```js\r\n<script data-main=\"./js/main.js\" src=\"./js/libs/require.js\"></script>\r\n```\r\n## require.js下载网址\r\nhttps://github.com/requirejs/requirejs\r\n### 注意事项\r\n* 尤其要注意地址路径是否正确。\r\n## require.js引入第三方模块\r\n* 下面我们以jquery这个库为例：\r\n1. 在libs下添加库文件\r\n![](https://img-blog.csdnimg.cn/img_convert/160f0e107058a36212317385f323bd08.png)\r\n2. 在主函数处配置路由\r\n![](https://img-blog.csdnimg.cn/img_convert/b7d602bf2cedf9344e0439b8ba4fa570.png)\r\n3. 在需要暴露的模块处添加参数\r\n![](https://img-blog.csdnimg.cn/img_convert/778d72d0092026ed3edc389ea491f2e0.png)"
    },
    {
      "id": "/LeetCode——链表中倒数第k个节点",
      "metadata": {
        "permalink": "/blog/LeetCode——链表中倒数第k个节点",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——链表中倒数第k个节点.md",
        "source": "@site/blog\\LeetCode——链表中倒数第k个节点.md",
        "title": "LeetCode——链表中倒数第k个节点",
        "description": "题目描述",
        "date": "2021-03-30T00:00:00.000Z",
        "formattedDate": "2021年3月30日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.87,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "LeetCode——链表中倒数第k个节点",
          "date": "2021-03-30T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "JS模块化（二）：AMD规范（require.js）",
          "permalink": "/blog/JS模块化（二）：AMD规范（require.js）"
        },
        "nextItem": {
          "title": "「注解」《你不知道的JavaScript（上卷）》第四章：提升",
          "permalink": "/blog/「注解」《你不知道的JavaScript（上卷）》第四章：提升"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/426cae4028de1cd7a1867c8a20765cb2.png)\r\n\r\n## 解题思路\r\n* 本题采用快慢指针的思路。\r\n* 快指针先走k步。\r\n* 然后快慢指针同步走。\r\n* 当快指针的next域为空的时候，慢指针再多走一步即到了倒数第K个节点。\r\n* 本题存在一种特殊情况，即当链表只有一个节点时，直接返回节点的头指针。\r\n## 实现代码\r\n```js\r\nvar getKthFromEnd = function(head, k) {\r\n    // 本题采用快慢指针的方法\r\n    // 首先定义一个快指针\r\n    let fast = head;\r\n    let slow = head;\r\n    for(let i = 1;i <= k;i++) {\r\n        fast = fast.next;\r\n    }\r\n    if(fast === null) {\r\n        return head;\r\n    }\r\n    while (fast.next) {\r\n        fast = fast.next;\r\n        slow = slow.next;\r\n    }\r\n    slow = slow.next;\r\n\r\n    return slow;\r\n};\r\n```"
    },
    {
      "id": "/「注解」《你不知道的JavaScript（上卷）》第四章：提升",
      "metadata": {
        "permalink": "/blog/「注解」《你不知道的JavaScript（上卷）》第四章：提升",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/「注解」《你不知道的JavaScript（上卷）》第四章：提升.md",
        "source": "@site/blog\\「注解」《你不知道的JavaScript（上卷）》第四章：提升.md",
        "title": "「注解」《你不知道的JavaScript（上卷）》第四章：提升",
        "description": "先有鸡还是先有蛋",
        "date": "2021-03-30T00:00:00.000Z",
        "formattedDate": "2021年3月30日",
        "tags": [
          {
            "label": "《你不知道的JavaScript》",
            "permalink": "/blog/tags/《你不知道的-java-script》"
          }
        ],
        "readingTime": 0.555,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "「注解」《你不知道的JavaScript（上卷）》第四章：提升",
          "date": "2021-03-30T00:00:00.000Z",
          "categories": "《你不知道的JavaScript》",
          "tags": [
            "《你不知道的JavaScript》"
          ]
        },
        "prevItem": {
          "title": "LeetCode——链表中倒数第k个节点",
          "permalink": "/blog/LeetCode——链表中倒数第k个节点"
        },
        "nextItem": {
          "title": "axios基础（五）：axios拦截器",
          "permalink": "/blog/axios基础（五）：axios拦截器"
        }
      },
      "content": "## 先有鸡还是先有蛋\r\n![](https://img-blog.csdnimg.cn/img_convert/acb85f3cbc19209b9124186e4b165e60.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/3ac22ebb0da28be7e2dd19ede06911d8.png)\r\n\r\n## 编译器再度来袭\r\n* 编译阶段会先执行声明，赋值是在执行阶段执行的\r\n![](https://img-blog.csdnimg.cn/img_convert/b1ef8bc153a4d66e3b06928ceb006a2e.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/628c7481e512a9822415aa6e63de8726.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/fb0b9a79ffdce38e08b770ed2017f366.png)\r\n* 函数声明会被提升，但是函数表达式不会被提升\r\n![](https://img-blog.csdnimg.cn/img_convert/ca08fd946b5c9de50765ee881b15794b.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/c9e3469c018e5c0f065413fdb38e6078.png)\r\n\r\n## 函数优先\r\n* 在JavaScript中，重复的声明是会被忽略掉的。\r\n* 函数声明优先级要高于变量声明的优先级的\r\n![](https://img-blog.csdnimg.cn/img_convert/7c7d1a091d5bcffc72ec9f5f734c0b43.png)\r\n\r\n## 小结\r\n![](https://img-blog.csdnimg.cn/img_convert/a610adcd5ecaaa5c1dc434e34b0d1910.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/7077dd9bf7342205ac37148ace8eff17.png)"
    },
    {
      "id": "/axios基础（五）：axios拦截器",
      "metadata": {
        "permalink": "/blog/axios基础（五）：axios拦截器",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/axios基础（五）：axios拦截器.md",
        "source": "@site/blog\\axios基础（五）：axios拦截器.md",
        "title": "axios基础（五）：axios拦截器",
        "description": "请求拦截器与响应拦截器的概念",
        "date": "2021-03-29T00:00:00.000Z",
        "formattedDate": "2021年3月29日",
        "tags": [
          {
            "label": "Axios",
            "permalink": "/blog/tags/axios"
          }
        ],
        "readingTime": 1.88,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "axios基础（五）：axios拦截器",
          "date": "2021-03-29T00:00:00.000Z",
          "categories": "Axios",
          "tags": [
            "Axios"
          ]
        },
        "prevItem": {
          "title": "「注解」《你不知道的JavaScript（上卷）》第四章：提升",
          "permalink": "/blog/「注解」《你不知道的JavaScript（上卷）》第四章：提升"
        },
        "nextItem": {
          "title": "LeetCode——二叉树的深度",
          "permalink": "/blog/LeetCode——二叉树的深度"
        }
      },
      "content": "## 请求拦截器与响应拦截器的概念\r\n* 请求拦截器：相当于一种请求检测机制，只有通过该检测的请求才能被发送。\r\n* 响应拦截器：相当于一种响应检测机制，只有通过该检测的响应才能被返回。\r\n\r\n## 请求拦截器有什么作用？\r\n* 请求拦截器可以给请求添加参数\r\n![](https://img-blog.csdnimg.cn/img_convert/87914f83b71466f1124c0865f570fe9d.png)\r\n* 响应拦截器可以对响应做出一些修改，使得客户端接收到的是被修改过的响应\r\n![](https://img-blog.csdnimg.cn/img_convert/23dc7f092d450a538bb6b98c49284a20.png)\r\n\r\n## 拦截器的执行顺序是什么？\r\n* 请求拦截器是谁在定义的最后，谁先拦截，相应拦截器则是谁先定义谁先拦截。\r\n![](https://img-blog.csdnimg.cn/img_convert/d90e60337ffc83429a0f8136977763d7.png)\r\n\r\n## 模板代码\r\n```js\r\n// 设置请求拦截器\r\naxios.interceptors.request.use(function (config) {\r\n    console.log(\"请求拦截器 拦截成功 1号\");\r\n    config.params = {a: 666666};    \r\n    return config;\r\n    // throw new Error;\r\n}, function (error) {\r\n    console.log(\"请求拦截器 拦截失败 1号\");\r\n    return Promise.reject(error);\r\n});\r\n\r\naxios.interceptors.request.use(function (config) {\r\n    console.log(\"请求拦截器 拦截成功 2号\");\r\n    return config;\r\n    // throw new Error;\r\n}, function (error) {\r\n    console.log(\"请求拦截器 拦截失败 2号\");\r\n    return Promise.reject(error);\r\n});\r\n// 设置响应拦截器\r\naxios.interceptors.response.use(function (response) {\r\n    console.log(\"响应拦截器 成功 1号\");\r\n    // console.log(response);\r\n    return response.data;\r\n}, function (error) {\r\n    console.log(\"响应拦截器 default 1号\");\r\n    return Promise.reject(error);\r\n});\r\n\r\naxios.interceptors.response.use(function (response) {\r\n    console.log(\"响应拦截器 成功 2号\");\r\n    return response;\r\n}, function (error) {\r\n    console.log(\"响应拦截器 default 2号\");\r\n    return Promise.reject(error);\r\n});\r\n\r\n// 使用axios发送请求\r\naxios({\r\n    method: 'GET',\r\n    url: 'http://localhost:3000/posts'\r\n}).then((response => {console.log(response)})).catch(reason => {console.log(\"自定义回调错误\");});\r\n```"
    },
    {
      "id": "/LeetCode——二叉树的深度",
      "metadata": {
        "permalink": "/blog/LeetCode——二叉树的深度",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——二叉树的深度.md",
        "source": "@site/blog\\LeetCode——二叉树的深度.md",
        "title": "LeetCode——二叉树的深度",
        "description": "题目描述",
        "date": "2021-03-29T00:00:00.000Z",
        "formattedDate": "2021年3月29日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.335,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "LeetCode——二叉树的深度",
          "date": "2021-03-29T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "axios基础（五）：axios拦截器",
          "permalink": "/blog/axios基础（五）：axios拦截器"
        },
        "nextItem": {
          "title": "代码提交到Github仓库但是绿色小点没增加的原因",
          "permalink": "/blog/代码提交到Github仓库但是绿色小点没增加的原因"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/494c120d7576940bb53f815f390ceaad.png)\r\n\r\n## 解题思路\r\n* 使用递归的思想，去左子孩子的最大深度和右子孩子的最大深度中的最大值 + 1\r\n\r\n## 解题代码\r\n```js\r\nvar maxDepth = function(root) {\r\n    if (!root) {\r\n        return 0;        \r\n    }\r\n\r\n    return Math.max(maxDepth(root.left),maxDepth(root.right)) + 1;\r\n};\r\n```"
    },
    {
      "id": "/代码提交到Github仓库但是绿色小点没增加的原因",
      "metadata": {
        "permalink": "/blog/代码提交到Github仓库但是绿色小点没增加的原因",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/代码提交到Github仓库但是绿色小点没增加的原因.md",
        "source": "@site/blog\\代码提交到Github仓库但是绿色小点没增加的原因.md",
        "title": "代码提交到Github仓库但是绿色小点没增加的原因",
        "description": "原因",
        "date": "2021-03-29T00:00:00.000Z",
        "formattedDate": "2021年3月29日",
        "tags": [
          {
            "label": "debug",
            "permalink": "/blog/tags/debug"
          }
        ],
        "readingTime": 0.305,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "代码提交到Github仓库但是绿色小点没增加的原因",
          "date": "2021-03-29T00:00:00.000Z",
          "categories": "debug",
          "tags": [
            "debug"
          ]
        },
        "prevItem": {
          "title": "LeetCode——二叉树的深度",
          "permalink": "/blog/LeetCode——二叉树的深度"
        },
        "nextItem": {
          "title": "axios基础（一）：json-server服务搭建",
          "permalink": "/blog/axios基础（一）：json-server服务搭建"
        }
      },
      "content": "## 原因\r\n大概率是因为Github本地仓库的邮件名和Github账户的邮件名不一致。\r\n## 解决办法\r\n```\r\ngit config user.email  'your_email@example.com'\r\n```\r\n## 参考文献\r\n[解决提交代码到Github不显示小绿点的问题](https://jasonkayzk.github.io/2020/06/25/%E8%A7%A3%E5%86%B3%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E5%88%B0Github%E4%B8%8D%E6%98%BE%E7%A4%BA%E5%B0%8F%E7%BB%BF%E7%82%B9%E7%9A%84%E9%97%AE%E9%A2%98/)"
    },
    {
      "id": "/axios基础（一）：json-server服务搭建",
      "metadata": {
        "permalink": "/blog/axios基础（一）：json-server服务搭建",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/axios基础（一）：json-server服务搭建.md",
        "source": "@site/blog\\axios基础（一）：json-server服务搭建.md",
        "title": "axios基础（一）：json-server服务搭建",
        "description": "搭建步骤",
        "date": "2021-03-28T00:00:00.000Z",
        "formattedDate": "2021年3月28日",
        "tags": [
          {
            "label": "Axios",
            "permalink": "/blog/tags/axios"
          }
        ],
        "readingTime": 0.315,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "axios基础（一）：json-server服务搭建",
          "date": "2021-03-28T00:00:00.000Z",
          "categories": "Axios",
          "tags": [
            "Axios"
          ]
        },
        "prevItem": {
          "title": "代码提交到Github仓库但是绿色小点没增加的原因",
          "permalink": "/blog/代码提交到Github仓库但是绿色小点没增加的原因"
        },
        "nextItem": {
          "title": "axios基础（三）：axios的常用基础配置",
          "permalink": "/blog/axios基础（三）：axios的常用基础配置"
        }
      },
      "content": "## 搭建步骤\r\n### 1：npm安装\r\n```\r\nnpm install -g json-server\r\n```\r\n### 2：创建db.json文件\r\n```json\r\n{\r\n  \"posts\": [\r\n    { \"id\": 1, \"title\": \"json-server\", \"author\": \"typicode\" }\r\n  ],\r\n  \"comments\": [\r\n    { \"id\": 1, \"body\": \"some comment\", \"postId\": 1 }\r\n  ],\r\n  \"profile\": { \"name\": \"typicode\" }\r\n}\r\n```\r\n### 3：启动json-server服务\r\n```\r\njson-server --watch db.json\r\n```"
    },
    {
      "id": "/axios基础（三）：axios的常用基础配置",
      "metadata": {
        "permalink": "/blog/axios基础（三）：axios的常用基础配置",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/axios基础（三）：axios的常用基础配置.md",
        "source": "@site/blog\\axios基础（三）：axios的常用基础配置.md",
        "title": "axios基础（三）：axios的常用基础配置",
        "description": "常用基础配置",
        "date": "2021-03-28T00:00:00.000Z",
        "formattedDate": "2021年3月28日",
        "tags": [
          {
            "label": "Axios",
            "permalink": "/blog/tags/axios"
          }
        ],
        "readingTime": 0.2,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "axios基础（三）：axios的常用基础配置",
          "date": "2021-03-28T00:00:00.000Z",
          "categories": "Axios",
          "tags": [
            "Axios"
          ]
        },
        "prevItem": {
          "title": "axios基础（一）：json-server服务搭建",
          "permalink": "/blog/axios基础（一）：json-server服务搭建"
        },
        "nextItem": {
          "title": "axios基础（二）：axios对服务器端进行增删改查的基本用法",
          "permalink": "/blog/axios基础（二）：axios对服务器端进行增删改查的基本用法"
        }
      },
      "content": "## 常用基础配置\r\n```js\r\n// axios的常用默认配置\r\naxios.defaults.method = 'GET';\r\naxios.defaults.baseURL = 'http://localhost:3000';\r\naxios.defaults.params = {id: 2};\r\n\r\nbtns[0].onclick = function() {\r\n    axios({\r\n        url: '/posts'\r\n    }).then(response => {console.log(response);})\r\n}\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/7ed04ef568b7f86ed357236ade6be5da.png)"
    },
    {
      "id": "/axios基础（二）：axios对服务器端进行增删改查的基本用法",
      "metadata": {
        "permalink": "/blog/axios基础（二）：axios对服务器端进行增删改查的基本用法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/axios基础（二）：axios对服务器端进行增删改查的基本用法.md",
        "source": "@site/blog\\axios基础（二）：axios对服务器端进行增删改查的基本用法.md",
        "title": "axios基础（二）：axios对服务器端进行增删改查的基本用法",
        "description": "GET请求",
        "date": "2021-03-28T00:00:00.000Z",
        "formattedDate": "2021年3月28日",
        "tags": [
          {
            "label": "Axios",
            "permalink": "/blog/tags/axios"
          }
        ],
        "readingTime": 1,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "axios基础（二）：axios对服务器端进行增删改查的基本用法",
          "date": "2021-03-28T00:00:00.000Z",
          "categories": "Axios",
          "tags": [
            "Axios"
          ]
        },
        "prevItem": {
          "title": "axios基础（三）：axios的常用基础配置",
          "permalink": "/blog/axios基础（三）：axios的常用基础配置"
        },
        "nextItem": {
          "title": "axios基础（四）：axios创建实例对象发送请求",
          "permalink": "/blog/axios基础（四）：axios创建实例对象发送请求"
        }
      },
      "content": "## GET请求\r\n```js\r\n// 给第一个btn绑定GET请求\r\nbtns[0].onclick = function() {\r\n    axios({\r\n        method: 'GET',\r\n        url: \"http://localhost:3000/posts/2\"\r\n    }).then((response) => {\r\n        console.log(response);\r\n    })\r\n}\r\n```\r\n## POST请求\r\n```js\r\n// 给第二个按钮，绑定POST请求，既然是POST请求则需要请求体\r\nbtns[1].onclick = function() {\r\n    axios({\r\n        method: 'POST',\r\n        url: \"http://localhost:3000/posts\",\r\n        data: {\r\n            title: \"这是第三篇文章，菜根谭\",\r\n            author: \"玩野猫\"\r\n        }\r\n    }).then((response) => {\r\n        console.log(response);\r\n    })\r\n}\r\n```\r\n## PUT请求\r\n```js\r\n// 给第三个按钮，绑定PUT请求，PUT请求可以理解为修改已有的数据  需要加id\r\nbtns[2].onclick = function() {\r\n    axios({\r\n        method: 'PUT',\r\n        url: \"http://localhost:3000/posts/3\",\r\n        data: {\r\n            title: \"朱元璋很好看\",\r\n            author: \"刘伯温\"\r\n        }\r\n    }).then((response) => {\r\n        console.log(response);\r\n    })\r\n}\r\n```\r\n## DELETE请求\r\n```js\r\n// 给第四个按钮，绑定DELETE请求，需要加id\r\nbtns[3].onclick = function() {\r\n    axios({\r\n        method: 'delete',\r\n        url: \"http://localhost:3000/posts/3\",\r\n    }).then((response) => {\r\n        console.log(response);\r\n    })\r\n}\r\n```"
    },
    {
      "id": "/axios基础（四）：axios创建实例对象发送请求",
      "metadata": {
        "permalink": "/blog/axios基础（四）：axios创建实例对象发送请求",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/axios基础（四）：axios创建实例对象发送请求.md",
        "source": "@site/blog\\axios基础（四）：axios创建实例对象发送请求.md",
        "title": "axios基础（四）：axios创建实例对象发送请求",
        "description": "示例代码",
        "date": "2021-03-28T00:00:00.000Z",
        "formattedDate": "2021年3月28日",
        "tags": [
          {
            "label": "Axios",
            "permalink": "/blog/tags/axios"
          }
        ],
        "readingTime": 0.165,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "axios基础（四）：axios创建实例对象发送请求",
          "date": "2021-03-28T00:00:00.000Z",
          "categories": "Axios",
          "tags": [
            "Axios"
          ]
        },
        "prevItem": {
          "title": "axios基础（二）：axios对服务器端进行增删改查的基本用法",
          "permalink": "/blog/axios基础（二）：axios对服务器端进行增删改查的基本用法"
        },
        "nextItem": {
          "title": "LeetCode——二叉树的镜像",
          "permalink": "/blog/LeetCode——二叉树的镜像"
        }
      },
      "content": "## 示例代码\r\n```js\r\n// axios创建实例对象来发起请求\r\nconst fun = axios.create({\r\n    baseURL: 'https://api.apiopen.top'\r\n});\r\n\r\nfun({\r\n    url: 'getJoke'\r\n}).then(response => console.log(response));\r\n```"
    },
    {
      "id": "/LeetCode——二叉树的镜像",
      "metadata": {
        "permalink": "/blog/LeetCode——二叉树的镜像",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——二叉树的镜像.md",
        "source": "@site/blog\\LeetCode——二叉树的镜像.md",
        "title": "LeetCode——二叉树的镜像",
        "description": "题目描述",
        "date": "2021-03-27T00:00:00.000Z",
        "formattedDate": "2021年3月27日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.71,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "LeetCode——二叉树的镜像",
          "date": "2021-03-27T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "axios基础（四）：axios创建实例对象发送请求",
          "permalink": "/blog/axios基础（四）：axios创建实例对象发送请求"
        },
        "nextItem": {
          "title": "LeetCode——数组中数字出现的次数II",
          "permalink": "/blog/LeetCode——数组中数字出现的次数II"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/38172ea25f3380b97a1b214c40e83eb6.png)\r\n\r\n## 解题思路\r\n* 需要明确指出的是我们返回的排序好的root对象\r\n* 我们首先判断root这个参数的左右孩子节点是否为空，只要为空，则说明排序好了。\r\n* 不为空，则使用交换方法，交换左右指针。\r\n* 最后使用递归，将左右孩子节点继续投入函数中。\r\n\r\n## 实现代码\r\n```js\r\nvar mirrorTree = function (root) {\r\n    fun(root);\r\n    return root;\r\n\r\n};\r\nvar fun = function (root) {\r\n\r\n\r\n    if (root !== null) {\r\n        var temp;\r\n        temp = root.left;\r\n        root.left = root.right;\r\n        root.right = temp;\r\n        mirrorTree(root.left);\r\n        mirrorTree(root.right);\r\n    }\r\n\r\n};\r\n```"
    },
    {
      "id": "/LeetCode——数组中数字出现的次数II",
      "metadata": {
        "permalink": "/blog/LeetCode——数组中数字出现的次数II",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——数组中数字出现的次数II.md",
        "source": "@site/blog\\LeetCode——数组中数字出现的次数II.md",
        "title": "LeetCode——数组中数字出现的次数II",
        "description": "题目描述",
        "date": "2021-03-27T00:00:00.000Z",
        "formattedDate": "2021年3月27日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.74,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "LeetCode——数组中数字出现的次数II",
          "date": "2021-03-27T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "LeetCode——二叉树的镜像",
          "permalink": "/blog/LeetCode——二叉树的镜像"
        },
        "nextItem": {
          "title": "「注解」《你不知道的JavaScript（上卷）》第三章：函数作用域和块作用域",
          "permalink": "/blog/「注解」《你不知道的JavaScript（上卷）》第三章：函数作用域和块作用域"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/61c65afd8488266619d74e11314a5cb5.png)\r\n\r\n## 解题思路\r\n* 使用JS中的Map数据结构\r\n* 首先创建Map数据结构，然后依次遍历判断该数据结构中是否包含数组的元素，如果不包含就创建键值对，并将值置为1，包含的话则将值+1\r\n* 最后遍历Map数据结构，如果值为1的话，则返回对应的键。\r\n\r\n## 解题代码\r\n```js\r\nvar singleNumber = function(nums) {\r\n    const m = new Map();\r\n\r\n    for(let v of nums) {\r\n        if (m.has(v)) {\r\n            m.set(v,m.get(v)+1);\r\n        } else {\r\n            m.set(v,1);\r\n        }\r\n    };\r\n    for (let v of m) {\r\n        if(v[1] === 1) {\r\n            return v[0];\r\n        }\r\n    }\r\n};\r\n```"
    },
    {
      "id": "/「注解」《你不知道的JavaScript（上卷）》第三章：函数作用域和块作用域",
      "metadata": {
        "permalink": "/blog/「注解」《你不知道的JavaScript（上卷）》第三章：函数作用域和块作用域",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/「注解」《你不知道的JavaScript（上卷）》第三章：函数作用域和块作用域.md",
        "source": "@site/blog\\「注解」《你不知道的JavaScript（上卷）》第三章：函数作用域和块作用域.md",
        "title": "「注解」《你不知道的JavaScript（上卷）》第三章：函数作用域和块作用域",
        "description": "函数中的作用域",
        "date": "2021-03-27T00:00:00.000Z",
        "formattedDate": "2021年3月27日",
        "tags": [
          {
            "label": "《你不知道的JavaScript》",
            "permalink": "/blog/tags/《你不知道的-java-script》"
          }
        ],
        "readingTime": 2.84,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "「注解」《你不知道的JavaScript（上卷）》第三章：函数作用域和块作用域",
          "date": "2021-03-27T00:00:00.000Z",
          "categories": "《你不知道的JavaScript》",
          "tags": [
            "《你不知道的JavaScript》"
          ]
        },
        "prevItem": {
          "title": "LeetCode——数组中数字出现的次数II",
          "permalink": "/blog/LeetCode——数组中数字出现的次数II"
        },
        "nextItem": {
          "title": "Ajax-20：Jquery发送jsonp请求",
          "permalink": "/blog/Ajax-20：Jquery发送jsonp请求"
        }
      },
      "content": "## 函数中的作用域\r\n![](https://img-blog.csdnimg.cn/img_convert/c1ed0673cb3b4fbdcd60935d35708c1a.png)\r\n\r\n## 隐藏内部实现\r\n![](https://img-blog.csdnimg.cn/img_convert/3d95f32d6d1cfcd0b361b7f5e2a0116b.png)\r\n\r\n* 为什么不将所有的变量和函数都放在全局作用域中？\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/4940c502dfce61c4dfe55601a38d1fa0.png)![](https://img-blog.csdnimg.cn/img_convert/6132b5cacf211ed25c3604a30a001a2d.png)\r\n\r\n### 规避冲突\r\n* 隐藏作用域中的变量和函数可以避免同名标识符之间的冲突。\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/55e2fd3103872ce5e99fb1052f72f045.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/3838ccc38577b9d385c20683f396de99.png)\r\n\r\n#### 全局命名空间\r\n* 很多第三方库为了防止变量冲突，通常会为变量命名一个非常独特的名字。\r\n![](https://img-blog.csdnimg.cn/img_convert/0581f499771c7f7190562544d272e893.png)\r\n\r\n#### 模块管理\r\n![](https://img-blog.csdnimg.cn/img_convert/22f90241e637adc223ec3c126a4d5295.png)\r\n\r\n## 函数作用域\r\n* 立即执行函数是一种既不需要函数名同时能够自动执行的函数。\r\n### 匿名和具名\r\n* 区分匿名函数表达式和函数声明：函数声明需要函数名，但是函数表达式则不需要。\r\n* 匿名函数表达式有以下几个缺点：\r\n1. 匿名函数在栈追踪中没有名字，会使得调试困难。\r\n2. 没有函数名，如果需要递归时，只能使用已经过期的arguments.callee引用。\r\n3. 匿名函数降低了代码的可读性。\r\n\r\n### 立即执行函数表达式\r\n* 立即执行函数的英文缩写：IIFE\r\n* 立即执行函数传递参数\r\n![](https://img-blog.csdnimg.cn/img_convert/2bcf4cd08df480a51e0ffe04dc0336f5.png)\r\n\r\n* 倒置代码的运行顺序：window才是真正的参数\r\n![](https://img-blog.csdnimg.cn/img_convert/6e5b25a8a4e846372831cc58a73bef86.png)\r\n\r\n## 块作用域\r\n* 分清定义在块级作用域内还是块级作用域之外\r\n![](https://img-blog.csdnimg.cn/img_convert/44a0fdca098fd7c75c1ae39c79abf21d.png)\r\n\r\n### with关键字可以形成一个块作用域\r\n### try/catch\r\n* catch中的参数会形成一个块级作用域\r\n* 但是如果在catch内部进行var声明，依然是声明在全局作用域中\r\n![](https://img-blog.csdnimg.cn/img_convert/5ca00bf0df7df66bdb30c963e4dadff9.png)\r\n\r\n### let关键字\r\n* let关键字会形成一个隐式的块级作用域，这个隐式是相对于下面的显式而言的。\r\n![](https://img-blog.csdnimg.cn/img_convert/372af1527c6736d2f2c790c9ded64a50.png)\r\n\r\n* let声明的变量不会在块作用域中进行提升。\r\n![](https://img-blog.csdnimg.cn/img_convert/3794585857f414406486b196b5e67ca1.png)\r\n\r\n#### 垃圾收集\r\n* 通过块级作用域，可以让引擎清楚的知道没有必要保存已经用不到的变量了。\r\n![](https://img-blog.csdnimg.cn/img_convert/42adb1f87135b859e4794875adc8ca79.png)\r\n\r\n#### const关键字\r\n* const同样可以用来创建块级作用域，但是块级作用域的值是固定的，但是如果存放的是引用地址的话，地址不能变，但是地址指向的值是可以修改的。\r\n![](https://img-blog.csdnimg.cn/img_convert/d259ecf852f429f9ab241f539e4450cd.png)\r\n\r\n## 小结\r\n![](https://img-blog.csdnimg.cn/img_convert/271abb84aab5f4aa89daf787599ccf1b.png)"
    },
    {
      "id": "/Ajax-20：Jquery发送jsonp请求",
      "metadata": {
        "permalink": "/blog/Ajax-20：Jquery发送jsonp请求",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Ajax-20：Jquery发送jsonp请求.md",
        "source": "@site/blog\\Ajax-20：Jquery发送jsonp请求.md",
        "title": "Ajax-20：Jquery发送jsonp请求",
        "description": "客户端",
        "date": "2021-03-26T00:00:00.000Z",
        "formattedDate": "2021年3月26日",
        "tags": [
          {
            "label": "Ajax",
            "permalink": "/blog/tags/ajax"
          }
        ],
        "readingTime": 0.345,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Ajax-20：Jquery发送jsonp请求",
          "date": "2021-03-26T00:00:00.000Z",
          "categories": "Ajax",
          "tags": [
            "Ajax"
          ]
        },
        "prevItem": {
          "title": "「注解」《你不知道的JavaScript（上卷）》第三章：函数作用域和块作用域",
          "permalink": "/blog/「注解」《你不知道的JavaScript（上卷）》第三章：函数作用域和块作用域"
        },
        "nextItem": {
          "title": "Ajax-21：设置CORS响应头实现跨域",
          "permalink": "/blog/Ajax-21：设置CORS响应头实现跨域"
        }
      },
      "content": "## 客户端\r\n```js\r\n$('button').eq(0).click(function() {\r\n    $.getJSON('http://localhost:9000/jquery-jsonp?callback=?',function(data) {\r\n        $('.result').html(`\r\n            编号: ${data.id}<br>\r\n            消息: ${data.msg}\r\n        `)\r\n    })\r\n});\r\n```\r\n## 服务器端\r\n```js\r\n// 测试jquery的jsonp服务\r\napp.all('/jquery-jsonp',(request,response) => {\r\n    const data = {\r\n        id: 1,\r\n        msg: '该用户名已存在'\r\n    };\r\n    const str = JSON.stringify(data);\r\n    // 接受callback参数\r\n    let cb = request.query.callback;\r\n\r\n    response.end(`${cb}(${str})`);\r\n})\r\n```"
    },
    {
      "id": "/Ajax-21：设置CORS响应头实现跨域",
      "metadata": {
        "permalink": "/blog/Ajax-21：设置CORS响应头实现跨域",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Ajax-21：设置CORS响应头实现跨域.md",
        "source": "@site/blog\\Ajax-21：设置CORS响应头实现跨域.md",
        "title": "Ajax-21：设置CORS响应头实现跨域",
        "description": "CORS是什么？",
        "date": "2021-03-26T00:00:00.000Z",
        "formattedDate": "2021年3月26日",
        "tags": [
          {
            "label": "Ajax",
            "permalink": "/blog/tags/ajax"
          }
        ],
        "readingTime": 0.59,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Ajax-21：设置CORS响应头实现跨域",
          "date": "2021-03-26T00:00:00.000Z",
          "categories": "Ajax",
          "tags": [
            "Ajax"
          ]
        },
        "prevItem": {
          "title": "Ajax-20：Jquery发送jsonp请求",
          "permalink": "/blog/Ajax-20：Jquery发送jsonp请求"
        },
        "nextItem": {
          "title": "「注解」《你不知道的JavaScript（上卷）》第一章：作用域是什么",
          "permalink": "/blog/「注解」《你不知道的JavaScript（上卷）》第一章：作用域是什么"
        }
      },
      "content": "## CORS是什么？\r\nCORS（跨域资源共享），是官方的跨域解决方案，它的特点是是不需要再客户端做任何特殊的操作，完全在服务器中进行处理，支持GET和POST请求。跨域资源共享标准新增了一组HTTP首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。\r\n## 设置允许跨域的相应头\r\n```js\r\nresponse.setHeader('Access-Control-Allow-Origin', '*')\r\n```"
    },
    {
      "id": "/「注解」《你不知道的JavaScript（上卷）》第一章：作用域是什么",
      "metadata": {
        "permalink": "/blog/「注解」《你不知道的JavaScript（上卷）》第一章：作用域是什么",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/「注解」《你不知道的JavaScript（上卷）》第一章：作用域是什么.md",
        "source": "@site/blog\\「注解」《你不知道的JavaScript（上卷）》第一章：作用域是什么.md",
        "title": "「注解」《你不知道的JavaScript（上卷）》第一章：作用域是什么",
        "description": "书名：《你不知道的JavaScript（上卷）》",
        "date": "2021-03-26T00:00:00.000Z",
        "formattedDate": "2021年3月26日",
        "tags": [
          {
            "label": "《你不知道的JavaScript》",
            "permalink": "/blog/tags/《你不知道的-java-script》"
          }
        ],
        "readingTime": 2.01,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "「注解」《你不知道的JavaScript（上卷）》第一章：作用域是什么",
          "date": "2021-03-26T00:00:00.000Z",
          "categories": "《你不知道的JavaScript》",
          "tags": [
            "《你不知道的JavaScript》"
          ]
        },
        "prevItem": {
          "title": "Ajax-21：设置CORS响应头实现跨域",
          "permalink": "/blog/Ajax-21：设置CORS响应头实现跨域"
        },
        "nextItem": {
          "title": "「注解」《你不知道的JavaScript（上卷）》第二章：词法作用域",
          "permalink": "/blog/「注解」《你不知道的JavaScript（上卷）》第二章：词法作用域"
        }
      },
      "content": ">书名：《你不知道的JavaScript（上卷）》\r\n>作者：Kyle Simpson\r\n>译者：赵望野 , 梁杰\r\n---\r\n## 1.1 编译原理\r\n在传统的编译语言的流程中，程序中的一段源代码在执行之前会经历以下三个步骤：\r\n1. 词法分析\r\n![](https://img-blog.csdnimg.cn/img_convert/f543405da3325f6b752cdb791e8e1308.png)\r\n\r\n2. 语法分析\r\n![](https://img-blog.csdnimg.cn/img_convert/0da30126bba9c670657e6a1b494d7ea5.png)\r\n\r\n3. 代码生成\r\n![](https://img-blog.csdnimg.cn/img_convert/8d98b49a64c99f21c6794653ce95acef.png)\r\n\r\n## 1.2 理解作用域\r\n### 理解引擎、编译器、作用域\r\n![](https://img-blog.csdnimg.cn/img_convert/ccbb1b0083681e2de6560ba1abdcf913.png)\r\n\r\n### 编译器如何处理 var a = 2;\r\n![](https://img-blog.csdnimg.cn/img_convert/734fbc2bddcb5810b9c716b4026154e3.png)\r\n\r\n总结：引擎在执行赋值操作之前会询问作用域中是否含有a这个变量，有则赋值，无则抛出异常，对编译器来说，遇到var a则会先询问作用域中是否有a，是则继续，无则让作用域在当前作用域的集合中声明一个新的变量，并命名为a。\r\n\r\n### 准确理解LHS查询和RHS查询\r\n>LHS指的是**赋值操作的目标是谁**\r\n>RHS指的是**赋值操作的源头**\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/626cf323cae2d1f2ebe03c878e718097.png)\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/19d4fb359147702317fe3e4a26e63416.png)\r\n\r\n## 1.3 作用域嵌套\r\n### 作用域有向上查找的规则\r\n![](https://img-blog.csdnimg.cn/img_convert/20093cf4e47a3a56f8adbd807ee253f9.png)\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/f3aa4784fb364f08dddd12211d5f153e.png)\r\n\r\n## 1.4 异常\r\n### 区分LHS查询和RHS查询是一件很重要的事情\r\n* RHS查询如果从下到上一直找到全局作用域都找不到的情况下，会抛出异常。\r\n* LHS查询如果从下到上一直找到全局作用域都找不到的情况下，全局作用域就会创建一个具有该名称的变量。（非严格模式下）\r\n## 1.5 小结\r\n### 作用域的概念\r\n>作用域是一套规则，用于确定在何处以及如何查找变量。\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/ad868fdd162e0ef274e3cdd06639e5c1.png)"
    },
    {
      "id": "/「注解」《你不知道的JavaScript（上卷）》第二章：词法作用域",
      "metadata": {
        "permalink": "/blog/「注解」《你不知道的JavaScript（上卷）》第二章：词法作用域",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/「注解」《你不知道的JavaScript（上卷）》第二章：词法作用域.md",
        "source": "@site/blog\\「注解」《你不知道的JavaScript（上卷）》第二章：词法作用域.md",
        "title": "「注解」《你不知道的JavaScript（上卷）》第二章：词法作用域",
        "description": "词法阶段",
        "date": "2021-03-26T00:00:00.000Z",
        "formattedDate": "2021年3月26日",
        "tags": [
          {
            "label": "《你不知道的JavaScript》",
            "permalink": "/blog/tags/《你不知道的-java-script》"
          }
        ],
        "readingTime": 0.385,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "「注解」《你不知道的JavaScript（上卷）》第二章：词法作用域",
          "date": "2021-03-26T00:00:00.000Z",
          "categories": "《你不知道的JavaScript》",
          "tags": [
            "《你不知道的JavaScript》"
          ]
        },
        "prevItem": {
          "title": "「注解」《你不知道的JavaScript（上卷）》第一章：作用域是什么",
          "permalink": "/blog/「注解」《你不知道的JavaScript（上卷）》第一章：作用域是什么"
        },
        "nextItem": {
          "title": "Ajax-16：Axios发送Ajax请求",
          "permalink": "/blog/Ajax-16：Axios发送Ajax请求"
        }
      },
      "content": "## 词法阶段\r\n* 逐级嵌套的作用域举例\r\n![](https://img-blog.csdnimg.cn/img_convert/418b2d1767b96c9583e36e4e75b99bd4.png)\r\n\r\n## 查找\r\n![](https://img-blog.csdnimg.cn/img_convert/f3b86bf4a5445540fcc89c3e69c6a31c.png)\r\n\r\n## 欺骗词法\r\n### eval()函数\r\n![](https://img-blog.csdnimg.cn/img_convert/fe6a139eb3c06223cba51ba50d157cbc.png)\r\n\r\n* 严格模式下的eval函数是无效的\r\n![](https://img-blog.csdnimg.cn/img_convert/6007767c8e5784cfa5cf2f54cf1490b2.png)\r\n\r\n### with关键字\r\n* 基本用法\r\n![](https://img-blog.csdnimg.cn/img_convert/db65a856a8923818ed4d017d39078eab.png)\r\n\r\n* 使用with有时候会污染全局变量\r\n![](https://img-blog.csdnimg.cn/img_convert/515e88fa570fa631064b9ff2d1a7f46f.png)\r\n\r\n## 性能\r\n![](https://img-blog.csdnimg.cn/img_convert/bbb8c3bcb187fe4f77f0169e9425b8b2.png)\r\n\r\n## 小结\r\n![](https://img-blog.csdnimg.cn/img_convert/5fe0486f56ea2449c8cbde5b6bdfe8c4.png)"
    },
    {
      "id": "/Ajax-16：Axios发送Ajax请求",
      "metadata": {
        "permalink": "/blog/Ajax-16：Axios发送Ajax请求",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Ajax-16：Axios发送Ajax请求.md",
        "source": "@site/blog\\Ajax-16：Axios发送Ajax请求.md",
        "title": "Ajax-16：Axios发送Ajax请求",
        "description": "axios的CDN引入链接",
        "date": "2021-03-25T00:00:00.000Z",
        "formattedDate": "2021年3月25日",
        "tags": [
          {
            "label": "Ajax",
            "permalink": "/blog/tags/ajax"
          }
        ],
        "readingTime": 1.005,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Ajax-16：Axios发送Ajax请求",
          "date": "2021-03-25T00:00:00.000Z",
          "categories": "Ajax",
          "tags": [
            "Ajax"
          ]
        },
        "prevItem": {
          "title": "「注解」《你不知道的JavaScript（上卷）》第二章：词法作用域",
          "permalink": "/blog/「注解」《你不知道的JavaScript（上卷）》第二章：词法作用域"
        },
        "nextItem": {
          "title": "Ajax-17：使用fetch函数发送ajax请求",
          "permalink": "/blog/Ajax-17：使用fetch函数发送ajax请求"
        }
      },
      "content": "## axios的CDN引入链接\r\n```\r\n<script src=\"https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js\"></script>\r\n```\r\n## axios的GET请求\r\n```js\r\nconst btns = document.querySelectorAll('button');\r\n// 配置baseURL\r\naxios.defaults.baseURL = 'http://localhost:8000';\r\nbtns[0].onclick = function() {\r\n    axios.get('/axios-server',{\r\n        // url参数\r\n        params: {\r\n            id: 666666,\r\n            name: 'justin'\r\n        },\r\n        // 请求头信息\r\n        headers: {\r\n            color: \"red\"\r\n        }\r\n    }).then(value => {console.log(value);})\r\n}\r\n```\r\n## axios的POST请求\r\n```js\r\nbtns[1].onclick = function () {\r\n    axios.post('/axios-server',{\r\n        username: 'pink',\r\n        password: 123456\r\n    }, {\r\n        // url参数\r\n        params: {\r\n            id: 999,\r\n            school: 'Tsinghua'\r\n        },\r\n        // 请求头参数\r\n        headers: {\r\n            height: 600,\r\n            weight: 300\r\n        }\r\n    })\r\n}\r\n```\r\n* 第一个参数是URL\r\n* 第二个参数是请求体\r\n* 第三个参数是请求头参数\r\n## axios的通用函数发送请求\r\n```js\r\nbtns[2].onclick = function() {\r\n    axios({\r\n        // 请求方式\r\n        method: 'POST',\r\n        url: '/axios-server',\r\n        // url参数\r\n        params: {\r\n            vip: 100,\r\n            name: 'jusitn'\r\n        },\r\n        // 头信息\r\n        headers: {\r\n            a: 100,\r\n            b: 30000\r\n        },\r\n        // 请求体参数\r\n        data: {\r\n            username: 'admin',\r\n            password: 123456\r\n        }\r\n    }).then(value => {console.log(value);})\r\n}\r\n```"
    },
    {
      "id": "/Ajax-17：使用fetch函数发送ajax请求",
      "metadata": {
        "permalink": "/blog/Ajax-17：使用fetch函数发送ajax请求",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Ajax-17：使用fetch函数发送ajax请求.md",
        "source": "@site/blog\\Ajax-17：使用fetch函数发送ajax请求.md",
        "title": "Ajax-17：使用fetch函数发送ajax请求",
        "description": "基础用法",
        "date": "2021-03-25T00:00:00.000Z",
        "formattedDate": "2021年3月25日",
        "tags": [
          {
            "label": "Ajax",
            "permalink": "/blog/tags/ajax"
          }
        ],
        "readingTime": 0.215,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Ajax-17：使用fetch函数发送ajax请求",
          "date": "2021-03-25T00:00:00.000Z",
          "categories": "Ajax",
          "tags": [
            "Ajax"
          ]
        },
        "prevItem": {
          "title": "Ajax-16：Axios发送Ajax请求",
          "permalink": "/blog/Ajax-16：Axios发送Ajax请求"
        },
        "nextItem": {
          "title": "Ajax-18：同源策略",
          "permalink": "/blog/Ajax-18：同源策略"
        }
      },
      "content": "## 基础用法\r\n```js\r\nbtn.onclick = function() {\r\n    fetch('http://localhost:8000/fetch',{\r\n        // 请求方法\r\n        method: 'POST',\r\n        // 请求头\r\n        headers: {\r\n            name: 'justin'\r\n        },\r\n        // 请求体\r\n        body: {\r\n            username: 'jusitn',\r\n            password: 123456\r\n        }\r\n    }).then(value => {console.log(value);})\r\n}\r\n```"
    },
    {
      "id": "/Ajax-18：同源策略",
      "metadata": {
        "permalink": "/blog/Ajax-18：同源策略",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Ajax-18：同源策略.md",
        "source": "@site/blog\\Ajax-18：同源策略.md",
        "title": "Ajax-18：同源策略",
        "description": "什么是同源策略？",
        "date": "2021-03-25T00:00:00.000Z",
        "formattedDate": "2021年3月25日",
        "tags": [
          {
            "label": "Ajax",
            "permalink": "/blog/tags/ajax"
          }
        ],
        "readingTime": 0.905,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Ajax-18：同源策略",
          "date": "2021-03-25T00:00:00.000Z",
          "categories": "Ajax",
          "tags": [
            "Ajax"
          ]
        },
        "prevItem": {
          "title": "Ajax-17：使用fetch函数发送ajax请求",
          "permalink": "/blog/Ajax-17：使用fetch函数发送ajax请求"
        },
        "nextItem": {
          "title": "Ajax-19：如何解决跨域问题",
          "permalink": "/blog/Ajax-19：如何解决跨域问题"
        }
      },
      "content": "## 什么是同源策略？\r\n同源策略是浏览器的一种安全策略。同源指的是协议、域名、端口号必须完全相同，违背同源策略就是**跨域**。\r\n## 同源下访问URL可以简写\r\n```js\r\nconst btn = document.querySelector('button');\r\n\r\nbtn.onclick = function() {\r\n    const xhr = new XMLHttpRequest();\r\n    // 因为满足同源策略，所以url路径可以简写\r\n    xhr.open('GET','/data');\r\n    xhr.send();\r\n    xhr.onreadystatechange = function() {\r\n        if(xhr.readyState === 4) {\r\n            if(xhr.status >= 200 && xhr.status < 300) {\r\n                console.log(xhr.response);\r\n            }\r\n        }\r\n    }            \r\n}\r\n```\r\n## 注意事项\r\n* 通过VScode右键打开的网页是5500端口，在进行测试的时候，我们一定要看清和我们服务器端口设置的端口是否一致，一旦不一致就会出现跨域问题。"
    },
    {
      "id": "/Ajax-19：如何解决跨域问题",
      "metadata": {
        "permalink": "/blog/Ajax-19：如何解决跨域问题",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Ajax-19：如何解决跨域问题.md",
        "source": "@site/blog\\Ajax-19：如何解决跨域问题.md",
        "title": "Ajax-19：如何解决跨域问题",
        "description": "什么是JSONP？",
        "date": "2021-03-25T00:00:00.000Z",
        "formattedDate": "2021年3月25日",
        "tags": [
          {
            "label": "Ajax",
            "permalink": "/blog/tags/ajax"
          }
        ],
        "readingTime": 1.53,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Ajax-19：如何解决跨域问题",
          "date": "2021-03-25T00:00:00.000Z",
          "categories": "Ajax",
          "tags": [
            "Ajax"
          ]
        },
        "prevItem": {
          "title": "Ajax-18：同源策略",
          "permalink": "/blog/Ajax-18：同源策略"
        },
        "nextItem": {
          "title": "JavaScript中reduce()函数的用法",
          "permalink": "/blog/JavaScript中reduce()函数的用法"
        }
      },
      "content": "## 什么是JSONP？\r\njsonp是一个非官方的跨域解决方案，只支持GET请求。\r\n## JSONP是如何工作的？\r\n网页中有一些原本就具有跨域能力的标签，比如img,link,iframe,script，jsonp就是利用script标签的跨域能力进行发送请求的。\r\n* 以script标签为例，jsonp接受的不能是普通的字符串，而应当是js代码\r\n![](https://img-blog.csdnimg.cn/img_convert/f455300cf5c16dc7e2f0f3a70dff1906.png)\r\n\r\n## 原生jsonp跨域案例\r\n* 当用户的焦点离开输入框时，发送jsonp请求，然后返回该用户名已存在，同时将输入框的边框颜色变成红色。\r\n* 客户端：\r\n```js\r\n// 获取input和p标签\r\nconst input = document.querySelector('input');\r\nconst p = document.querySelector('p');\r\n\r\n// 定义handle函数\r\nfunction handle(data) {\r\n    input.style.border = 'solid 2px red';\r\n    p.innerHTML = data.msg;\r\n};\r\n\r\n// 当用户的焦点移出输入框时触发函数\r\ninput.onblur = function() {\r\n    // 获取用户输入的值\r\n    let user_input = this.value;\r\n\r\n    // 创建script标签,发送jsonp请求\r\n    const script = document.createElement('script');\r\n    // 向script标签中添加url\r\n    script.src = \"http://localhost:9000/jsonp\";\r\n    // 将创建好的script标签加到文档对象模型中\r\n    document.body.appendChild(script);\r\n```\r\n* 服务器端\r\n```js\r\n// 测试jsonp服务\r\napp.all('/jsonp',(request,response) => {\r\n    const data = {\r\n        id: 1,\r\n        msg: '该用户名已存在'\r\n    };\r\n    const str = JSON.stringify(data);\r\n    response.send(`handle(${str})`);\r\n})\r\n```"
    },
    {
      "id": "/JavaScript中reduce()函数的用法",
      "metadata": {
        "permalink": "/blog/JavaScript中reduce()函数的用法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/JavaScript中reduce()函数的用法.md",
        "source": "@site/blog\\JavaScript中reduce()函数的用法.md",
        "title": "JavaScript中reduce()函数的用法",
        "description": "reduce()方法对数组中的每一个元素执行一个由您提供的reducer函数（升序执行），将其结果汇总为单个返回的值。",
        "date": "2021-03-25T00:00:00.000Z",
        "formattedDate": "2021年3月25日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.22,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "JavaScript中reduce()函数的用法",
          "date": "2021-03-25T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "Ajax-19：如何解决跨域问题",
          "permalink": "/blog/Ajax-19：如何解决跨域问题"
        },
        "nextItem": {
          "title": "LeetCode——求1+2+…+n",
          "permalink": "/blog/LeetCode——求1+2+…+n"
        }
      },
      "content": "## reduce()方法对数组中的每一个元素执行一个由您提供的reducer函数（升序执行），将其结果汇总为单个返回的值。\r\n![](https://img-blog.csdnimg.cn/img_convert/8e2959d16de7fb57580d3a3e4c2db2d7.png)"
    },
    {
      "id": "/LeetCode——求1+2+…+n",
      "metadata": {
        "permalink": "/blog/LeetCode——求1+2+…+n",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——求1+2+…+n.md",
        "source": "@site/blog\\LeetCode——求1+2+…+n.md",
        "title": "LeetCode——求1+2+…+n",
        "description": "题目描述",
        "date": "2021-03-25T00:00:00.000Z",
        "formattedDate": "2021年3月25日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.38,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "LeetCode——求1+2+…+n",
          "date": "2021-03-25T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "JavaScript中reduce()函数的用法",
          "permalink": "/blog/JavaScript中reduce()函数的用法"
        },
        "nextItem": {
          "title": "坚定信念",
          "permalink": "/blog/坚定信念"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/625074c72a559d2fb8a469ca1ab97346.png)\r\n## 解题思路\r\n1. 使用递归\r\n2. 使用数组的reduce方法，将初始累积器值置为1，然后索引下标+1进行累积。\r\n\r\n## 解题代码\r\n```js\r\nvar sumNums = function (n) {\r\n    return Array(n).fill(null).reduce((pre, item, idx) => pre + idx + 1, 0)\r\n};\r\n\r\n```\r\n## 实现效果\r\n![](https://img-blog.csdnimg.cn/img_convert/f66b7a763e8abda77be8f2587827a6bc.png)"
    },
    {
      "id": "/坚定信念",
      "metadata": {
        "permalink": "/blog/坚定信念",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/坚定信念.md",
        "source": "@site/blog\\坚定信念.md",
        "title": "坚定信念",
        "description": "最近一段时间，一直在努力学React,学数据结构，学JS，有些感悟和想法，想要记录下来：",
        "date": "2021-03-25T00:00:00.000Z",
        "formattedDate": "2021年3月25日",
        "tags": [
          {
            "label": "人生格言",
            "permalink": "/blog/tags/人生格言"
          }
        ],
        "readingTime": 0.75,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "坚定信念",
          "date": "2021-03-25T00:00:00.000Z",
          "categories": "人生格言",
          "tags": [
            "人生格言"
          ]
        },
        "prevItem": {
          "title": "LeetCode——求1+2+…+n",
          "permalink": "/blog/LeetCode——求1+2+…+n"
        },
        "nextItem": {
          "title": "Ajax-11：解决IE缓存问题",
          "permalink": "/blog/Ajax-11：解决IE缓存问题"
        }
      },
      "content": ">最近一段时间，一直在努力学React,学数据结构，学JS，有些感悟和想法，想要记录下来：\r\n1. 要相信努力的力量。\r\n2. 要相信时间的力量。\r\n3. 要相信积累的力量。\r\n4. 要相信自律的力量。\r\n\r\n把想要完成的目标进行拆分，比如一个大型教程几百集或者几十集，每天给自己定个计划，每天看几集，强制自己每天完成任务，相信自己，一定可以完成这个目标。\r\n\r\n相信自己！简单信念！加油！加油！加油！"
    },
    {
      "id": "/Ajax-11：解决IE缓存问题",
      "metadata": {
        "permalink": "/blog/Ajax-11：解决IE缓存问题",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Ajax-11：解决IE缓存问题.md",
        "source": "@site/blog\\Ajax-11：解决IE缓存问题.md",
        "title": "Ajax-11：解决IE缓存问题",
        "description": "什么是IE缓存问题",
        "date": "2021-03-24T00:00:00.000Z",
        "formattedDate": "2021年3月24日",
        "tags": [
          {
            "label": "Ajax",
            "permalink": "/blog/tags/ajax"
          }
        ],
        "readingTime": 0.405,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Ajax-11：解决IE缓存问题",
          "date": "2021-03-24T00:00:00.000Z",
          "categories": "Ajax",
          "tags": [
            "Ajax"
          ]
        },
        "prevItem": {
          "title": "坚定信念",
          "permalink": "/blog/坚定信念"
        },
        "nextItem": {
          "title": "Ajax-12：请求超时与异常处理",
          "permalink": "/blog/Ajax-12：请求超时与异常处理"
        }
      },
      "content": "## 什么是IE缓存问题\r\n答：IE缓存问题指的是IE浏览器遇到同样的Ajax请求的时候，会缓存返回结果，当返回结果发生变化的时候，浏览器显示的还是为变化的内容。\r\n## 解决办法\r\n![](https://img-blog.csdnimg.cn/img_convert/b673332fc048574e4a9d0dbc7eb50068.png)\r\n在请求的URL上加上?t=  Date.now();"
    },
    {
      "id": "/Ajax-12：请求超时与异常处理",
      "metadata": {
        "permalink": "/blog/Ajax-12：请求超时与异常处理",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Ajax-12：请求超时与异常处理.md",
        "source": "@site/blog\\Ajax-12：请求超时与异常处理.md",
        "title": "Ajax-12：请求超时与异常处理",
        "description": "设置多久之后请求不到即取消请求",
        "date": "2021-03-24T00:00:00.000Z",
        "formattedDate": "2021年3月24日",
        "tags": [
          {
            "label": "Ajax",
            "permalink": "/blog/tags/ajax"
          }
        ],
        "readingTime": 0.25,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Ajax-12：请求超时与异常处理",
          "date": "2021-03-24T00:00:00.000Z",
          "categories": "Ajax",
          "tags": [
            "Ajax"
          ]
        },
        "prevItem": {
          "title": "Ajax-11：解决IE缓存问题",
          "permalink": "/blog/Ajax-11：解决IE缓存问题"
        },
        "nextItem": {
          "title": "Ajax-13：取消请求",
          "permalink": "/blog/Ajax-13：取消请求"
        }
      },
      "content": "## 设置多久之后请求不到即取消请求\r\n![](https://img-blog.csdnimg.cn/img_convert/d48a3c9c5439b4bc0abe276476101607.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/1b8736ad2f5a51e05484367d6f829007.png)\r\n## 超时回调\r\n![](https://img-blog.csdnimg.cn/img_convert/abcf93057ebbbb553faac1654e5f23db.png)\r\n上面的两个语句要结合使用。\r\n## 浏览器断网开关\r\n![](https://img-blog.csdnimg.cn/img_convert/a624bb3afeebda77a2d7f83f1b075c14.png)\r\n## 断网提示\r\n![](https://img-blog.csdnimg.cn/img_convert/1b71382b96a16e7c60dd477846232ec4.png)"
    },
    {
      "id": "/Ajax-13：取消请求",
      "metadata": {
        "permalink": "/blog/Ajax-13：取消请求",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Ajax-13：取消请求.md",
        "source": "@site/blog\\Ajax-13：取消请求.md",
        "title": "Ajax-13：取消请求",
        "description": "通过Ajax的abort方法取消请求",
        "date": "2021-03-24T00:00:00.000Z",
        "formattedDate": "2021年3月24日",
        "tags": [
          {
            "label": "Ajax",
            "permalink": "/blog/tags/ajax"
          }
        ],
        "readingTime": 0.095,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Ajax-13：取消请求",
          "date": "2021-03-24T00:00:00.000Z",
          "categories": "Ajax",
          "tags": [
            "Ajax"
          ]
        },
        "prevItem": {
          "title": "Ajax-12：请求超时与异常处理",
          "permalink": "/blog/Ajax-12：请求超时与异常处理"
        },
        "nextItem": {
          "title": "Ajax-14：请求重复发送问题",
          "permalink": "/blog/Ajax-14：请求重复发送问题"
        }
      },
      "content": "## 通过Ajax的abort方法取消请求\r\n![](https://img-blog.csdnimg.cn/img_convert/a2b229e58d34b1827c03f965bc1b4d3a.png)\r\n## 实现效果\r\n![](https://img-blog.csdnimg.cn/img_convert/c08b00ab1b5c5b663a444cdc46e3b6dd.png)"
    },
    {
      "id": "/Ajax-14：请求重复发送问题",
      "metadata": {
        "permalink": "/blog/Ajax-14：请求重复发送问题",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Ajax-14：请求重复发送问题.md",
        "source": "@site/blog\\Ajax-14：请求重复发送问题.md",
        "title": "Ajax-14：请求重复发送问题",
        "description": "目标：当点击最新请求的时候，将上一次未完成的请求取消掉",
        "date": "2021-03-24T00:00:00.000Z",
        "formattedDate": "2021年3月24日",
        "tags": [
          {
            "label": "Ajax",
            "permalink": "/blog/tags/ajax"
          }
        ],
        "readingTime": 0.865,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Ajax-14：请求重复发送问题",
          "date": "2021-03-24T00:00:00.000Z",
          "categories": "Ajax",
          "tags": [
            "Ajax"
          ]
        },
        "prevItem": {
          "title": "Ajax-13：取消请求",
          "permalink": "/blog/Ajax-13：取消请求"
        },
        "nextItem": {
          "title": "Ajax-15：Jquery中的Ajax",
          "permalink": "/blog/Ajax-15：Jquery中的Ajax"
        }
      },
      "content": "## 目标：当点击最新请求的时候，将上一次未完成的请求取消掉\r\n* 通过定义变量来存储表示是否正在发送请求的布尔值\r\n* 当用户点击发送请求的时候，开始判断这个变量是否为true,如果为true，则取消请求\r\n* 然后将变量置为true,直到检测到返回状态码为4将变量置为false\r\n## 代码\r\n```js\r\nlet isSending = false;\r\nbtn[0].onclick = function() {\r\n    // 在此处判断是否正在发送，如果正在发送则取消\r\n    if(isSending) xhr.abort();\r\n    isSending = true;\r\n    xhr = new XMLHttpRequest();\r\n    xhr.open(\"GET\",\"http://localhost:8000/cancel\");\r\n    xhr.send();\r\n    xhr.onreadystatechange = function() {\r\n        if(xhr.readystate === 4) {\r\n            isSending = false;\r\n        }\r\n    }\r\n};\r\n```\r\n## 实现效果\r\n![](https://img-blog.csdnimg.cn/img_convert/2d0acc2f93739bb8a59a8fc546b1ebe0.png)"
    },
    {
      "id": "/Ajax-15：Jquery中的Ajax",
      "metadata": {
        "permalink": "/blog/Ajax-15：Jquery中的Ajax",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Ajax-15：Jquery中的Ajax.md",
        "source": "@site/blog\\Ajax-15：Jquery中的Ajax.md",
        "title": "Ajax-15：Jquery中的Ajax",
        "description": "注意事项：在使用Jquery之前一定要先引入相关库。",
        "date": "2021-03-24T00:00:00.000Z",
        "formattedDate": "2021年3月24日",
        "tags": [
          {
            "label": "Ajax",
            "permalink": "/blog/tags/ajax"
          }
        ],
        "readingTime": 0.845,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Ajax-15：Jquery中的Ajax",
          "date": "2021-03-24T00:00:00.000Z",
          "categories": "Ajax",
          "tags": [
            "Ajax"
          ]
        },
        "prevItem": {
          "title": "Ajax-14：请求重复发送问题",
          "permalink": "/blog/Ajax-14：请求重复发送问题"
        },
        "nextItem": {
          "title": "LeetCode——左旋转字符串",
          "permalink": "/blog/LeetCode——左旋转字符串"
        }
      },
      "content": ">注意事项：在使用Jquery之前一定要先引入相关库。\r\n```js\r\n<script src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js\"></script>\r\n```\r\n## 使用Jquery发送GET请求\r\n```js\r\n$('button').eq(0).click(function() {\r\n  $.get('http://localhost:8000/jquery-server',{a:20,b:30},function(data) {\r\n      console.log(data);\r\n  },'json')\r\n});\r\n```\r\n## 使用Jquery发送POST请求\r\n```js\r\n$('button').eq(1).click(function() {\r\n    $.post('http://localhost:8000/jquery-server',{a:20,b:30},function(data) {\r\n        console.log(data);\r\n    })\r\n});\r\n```\r\n## 使用Jquery进行通用型方法请求\r\n```js\r\n// 通用型方法\r\n$('button').eq(2).click(function () {\r\n    $.ajax({\r\n        url: 'http://localhost:8000/jquery-server',\r\n        data: { a: 20, b: 100 },\r\n        dataType: 'json',\r\n        type: 'GET',\r\n        success: function (data) {\r\n            console.log(data);\r\n        },\r\n        // 超时时间\r\n        timeout: 4000,\r\n        error: function () {\r\n            console.log(\"网络超时\");\r\n        },\r\n\r\n        headers: {\r\n            a: 666,\r\n            b: 777\r\n        }\r\n    })\r\n})\r\n```\r\n* 上面的很多属性都是可以进行自定义的。\r\n* 在设置headers的时候，服务端必须有下面这段代码\r\n```\r\nresponse.setHeader('Access-Control-Allow-Headers', '*');\r\n```"
    },
    {
      "id": "/LeetCode——左旋转字符串",
      "metadata": {
        "permalink": "/blog/LeetCode——左旋转字符串",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——左旋转字符串.md",
        "source": "@site/blog\\LeetCode——左旋转字符串.md",
        "title": "LeetCode——左旋转字符串",
        "description": "题目描述",
        "date": "2021-03-24T00:00:00.000Z",
        "formattedDate": "2021年3月24日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.03,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "LeetCode——左旋转字符串",
          "date": "2021-03-24T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "Ajax-15：Jquery中的Ajax",
          "permalink": "/blog/Ajax-15：Jquery中的Ajax"
        },
        "nextItem": {
          "title": "Ajax-06：Ajax设置请求参数",
          "permalink": "/blog/Ajax-06：Ajax设置请求参数"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/a98d9b41600675ceed6f7fc4eee6818f.png)\r\n## 解题思路\r\n1. 首先将字符串转为字符数组。\r\n2. 定义两个临时数组，一个存放分割前的数组，一个存放分割后的数组。\r\n3. 依次遍历字符数组，如果索引下标+1小于等于n，则将其加入分割前的数组，反之加入分割后的数组。\r\n4. 使用拓展运算符合并两个数组。\r\n5. 使用for of循环将数组中的所有元素合并成字符串进行返回。\r\n\r\n## 实现代码\r\n```js\r\nvar reverseLeftWords = function (s, n) {\r\n    let temp = [];\r\n    for(let v of s) {\r\n        temp.push(v);\r\n    }\r\n    let temp2 = [];\r\n    let temp3 = [];\r\n    temp.some((value,index) => {\r\n        if ((index + 1) <= n) {\r\n            temp2.push(value);\r\n        } else {\r\n            temp3.push(value);\r\n        }\r\n    });\r\n    const merge = [...temp3,...temp2];\r\n    let str = '';\r\n    for(let v of merge) {\r\n        str = str + v;\r\n    }\r\n    return str;\r\n};\r\n```"
    },
    {
      "id": "/Ajax-06：Ajax设置请求参数",
      "metadata": {
        "permalink": "/blog/Ajax-06：Ajax设置请求参数",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Ajax-06：Ajax设置请求参数.md",
        "source": "@site/blog\\Ajax-06：Ajax设置请求参数.md",
        "title": "Ajax-06：Ajax设置请求参数",
        "description": "请求参数中的a,b,c",
        "date": "2021-03-23T00:00:00.000Z",
        "formattedDate": "2021年3月23日",
        "tags": [
          {
            "label": "Ajax",
            "permalink": "/blog/tags/ajax"
          }
        ],
        "readingTime": 0.11,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Ajax-06：Ajax设置请求参数",
          "date": "2021-03-23T00:00:00.000Z",
          "categories": "Ajax",
          "tags": [
            "Ajax"
          ]
        },
        "prevItem": {
          "title": "LeetCode——左旋转字符串",
          "permalink": "/blog/LeetCode——左旋转字符串"
        },
        "nextItem": {
          "title": "Ajax-07：Ajax发送POST请求",
          "permalink": "/blog/Ajax-07：Ajax发送POST请求"
        }
      },
      "content": "## 请求参数中的a,b,c\r\n通过添加\r\n```js\r\n?a=10&b=20&c=30\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/57ab0a800c2c5de19bf9af2c9844c891.png)\r\n## 实现效果\r\n![](https://img-blog.csdnimg.cn/img_convert/a01822786c92c6e52ce5aae466afacf1.png)"
    },
    {
      "id": "/Ajax-07：Ajax发送POST请求",
      "metadata": {
        "permalink": "/blog/Ajax-07：Ajax发送POST请求",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Ajax-07：Ajax发送POST请求.md",
        "source": "@site/blog\\Ajax-07：Ajax发送POST请求.md",
        "title": "Ajax-07：Ajax发送POST请求",
        "description": "需求描述",
        "date": "2021-03-23T00:00:00.000Z",
        "formattedDate": "2021年3月23日",
        "tags": [
          {
            "label": "Ajax",
            "permalink": "/blog/tags/ajax"
          }
        ],
        "readingTime": 1.14,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Ajax-07：Ajax发送POST请求",
          "date": "2021-03-23T00:00:00.000Z",
          "categories": "Ajax",
          "tags": [
            "Ajax"
          ]
        },
        "prevItem": {
          "title": "Ajax-06：Ajax设置请求参数",
          "permalink": "/blog/Ajax-06：Ajax设置请求参数"
        },
        "nextItem": {
          "title": "Ajax-08：Ajax设置请求头信息",
          "permalink": "/blog/Ajax-08：Ajax设置请求头信息"
        }
      },
      "content": "## 需求描述\r\n当鼠标移动到div上的时候，向服务器发送请求，然后把服务器返回的结果显示到div上\r\n## 客户端网页\r\n![](https://img-blog.csdnimg.cn/img_convert/71743c0ab96465870b5cab9c8bebc1f2.png)\r\n## 客户端代码\r\n```js\r\n<h2>需求：当鼠标移动到div上的时候，向服务器发送请求，然后把服务器返回的结果显示到div上</h2>\r\n<div class=\"result\"></div>\r\n<script>\r\n    const result = document.querySelector('.result');\r\n    result.addEventListener('mouseover',function() {\r\n        // 1. 创建xhr对象\r\n        const xhr = new XMLHttpRequest();\r\n\r\n        // 2. 初始化，设置请求方式和URL\r\n        xhr.open('POST',\"http://localhost:8000/server\");\r\n\r\n        // 3. 发送\r\n        xhr.send();\r\n\r\n        // 4. 事件绑定，处理服务器返回的结果\r\n        xhr.onreadystatechange = function() {\r\n            if(xhr.readyState === 4) {\r\n                if(xhr.status >= 200 && xhr.status < 300) {\r\n                    result.innerHTML = xhr.response;\r\n                }\r\n            }\r\n        }\r\n    });\r\n```\r\n## 服务器端代码\r\n由于是POST请求，需要添加路由，才能防止跨域问题的出现。\r\n![](https://img-blog.csdnimg.cn/img_convert/b12fad447869784eecf4b443f2bf2b7d.png)\r\n## 实现效果\r\n![](https://img-blog.csdnimg.cn/img_convert/05b29bd723571018526e34b2ef39a26c.png)\r\n## POST设置请求体\r\n![](https://img-blog.csdnimg.cn/img_convert/c20a70552cb904909ae0b18165e87481.png)\r\n* 请求体的格式无要求。\r\n![](https://img-blog.csdnimg.cn/img_convert/467bba9c0a9575d42b8be5206b73b3b0.png)"
    },
    {
      "id": "/Ajax-08：Ajax设置请求头信息",
      "metadata": {
        "permalink": "/blog/Ajax-08：Ajax设置请求头信息",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Ajax-08：Ajax设置请求头信息.md",
        "source": "@site/blog\\Ajax-08：Ajax设置请求头信息.md",
        "title": "Ajax-08：Ajax设置请求头信息",
        "description": "固定情况",
        "date": "2021-03-23T00:00:00.000Z",
        "formattedDate": "2021年3月23日",
        "tags": [
          {
            "label": "Ajax",
            "permalink": "/blog/tags/ajax"
          }
        ],
        "readingTime": 0.24,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Ajax-08：Ajax设置请求头信息",
          "date": "2021-03-23T00:00:00.000Z",
          "categories": "Ajax",
          "tags": [
            "Ajax"
          ]
        },
        "prevItem": {
          "title": "Ajax-07：Ajax发送POST请求",
          "permalink": "/blog/Ajax-07：Ajax发送POST请求"
        },
        "nextItem": {
          "title": "Ajax-09：服务端响应JSON数据",
          "permalink": "/blog/Ajax-09：服务端响应JSON数据"
        }
      },
      "content": "## 固定情况\r\n```js\r\nxhr.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded\");\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/1039f8da8911bb87812856856364b648.png)\r\n## 自定义请求头\r\n1. 添加自定义请求头\r\n![](https://img-blog.csdnimg.cn/img_convert/4d107e66c0719becebb9e2b889b45e80.png)\r\n2. 服务器路由设置为all,并且添加自定义响应头\r\n![](https://img-blog.csdnimg.cn/img_convert/035ccedc2febffea1a9fe3c9fc81db52.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/1d163530a36a031731ee14a286de6192.png)"
    },
    {
      "id": "/Ajax-09：服务端响应JSON数据",
      "metadata": {
        "permalink": "/blog/Ajax-09：服务端响应JSON数据",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Ajax-09：服务端响应JSON数据.md",
        "source": "@site/blog\\Ajax-09：服务端响应JSON数据.md",
        "title": "Ajax-09：服务端响应JSON数据",
        "description": "服务端响应的数据应是字符串格式",
        "date": "2021-03-23T00:00:00.000Z",
        "formattedDate": "2021年3月23日",
        "tags": [
          {
            "label": "Ajax",
            "permalink": "/blog/tags/ajax"
          }
        ],
        "readingTime": 0.295,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Ajax-09：服务端响应JSON数据",
          "date": "2021-03-23T00:00:00.000Z",
          "categories": "Ajax",
          "tags": [
            "Ajax"
          ]
        },
        "prevItem": {
          "title": "Ajax-08：Ajax设置请求头信息",
          "permalink": "/blog/Ajax-08：Ajax设置请求头信息"
        },
        "nextItem": {
          "title": "Ajax-10：服务端保存即自动重启工具包nodemon安装",
          "permalink": "/blog/Ajax-10：服务端保存即自动重启工具包nodemon安装"
        }
      },
      "content": "## 服务端响应的数据应是字符串格式\r\n* 将对象通过JSON.stringify(data)转化为字符串\r\n![](https://img-blog.csdnimg.cn/img_convert/b21019a07a19698a8219cf9ca089cf3b.png)\r\n## 客户端通过设置响应体格式或者通过JSON.parse获取搭配json\r\n![](https://img-blog.csdnimg.cn/img_convert/1d921e497fa07f9e69b59bc0bf585ea9.png)\r\n## 实现效果\r\n![](https://img-blog.csdnimg.cn/img_convert/b419d16c675c07c2eefc522e3060c05e.png)"
    },
    {
      "id": "/Ajax-10：服务端保存即自动重启工具包nodemon安装",
      "metadata": {
        "permalink": "/blog/Ajax-10：服务端保存即自动重启工具包nodemon安装",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Ajax-10：服务端保存即自动重启工具包nodemon安装.md",
        "source": "@site/blog\\Ajax-10：服务端保存即自动重启工具包nodemon安装.md",
        "title": "Ajax-10：服务端保存即自动重启工具包nodemon安装",
        "description": "安装代码",
        "date": "2021-03-23T00:00:00.000Z",
        "formattedDate": "2021年3月23日",
        "tags": [
          {
            "label": "Ajax",
            "permalink": "/blog/tags/ajax"
          }
        ],
        "readingTime": 0.42,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Ajax-10：服务端保存即自动重启工具包nodemon安装",
          "date": "2021-03-23T00:00:00.000Z",
          "categories": "Ajax",
          "tags": [
            "Ajax"
          ]
        },
        "prevItem": {
          "title": "Ajax-09：服务端响应JSON数据",
          "permalink": "/blog/Ajax-09：服务端响应JSON数据"
        },
        "nextItem": {
          "title": "Ajax-04：使用Ajax前的准备工作",
          "permalink": "/blog/Ajax-04：使用Ajax前的准备工作"
        }
      },
      "content": "## 安装代码\r\n```\r\nnpm install -g nodemon\r\n```\r\n## 使用方式\r\n```\r\nnodemon xxx.js\r\n```\r\n## 实现效果\r\n* 在未使用该工具之前，如果对服务器端的代码做了修改，需要暂停服务器端，重新node以下才可以实现刷新，但是通过nodemon可以无需暂停，保存即实现刷新。"
    },
    {
      "id": "/Ajax-04：使用Ajax前的准备工作",
      "metadata": {
        "permalink": "/blog/Ajax-04：使用Ajax前的准备工作",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Ajax-04：使用Ajax前的准备工作.md",
        "source": "@site/blog\\Ajax-04：使用Ajax前的准备工作.md",
        "title": "Ajax-04：使用Ajax前的准备工作",
        "description": "客户端",
        "date": "2021-03-22T00:00:00.000Z",
        "formattedDate": "2021年3月22日",
        "tags": [
          {
            "label": "Ajax",
            "permalink": "/blog/tags/ajax"
          }
        ],
        "readingTime": 0.38,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Ajax-04：使用Ajax前的准备工作",
          "date": "2021-03-22T00:00:00.000Z",
          "categories": "Ajax",
          "tags": [
            "Ajax"
          ]
        },
        "prevItem": {
          "title": "Ajax-10：服务端保存即自动重启工具包nodemon安装",
          "permalink": "/blog/Ajax-10：服务端保存即自动重启工具包nodemon安装"
        },
        "nextItem": {
          "title": "Ajax-05：Ajax请求的基本步骤",
          "permalink": "/blog/Ajax-05：Ajax请求的基本步骤"
        }
      },
      "content": "## 客户端\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Ajax GET 请求</title>\r\n    <style>\r\n        .result {\r\n            width: 200px;\r\n            height: 200px;\r\n            border: 1px solid red;\r\n            margin: 0 auto;\r\n            margin-top: 10px;\r\n        }\r\n        button {\r\n            display: block;\r\n            margin: 0 auto;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <button>给服务器发送Ajax请求</button>\r\n\r\n    <div class=\"result\"></div>\r\n    <script>\r\n        \r\n    </script>\r\n</body>\r\n</html>\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/9d61fa8ad127fe6061aafbdd0dfe1c36.png)\r\n## 服务端\r\n![](https://img-blog.csdnimg.cn/img_convert/3f9d06283df9e39be5987023215cd8f3.png)"
    },
    {
      "id": "/Ajax-05：Ajax请求的基本步骤",
      "metadata": {
        "permalink": "/blog/Ajax-05：Ajax请求的基本步骤",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Ajax-05：Ajax请求的基本步骤.md",
        "source": "@site/blog\\Ajax-05：Ajax请求的基本步骤.md",
        "title": "Ajax-05：Ajax请求的基本步骤",
        "description": "XHR请求即Ajax请求",
        "date": "2021-03-22T00:00:00.000Z",
        "formattedDate": "2021年3月22日",
        "tags": [
          {
            "label": "Ajax",
            "permalink": "/blog/tags/ajax"
          }
        ],
        "readingTime": 1.04,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Ajax-05：Ajax请求的基本步骤",
          "date": "2021-03-22T00:00:00.000Z",
          "categories": "Ajax",
          "tags": [
            "Ajax"
          ]
        },
        "prevItem": {
          "title": "Ajax-04：使用Ajax前的准备工作",
          "permalink": "/blog/Ajax-04：使用Ajax前的准备工作"
        },
        "nextItem": {
          "title": "JavaScript中链表的基础结构与增加节点的方法",
          "permalink": "/blog/JavaScript中链表的基础结构与增加节点的方法"
        }
      },
      "content": "## XHR请求即Ajax请求\r\n![](https://img-blog.csdnimg.cn/img_convert/dabb9311e04d4195a1d69070fa6272ac.png)\r\n## 1：创建对象\r\n```js\r\nconst xhr = new XMLHttpRequest();\r\n```\r\n## 2：设置请求方法和url\r\n```js\r\nxhr.open('GET','http://127.0.0.1:8000/server');\r\n```\r\n## 3：发送\r\n```js\r\nxhr.send();\r\n```\r\n## 4：事件绑定\r\n* on 当...的时候\r\n* readystate 是xhr对象的属性，表示状态0 1 2 3 4\r\n* 0 表示未初始化\r\n* 1 表示open方法已经调用完毕\r\n* 2 表示send方法已经调用完毕\r\n* 3 表示服务端返回了部分结果\r\n* 4 表示服务端返回了全部结果\r\n```js\r\nxhr.onreadystatechange = function() {\r\n      // 首先判断服务端是否返回了所有结果\r\n      if (xhr.readyState === 4) {\r\n          // 判断响应状态码  2XX 表示成功\r\n          if (xhr.status >= 200 && xhr.status < 300) {\r\n              // 状态码\r\n              console.log(xhr.status);\r\n              // 状态字符串\r\n              console.log(xhr.statusText);\r\n              // 所有响应头\r\n              console.log(xhr.getAllResponseHeaders());\r\n              // 响应体\r\n              console.log(xhr.response);\r\n              result.innerHTML = xhr.response;\r\n          }\r\n\r\n      }\r\n  }\r\n```"
    },
    {
      "id": "/JavaScript中链表的基础结构与增加节点的方法",
      "metadata": {
        "permalink": "/blog/JavaScript中链表的基础结构与增加节点的方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/JavaScript中链表的基础结构与增加节点的方法.md",
        "source": "@site/blog\\JavaScript中链表的基础结构与增加节点的方法.md",
        "title": "JavaScript中链表的基础结构与增加节点的方法",
        "description": "基础结构",
        "date": "2021-03-22T00:00:00.000Z",
        "formattedDate": "2021年3月22日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.835,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "JavaScript中链表的基础结构与增加节点的方法",
          "date": "2021-03-22T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "Ajax-05：Ajax请求的基本步骤",
          "permalink": "/blog/Ajax-05：Ajax请求的基本步骤"
        },
        "nextItem": {
          "title": "LeetCode——删除链表的节点",
          "permalink": "/blog/LeetCode——删除链表的节点"
        }
      },
      "content": "## 基础结构\r\n![](https://img-blog.csdnimg.cn/img_convert/17c6ecc0d2faad015521b6d88b5adb85.png)\r\n## 向链表中添加节点的方法\r\n```js\r\n// 链表的添加方法\r\nLinkedList.prototype.append = function (data) {\r\n    // 1. 创建新的节点\r\n    let node = new ListNode(data);\r\n    // 2. 判断添加的是否是第一个节点，如果是则让头指针指向该节点\r\n    if (this.length === 0) {\r\n        this.head = node;\r\n    } else {\r\n        // 获取当前头指针指向的节点\r\n        let current = this.head;\r\n        // 找到最后一个节点\r\n        while (current.next) {\r\n            current = current.next;\r\n        };\r\n        // 走到这里说明，current这个指针已经指向了最后一个元素\r\n        current.next = node;\r\n    };\r\n    this.length = this.length + 1;\r\n}\r\n\r\nconst heads = new LinkedList();\r\nconst temp = [4,5,1,9];\r\n\r\nfor(let v of temp) {\r\n    heads.append(v);\r\n};\r\n```"
    },
    {
      "id": "/LeetCode——删除链表的节点",
      "metadata": {
        "permalink": "/blog/LeetCode——删除链表的节点",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——删除链表的节点.md",
        "source": "@site/blog\\LeetCode——删除链表的节点.md",
        "title": "LeetCode——删除链表的节点",
        "description": "题目描述",
        "date": "2021-03-22T00:00:00.000Z",
        "formattedDate": "2021年3月22日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 1.575,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "LeetCode——删除链表的节点",
          "date": "2021-03-22T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "JavaScript中链表的基础结构与增加节点的方法",
          "permalink": "/blog/JavaScript中链表的基础结构与增加节点的方法"
        },
        "nextItem": {
          "title": "使用mouseover事件在Chrome浏览器失灵的原因",
          "permalink": "/blog/使用mouseover事件在Chrome浏览器失灵的原因"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/d4dcf2f3f7d2c54a88dde94549a3f7b5.png)\r\n## 解题思路\r\n* 参数的head指的是链表的头指针。\r\n* val指的是目标number\r\n* 首先判断要删除的是不是第一个头节点，如果是头节点，直接让头指针指向下一个节点，然后返回。\r\n* 如果不是头节点，首先使用临时指针记录这个头指针的位置，让临时指针往后遍历，头指针不要移动了。\r\n* 使用while循环进行遍历，当临时指针的next节点的值等于要删除的节点，那么让临时指针的next指向临时指针的next的next。\r\n* 因为head指向的是引用型变量，临时指针修改也会影响到head的，所以最后返回head即是我们要返回的头指针。\r\n## 解题代码\r\n```js\r\nvar deleteNode = function (head, val) {\r\n    // 这里的head指的不是链表，而是链表的头指针\r\n    // 如果删除的是头节点的话，直接返回头节点的下一个节点\r\n    if(head.val === val) {\r\n        return head.next;\r\n    };\r\n    // 如果函数走到这里说明删除的不是头节点\r\n    // 用临时变量记录头指针\r\n    let node = head;\r\n    while(node.next.val !== val) {\r\n        node = node.next;\r\n    }\r\n    node.next = node.next.next;\r\n    return head;\r\n};\r\n```"
    },
    {
      "id": "/使用mouseover事件在Chrome浏览器失灵的原因",
      "metadata": {
        "permalink": "/blog/使用mouseover事件在Chrome浏览器失灵的原因",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/使用mouseover事件在Chrome浏览器失灵的原因.md",
        "source": "@site/blog\\使用mouseover事件在Chrome浏览器失灵的原因.md",
        "title": "使用mouseover事件在Chrome浏览器失灵的原因",
        "description": "问题描述",
        "date": "2021-03-22T00:00:00.000Z",
        "formattedDate": "2021年3月22日",
        "tags": [
          {
            "label": "debug",
            "permalink": "/blog/tags/debug"
          }
        ],
        "readingTime": 0.385,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "使用mouseover事件在Chrome浏览器失灵的原因",
          "date": "2021-03-22T00:00:00.000Z",
          "categories": "debug",
          "tags": [
            "debug"
          ]
        },
        "prevItem": {
          "title": "LeetCode——删除链表的节点",
          "permalink": "/blog/LeetCode——删除链表的节点"
        },
        "nextItem": {
          "title": "Ajax-01：Ajax概述",
          "permalink": "/blog/Ajax-01：Ajax概述"
        }
      },
      "content": "## 问题描述\r\n当我使用原生JS写鼠标悬停的监听事件的时候，发现在Edge浏览器中，正常工作，但是在Chrome浏览器中失灵。\r\n## 原因\r\n![](https://img-blog.csdnimg.cn/img_convert/aa3e6abeb542afda62fa5aad55f0b0bf.png)\r\n也就是说打开了“切换设备工具栏”会使得鼠标悬停效果无效。"
    },
    {
      "id": "/Ajax-01：Ajax概述",
      "metadata": {
        "permalink": "/blog/Ajax-01：Ajax概述",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Ajax-01：Ajax概述.md",
        "source": "@site/blog\\Ajax-01：Ajax概述.md",
        "title": "Ajax-01：Ajax概述",
        "description": "什么是Ajax？",
        "date": "2021-03-21T00:00:00.000Z",
        "formattedDate": "2021年3月21日",
        "tags": [
          {
            "label": "Ajax",
            "permalink": "/blog/tags/ajax"
          }
        ],
        "readingTime": 1.26,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Ajax-01：Ajax概述",
          "date": "2021-03-21T00:00:00.000Z",
          "categories": "Ajax",
          "tags": [
            "Ajax"
          ]
        },
        "prevItem": {
          "title": "使用mouseover事件在Chrome浏览器失灵的原因",
          "permalink": "/blog/使用mouseover事件在Chrome浏览器失灵的原因"
        },
        "nextItem": {
          "title": "Ajax-02：Chrome网络控制台查看通信报文",
          "permalink": "/blog/Ajax-02：Chrome网络控制台查看通信报文"
        }
      },
      "content": "## 什么是Ajax？\r\n答：它是浏览器提供的一套方法，可以实现页面无刷新更新数据，提高用户浏览网站的体验。\r\n## Ajax发送的请求是什么请求？\r\n答：HTTP请求。\r\n## Ajax的优缺点\r\n优点：\r\n1. 可以无需刷新页面即与服务器端进行通信。\r\n2. 允许你根据用户事件来更新部分页面内容。\r\n\r\n缺点：\r\n1. 没有浏览历史，不能后退。\r\n2. 存在跨域问题。   \r\n2.  SEO不友好。\r\n\r\n## HTTP协议的请求报文\r\n* 行：GET/POST等请求方式、 URL相关参数、HTTP协议的版本。\r\n* 头：Host，Cookie，Content-Type、User-Agent\r\n* 空行：这个是固定的，不用管。\r\n* 体：如果是GET请求，这个是空的，如果是POST请求，那么这个就不为空，可以是要发送的参数。\r\n![](https://img-blog.csdnimg.cn/img_convert/1e3fc4c1af3a347a65e4d5bf4744a427.png)\r\n## HTTP协议的响应报文\r\n* 行：HTTP协议版本、返回状态码、状态字符串\r\n* 头：Content-Type: text/html，字符编码：charset=utf-8，Content-length:2048，内容编码格式：Content-encoding：gzip\r\n* 空行：固定的\r\n* 体： <html>...</html>\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/686f35ce1f8ca0a5a5b28624b0f0867b.png)"
    },
    {
      "id": "/Ajax-02：Chrome网络控制台查看通信报文",
      "metadata": {
        "permalink": "/blog/Ajax-02：Chrome网络控制台查看通信报文",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Ajax-02：Chrome网络控制台查看通信报文.md",
        "source": "@site/blog\\Ajax-02：Chrome网络控制台查看通信报文.md",
        "title": "Ajax-02：Chrome网络控制台查看通信报文",
        "description": "1. 在network中查看网络请求",
        "date": "2021-03-21T00:00:00.000Z",
        "formattedDate": "2021年3月21日",
        "tags": [
          {
            "label": "Ajax",
            "permalink": "/blog/tags/ajax"
          }
        ],
        "readingTime": 0.21,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Ajax-02：Chrome网络控制台查看通信报文",
          "date": "2021-03-21T00:00:00.000Z",
          "categories": "Ajax",
          "tags": [
            "Ajax"
          ]
        },
        "prevItem": {
          "title": "Ajax-01：Ajax概述",
          "permalink": "/blog/Ajax-01：Ajax概述"
        },
        "nextItem": {
          "title": "Ajax-03：Express基本使用",
          "permalink": "/blog/Ajax-03：Express基本使用"
        }
      },
      "content": "## 1. 在network中查看网络请求\r\n![](https://img-blog.csdnimg.cn/img_convert/8dcf52b791528142010448ad90cb8788.png)\r\n## 2. 在Headers中的Request Headers中查看请求头\r\n![](https://img-blog.csdnimg.cn/img_convert/756be824ce0f6b088f455e4e6ab2a82a.png)\r\n## 3. 查看Response Headers\r\n![](https://img-blog.csdnimg.cn/img_convert/7c15452e6b831e4fe59cca441364a070.png)\r\n## 4. 查看响应体\r\n![](https://img-blog.csdnimg.cn/img_convert/038cc83f6e8d2be0c8d3a34b908c0894.png)"
    },
    {
      "id": "/Ajax-03：Express基本使用",
      "metadata": {
        "permalink": "/blog/Ajax-03：Express基本使用",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Ajax-03：Express基本使用.md",
        "source": "@site/blog\\Ajax-03：Express基本使用.md",
        "title": "Ajax-03：Express基本使用",
        "description": "express的安装步骤",
        "date": "2021-03-21T00:00:00.000Z",
        "formattedDate": "2021年3月21日",
        "tags": [
          {
            "label": "Ajax",
            "permalink": "/blog/tags/ajax"
          }
        ],
        "readingTime": 0.565,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Ajax-03：Express基本使用",
          "date": "2021-03-21T00:00:00.000Z",
          "categories": "Ajax",
          "tags": [
            "Ajax"
          ]
        },
        "prevItem": {
          "title": "Ajax-02：Chrome网络控制台查看通信报文",
          "permalink": "/blog/Ajax-02：Chrome网络控制台查看通信报文"
        },
        "nextItem": {
          "title": "LeetCode——第一个只出现一次的字符",
          "permalink": "/blog/LeetCode——第一个只出现一次的字符"
        }
      },
      "content": "## express的安装步骤\r\n1. npm init --yes\r\n2. npm i express\r\n\r\n## express监听端口的步骤\r\n```js\r\n// 1. 引入express\r\nconst express = require('express');\r\n\r\n// 2. 创建应用对象\r\nconst app = express();\r\n\r\n// 3. 创建路由规则\r\n// request是对请求报文的封装，response是对请求报文的一个封装\r\napp.get('/',(request,response) => {\r\n    // 设置相应\r\n    response.send(\"Hello,Express框架！\")\r\n});\r\n\r\n// 4. 监听端口启动服务\r\napp.listen(8000,() => {\r\n    console.log(\"服务已经启动，正在监听8000端口......\");\r\n})\r\n```"
    },
    {
      "id": "/LeetCode——第一个只出现一次的字符",
      "metadata": {
        "permalink": "/blog/LeetCode——第一个只出现一次的字符",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——第一个只出现一次的字符.md",
        "source": "@site/blog\\LeetCode——第一个只出现一次的字符.md",
        "title": "LeetCode——第一个只出现一次的字符",
        "description": "题目描述",
        "date": "2021-03-20T00:00:00.000Z",
        "formattedDate": "2021年3月20日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.56,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "LeetCode——第一个只出现一次的字符",
          "date": "2021-03-20T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "Ajax-03：Express基本使用",
          "permalink": "/blog/Ajax-03：Express基本使用"
        },
        "nextItem": {
          "title": "ES6——51：awiat与async结合使用",
          "permalink": "/blog/ES6——51：awiat与async结合使用"
        }
      },
      "content": "## 题目描述\r\n![](https://img-blog.csdnimg.cn/img_convert/6c482ae46a512ff0f185da678baa78da.png)\r\n## 解题方法\r\n* 通过JS中的Map数据结构\r\n* 将字符列为键，该字符出现的次数列为值，找到第一个值为1的即为返回值\r\n```js\r\nvar firstUniqChar = function (s) {\r\n    const m = new Map();\r\n    const flag = 1;\r\n    for (let v of s) {\r\n        if (m.has(v) === false) {\r\n            m.set(v,flag)\r\n        } else {\r\n            m.set(v,m.get(v)+1);\r\n        }\r\n    }\r\n    \r\n    var result = ' ';\r\n    for (let v of m) {\r\n        if (v[1] === 1) {\r\n            result = v[0];\r\n            break;\r\n        }\r\n    }\r\n\r\n    return result;\r\n\r\n};\r\n```"
    },
    {
      "id": "/ES6——51：awiat与async结合使用",
      "metadata": {
        "permalink": "/blog/ES6——51：awiat与async结合使用",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——51：awiat与async结合使用.md",
        "source": "@site/blog\\ES6——51：awiat与async结合使用.md",
        "title": "ES6——51：awiat与async结合使用",
        "description": "await要放在async函数中",
        "date": "2021-03-19T00:00:00.000Z",
        "formattedDate": "2021年3月19日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.58,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——51：awiat与async结合使用",
          "date": "2021-03-19T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "LeetCode——第一个只出现一次的字符",
          "permalink": "/blog/LeetCode——第一个只出现一次的字符"
        },
        "nextItem": {
          "title": "ES6——52：正则拓展",
          "permalink": "/blog/ES6——52：正则拓展"
        }
      },
      "content": "## await要放在async函数中\r\n## 基础用法\r\n![](https://img-blog.csdnimg.cn/img_convert/c7456a1452804442a9e9512d0e20203c.png)\r\n## async和await结合读取文件内容\r\n![](https://img-blog.csdnimg.cn/img_convert/302340f1abec4308160dbf99e02df396.png)\r\n## async与await结合发送ajax请求\r\n```js\r\nfunction sendAjax(url) {\r\n    return new Promise((resolve,reject) => {\r\n        // 1. 创建对象\r\n        const x = new XMLHttpRequest();\r\n        // 2. 初始化\r\n        x.open('GET',url);\r\n        // 3. 发送\r\n        x.send();\r\n        // 4. 事件绑定\r\n        x.onreadystatechange = function() {\r\n            if (x.readyState === 4) {\r\n                if (x.status >= 200 && x.status <= 300) {\r\n                    resolve(x.response);\r\n                } else {\r\n                    reject(x.status);\r\n                };\r\n            };\r\n        };\r\n    });\r\n};\r\n\r\nasync function readAjax() {\r\n    let result = await sendAjax('https://api.apiopen.top/getJoke');\r\n    console.log(result);\r\n}\r\n\r\nreadAjax();\r\n```"
    },
    {
      "id": "/ES6——52：正则拓展",
      "metadata": {
        "permalink": "/blog/ES6——52：正则拓展",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——52：正则拓展.md",
        "source": "@site/blog\\ES6——52：正则拓展.md",
        "title": "ES6——52：正则拓展",
        "description": "传统方法",
        "date": "2021-03-19T00:00:00.000Z",
        "formattedDate": "2021年3月19日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.285,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——52：正则拓展",
          "date": "2021-03-19T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——51：awiat与async结合使用",
          "permalink": "/blog/ES6——51：awiat与async结合使用"
        },
        "nextItem": {
          "title": "ES6——53：字符串方法拓展",
          "permalink": "/blog/ES6——53：字符串方法拓展"
        }
      },
      "content": "## 传统方法\r\n![](https://img-blog.csdnimg.cn/img_convert/a128460fc841a6d38cb63bd570923e49.png)\r\n\r\n## 新方法\r\n![](https://img-blog.csdnimg.cn/img_convert/099186b00c1aa3c50423db5cb2f90ae3.png)\r\n通过?<></>的方法，相当于给捕获到的正则进行命名。\r\n\r\n# 反向断言\r\n![](https://img-blog.csdnimg.cn/img_convert/fd1400fcccaa805b03847edbccc594c4.png)\r\n\r\n# dotAll模式（关键就是在正则后面加个s）\r\n![](https://img-blog.csdnimg.cn/img_convert/469b0198a034ba40845b51d56d8dc6e2.png)\r\n\r\n# matchAll方法\r\n![](https://img-blog.csdnimg.cn/img_convert/aaa173ab87d9e04561caf18e24d7aa38.png)"
    },
    {
      "id": "/ES6——53：字符串方法拓展",
      "metadata": {
        "permalink": "/blog/ES6——53：字符串方法拓展",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——53：字符串方法拓展.md",
        "source": "@site/blog\\ES6——53：字符串方法拓展.md",
        "title": "ES6——53：字符串方法拓展",
        "description": "trimStart与trimEnd方法",
        "date": "2021-03-19T00:00:00.000Z",
        "formattedDate": "2021年3月19日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.175,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——53：字符串方法拓展",
          "date": "2021-03-19T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——52：正则拓展",
          "permalink": "/blog/ES6——52：正则拓展"
        },
        "nextItem": {
          "title": "ES6——54：私有属性",
          "permalink": "/blog/ES6——54：私有属性"
        }
      },
      "content": "## trimStart与trimEnd方法\r\n>trimStart()方法用于清除字符串左侧空白，trimEnd()方法用于清除字符串右侧空白。\r\n![](https://img-blog.csdnimg.cn/img_convert/1db660e85f4021dbb1b4c8d2d93d849e.png)"
    },
    {
      "id": "/ES6——54：私有属性",
      "metadata": {
        "permalink": "/blog/ES6——54：私有属性",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——54：私有属性.md",
        "source": "@site/blog\\ES6——54：私有属性.md",
        "title": "ES6——54：私有属性",
        "description": "注意事项",
        "date": "2021-03-19T00:00:00.000Z",
        "formattedDate": "2021年3月19日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.275,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——54：私有属性",
          "date": "2021-03-19T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——53：字符串方法拓展",
          "permalink": "/blog/ES6——53：字符串方法拓展"
        },
        "nextItem": {
          "title": "ES6——55：可选链操作符",
          "permalink": "/blog/ES6——55：可选链操作符"
        }
      },
      "content": "## 注意事项\r\n1. 私有变量在类中必须先声明。\r\n2. 通过外部函数是无法访问到私有变量的，要想访问私有变量必须通过类内部的函数。\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/f233c9efc64e51ae693ea55bf3f3257d.png)"
    },
    {
      "id": "/ES6——55：可选链操作符",
      "metadata": {
        "permalink": "/blog/ES6——55：可选链操作符",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——55：可选链操作符.md",
        "source": "@site/blog\\ES6——55：可选链操作符.md",
        "title": "ES6——55：可选链操作符",
        "description": "基础用法",
        "date": "2021-03-19T00:00:00.000Z",
        "formattedDate": "2021年3月19日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.03,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——55：可选链操作符",
          "date": "2021-03-19T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——54：私有属性",
          "permalink": "/blog/ES6——54：私有属性"
        },
        "nextItem": {
          "title": "ES6——56：动态import",
          "permalink": "/blog/ES6——56：动态import"
        }
      },
      "content": "## 基础用法\r\n![](https://img-blog.csdnimg.cn/img_convert/355724ce24cd583171410ca94b83486d.png)"
    },
    {
      "id": "/ES6——56：动态import",
      "metadata": {
        "permalink": "/blog/ES6——56：动态import",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——56：动态import.md",
        "source": "@site/blog\\ES6——56：动态import.md",
        "title": "ES6——56：动态import",
        "description": "注意事项",
        "date": "2021-03-19T00:00:00.000Z",
        "formattedDate": "2021年3月19日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.195,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——56：动态import",
          "date": "2021-03-19T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——55：可选链操作符",
          "permalink": "/blog/ES6——55：可选链操作符"
        },
        "nextItem": {
          "title": "ES6——57：BigInt类型",
          "permalink": "/blog/ES6——57：BigInt类型"
        }
      },
      "content": "## 注意事项\r\n* 别忘了加export\r\n* 通过querySelector()获取id的时候，别忘了加#\r\n* 动态import返回的是一个promise对象\r\n![](https://img-blog.csdnimg.cn/img_convert/d8635fd2a61f5f81fa4446c011a0f1f6.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/26c5e4481b582dc8c3e7a14327285988.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/e57b706d200585127fcabcd8ad36187b.png)"
    },
    {
      "id": "/ES6——57：BigInt类型",
      "metadata": {
        "permalink": "/blog/ES6——57：BigInt类型",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——57：BigInt类型.md",
        "source": "@site/blog\\ES6——57：BigInt类型.md",
        "title": "ES6——57：BigInt类型",
        "description": "基础概念",
        "date": "2021-03-19T00:00:00.000Z",
        "formattedDate": "2021年3月19日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.065,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——57：BigInt类型",
          "date": "2021-03-19T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——56：动态import",
          "permalink": "/blog/ES6——56：动态import"
        },
        "nextItem": {
          "title": "ES6——58：globalThis",
          "permalink": "/blog/ES6——58：globalThis"
        }
      },
      "content": "## 基础概念\r\n![](https://img-blog.csdnimg.cn/img_convert/6cee45f93fa838b5fe33c24cb2c1056b.png)\r\n## 大数值运算\r\n![](https://img-blog.csdnimg.cn/img_convert/e3d8b5c57a47ad1438ff981e1ec951be.png)"
    },
    {
      "id": "/ES6——58：globalThis",
      "metadata": {
        "permalink": "/blog/ES6——58：globalThis",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——58：globalThis.md",
        "source": "@site/blog\\ES6——58：globalThis.md",
        "title": "ES6——58：globalThis",
        "description": "globalThis始终指向全局变量",
        "date": "2021-03-19T00:00:00.000Z",
        "formattedDate": "2021年3月19日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.125,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——58：globalThis",
          "date": "2021-03-19T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——57：BigInt类型",
          "permalink": "/blog/ES6——57：BigInt类型"
        },
        "nextItem": {
          "title": "ES6——41：迭代器",
          "permalink": "/blog/ES6——41：迭代器"
        }
      },
      "content": "## globalThis始终指向全局变量\r\n* 在浏览器环境下\r\n![](https://img-blog.csdnimg.cn/img_convert/627820c6217d43c68b5028ded2d74b36.png)\r\n* 在NodeJs环境下\r\n![](https://img-blog.csdnimg.cn/img_convert/f4b22623a2fded1ea9d8c054c9558f70.png)"
    },
    {
      "id": "/ES6——41：迭代器",
      "metadata": {
        "permalink": "/blog/ES6——41：迭代器",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——41：迭代器.md",
        "source": "@site/blog\\ES6——41：迭代器.md",
        "title": "ES6——41：迭代器",
        "description": "使用for of 进行遍历",
        "date": "2021-03-18T00:00:00.000Z",
        "formattedDate": "2021年3月18日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.695,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——41：迭代器",
          "date": "2021-03-18T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——58：globalThis",
          "permalink": "/blog/ES6——58：globalThis"
        },
        "nextItem": {
          "title": "ES6——42：生成器",
          "permalink": "/blog/ES6——42：生成器"
        }
      },
      "content": "## 使用for of 进行遍历\r\n![](https://img-blog.csdnimg.cn/img_convert/386c89ec6bb12687990f99e3de2e5e26.png)\r\n>注意：for of 遍历的是键的值\r\n## 使用for in遍历\r\n![](https://img-blog.csdnimg.cn/img_convert/c096ed6cea0dc2fed3a5326def26d99c.png)\r\n>注意：for in 遍历的是键，即序号。\r\n## 数组为什么能够进行遍历？\r\n答：是因为其有可遍历的属性。\r\n![](https://img-blog.csdnimg.cn/img_convert/56cd759ccd244faab6e4930a7e55917d.png)\r\n## 自定义遍历属性\r\n```js\r\nconst banji = {\r\n    name: \"终极一班\",\r\n    arr: [\"赵\",\"钱\",\"孙\",\"李\"],\r\n    [Symbol.iterator]() {\r\n        let index = 0;\r\n        let _this = this;\r\n        return {\r\n            next: function() {\r\n                if(index < _this.arr.length) {\r\n                    const result =  {value: _this.arr[index],done: false};\r\n                    index++;\r\n                    return result;\r\n                } else {\r\n                    return {value: undefined,done:true};\r\n                }\r\n                \r\n            }\r\n        }\r\n    }\r\n};\r\nfor(let v of banji) {\r\n    console.log(v);\r\n};\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/1cdcbe862ebf55580491b2a75e973dd9.png)"
    },
    {
      "id": "/ES6——42：生成器",
      "metadata": {
        "permalink": "/blog/ES6——42：生成器",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——42：生成器.md",
        "source": "@site/blog\\ES6——42：生成器.md",
        "title": "ES6——42：生成器",
        "description": "生成器函数的函数声明与调用",
        "date": "2021-03-18T00:00:00.000Z",
        "formattedDate": "2021年3月18日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.59,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——42：生成器",
          "date": "2021-03-18T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——41：迭代器",
          "permalink": "/blog/ES6——41：迭代器"
        },
        "nextItem": {
          "title": "ES6——43：Promise",
          "permalink": "/blog/ES6——43：Promise"
        }
      },
      "content": "## 生成器函数的函数声明与调用\r\n![](https://img-blog.csdnimg.cn/img_convert/abdae864693a7206ef60f1cb2ad4bc40.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/037f1b19fb07828408566c3f4db87c39.png)\r\n## 生成器函数的参数传递\r\n![](https://img-blog.csdnimg.cn/img_convert/d8cc9cd697515a986232104d224ba3d6.png)\r\n## 生成器函数实例\r\n```js\r\n// 1s后控制台输出111 2s后控制台输出222 3s后控制台输出333\r\nfunction one() {\r\n    setTimeout(() => {\r\n        console.log(111);\r\n        iterator.next();\r\n    },1000);\r\n}\r\n\r\nfunction two() {\r\n    setTimeout(() => {\r\n        console.log(222);\r\n        iterator.next();\r\n    },2000);\r\n}\r\n\r\nfunction three() {\r\n    setTimeout(() => {\r\n        console.log(333);\r\n        iterator.next();\r\n    },3000);\r\n}\r\n\r\nfunction * gen() {\r\n    yield one();\r\n    yield two();\r\n    yield three();\r\n}\r\n\r\n// 获取迭代器对象\r\nconst iterator = gen();\r\niterator.next();\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/082a5123aba898a76f6435bf109065ca.png)"
    },
    {
      "id": "/ES6——43：Promise",
      "metadata": {
        "permalink": "/blog/ES6——43：Promise",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——43：Promise.md",
        "source": "@site/blog\\ES6——43：Promise.md",
        "title": "ES6——43：Promise",
        "description": "基本使用",
        "date": "2021-03-18T00:00:00.000Z",
        "formattedDate": "2021年3月18日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 1.715,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——43：Promise",
          "date": "2021-03-18T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——42：生成器",
          "permalink": "/blog/ES6——42：生成器"
        },
        "nextItem": {
          "title": "ES6——44：Map数据结构",
          "permalink": "/blog/ES6——44：Map数据结构"
        }
      },
      "content": "## 基本使用\r\n![](https://img-blog.csdnimg.cn/img_convert/db7804af105d8cedd09f7d5df5952607.png)\r\n## Promise封装读取文件\r\n![](https://img-blog.csdnimg.cn/img_convert/44e7e89667c31444643637e0490ade9e.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/b5cc0df85c9008f0f167e866cff22108.png)\r\n## Promise封装AJAX请求\r\n```js\r\nconst p = new Promise((resolve,reject) => {\r\n    // 1. 创建对象\r\n    const xhr = new XMLHttpRequest();\r\n    // 2. 初始化\r\n    xhr.open(\"GET\",\"https://api.apiopen.top/getJoke\");\r\n    // 3. 发送\r\n    xhr.send();\r\n    // 4. 绑定事件，处理响应结果\r\n    xhr.onreadystatechange = function() {\r\n        if (xhr.readyState === 4) {\r\n            if (xhr.status >= 200 && xhr.status <= 300) {\r\n                resolve(xhr.response);\r\n            } else {\r\n                reject(xhr.status);\r\n            }\r\n        }\r\n    }\r\n});\r\n\r\np.then(function(value) {\r\n    console.log(value);\r\n},function(reason) {\r\n    console.log(reason);\r\n});\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/c1246b449de327693defac371c4bd8e2.png)\r\n## Promise.prototype.then 方法\r\nthen方法的返回值分以下三种情况：\r\n1. 返回非Promise对象\r\n![](https://img-blog.csdnimg.cn/img_convert/672619937e10bcdd4a8ce6aca0c09871.png)\r\n2. 返回Promise对象（resove状态）\r\n![](https://img-blog.csdnimg.cn/img_convert/7ecc720a5cac68f8c171180076556264.png)\r\n3. 返回Promise对象（reject状态）\r\n![](https://img-blog.csdnimg.cn/img_convert/6b4ffd0f841b7217da9b7836c58a5da2.png)\r\n## Promise对象的catch方法\r\n>此方法是当Promise对象的状态为reject时，调用的方法，参数只是一个函数。\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/6fa69162f0bcd3170ecba0d8a3538368.png)\r\n## 使用Promise读取三个文件中的内容\r\n```js\r\n// 首先，引入fs模块\r\nconst fs = require('fs');\r\n\r\nconst p = new Promise((resolve,reject) => {\r\n    fs.readFile(\"./test.md\",(err,data) => {\r\n        resolve(data);\r\n    });\r\n});\r\n\r\np.then((value) => {\r\n    return new Promise((resolve,reject) => {\r\n        fs.readFile(\"./木言人.md\",(err,data) => {\r\n            resolve([value,data]);\r\n        });\r\n    });\r\n}).then((value) => {\r\n    return new Promise((resolve) => {\r\n        fs.readFile(\"./读书有感.md\",(err,data) => {\r\n            value.push(data);\r\n            resolve(value);\r\n        });\r\n    });\r\n}).then((value) => {\r\n    console.log(value.toString());\r\n});\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/7ae108cbabc7b4adad0404c2940ad4fc.png)\r\n## Promise.allSettled()方法\r\n* 参数是一个数组。\r\n* 这个数组的每一个元素都是一个Promise对象\r\n* 该方法返回的始终是一个成功的Promise对象，这个对象的结果包含了参数数组中的每一个Promise对象的返回状态和值。\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/3ee2df06f76d5f08aa2048e1c28e6340.png)"
    },
    {
      "id": "/ES6——44：Map数据结构",
      "metadata": {
        "permalink": "/blog/ES6——44：Map数据结构",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——44：Map数据结构.md",
        "source": "@site/blog\\ES6——44：Map数据结构.md",
        "title": "ES6——44：Map数据结构",
        "description": "关于Map数据结构的增删改查",
        "date": "2021-03-18T00:00:00.000Z",
        "formattedDate": "2021年3月18日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.175,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——44：Map数据结构",
          "date": "2021-03-18T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——43：Promise",
          "permalink": "/blog/ES6——43：Promise"
        },
        "nextItem": {
          "title": "ES6——45：子类对父类方法的重写",
          "permalink": "/blog/ES6——45：子类对父类方法的重写"
        }
      },
      "content": "## 关于Map数据结构的增删改查\r\n![](https://img-blog.csdnimg.cn/img_convert/1971d09888d6e0ce7ce242f02fdfc455.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/e12d6fcf07e52075fd4e66f844ffb4cf.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/679724103ef7ec6ed268c89dd8d6a695.png)\r\n## 修改Map键对应的值\r\n```js\r\nm.set(v,m.get(v)+1);\r\n```\r\n相当于给值加一。"
    },
    {
      "id": "/ES6——45：子类对父类方法的重写",
      "metadata": {
        "permalink": "/blog/ES6——45：子类对父类方法的重写",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——45：子类对父类方法的重写.md",
        "source": "@site/blog\\ES6——45：子类对父类方法的重写.md",
        "title": "ES6——45：子类对父类方法的重写",
        "description": "代码示例",
        "date": "2021-03-18T00:00:00.000Z",
        "formattedDate": "2021年3月18日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.425,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——45：子类对父类方法的重写",
          "date": "2021-03-18T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——44：Map数据结构",
          "permalink": "/blog/ES6——44：Map数据结构"
        },
        "nextItem": {
          "title": "ES6——46：class中getter和setter的设置方法",
          "permalink": "/blog/ES6——46：class中getter和setter的设置方法"
        }
      },
      "content": "## 代码示例\r\n```js\r\nclass Father {\r\n    constructor(name,price) {\r\n        this.name = name;\r\n        this.price = price;\r\n    };\r\n    call() {\r\n        console.log(\"手机可以打电话！\");\r\n    };\r\n};\r\n\r\nclass Son extends Father {\r\n    constructor(name,price,color,size) {\r\n        super(name,price);\r\n        this.color = color;\r\n        this.size = size;\r\n    };\r\n    photo() {\r\n        console.log(\"手机可以拍照\");\r\n    };\r\n    call() {\r\n        console.log(\"这是子类的函数\");\r\n    };\r\n};\r\n\r\nconst xiaomi = new Son(\"红米K30\",\"4999\",\"荣耀黑\",\"6.7英寸\");\r\n\r\nconsole.log(xiaomi);\r\nxiaomi.call();\r\n```\r\n\r\n## 实现效果\r\n![](https://img-blog.csdnimg.cn/img_convert/e608b5df66ff80489c5cb09f6968c34b.png)"
    },
    {
      "id": "/ES6——46：class中getter和setter的设置方法",
      "metadata": {
        "permalink": "/blog/ES6——46：class中getter和setter的设置方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——46：class中getter和setter的设置方法.md",
        "source": "@site/blog\\ES6——46：class中getter和setter的设置方法.md",
        "title": "ES6——46：class中getter和setter的设置方法",
        "description": "测试代码",
        "date": "2021-03-18T00:00:00.000Z",
        "formattedDate": "2021年3月18日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.06,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——46：class中getter和setter的设置方法",
          "date": "2021-03-18T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——45：子类对父类方法的重写",
          "permalink": "/blog/ES6——45：子类对父类方法的重写"
        },
        "nextItem": {
          "title": "ES6——47：ES6中的数值拓展",
          "permalink": "/blog/ES6——47：ES6中的数值拓展"
        }
      },
      "content": "## 测试代码\r\n![](https://img-blog.csdnimg.cn/img_convert/555d6a15b634f6d447258165f5e3e693.png)\r\n## 实现效果\r\n![](https://img-blog.csdnimg.cn/img_convert/8a6f252a9859b4d2e9eb911164173e6b.png)"
    },
    {
      "id": "/ES6——47：ES6中的数值拓展",
      "metadata": {
        "permalink": "/blog/ES6——47：ES6中的数值拓展",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——47：ES6中的数值拓展.md",
        "source": "@site/blog\\ES6——47：ES6中的数值拓展.md",
        "title": "ES6——47：ES6中的数值拓展",
        "description": "JavaScript中能表示的最小的数",
        "date": "2021-03-18T00:00:00.000Z",
        "formattedDate": "2021年3月18日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.625,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——47：ES6中的数值拓展",
          "date": "2021-03-18T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——46：class中getter和setter的设置方法",
          "permalink": "/blog/ES6——46：class中getter和setter的设置方法"
        },
        "nextItem": {
          "title": "ES6——48：ES6的对象方法拓展",
          "permalink": "/blog/ES6——48：ES6的对象方法拓展"
        }
      },
      "content": "## JavaScript中能表示的最小的数\r\n只要两个数的差值小于这个数字，我们就认为这两个数是相等的。\r\n![](https://img-blog.csdnimg.cn/img_convert/ae21d873b06fbe18d84dcc130bc3f31c.png)\r\n## 二进制、八进制、十六进制\r\n![](https://img-blog.csdnimg.cn/img_convert/47aade8339467c08b5829c2cb19182ae.png)\r\n## 检测一个数值是否为有限数\r\n![](https://img-blog.csdnimg.cn/img_convert/77abf4b374cc83efc7baac3e146c9a98.png)\r\n## 检测一个数值是否为NaN\r\n![](https://img-blog.csdnimg.cn/img_convert/442377676811bef9b7439507ec3f2568.png)\r\n## 字符串转整数\r\n![](https://img-blog.csdnimg.cn/img_convert/027e071b1b34b7d3e6946edfb11961c5.png)\r\n## 判断一个数字是否为整数\r\n![](https://img-blog.csdnimg.cn/img_convert/b47331d4eae97a97636395f9d983a7be.png)\r\n## 将数字的小数部分抹掉\r\n![](https://img-blog.csdnimg.cn/img_convert/ac73b82afb840bf31968d726a09e4c93.png)\r\n## 判断一个数是正数、负数还是0\r\n![](https://img-blog.csdnimg.cn/img_convert/efcbedbbfa1044c949a470b3cb0014ee.png)"
    },
    {
      "id": "/ES6——48：ES6的对象方法拓展",
      "metadata": {
        "permalink": "/blog/ES6——48：ES6的对象方法拓展",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——48：ES6的对象方法拓展.md",
        "source": "@site/blog\\ES6——48：ES6的对象方法拓展.md",
        "title": "ES6——48：ES6的对象方法拓展",
        "description": "判断两个值是否完全相等（Object.is）",
        "date": "2021-03-18T00:00:00.000Z",
        "formattedDate": "2021年3月18日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.585,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——48：ES6的对象方法拓展",
          "date": "2021-03-18T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——47：ES6中的数值拓展",
          "permalink": "/blog/ES6——47：ES6中的数值拓展"
        },
        "nextItem": {
          "title": "ES6——49：模块化",
          "permalink": "/blog/ES6——49：模块化"
        }
      },
      "content": "## 判断两个值是否完全相等（Object.is）\r\n![](https://img-blog.csdnimg.cn/img_convert/067d32b033656d936d1ba046e25a44c3.png)\r\n## 对象的合并\r\n![](https://img-blog.csdnimg.cn/img_convert/be59fc4c9aa86459e7218a6cc82aa068.png)\r\n## 设置对象的原型对象\r\n![](https://img-blog.csdnimg.cn/img_convert/9db22bf41a3b945ea294824c3d3a8cca.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/fc5a50a4ab4a245b5deb629964590ebe.png)\r\n## 获取对象所有的键（Object.keys()）\r\n![](https://img-blog.csdnimg.cn/img_convert/d6a0bb0f2ad1dffaa1150110c71f2171.png)\r\n## 获取对象键对应的所有的值（Object.values(obj)）\r\n![](https://img-blog.csdnimg.cn/img_convert/8795b90cd0eb7b7ef1c2183a7303ed35.png)\r\n## 把对象的键值映射成一个拥有两个值的数组（Object.entries(obj)）\r\n![](https://img-blog.csdnimg.cn/img_convert/393f723b693e7879b2df38d9d2dce5c0.png)\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/393f723b693e7879b2df38d9d2dce5c0.png)\r\n## entries与map结合使用\r\n![](https://img-blog.csdnimg.cn/img_convert/03307def5a16440174d11a7082aade6d.png)\r\n## 获取对象的属性描述Object.getOwnPropertyDescriptors(obj)\r\n![](https://img-blog.csdnimg.cn/img_convert/25075278f7df3a3794c34ddc2de0c7bd.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/e5a31feb1a14bfc122a72de08b50c0e4.png)\r\n## Object.fromEntries方法\r\n![](https://img-blog.csdnimg.cn/img_convert/7e7c3d8401c66b7785fd51eaed52e4ec.png)\r\nentries与fromEntries互为逆运算。"
    },
    {
      "id": "/ES6——49：模块化",
      "metadata": {
        "permalink": "/blog/ES6——49：模块化",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——49：模块化.md",
        "source": "@site/blog\\ES6——49：模块化.md",
        "title": "ES6——49：模块化",
        "description": "导入模块（分别暴露）",
        "date": "2021-03-18T00:00:00.000Z",
        "formattedDate": "2021年3月18日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.63,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——49：模块化",
          "date": "2021-03-18T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——48：ES6的对象方法拓展",
          "permalink": "/blog/ES6——48：ES6的对象方法拓展"
        },
        "nextItem": {
          "title": "ES6——50：async函数",
          "permalink": "/blog/ES6——50：async函数"
        }
      },
      "content": "## 导入模块（分别暴露）\r\n![](https://img-blog.csdnimg.cn/img_convert/5b694115e6c1d407de667ee06a1ec1f3.png)\r\n## 导入模块（选择暴露）\r\n![](https://img-blog.csdnimg.cn/img_convert/5f85115d969d6a17ed4e7f5ece5d2c53.png)\r\n## 导入模块（默认暴露）\r\n![](https://img-blog.csdnimg.cn/img_convert/4f2a961b9bef06bec58847c19952395e.png)\r\n* 这里为什么要加this，因为不加this访问的是全局作用域下的name2所以会报错，加了访问的是对象内部的name2所以不会报错。\r\n## 解构赋值形式导入\r\n![](https://img-blog.csdnimg.cn/img_convert/5fd11861d00da8e6fce9165a137ad4fd.png)\r\n## 通过入口文件引入\r\n![](https://img-blog.csdnimg.cn/img_convert/cd17244856f2d512cfe9d68579dd09cd.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/94d0a96a5ff38df311ef023fe49c57ab.png)\r\n## 使用Babel对模块化代码进行转换\r\n![](https://img-blog.csdnimg.cn/img_convert/e8140b34f999af935c23ff1e736d3e07.png)\r\n（注意在哪个路径运行的）\r\n![](https://img-blog.csdnimg.cn/img_convert/faf1402bc29393e354948815faf0aeba.png)"
    },
    {
      "id": "/ES6——50：async函数",
      "metadata": {
        "permalink": "/blog/ES6——50：async函数",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——50：async函数.md",
        "source": "@site/blog\\ES6——50：async函数.md",
        "title": "ES6——50：async函数",
        "description": "1：return的只要不是promise对象，那么返回的则是成功的promise对象",
        "date": "2021-03-18T00:00:00.000Z",
        "formattedDate": "2021年3月18日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.375,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——50：async函数",
          "date": "2021-03-18T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——49：模块化",
          "permalink": "/blog/ES6——49：模块化"
        },
        "nextItem": {
          "title": "ES6——31：递归基础",
          "permalink": "/blog/ES6——31：递归基础"
        }
      },
      "content": "## 1：return的只要不是promise对象，那么返回的则是成功的promise对象\r\n![](https://img-blog.csdnimg.cn/img_convert/501b23abd066a914a9e82c203936bc96.png)\r\n## 2：抛出错误，返回的是失败的promise\r\n![](https://img-blog.csdnimg.cn/img_convert/b64908645fbe1b75282c74aec1d50108.png)\r\n## 3：返回的是一个promise对象，该对象若是成功的promise，返回的则是成功的，反之则是失败的。\r\n![](https://img-blog.csdnimg.cn/img_convert/6f2cd58458e8196956eaae7f18337021.png)"
    },
    {
      "id": "/ES6——31：递归基础",
      "metadata": {
        "permalink": "/blog/ES6——31：递归基础",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——31：递归基础.md",
        "source": "@site/blog\\ES6——31：递归基础.md",
        "title": "ES6——31：递归基础",
        "description": "递归的定义",
        "date": "2021-03-17T00:00:00.000Z",
        "formattedDate": "2021年3月17日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.66,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——31：递归基础",
          "date": "2021-03-17T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——50：async函数",
          "permalink": "/blog/ES6——50：async函数"
        },
        "nextItem": {
          "title": "ES6——32：浅拷贝和深拷贝",
          "permalink": "/blog/ES6——32：浅拷贝和深拷贝"
        }
      },
      "content": "## 递归的定义\r\n>函数的内部，可以调用其本身的函数。\r\n\r\n## 利用递归求阶乘\r\n![](https://img-blog.csdnimg.cn/img_convert/e93817490d646717c8e6b4f3f93117ff.png)\r\n## 利用递归求斐波那契数列\r\n![](https://img-blog.csdnimg.cn/img_convert/97ded0504100f21869c4dca19c0866d2.png)\r\n## 使用递归遍历数据\r\n```html\r\n<script>\r\n// 利用递归遍历数据，要求输入id号，返回对象值\r\nvar data = [{\r\n    id: 1,\r\n    name: '家电',\r\n    goods: [{\r\n        id: 11,\r\n        gname: '冰箱'\r\n    }, {\r\n        id: 12,\r\n        gname: '洗衣机'\r\n    }]\r\n}, {\r\n    id: 2,\r\n    name: '服饰'\r\n}];\r\nfunction getId(data,id) {\r\n    data.forEach(function(values) {\r\n        if(values.id == id) {\r\n            console.log(values);\r\n        } else if(values.goods && values.goods.length > 0) {\r\n            getId(values.goods,id);\r\n        };\r\n    })\r\n}\r\nconsole.log(getId(data,12));\r\nconsole.log(getId(data,1));\r\nconsole.log(getId(data,11));\r\n</script>\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/ba66db89f74f9a5f75ed5a148f232dd5.png)"
    },
    {
      "id": "/ES6——32：浅拷贝和深拷贝",
      "metadata": {
        "permalink": "/blog/ES6——32：浅拷贝和深拷贝",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——32：浅拷贝和深拷贝.md",
        "source": "@site/blog\\ES6——32：浅拷贝和深拷贝.md",
        "title": "ES6——32：浅拷贝和深拷贝",
        "description": "1. 浅拷贝只是拷贝一层，更深层次对象级别的只是拷贝引用。",
        "date": "2021-03-17T00:00:00.000Z",
        "formattedDate": "2021年3月17日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.895,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——32：浅拷贝和深拷贝",
          "date": "2021-03-17T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——31：递归基础",
          "permalink": "/blog/ES6——31：递归基础"
        },
        "nextItem": {
          "title": "ES6——33：解构赋值",
          "permalink": "/blog/ES6——33：解构赋值"
        }
      },
      "content": "1. 浅拷贝只是拷贝一层，更深层次对象级别的只是拷贝引用。\r\n2. 深拷贝拷贝多层，每一级别的数据都会拷贝。\r\n## 浅拷贝\r\n![](https://img-blog.csdnimg.cn/img_convert/ede0170e296c33f01ad3e4938564ff1e.png)\r\n浅拷贝在拷贝对象的时候，只会拷贝引用。\r\n## ES6提供的浅拷贝方法\r\n![](https://img-blog.csdnimg.cn/img_convert/84df2535bd5256e386619a6c67a23248.png)\r\n## 深拷贝（原生JS）\r\n```html\r\n<script>\r\n        var obj = {\r\n            id: 1,\r\n            name: 'andy',\r\n            age: {\r\n                pink: 666\r\n            }\r\n        };\r\n        var o = {};\r\n        \r\n        function deepCopy(newObj,oldObj) {\r\n            for(var k in oldObj) {\r\n                // 首先获取每一个键对应的值，然后判断这个值是否为数组、对象\r\n                var temp = oldObj[k];\r\n                if(temp instanceof Array) {\r\n                    newObj[k] = [];\r\n                    deepCopy(newObj[k],temp);\r\n                } else if(temp instanceof Object) {\r\n                    newObj[k] = {};\r\n                    deepCopy(newObj[k],temp);\r\n                } else {\r\n                    newObj[k] = temp;\r\n                }\r\n            }\r\n        }\r\n        deepCopy(o,obj);\r\n        // console.log(o);\r\n        o.age.pink = 777;\r\n        console.log(obj);\r\n        console.log(o);\r\n    </script>\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/944c2178f9cfcc00fe10b17fc7264968.png)"
    },
    {
      "id": "/ES6——33：解构赋值",
      "metadata": {
        "permalink": "/blog/ES6——33：解构赋值",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——33：解构赋值.md",
        "source": "@site/blog\\ES6——33：解构赋值.md",
        "title": "ES6——33：解构赋值",
        "description": "数组解构赋值和对象解构赋值",
        "date": "2021-03-17T00:00:00.000Z",
        "formattedDate": "2021年3月17日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.075,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——33：解构赋值",
          "date": "2021-03-17T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——32：浅拷贝和深拷贝",
          "permalink": "/blog/ES6——32：浅拷贝和深拷贝"
        },
        "nextItem": {
          "title": "ES6——34：剩余参数",
          "permalink": "/blog/ES6——34：剩余参数"
        }
      },
      "content": "## 数组解构赋值和对象解构赋值\r\n![](https://img-blog.csdnimg.cn/img_convert/3e931a63f9fc64fddddd29bbebf4e02d.png)"
    },
    {
      "id": "/ES6——34：剩余参数",
      "metadata": {
        "permalink": "/blog/ES6——34：剩余参数",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——34：剩余参数.md",
        "source": "@site/blog\\ES6——34：剩余参数.md",
        "title": "ES6——34：剩余参数",
        "description": "剩余参数基础",
        "date": "2021-03-17T00:00:00.000Z",
        "formattedDate": "2021年3月17日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.105,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——34：剩余参数",
          "date": "2021-03-17T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——33：解构赋值",
          "permalink": "/blog/ES6——33：解构赋值"
        },
        "nextItem": {
          "title": "ES6——35：拓展运算符",
          "permalink": "/blog/ES6——35：拓展运算符"
        }
      },
      "content": "## 剩余参数基础\r\n![](https://img-blog.csdnimg.cn/img_convert/4740a221b6af5a61c6eab4e5965cf6e4.png)\r\n## 剩余参数与解构配合使用\r\n![](https://img-blog.csdnimg.cn/img_convert/48e746fe4177db5d46821724220f4e4e.png)"
    },
    {
      "id": "/ES6——35：拓展运算符",
      "metadata": {
        "permalink": "/blog/ES6——35：拓展运算符",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——35：拓展运算符.md",
        "source": "@site/blog\\ES6——35：拓展运算符.md",
        "title": "ES6——35：拓展运算符",
        "description": "基础用法",
        "date": "2021-03-17T00:00:00.000Z",
        "formattedDate": "2021年3月17日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.165,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——35：拓展运算符",
          "date": "2021-03-17T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——34：剩余参数",
          "permalink": "/blog/ES6——34：剩余参数"
        },
        "nextItem": {
          "title": "ES6——36：Array拓展方法",
          "permalink": "/blog/ES6——36：Array拓展方法"
        }
      },
      "content": "## 基础用法\r\n![](https://img-blog.csdnimg.cn/img_convert/46c2df93a275c5e60b81e20f3f98cc15.png)\r\n## 拓展运算符用于合并数组\r\n![](https://img-blog.csdnimg.cn/img_convert/ca840b41a9d06749a5aa1c663610afe8.png)\r\n## 将伪数组转换为真正的数组\r\n![](https://img-blog.csdnimg.cn/img_convert/d0ed9b67b9d203522c92dbd10842701e.png)"
    },
    {
      "id": "/ES6——36：Array拓展方法",
      "metadata": {
        "permalink": "/blog/ES6——36：Array拓展方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——36：Array拓展方法.md",
        "source": "@site/blog\\ES6——36：Array拓展方法.md",
        "title": "ES6——36：Array拓展方法",
        "description": "Array.form()：将伪数组转换为真正的数组",
        "date": "2021-03-17T00:00:00.000Z",
        "formattedDate": "2021年3月17日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.725,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——36：Array拓展方法",
          "date": "2021-03-17T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——35：拓展运算符",
          "permalink": "/blog/ES6——35：拓展运算符"
        },
        "nextItem": {
          "title": "ES6——37：模板字符串",
          "permalink": "/blog/ES6——37：模板字符串"
        }
      },
      "content": "## Array.form()：将伪数组转换为真正的数组\r\n![](https://img-blog.csdnimg.cn/img_convert/4d76fae9c5e7b3455e3bb20e6d1d891d.png)\r\n## 数组.find()方法\r\n![](https://img-blog.csdnimg.cn/img_convert/951a7acf9bc4ad75d6f05cb0b012fbea.png)\r\n## findIndex() 方法：找出数组中符合条件的第一个元素的位置\r\n![](https://img-blog.csdnimg.cn/img_convert/b569127015f4d4a7aaa998972ae9aabe.png)\r\n## 数组.includes()方法：表示某个数组是否包含给定的值\r\n![](https://img-blog.csdnimg.cn/img_convert/81d90d4fe7770bf2b8d35e82622631ad.png)\r\n## flat与flatMap方法\r\n* 数组.flat()方法：将高维数组转化为低微数组\r\n![](https://img-blog.csdnimg.cn/img_convert/07951c4e96c3e36d33ac60a587f0b7e0.png)\r\n* flat带参数的情况，2表述将2维的转化为1维，3则代表的是将3维的转化为1维\r\n![](https://img-blog.csdnimg.cn/img_convert/377b1ae4ab4e8c02e59b3c12f077abea.png)\r\n* 数组.flatMap方法：将返回的多维数组变为1维\r\n![](https://img-blog.csdnimg.cn/img_convert/c98ba42965d887d5ed6ff5eb10e326d8.png)"
    },
    {
      "id": "/ES6——37：模板字符串",
      "metadata": {
        "permalink": "/blog/ES6——37：模板字符串",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——37：模板字符串.md",
        "source": "@site/blog\\ES6——37：模板字符串.md",
        "title": "ES6——37：模板字符串",
        "description": "基础用法",
        "date": "2021-03-17T00:00:00.000Z",
        "formattedDate": "2021年3月17日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.15,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——37：模板字符串",
          "date": "2021-03-17T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——36：Array拓展方法",
          "permalink": "/blog/ES6——36：Array拓展方法"
        },
        "nextItem": {
          "title": "ES6——38：String的拓展方法",
          "permalink": "/blog/ES6——38：String的拓展方法"
        }
      },
      "content": "## 基础用法\r\n![](https://img-blog.csdnimg.cn/img_convert/3496b438ee3199b1d6a8205fd755c234.png)\r\n## 模板字符串可以换行\r\n![](https://img-blog.csdnimg.cn/img_convert/722b258691025025a211795a5ab09ab0.png)\r\n## 模板字符串支持调用函数\r\n![](https://img-blog.csdnimg.cn/img_convert/c60880d094fd57fb068d9f1a23ecf9e3.png)"
    },
    {
      "id": "/ES6——38：String的拓展方法",
      "metadata": {
        "permalink": "/blog/ES6——38：String的拓展方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——38：String的拓展方法.md",
        "source": "@site/blog\\ES6——38：String的拓展方法.md",
        "title": "ES6——38：String的拓展方法",
        "description": "startsWith()和endsWith()方法",
        "date": "2021-03-17T00:00:00.000Z",
        "formattedDate": "2021年3月17日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.205,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——38：String的拓展方法",
          "date": "2021-03-17T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——37：模板字符串",
          "permalink": "/blog/ES6——37：模板字符串"
        },
        "nextItem": {
          "title": "ES6——39：set数据结构",
          "permalink": "/blog/ES6——39：set数据结构"
        }
      },
      "content": "## startsWith()和endsWith()方法\r\n判断字符串是否在原字符串的头部或尾部。\r\n![](https://img-blog.csdnimg.cn/img_convert/5ef45e5c0cdac64078445635abfdfaae.png)\r\n## repeat()方法：表示将原字符串重复n次\r\n![](https://img-blog.csdnimg.cn/img_convert/4c61b40ada639fc02b729baa3b5f68f4.png)"
    },
    {
      "id": "/ES6——39：set数据结构",
      "metadata": {
        "permalink": "/blog/ES6——39：set数据结构",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——39：set数据结构.md",
        "source": "@site/blog\\ES6——39：set数据结构.md",
        "title": "ES6——39：set数据结构",
        "description": "基础用法",
        "date": "2021-03-17T00:00:00.000Z",
        "formattedDate": "2021年3月17日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.825,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——39：set数据结构",
          "date": "2021-03-17T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——38：String的拓展方法",
          "permalink": "/blog/ES6——38：String的拓展方法"
        },
        "nextItem": {
          "title": "ES6——40：Symbol的用法",
          "permalink": "/blog/ES6——40：Symbol的用法"
        }
      },
      "content": "## 基础用法\r\n>类似于数组，但是成员的值都是唯一的。没有重复的值。\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/2ec082abda76529abe1dbb3b03e5194e.png)\r\n利用set数据结构做数组去重\r\n## set的默认方法\r\n![](https://img-blog.csdnimg.cn/img_convert/65a3fa5db156b8cb32b972ed00fac875.png)\r\n## 遍历set数据结构\r\n![](https://img-blog.csdnimg.cn/img_convert/39ddd58a2f220a6bfed1ec04107dcfe6.png)\r\n## 数组去重，求交集，并集，差集\r\n```js\r\n// 1. 数组去重\r\nconst arr = [1,2,3,4,5,5,6,8,9,9,9,9];\r\nconst result = [...new Set(arr)];\r\nconsole.log(result);\r\n// 2. 交集\r\nconst arr2 = [1,2,5,8,6];\r\nconst result2 = [...new Set(arr)].filter(item => {\r\n    \r\n    if (arr2.includes(item)) {\r\n        return true;\r\n    }\r\n});\r\nconsole.log(result2);\r\n// 3. 求并集\r\nconst merge = [...new Set([...new Set(arr),...new Set(arr2)])];\r\nconsole.log(merge);\r\n// 4. arr 对 arr2 求差集  所谓的差集就是我有你没有\r\nconst sub = [...new Set(arr)].filter(item => {\r\n    const arr2s = [...new Set(arr2)];\r\n    if (arr2s.includes(item) === false) {\r\n        return true;\r\n    };\r\n});\r\n\r\nconsole.log(sub);\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/d21d63ff5197c405ac41ceb02902ca5d.png)"
    },
    {
      "id": "/ES6——40：Symbol的用法",
      "metadata": {
        "permalink": "/blog/ES6——40：Symbol的用法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——40：Symbol的用法.md",
        "source": "@site/blog\\ES6——40：Symbol的用法.md",
        "title": "ES6——40：Symbol的用法",
        "description": "* Symbol的值是唯一的。",
        "date": "2021-03-17T00:00:00.000Z",
        "formattedDate": "2021年3月17日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.595,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——40：Symbol的用法",
          "date": "2021-03-17T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——39：set数据结构",
          "permalink": "/blog/ES6——39：set数据结构"
        },
        "nextItem": {
          "title": "ES6—30：一文搞懂闭包",
          "permalink": "/blog/ES6—30：一文搞懂闭包"
        }
      },
      "content": "* Symbol的值是唯一的。\r\n## 创建Symbol\r\n![](https://img-blog.csdnimg.cn/img_convert/191bead386ccb692fac6d4a6d232db06.png)\r\n## Symbol不能与其他数据进行运算\r\n![](https://img-blog.csdnimg.cn/img_convert/2f6db9207cc38e218b11b650ff67d09a.png)\r\n## Symbol的使用场景\r\n>有时候一个对象里有很多属性可能很相似，以至于我们不知道找那个属性，Symbol可以让他们变为唯一。\r\n* 假如对象中有重复属性，只显示一个（这是不符合逻辑的）\r\n![](https://img-blog.csdnimg.cn/img_convert/02fa098de18efc351feb108877063e21.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/d5c7e53319c63bbd82732e72ebbdd363.png)\r\n## Symbol内置属性\r\n1. 自己控制instance检测\r\n![](https://img-blog.csdnimg.cn/img_convert/c6adcc62815c11dcee3ee763c6404370.png)\r\n## description属性\r\n![](https://img-blog.csdnimg.cn/img_convert/db4457110c0e689a9e5737f9138c8fec.png)"
    },
    {
      "id": "/ES6—30：一文搞懂闭包",
      "metadata": {
        "permalink": "/blog/ES6—30：一文搞懂闭包",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6—30：一文搞懂闭包.md",
        "source": "@site/blog\\ES6—30：一文搞懂闭包.md",
        "title": "ES6—30：一文搞懂闭包",
        "description": "什么是闭包？",
        "date": "2021-03-16T00:00:00.000Z",
        "formattedDate": "2021年3月16日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 1.095,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6—30：一文搞懂闭包",
          "date": "2021-03-16T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——40：Symbol的用法",
          "permalink": "/blog/ES6——40：Symbol的用法"
        },
        "nextItem": {
          "title": "ES6——21：trim()方法去除字符串两侧空格",
          "permalink": "/blog/ES6——21：trim()方法去除字符串两侧空格"
        }
      },
      "content": "## 什么是闭包？\r\n>闭包是一种有权访问另一个函数作用域中变量的**函数**。\r\n\r\n## 闭包的主要作用\r\n答：延伸了变量的作用范围。\r\n\r\n## 闭包应用1（利用闭包的方式得到当前小li的索引号）\r\n![](https://img-blog.csdnimg.cn/img_convert/9f311b6d5760493173c22803ad7d011a.png)\r\n\r\n## 闭包应用2（计算打车价格）\r\n```js\r\n<script>\r\n// 计算打车价格\r\n// 打车起步价13（3公里内），之后每多一公里增加5块钱，用户输入公里数就可以计算\r\n// 打车价格，如果有拥堵的情况，总价格多收取10块钱的拥堵费\r\nvar user_price = (function () {\r\n    var start = 13;\r\n    var total = 0;\r\n    return {\r\n        price: function (n, flag) {\r\n            if (n <= 3) {\r\n                total = start;\r\n            } else {\r\n                total = start + (n - 3) * 5;\r\n            }\r\n            if (flag == true) {\r\n                total = total + 10;\r\n            } else {\r\n                total = total;\r\n            }\r\n            return total;\r\n        }\r\n    }\r\n})();\r\nconsole.log(user_price.price(5, true));\r\nconsole.log(user_price.price(1, false));\r\n\r\n</script>\r\n```"
    },
    {
      "id": "/ES6——21：trim()方法去除字符串两侧空格",
      "metadata": {
        "permalink": "/blog/ES6——21：trim()方法去除字符串两侧空格",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——21：trim()方法去除字符串两侧空格.md",
        "source": "@site/blog\\ES6——21：trim()方法去除字符串两侧空格.md",
        "title": "ES6——21：trim()方法去除字符串两侧空格",
        "description": "基本参数",
        "date": "2021-03-16T00:00:00.000Z",
        "formattedDate": "2021年3月16日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.06,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——21：trim()方法去除字符串两侧空格",
          "date": "2021-03-16T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6—30：一文搞懂闭包",
          "permalink": "/blog/ES6—30：一文搞懂闭包"
        },
        "nextItem": {
          "title": "ES6——22：Object.defineProperty()方法",
          "permalink": "/blog/ES6——22：Object.defineProperty()方法"
        }
      },
      "content": "## 基本参数\r\n![](https://img-blog.csdnimg.cn/img_convert/7af3742bd134cdf55b256db2dc667e88.png)\r\n## 用法实例\r\n![](https://img-blog.csdnimg.cn/img_convert/e6884982eb55cc21faee0f4f9b1d929e.png)"
    },
    {
      "id": "/ES6——22：Object.defineProperty()方法",
      "metadata": {
        "permalink": "/blog/ES6——22：Object.defineProperty()方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——22：Object.defineProperty()方法.md",
        "source": "@site/blog\\ES6——22：Object.defineProperty()方法.md",
        "title": "ES6——22：Object.defineProperty()方法",
        "description": "基本参数",
        "date": "2021-03-16T00:00:00.000Z",
        "formattedDate": "2021年3月16日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.32,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——22：Object.defineProperty()方法",
          "date": "2021-03-16T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——21：trim()方法去除字符串两侧空格",
          "permalink": "/blog/ES6——21：trim()方法去除字符串两侧空格"
        },
        "nextItem": {
          "title": "ES6——23：函数的定义方式",
          "permalink": "/blog/ES6——23：函数的定义方式"
        }
      },
      "content": "## 基本参数\r\n![](https://img-blog.csdnimg.cn/img_convert/67df5925a84cbb80d8fe440e89d1b979.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/c7e1f0729cc8dd6d9b66bc415c68d67b.png)\r\n## 用法实例\r\n![](https://img-blog.csdnimg.cn/img_convert/4eadef9927299210e7eb8c2140c31cd3.png)\r\n* enumerable: true  会使得设置的这个参数能够被遍历到，反之不能被遍历到\r\n* configurable: true 会使得设置的这个参数的属性不能被删除，默认为false"
    },
    {
      "id": "/ES6——23：函数的定义方式",
      "metadata": {
        "permalink": "/blog/ES6——23：函数的定义方式",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——23：函数的定义方式.md",
        "source": "@site/blog\\ES6——23：函数的定义方式.md",
        "title": "ES6——23：函数的定义方式",
        "description": "方式1：使用function关键字",
        "date": "2021-03-16T00:00:00.000Z",
        "formattedDate": "2021年3月16日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.11,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——23：函数的定义方式",
          "date": "2021-03-16T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——22：Object.defineProperty()方法",
          "permalink": "/blog/ES6——22：Object.defineProperty()方法"
        },
        "nextItem": {
          "title": "ES6——24：函数内部的this指向",
          "permalink": "/blog/ES6——24：函数内部的this指向"
        }
      },
      "content": "## 方式1：使用function关键字\r\n## 方式2：匿名函数\r\n## 方式3：new Function()\r\n![](https://img-blog.csdnimg.cn/img_convert/a0150f0f333dac6326098120c168ac1b.png)"
    },
    {
      "id": "/ES6——24：函数内部的this指向",
      "metadata": {
        "permalink": "/blog/ES6——24：函数内部的this指向",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——24：函数内部的this指向.md",
        "source": "@site/blog\\ES6——24：函数内部的this指向.md",
        "title": "ES6——24：函数内部的this指向",
        "description": "六种方式",
        "date": "2021-03-16T00:00:00.000Z",
        "formattedDate": "2021年3月16日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.03,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——24：函数内部的this指向",
          "date": "2021-03-16T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——23：函数的定义方式",
          "permalink": "/blog/ES6——23：函数的定义方式"
        },
        "nextItem": {
          "title": "ES6——24：函数的调用方式",
          "permalink": "/blog/ES6——24：函数的调用方式"
        }
      },
      "content": "## 六种方式\r\n![](https://img-blog.csdnimg.cn/img_convert/ebb8e76b56eef7aafd7b56b33687c1f3.png)"
    },
    {
      "id": "/ES6——24：函数的调用方式",
      "metadata": {
        "permalink": "/blog/ES6——24：函数的调用方式",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——24：函数的调用方式.md",
        "source": "@site/blog\\ES6——24：函数的调用方式.md",
        "title": "ES6——24：函数的调用方式",
        "description": "1：普通函数",
        "date": "2021-03-16T00:00:00.000Z",
        "formattedDate": "2021年3月16日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.235,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——24：函数的调用方式",
          "date": "2021-03-16T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——24：函数内部的this指向",
          "permalink": "/blog/ES6——24：函数内部的this指向"
        },
        "nextItem": {
          "title": "ES6——25：函数内部this指向的三种方法",
          "permalink": "/blog/ES6——25：函数内部this指向的三种方法"
        }
      },
      "content": "## 1：普通函数\r\n![](https://img-blog.csdnimg.cn/img_convert/cd3d8089a3c71b2ee1764dd1ebb065c3.png)\r\n## 2：对象方法\r\n![](https://img-blog.csdnimg.cn/img_convert/578acc5e73583e5998bae6bd1cacb11b.png)\r\n## 3：构造函数\r\n![](https://img-blog.csdnimg.cn/img_convert/e90f8727cdf7b37f8adc4b3484e09587.png)\r\n## 4：绑定事件函数\r\n![](https://img-blog.csdnimg.cn/img_convert/2377985caac537c222c26567b4b31eca.png)\r\n## 5：定时器函数\r\n![](https://img-blog.csdnimg.cn/img_convert/8d71fc4dbbbc3890f78a57b35bdf7e53.png)\r\n## 6：立即执行函数\r\n![](https://img-blog.csdnimg.cn/img_convert/5f833691cc7fa7d18804ce56d0eb00fb.png)"
    },
    {
      "id": "/ES6——25：函数内部this指向的三种方法",
      "metadata": {
        "permalink": "/blog/ES6——25：函数内部this指向的三种方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——25：函数内部this指向的三种方法.md",
        "source": "@site/blog\\ES6——25：函数内部this指向的三种方法.md",
        "title": "ES6——25：函数内部this指向的三种方法",
        "description": "1：call()方法",
        "date": "2021-03-16T00:00:00.000Z",
        "formattedDate": "2021年3月16日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.405,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——25：函数内部this指向的三种方法",
          "date": "2021-03-16T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——24：函数的调用方式",
          "permalink": "/blog/ES6——24：函数的调用方式"
        },
        "nextItem": {
          "title": "ES6——26：bind方法应用",
          "permalink": "/blog/ES6——26：bind方法应用"
        }
      },
      "content": "## 1：call()方法\r\n![](https://img-blog.csdnimg.cn/img_convert/cc5a3902b0481327a1fd49c6bd660c32.png)\r\n## 2：apply()方法\r\n![](https://img-blog.csdnimg.cn/img_convert/55ea899b07d13f5e54f58d155b37773b.png)\r\n* apply方法的第二个参数是一个数组\r\n* 使用apply可以求最大值和最小值\r\n![](https://img-blog.csdnimg.cn/img_convert/84b9015a070f5d066a77cbcf2ce40169.png)\r\n## 3：bind()方法\r\n![](https://img-blog.csdnimg.cn/img_convert/714951d486a49e99f7ddf8ee8bef7a16.png)\r\n* bind不会调用函数。\r\n* 调用bind函数后返回的是一个新函数，这个新函数的this是我们指定的。\r\n![](https://img-blog.csdnimg.cn/img_convert/a08a50021ff55aefaf3bc9d7abec23c3.png)"
    },
    {
      "id": "/ES6——26：bind方法应用",
      "metadata": {
        "permalink": "/blog/ES6——26：bind方法应用",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——26：bind方法应用.md",
        "source": "@site/blog\\ES6——26：bind方法应用.md",
        "title": "ES6——26：bind方法应用",
        "description": "应用实例",
        "date": "2021-03-16T00:00:00.000Z",
        "formattedDate": "2021年3月16日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.12,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——26：bind方法应用",
          "date": "2021-03-16T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——25：函数内部this指向的三种方法",
          "permalink": "/blog/ES6——25：函数内部this指向的三种方法"
        },
        "nextItem": {
          "title": "ES6——27：call_apply_bind方法总结",
          "permalink": "/blog/ES6——27：call_apply_bind方法总结"
        }
      },
      "content": "## 应用实例\r\n### 点击按钮，指定时间后状态从不可用到可用\r\n![](https://img-blog.csdnimg.cn/img_convert/b12c3b1555a91ae6be4e7a577ca9d405.png)"
    },
    {
      "id": "/ES6——27：call_apply_bind方法总结",
      "metadata": {
        "permalink": "/blog/ES6——27：call_apply_bind方法总结",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——27：call_apply_bind方法总结.md",
        "source": "@site/blog\\ES6——27：call_apply_bind方法总结.md",
        "title": "ES6——27：call_apply_bind方法总结",
        "description": "总结",
        "date": "2021-03-16T00:00:00.000Z",
        "formattedDate": "2021年3月16日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.02,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——27：call_apply_bind方法总结",
          "date": "2021-03-16T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——26：bind方法应用",
          "permalink": "/blog/ES6——26：bind方法应用"
        },
        "nextItem": {
          "title": "ES6——28：严格模式",
          "permalink": "/blog/ES6——28：严格模式"
        }
      },
      "content": "## 总结\r\n![](https://img-blog.csdnimg.cn/img_convert/8c1255b3f490edac3a2db61a28d5b1a7.png)"
    },
    {
      "id": "/ES6——28：严格模式",
      "metadata": {
        "permalink": "/blog/ES6——28：严格模式",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——28：严格模式.md",
        "source": "@site/blog\\ES6——28：严格模式.md",
        "title": "ES6——28：严格模式",
        "description": "什么是严格模式？",
        "date": "2021-03-16T00:00:00.000Z",
        "formattedDate": "2021年3月16日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.665,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——28：严格模式",
          "date": "2021-03-16T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——27：call_apply_bind方法总结",
          "permalink": "/blog/ES6——27：call_apply_bind方法总结"
        },
        "nextItem": {
          "title": "ES6——29：高阶函数",
          "permalink": "/blog/ES6——29：高阶函数"
        }
      },
      "content": "## 什么是严格模式？\r\n![](https://img-blog.csdnimg.cn/img_convert/2f8e4e87b936b50aca845f9138f137f0.png)\r\n## 如何开启严格模式？\r\n* 脚本开启严格模式\r\n![](https://img-blog.csdnimg.cn/img_convert/3e9e25a99c3d9c259e734f0d7cd5a9ad.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/6eafeb5fcd0b19c818afdbe6c19158ba.png)\r\n* 函数开启严格模式\r\n![](https://img-blog.csdnimg.cn/img_convert/1b74ab34e858f73783c9e95d8bee9399.png)\r\n## 严格模式下哪些不能用？\r\n1. 未定义变量，不能直接赋值。（非严格模式下可以）\r\n![](https://img-blog.csdnimg.cn/img_convert/72ad5c51bd84a64edece087fed4382dd.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/51a37bcaa30725edce5bd4a1eb2045dc.png)\r\n2. 不能在严格模式下随意删除已经定义好的变量\r\n![](https://img-blog.csdnimg.cn/img_convert/2f76be5daf8a987a5ad1a682fc7d0d76.png)\r\n3. 在严格模式下，全局函数中的this指向的不再是window，而是undefined\r\n![](https://img-blog.csdnimg.cn/img_convert/00231529dbaabcae95449cdc88872422.png)\r\n4. 严格模式下，函数参数不允许重名。"
    },
    {
      "id": "/ES6——29：高阶函数",
      "metadata": {
        "permalink": "/blog/ES6——29：高阶函数",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——29：高阶函数.md",
        "source": "@site/blog\\ES6——29：高阶函数.md",
        "title": "ES6——29：高阶函数",
        "description": "高阶函数的概念",
        "date": "2021-03-16T00:00:00.000Z",
        "formattedDate": "2021年3月16日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.225,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——29：高阶函数",
          "date": "2021-03-16T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——28：严格模式",
          "permalink": "/blog/ES6——28：严格模式"
        },
        "nextItem": {
          "title": "ES6——12：call()方法的应用",
          "permalink": "/blog/ES6——12：call()方法的应用"
        }
      },
      "content": "## 高阶函数的概念\r\n1. 参数是一个函数。\r\n2. 返回值是一个函数。\r\n![](https://img-blog.csdnimg.cn/img_convert/df455a00c976faab175c86374ce52407.png)\r\n## 注意高阶函数的调用方式\r\n* callback&&callback()\r\n* 形参是callback\r\n![](https://img-blog.csdnimg.cn/img_convert/f22c19309941b0d5a9a24f9a36f8334d.png)"
    },
    {
      "id": "/ES6——12：call()方法的应用",
      "metadata": {
        "permalink": "/blog/ES6——12：call()方法的应用",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——12：call()方法的应用.md",
        "source": "@site/blog\\ES6——12：call()方法的应用.md",
        "title": "ES6——12：call()方法的应用",
        "description": "组合继承的概念",
        "date": "2021-03-13T00:00:00.000Z",
        "formattedDate": "2021年3月13日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.385,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——12：call()方法的应用",
          "date": "2021-03-13T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——29：高阶函数",
          "permalink": "/blog/ES6——29：高阶函数"
        },
        "nextItem": {
          "title": "ES6——13：利用构造函数继承父类属性",
          "permalink": "/blog/ES6——13：利用构造函数继承父类属性"
        }
      },
      "content": "## 组合继承的概念\r\n通过**构造函数**和**原型对象**模拟实现继承，这种方式被称为组合继承。\r\n## call()方法的相关参数\r\n![](https://img-blog.csdnimg.cn/img_convert/ed2429a383ee867b0fe3948a4378b5c0.png)\r\n## 参考文献\r\n曾经写过一篇文章[JavaScript中call方法详解](https://blog.csdn.net/sinat_41696687/article/details/110405771?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161365192216780299083613%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fblog.%252522%25257D&request_id=161365192216780299083613&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v1~rank_blog_v1-1-110405771.pc_v1_rank_blog_v1&utm_term=call)\r\n## 改变函数内部this指向\r\n![](https://img-blog.csdnimg.cn/img_convert/3e04e4b8aad2b02a8dd853f1217ddbd5.png)"
    },
    {
      "id": "/ES6——13：利用构造函数继承父类属性",
      "metadata": {
        "permalink": "/blog/ES6——13：利用构造函数继承父类属性",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——13：利用构造函数继承父类属性.md",
        "source": "@site/blog\\ES6——13：利用构造函数继承父类属性.md",
        "title": "ES6——13：利用构造函数继承父类属性",
        "description": "子构造函数继承父构造函数的属性的实例",
        "date": "2021-03-13T00:00:00.000Z",
        "formattedDate": "2021年3月13日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.1,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——13：利用构造函数继承父类属性",
          "date": "2021-03-13T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——12：call()方法的应用",
          "permalink": "/blog/ES6——12：call()方法的应用"
        },
        "nextItem": {
          "title": "ES6——14：借用原型对象继承父构造函数的方法",
          "permalink": "/blog/ES6——14：借用原型对象继承父构造函数的方法"
        }
      },
      "content": "## 子构造函数继承父构造函数的属性的实例\r\n![](https://img-blog.csdnimg.cn/img_convert/c38078ddb94557f31a8d9754423fd978.png)"
    },
    {
      "id": "/ES6——14：借用原型对象继承父构造函数的方法",
      "metadata": {
        "permalink": "/blog/ES6——14：借用原型对象继承父构造函数的方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——14：借用原型对象继承父构造函数的方法.md",
        "source": "@site/blog\\ES6——14：借用原型对象继承父构造函数的方法.md",
        "title": "ES6——14：借用原型对象继承父构造函数的方法",
        "description": "直接将父构造函数的原型对象赋值给子构造函数的原型对象为什么行不通？",
        "date": "2021-03-13T00:00:00.000Z",
        "formattedDate": "2021年3月13日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.26,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——14：借用原型对象继承父构造函数的方法",
          "date": "2021-03-13T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——13：利用构造函数继承父类属性",
          "permalink": "/blog/ES6——13：利用构造函数继承父类属性"
        },
        "nextItem": {
          "title": "ES6——15：类的本质",
          "permalink": "/blog/ES6——15：类的本质"
        }
      },
      "content": "## 直接将父构造函数的原型对象赋值给子构造函数的原型对象为什么行不通？\r\n![](https://img-blog.csdnimg.cn/img_convert/a240d37cd32dd6024a308d73e21b0d28.png)\r\n## 正确的方式\r\n![](https://img-blog.csdnimg.cn/img_convert/1804fd1e9f5401e54a3e3fbed122679b.png)\r\n## 实例代码\r\n![](https://img-blog.csdnimg.cn/img_convert/7da35db379f991eed00b9fe50765dd53.png)\r\n注意事项\r\n![](https://img-blog.csdnimg.cn/img_convert/15ea8978957d521e430001d0f559358e.png)"
    },
    {
      "id": "/ES6——15：类的本质",
      "metadata": {
        "permalink": "/blog/ES6——15：类的本质",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——15：类的本质.md",
        "source": "@site/blog\\ES6——15：类的本质.md",
        "title": "ES6——15：类的本质",
        "description": "1：class的本质是function",
        "date": "2021-03-13T00:00:00.000Z",
        "formattedDate": "2021年3月13日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.16,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——15：类的本质",
          "date": "2021-03-13T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——14：借用原型对象继承父构造函数的方法",
          "permalink": "/blog/ES6——14：借用原型对象继承父构造函数的方法"
        },
        "nextItem": {
          "title": "ES6——16：迭代数组（forEach）",
          "permalink": "/blog/ES6——16：迭代数组（forEach）"
        }
      },
      "content": "## 1：class的本质是function\r\n## 2：类也有原型对象\r\n## 3：类也可以通过原型对象添加方法\r\n![](https://img-blog.csdnimg.cn/img_convert/a6de325846f29ce2992a030cbcf62216.png)"
    },
    {
      "id": "/ES6——16：迭代数组（forEach）",
      "metadata": {
        "permalink": "/blog/ES6——16：迭代数组（forEach）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——16：迭代数组（forEach）.md",
        "source": "@site/blog\\ES6——16：迭代数组（forEach）.md",
        "title": "ES6——16：迭代数组（forEach）",
        "description": "示例代码",
        "date": "2021-03-13T00:00:00.000Z",
        "formattedDate": "2021年3月13日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.03,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——16：迭代数组（forEach）",
          "date": "2021-03-13T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——15：类的本质",
          "permalink": "/blog/ES6——15：类的本质"
        },
        "nextItem": {
          "title": "ES6——17：筛选数组（filter）",
          "permalink": "/blog/ES6——17：筛选数组（filter）"
        }
      },
      "content": "## 示例代码\r\n![](https://img-blog.csdnimg.cn/img_convert/22dfa29acb6b5fe34c4594cb72df63b3.png)"
    },
    {
      "id": "/ES6——17：筛选数组（filter）",
      "metadata": {
        "permalink": "/blog/ES6——17：筛选数组（filter）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——17：筛选数组（filter）.md",
        "source": "@site/blog\\ES6——17：筛选数组（filter）.md",
        "title": "ES6——17：筛选数组（filter）",
        "description": "用法基本介绍",
        "date": "2021-03-13T00:00:00.000Z",
        "formattedDate": "2021年3月13日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.07,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——17：筛选数组（filter）",
          "date": "2021-03-13T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——16：迭代数组（forEach）",
          "permalink": "/blog/ES6——16：迭代数组（forEach）"
        },
        "nextItem": {
          "title": "ES6——18：查找数组中是否有满足条件的数组（some）",
          "permalink": "/blog/ES6——18：查找数组中是否有满足条件的数组（some）"
        }
      },
      "content": "## 用法基本介绍\r\n![](https://img-blog.csdnimg.cn/img_convert/64067a895d963be4197a93e9581c89a2.png)\r\n## 用法实例\r\n![](https://img-blog.csdnimg.cn/img_convert/d6e710d511d115e7ad75205cbc66cd83.png)"
    },
    {
      "id": "/ES6——18：查找数组中是否有满足条件的数组（some）",
      "metadata": {
        "permalink": "/blog/ES6——18：查找数组中是否有满足条件的数组（some）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——18：查找数组中是否有满足条件的数组（some）.md",
        "source": "@site/blog\\ES6——18：查找数组中是否有满足条件的数组（some）.md",
        "title": "ES6——18：查找数组中是否有满足条件的数组（some）",
        "description": "基本参数",
        "date": "2021-03-13T00:00:00.000Z",
        "formattedDate": "2021年3月13日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.06,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——18：查找数组中是否有满足条件的数组（some）",
          "date": "2021-03-13T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——17：筛选数组（filter）",
          "permalink": "/blog/ES6——17：筛选数组（filter）"
        },
        "nextItem": {
          "title": "ES6——19：查询商品案例",
          "permalink": "/blog/ES6——19：查询商品案例"
        }
      },
      "content": "## 基本参数\r\n![](https://img-blog.csdnimg.cn/img_convert/99bb07783ece27d90ac48324fe0010af.png)\r\n## 使用实例\r\n![](https://img-blog.csdnimg.cn/img_convert/ef4df14d277e27aea988d818b8e4034b.png)"
    },
    {
      "id": "/ES6——19：查询商品案例",
      "metadata": {
        "permalink": "/blog/ES6——19：查询商品案例",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——19：查询商品案例.md",
        "source": "@site/blog\\ES6——19：查询商品案例.md",
        "title": "ES6——19：查询商品案例",
        "description": "1：使用forEach循环渲染数据",
        "date": "2021-03-13T00:00:00.000Z",
        "formattedDate": "2021年3月13日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 2.7,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——19：查询商品案例",
          "date": "2021-03-13T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——18：查找数组中是否有满足条件的数组（some）",
          "permalink": "/blog/ES6——18：查找数组中是否有满足条件的数组（some）"
        },
        "nextItem": {
          "title": "ES6——20：some和forEach的区别",
          "permalink": "/blog/ES6——20：some和forEach的区别"
        }
      },
      "content": "## 1：使用forEach循环渲染数据\r\n![](https://img-blog.csdnimg.cn/img_convert/f2ba37b36900cf2ddd46622724dd781e.png)\r\n### 代码\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <style>\r\n        .search {\r\n            width: 600px;\r\n            margin: 20px auto;\r\n        }\r\n        input {\r\n            width: 50px;\r\n        }\r\n        table {\r\n            width: 400px;\r\n            border-collapse: collapse;\r\n            margin: 0 auto;\r\n        }\r\n        td,th {\r\n            border: 1px solid;\r\n            border-collapse: collapse;\r\n            text-align: center;\r\n        }\r\n    </style>\r\n</head>\r\n\r\n<body>\r\n    <div class=\"search\">\r\n        按照价格查询：<input type=\"text\"> - <input type=\"text\">\r\n        <button class=\"search-price\">搜索</button> 按照商品名称查询：<input type=\"text\" class=\"product\"><button\r\n            class=\"search-pro\">查询</button>\r\n    </div>\r\n    <table>\r\n        <thead>\r\n            <tr>\r\n                <th>id</th>\r\n                <th>产品名称</th>\r\n                <th>价格</th>\r\n            </tr>\r\n        </thead>\r\n        <tbody>\r\n\r\n        </tbody>\r\n    </table>\r\n\r\n    <script>\r\n        var data = [{\r\n            id: 1,\r\n            pname: \"小米\",\r\n            price: 3999\r\n        }, {\r\n            id: 2,\r\n            pname: \"oppo\",\r\n            price: 999\r\n        }, {\r\n            id: 3,\r\n            pname: \"荣耀\",\r\n            price: 1299\r\n        }, {\r\n            id: 4,\r\n            pname: \"华为\",\r\n            price: 1999\r\n        }, ];\r\n        // 获取相应的元素\r\n        var tbody = document.querySelector(\"tbody\");\r\n        // 把数据渲染到页面中\r\n        data.forEach(function(value) {\r\n            console.log(value.pname);\r\n            // 开始渲染\r\n            var tr = document.createElement('tr');\r\n            tr.innerHTML = '<td>'+ value.id +'</td><td>'+ value.pname +'</td><td>'+ value.price +'</td>';\r\n            tbody.appendChild(tr);\r\n        })\r\n    </script>\r\n</body>\r\n\r\n</html>\r\n```\r\n## 2：根据价格筛选商品\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <style>\r\n        .search {\r\n            width: 600px;\r\n            margin: 20px auto;\r\n        }\r\n\r\n        input {\r\n            width: 50px;\r\n        }\r\n\r\n        table {\r\n            width: 400px;\r\n            border-collapse: collapse;\r\n            margin: 0 auto;\r\n        }\r\n\r\n        td,\r\n        th {\r\n            border: 1px solid;\r\n            border-collapse: collapse;\r\n            text-align: center;\r\n        }\r\n    </style>\r\n</head>\r\n\r\n<body>\r\n<div class=\"search\">\r\n按照价格查询：<input type=\"text\" class=\"start\"> - <input type=\"text\" class=\"end\">\r\n<button class=\"search-price\">搜索</button> 按照商品名称查询：<input type=\"text\" class=\"product\"><button\r\n    class=\"search-pro\">查询</button>\r\n</div>\r\n<table>\r\n<thead>\r\n    <tr>\r\n        <th>id</th>\r\n        <th>产品名称</th>\r\n        <th>价格</th>\r\n    </tr>\r\n</thead>\r\n<tbody>\r\n\r\n</tbody>\r\n</table>\r\n\r\n<script>\r\nvar data = [{\r\n    id: 1,\r\n    pname: \"小米\",\r\n    price: 3999\r\n}, {\r\n    id: 2,\r\n    pname: \"oppo\",\r\n    price: 999\r\n}, {\r\n    id: 3,\r\n    pname: \"荣耀\",\r\n    price: 1299\r\n}, {\r\n    id: 4,\r\n    pname: \"华为\",\r\n    price: 1999\r\n}];\r\n// 获取相应的元素\r\nvar tbody = document.querySelector(\"tbody\");\r\n// 根据价格筛选商品\r\n// 获取价格区间\r\nvar newarr;\r\nvar search_price = document.querySelector('.search-price');\r\nsearch_price.onclick = function () {\r\n    let input_start = document.querySelector(\".start\");\r\n    let input_end = document.querySelector(\".end\");\r\n    let tbody = document.querySelector('tbody');\r\n    tbody.innerHTML = '';\r\n    newarr = data.filter(function (values) {\r\n        return values.price >= input_start.value && values.price <= input_end.value;\r\n    })\r\n    console.log(newarr);\r\n    if (newarr.length == 0) {\r\n    } else {\r\n        newarr.forEach(function (value) {\r\n            var tr = document.createElement('tr');\r\n            tr.innerHTML = '<td>' + value.id + '</td><td>' + value.pname + '</td><td>' + value.price;\r\n            tbody.appendChild(tr);\r\n        })\r\n    }\r\n\r\n}\r\n\r\n// 根据商品名称查询\r\nvar search_pro = document.querySelector('.search-pro');\r\nsearch_pro.onclick = function() {\r\n    let tbody = document.querySelector('tbody');\r\n    tbody.innerHTML = '';\r\n    var product = document.querySelector('.product');\r\n    data.forEach(function(values) {\r\n        if(product.value == values.pname) {\r\n            let tr = document.createElement('tr');\r\n            tr.innerHTML = '<td>' + values.id + '</td><td>' + values.pname + '</td><td>' + values.price;\r\n            tbody.appendChild(tr);    \r\n        }\r\n    })\r\n}\r\n    </script>\r\n</body>\r\n</html>\r\n```\r\n## 实现效果\r\n![](https://img-blog.csdnimg.cn/img_convert/36e428e1405b068c7e7b3297b1555e8a.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/f78c93e602731b52358d66f959516e0d.png)"
    },
    {
      "id": "/ES6——20：some和forEach的区别",
      "metadata": {
        "permalink": "/blog/ES6——20：some和forEach的区别",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——20：some和forEach的区别.md",
        "source": "@site/blog\\ES6——20：some和forEach的区别.md",
        "title": "ES6——20：some和forEach的区别",
        "description": "区别：forEach中的return不会终止循环，但是some中的return会终止循环",
        "date": "2021-03-13T00:00:00.000Z",
        "formattedDate": "2021年3月13日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.13,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——20：some和forEach的区别",
          "date": "2021-03-13T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——19：查询商品案例",
          "permalink": "/blog/ES6——19：查询商品案例"
        },
        "nextItem": {
          "title": "ES6———11：利用原型对象拓展内置对象方法",
          "permalink": "/blog/ES6———11：利用原型对象拓展内置对象方法"
        }
      },
      "content": "## 区别：forEach中的return不会终止循环，但是some中的return会终止循环\r\n![](https://img-blog.csdnimg.cn/img_convert/397d2d224f9679d7adcd08670729c3fa.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/c67faf6cd5beac66a5bc257403947936.png)"
    },
    {
      "id": "/ES6———11：利用原型对象拓展内置对象方法",
      "metadata": {
        "permalink": "/blog/ES6———11：利用原型对象拓展内置对象方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6———11：利用原型对象拓展内置对象方法.md",
        "source": "@site/blog\\ES6———11：利用原型对象拓展内置对象方法.md",
        "title": "ES6———11：利用原型对象拓展内置对象方法",
        "description": "拓展内置对象的注意事项",
        "date": "2021-03-13T00:00:00.000Z",
        "formattedDate": "2021年3月13日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.115,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6———11：利用原型对象拓展内置对象方法",
          "date": "2021-03-13T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——20：some和forEach的区别",
          "permalink": "/blog/ES6——20：some和forEach的区别"
        },
        "nextItem": {
          "title": "ES6——01.创建类和实例",
          "permalink": "/blog/ES6——01.创建类和实例"
        }
      },
      "content": "## 拓展内置对象的注意事项\r\n![](https://img-blog.csdnimg.cn/img_convert/2ee4760519d5862e1e99fbb1cc2d7400.png)\r\n## 拓展内置对象实例\r\n![](https://img-blog.csdnimg.cn/img_convert/e5dcabbd1a27547c7b292a6cb3185779.png)"
    },
    {
      "id": "/ES6——01.创建类和实例",
      "metadata": {
        "permalink": "/blog/ES6——01.创建类和实例",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——01.创建类和实例.md",
        "source": "@site/blog\\ES6——01.创建类和实例.md",
        "title": "ES6——01.创建类和实例",
        "description": "constructor(构造函数)",
        "date": "2021-03-12T00:00:00.000Z",
        "formattedDate": "2021年3月12日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.64,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——01.创建类和实例",
          "date": "2021-03-12T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6———11：利用原型对象拓展内置对象方法",
          "permalink": "/blog/ES6———11：利用原型对象拓展内置对象方法"
        },
        "nextItem": {
          "title": "ES6——02：class中的函数",
          "permalink": "/blog/ES6——02：class中的函数"
        }
      },
      "content": "## constructor(构造函数)\r\n>constructor()方法是类的构造函数（默认方法），用于传递参数，返回实例对象，通过new命令生成对象实例时，自动调用该方法。如果没有显示定义，类内部会总动给我们创建一个constructor().\r\n![](https://img-blog.csdnimg.cn/img_convert/82445679f9a458c495b3a36304b1021b.png)\r\n* 只要new对象，就会自动调用类的构造函数。\r\n* 类名首字母一般大写。\r\n![](https://img-blog.csdnimg.cn/img_convert/40992c6972f49626b72f66d015f93542.png)\r\n## 代码\r\n```html\r\n<script>\r\n    class Star {\r\n        constructor(name) {\r\n            this.name = name;\r\n        }\r\n    }\r\n    var test = new Star(\"测试名\");\r\n    console.log(test.name);\r\n</script>\r\n```"
    },
    {
      "id": "/ES6——02：class中的函数",
      "metadata": {
        "permalink": "/blog/ES6——02：class中的函数",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——02：class中的函数.md",
        "source": "@site/blog\\ES6——02：class中的函数.md",
        "title": "ES6——02：class中的函数",
        "description": "类中的函数",
        "date": "2021-03-12T00:00:00.000Z",
        "formattedDate": "2021年3月12日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.16,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——02：class中的函数",
          "date": "2021-03-12T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——01.创建类和实例",
          "permalink": "/blog/ES6——01.创建类和实例"
        },
        "nextItem": {
          "title": "ES6——03：类的继承与extends和super关键字",
          "permalink": "/blog/ES6——03：类的继承与extends和super关键字"
        }
      },
      "content": "## 类中的函数\r\n* 类中的函数不用加function。\r\n* 类中的函数与函数之间不用加逗号。\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/a24f3cad4f4d801c3ca5e3e70a536881.png)"
    },
    {
      "id": "/ES6——03：类的继承与extends和super关键字",
      "metadata": {
        "permalink": "/blog/ES6——03：类的继承与extends和super关键字",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——03：类的继承与extends和super关键字.md",
        "source": "@site/blog\\ES6——03：类的继承与extends和super关键字.md",
        "title": "ES6——03：类的继承与extends和super关键字",
        "description": "extends关键字",
        "date": "2021-03-12T00:00:00.000Z",
        "formattedDate": "2021年3月12日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.475,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——03：类的继承与extends和super关键字",
          "date": "2021-03-12T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——02：class中的函数",
          "permalink": "/blog/ES6——02：class中的函数"
        },
        "nextItem": {
          "title": "ES6——04：使用类时注意事项",
          "permalink": "/blog/ES6——04：使用类时注意事项"
        }
      },
      "content": "## extends关键字\r\n>使用entends关键字可以让子类继承父类的函数。\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/fd0681005822af531b2b746324caf418.png)\r\n## super关键字\r\n* super关键字用来调用父类的普通函数和构造函数。\r\n![](https://img-blog.csdnimg.cn/img_convert/9e4d9f17cc3cd9bfdaad90e20feb4171.png)\r\n### super调用父类的构造函数\r\n![](https://img-blog.csdnimg.cn/img_convert/97fd4ee06890548054aec3e462159aab.png)\r\n### 调用父类的普通函数\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210217184249624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzQxNjk2Njg3,size_16,color_FFFFFF,t_70)\r\n### super必须在子类this之前调用\r\n![](https://img-blog.csdnimg.cn/img_convert/4fcaa14f949295c17e45d1db38e43ad0.png)"
    },
    {
      "id": "/ES6——04：使用类时注意事项",
      "metadata": {
        "permalink": "/blog/ES6——04：使用类时注意事项",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——04：使用类时注意事项.md",
        "source": "@site/blog\\ES6——04：使用类时注意事项.md",
        "title": "ES6——04：使用类时注意事项",
        "description": "1：类没有变量提升，必须先定义才能实例化对象。",
        "date": "2021-03-12T00:00:00.000Z",
        "formattedDate": "2021年3月12日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.345,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——04：使用类时注意事项",
          "date": "2021-03-12T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——03：类的继承与extends和super关键字",
          "permalink": "/blog/ES6——03：类的继承与extends和super关键字"
        },
        "nextItem": {
          "title": "ES6——05：利用构造函数创建对象",
          "permalink": "/blog/ES6——05：利用构造函数创建对象"
        }
      },
      "content": "## 1：类没有变量提升，必须先定义才能实例化对象。\r\n## 2：类里面共有的属性和方法一定要加this使用。\r\n## 3：constructor中的this指向的是实例对象，方法里面的this指向这个方法的调用者。\r\n![](https://img-blog.csdnimg.cn/img_convert/b338b7195200fbcbaea7fa3cd797ac1d.png)"
    },
    {
      "id": "/ES6——05：利用构造函数创建对象",
      "metadata": {
        "permalink": "/blog/ES6——05：利用构造函数创建对象",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——05：利用构造函数创建对象.md",
        "source": "@site/blog\\ES6——05：利用构造函数创建对象.md",
        "title": "ES6——05：利用构造函数创建对象",
        "description": "基本实例",
        "date": "2021-03-12T00:00:00.000Z",
        "formattedDate": "2021年3月12日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 1.06,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——05：利用构造函数创建对象",
          "date": "2021-03-12T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——04：使用类时注意事项",
          "permalink": "/blog/ES6——04：使用类时注意事项"
        },
        "nextItem": {
          "title": "ES6——06：构造函数原型对象prototype",
          "permalink": "/blog/ES6——06：构造函数原型对象prototype"
        }
      },
      "content": "## 基本实例\r\n![](https://img-blog.csdnimg.cn/img_convert/93b24155fd699d209537e38ae3798638.png)\r\n## new在执行的时候发生的四件事情\r\n1. 在内存中创建一个新的空对象。\r\n2. 让this指向这个新的对象。\r\n3. 执行构造函数里面的代码，给这个新对象添加属性和方法。\r\n4. 返回这个新对象。\r\n## 静态成员与实例成员\r\n1. 什么是成员？\r\n\t答：在构造函数中的属性和方法我们称之为成员。\r\n2. 什么是实例成员？\r\n\t答：实例成员就是构造函数内部通过this添加的成员。实例成员只能通过实例化的对象来访问。\r\n3. 什么是静态成员？\r\n\t答：在构造函数本身上添加的成员。静态成员只能通过构造函数来访问。\r\n## 给构造函数添加静态成员并调用\r\n![](https://img-blog.csdnimg.cn/img_convert/e606b0729bbcd0b5ef6c1c4807c7fea8.png)"
    },
    {
      "id": "/ES6——06：构造函数原型对象prototype",
      "metadata": {
        "permalink": "/blog/ES6——06：构造函数原型对象prototype",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——06：构造函数原型对象prototype.md",
        "source": "@site/blog\\ES6——06：构造函数原型对象prototype.md",
        "title": "ES6——06：构造函数原型对象prototype",
        "description": "构造函数存在的问题",
        "date": "2021-03-12T00:00:00.000Z",
        "formattedDate": "2021年3月12日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.67,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——06：构造函数原型对象prototype",
          "date": "2021-03-12T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——05：利用构造函数创建对象",
          "permalink": "/blog/ES6——05：利用构造函数创建对象"
        },
        "nextItem": {
          "title": "ES6——07：构造函数与原型对象、对象原型三者关系图解",
          "permalink": "/blog/ES6——07：构造函数与原型对象、对象原型三者关系图解"
        }
      },
      "content": "## 构造函数存在的问题\r\n* 浪费内存问题\r\n![](https://img-blog.csdnimg.cn/img_convert/af7eda2de693ec35e704b409f8c30a03.png)\r\n## 构造函数原型对象prototype\r\n* 构造函数的原型对象prototype是所有实例对象所共享的。\r\n* 每一个构造函数都有一个prototype属性。\r\n* prototype所具有的属性和方法都将被构造函数所拥有。\r\n* 若实例本身没有的属性和方法可以去其构造函数的原型对象中去寻找。\r\n## 原型对象存在的意义是什么？\r\n答：共享方法，节省内存。"
    },
    {
      "id": "/ES6——07：构造函数与原型对象、对象原型三者关系图解",
      "metadata": {
        "permalink": "/blog/ES6——07：构造函数与原型对象、对象原型三者关系图解",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——07：构造函数与原型对象、对象原型三者关系图解.md",
        "source": "@site/blog\\ES6——07：构造函数与原型对象、对象原型三者关系图解.md",
        "title": "ES6——07：构造函数与原型对象、对象原型三者关系图解",
        "description": "proto指向什么？",
        "date": "2021-03-12T00:00:00.000Z",
        "formattedDate": "2021年3月12日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.505,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——07：构造函数与原型对象、对象原型三者关系图解",
          "date": "2021-03-12T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——06：构造函数原型对象prototype",
          "permalink": "/blog/ES6——06：构造函数原型对象prototype"
        },
        "nextItem": {
          "title": "ES6——08：原型链",
          "permalink": "/blog/ES6——08：原型链"
        }
      },
      "content": "## __proto__指向什么？\r\n答： __proto__指向的是该对象的构造函数的原型对象（prototype）。\r\n![](https://img-blog.csdnimg.cn/img_convert/795ec2047c44905085796e348aada0f6.png)\r\n## 构造函数与原型对象、对象原型的关联图\r\n![](https://img-blog.csdnimg.cn/img_convert/afd360d516e0aad266143862c16e74a4.png)\r\n## constructor属性\r\n* constructor属性帮助我们指向构造函数本身。\r\n![](https://img-blog.csdnimg.cn/img_convert/a4c7e02929e95790560ef787ac804849.png)\r\n## constructor属性不能指向构造函数的情况\r\n![](https://img-blog.csdnimg.cn/img_convert/56f08a742e9111f1ec146b2d741a590c.png)\r\n## 构造函数，实例对象，原型对象三者关系图\r\n![](https://img-blog.csdnimg.cn/img_convert/e0933adb7ba72c4c2430c51e21ea97c8.png)"
    },
    {
      "id": "/ES6——08：原型链",
      "metadata": {
        "permalink": "/blog/ES6——08：原型链",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——08：原型链.md",
        "source": "@site/blog\\ES6——08：原型链.md",
        "title": "ES6——08：原型链",
        "description": "图解原型链",
        "date": "2021-03-12T00:00:00.000Z",
        "formattedDate": "2021年3月12日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.035,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——08：原型链",
          "date": "2021-03-12T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——07：构造函数与原型对象、对象原型三者关系图解",
          "permalink": "/blog/ES6——07：构造函数与原型对象、对象原型三者关系图解"
        },
        "nextItem": {
          "title": "ES6——09：对象成员查找规则",
          "permalink": "/blog/ES6——09：对象成员查找规则"
        }
      },
      "content": "## 图解原型链\r\n![](https://img-blog.csdnimg.cn/img_convert/f10d50d27abd50f2ab61f98163a2fd74.png)"
    },
    {
      "id": "/ES6——09：对象成员查找规则",
      "metadata": {
        "permalink": "/blog/ES6——09：对象成员查找规则",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——09：对象成员查找规则.md",
        "source": "@site/blog\\ES6——09：对象成员查找规则.md",
        "title": "ES6——09：对象成员查找规则",
        "description": "1：当访问一个对象的属性时，首先查找这个对象自身有没有该属性。有则使用，无则进入第二步。",
        "date": "2021-03-12T00:00:00.000Z",
        "formattedDate": "2021年3月12日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.405,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——09：对象成员查找规则",
          "date": "2021-03-12T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——08：原型链",
          "permalink": "/blog/ES6——08：原型链"
        },
        "nextItem": {
          "title": "ES6——10：原型对象的this指向问题",
          "permalink": "/blog/ES6——10：原型对象的this指向问题"
        }
      },
      "content": "## 1：当访问一个对象的属性时，首先查找这个对象自身有没有该属性。有则使用，无则进入第二步。\r\n## 2：如果没有就查找它的原型。\r\n## 3：如果还没有就查找原型对象的原型。\r\n## 4：以此类推一直找到Object为止。\r\n![](https://img-blog.csdnimg.cn/img_convert/6a28c76791c35dfbb4c6d5250bb97b5f.png)"
    },
    {
      "id": "/ES6——10：原型对象的this指向问题",
      "metadata": {
        "permalink": "/blog/ES6——10：原型对象的this指向问题",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/ES6——10：原型对象的this指向问题.md",
        "source": "@site/blog\\ES6——10：原型对象的this指向问题.md",
        "title": "ES6——10：原型对象的this指向问题",
        "description": "原型对象中的this指的是实例对象且调用它的那个实例对象",
        "date": "2021-03-12T00:00:00.000Z",
        "formattedDate": "2021年3月12日",
        "tags": [
          {
            "label": "ES6",
            "permalink": "/blog/tags/es-6"
          }
        ],
        "readingTime": 0.135,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "ES6——10：原型对象的this指向问题",
          "date": "2021-03-12T00:00:00.000Z",
          "categories": "ES6",
          "tags": [
            "ES6"
          ]
        },
        "prevItem": {
          "title": "ES6——09：对象成员查找规则",
          "permalink": "/blog/ES6——09：对象成员查找规则"
        },
        "nextItem": {
          "title": "一台电脑绑定两个Github账号",
          "permalink": "/blog/一台电脑绑定两个Github账号"
        }
      },
      "content": "## 原型对象中的this指的是实例对象且调用它的那个实例对象\r\n![](https://img-blog.csdnimg.cn/img_convert/1ca4038bd42449424f511bcc320465bb.png)"
    },
    {
      "id": "/一台电脑绑定两个Github账号",
      "metadata": {
        "permalink": "/blog/一台电脑绑定两个Github账号",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/一台电脑绑定两个Github账号.md",
        "source": "@site/blog\\一台电脑绑定两个Github账号.md",
        "title": "一台电脑绑定两个Github账号",
        "description": "1：首先我们的PC已经绑定过一个账号了，也就意味这我们右id_rsa了。",
        "date": "2021-02-17T00:00:00.000Z",
        "formattedDate": "2021年2月17日",
        "tags": [
          {
            "label": "Git",
            "permalink": "/blog/tags/git"
          }
        ],
        "readingTime": 0.705,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "一台电脑绑定两个Github账号",
          "date": "2021-02-17T00:00:00.000Z",
          "categories": "Git",
          "tags": [
            "Git"
          ]
        },
        "prevItem": {
          "title": "ES6——10：原型对象的this指向问题",
          "permalink": "/blog/ES6——10：原型对象的this指向问题"
        },
        "nextItem": {
          "title": "一篇文章学会使用BootStrap",
          "permalink": "/blog/一篇文章学会使用BootStrap"
        }
      },
      "content": "## 1：首先我们的PC已经绑定过一个账号了，也就意味这我们右id_rsa了。\r\n## 2：生成新的公钥并命名为id_rsa_2\r\n```\r\nssh-keygen -t rsa -f ~/.ssh/id_rsa_2 -C \"yourmail@xxx.com\"\r\n```\r\n## 3：修改config配置\r\n![](https://img-blog.csdnimg.cn/img_convert/4ffa3ddaaca09adcf1cf074fa30ceeb0.png)\r\n## 4：将指定公钥输入github\r\nid_rsa_2.pub  指的是公钥\r\n## 5：设置全局用户名和密码\r\n```\r\n# 取消全局 用户名/邮箱 配置\r\ngit config –global –unset user.name\r\ngit config –global –unset user.email\r\n# 单独设置每个repo 用户名/邮箱\r\ngit config user.email “xxxx@xx.com”\r\ngit config user.name “xxxx”\r\n```\r\n## 6：链接远程仓库\r\n```\r\ngit remote add origin ***\r\n```"
    },
    {
      "id": "/一篇文章学会使用BootStrap",
      "metadata": {
        "permalink": "/blog/一篇文章学会使用BootStrap",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/一篇文章学会使用BootStrap.md",
        "source": "@site/blog\\一篇文章学会使用BootStrap.md",
        "title": "一篇文章学会使用BootStrap",
        "description": "1：引入BootStrap的结构",
        "date": "2021-02-16T00:00:00.000Z",
        "formattedDate": "2021年2月16日",
        "tags": [
          {
            "label": "BootStrap",
            "permalink": "/blog/tags/boot-strap"
          },
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 21.835,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "一篇文章学会使用BootStrap",
          "date": "2021-02-16T00:00:00.000Z",
          "categories": "BootStrap",
          "tags": [
            "BootStrap",
            "前端"
          ]
        },
        "prevItem": {
          "title": "一台电脑绑定两个Github账号",
          "permalink": "/blog/一台电脑绑定两个Github账号"
        },
        "nextItem": {
          "title": "考查候选人正则基本功的面试题之《解析URL请求参数》",
          "permalink": "/blog/考查候选人正则基本功的面试题之《解析URL请求参数》"
        }
      },
      "content": "## 1：引入BootStrap的结构\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <link rel=\"stylesheet\" href=\"css/bootstrap.min.css\">\r\n</head>\r\n<body>\r\n    <script src=\"js/bootstrap.min.js\"></script>\r\n    <script src=\"js/jquery.min.js\"></script>\r\n</body>\r\n</html>\r\n```\r\n## 2：基本模板\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"zh-CN\">\r\n  <head>\r\n    <meta charset=\"utf-8\">\r\n    <!-- 下面一句的作用是告诉IE浏览器以最新版本（edge)的方式渲染页面 -->\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <!-- 实现响应式，支持移动设备 -->\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\r\n    <!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ -->\r\n    <title>Bootstrap 101 Template</title>\r\n\r\n    <!-- Bootstrap -->\r\n    <link href=\"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css\" rel=\"stylesheet\">\r\n\r\n    <!-- HTML5 shim 和 Respond.js 是为了让 IE8 支持 HTML5 元素和媒体查询（media queries）功能 -->\r\n    <!-- 警告：通过 file:// 协议（就是直接将 html 页面拖拽到浏览器中）访问页面时 Respond.js 不起作用 -->\r\n    <!--[if lt IE 9]>\r\n      <script src=\"https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js\"></script>\r\n      <script src=\"https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js\"></script>\r\n    <![endif]-->\r\n  </head>\r\n  <body>\r\n    <h1>你好，世界！</h1>\r\n\r\n    <!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) -->\r\n    <script src=\"https://cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js\"></script>\r\n    <!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 -->\r\n    <script src=\"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js\"></script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n## 3：流体容器（.container-fluid）\r\n* 流体容器会随着页面窗口的大小变化而变化，其宽度始终占据整个屏幕的宽度。\r\n* 流体容器相当于width=100%\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <link rel=\"stylesheet\" href=\"css/bootstrap.min.css\">\r\n    <style>\r\n        .container-fluid {\r\n            background-color: aqua;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"container-fluid\">\r\n        test\r\n    </div>\r\n    <script src=\"js/bootstrap.min.js\"></script>\r\n    <script src=\"js/jquery.min.js\"></script>\r\n</body>\r\n</html>\r\n```\r\n## 4：固定容器（.container）\r\n* 固定容器的宽度是固定的，不会随屏幕大小的变化而变化。\r\n* 固定容器是有三个阈值的，如下图所示（当屏幕宽度大于等于1200px的时候，容器的宽度为1170px）\r\n![](https://img-blog.csdnimg.cn/img_convert/f84f87e5f4aafddf1e654d64af919dc0.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/92d1289d35a1cd17239e14ae68c76e21.png)\r\n## 5：栅格系统\r\n* 在栅格系统中一行被分为12列\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <link rel=\"stylesheet\" href=\"css/bootstrap.min.css\">\r\n    <style>\r\n        .container {\r\n            background-color: aqua;\r\n        }\r\n        div[class |= col] {\r\n            border: 1px solid;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"container\">\r\n        <div class=\"row\">\r\n            <div class=\"col-lg-10\">col-lg-10</div>\r\n            <div class=\"col-lg-2\">col-lg-2</div>\r\n        </div>\r\n        <div class=\"row\">\r\n            <div class=\"col-lg-2\">col-lg-2</div>\r\n            <div class=\"col-lg-10\">col-lg-10</div>\r\n        </div>\r\n        <div class=\"row\">\r\n            <div class=\"col-lg-6\">col-lg-6</div>\r\n            <div class=\"col-lg-6\">col-lg-6</div>\r\n        </div>\r\n    </div>\r\n    <script src=\"js/bootstrap.min.js\"></script>\r\n    <script src=\"js/jquery.min.js\"></script>\r\n</body>\r\n</html>\r\n```\r\n### 5.1 效果\r\n![](https://img-blog.csdnimg.cn/img_convert/fea1c0de9b385b74e7ef0bf2229bb45d.png)\r\n### 5.2 列的阈值划分（lg,md,sm,xs的含义）\r\n![](https://img-blog.csdnimg.cn/img_convert/0a49c94385566326a2423a50b9f488f6.png)\r\n### 5.3 被两个列控制\r\n![](https://img-blog.csdnimg.cn/img_convert/8f8496941cb97567c620393a9ba8d186.png)\r\n> 当屏幕处于lg的时候是10列，2列分布\r\n> 当屏幕处于md大小的时候，是6列，6列平分。\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/d3796093ce763130b93653b27df0b317.png)\r\n>当屏幕处于sm的状态时，第一个占6列，第二个占6列，第二个之所以占6列，是因为第二个col-xs-6向上兼容。\r\n\r\n### 5.4 列偏移\r\n* 向右偏移一列。\r\n![](https://img-blog.csdnimg.cn/img_convert/c4a13d3b16d522d4b2e6e9b314d53527.png)\r\n## 6：标题标签\r\n* 给类名添加.h1到.h6，实现下面的效果\r\n![](https://img-blog.csdnimg.cn/img_convert/6dd832f1dab894e9d2b8f42b08000d1f.png)\r\n## 7：常用标签\r\n### 7.1 对齐\r\n```html\r\n<p class=\"text-left\">Left aligned text.</p>\r\n<p class=\"text-center\">Center aligned text.</p>\r\n<p class=\"text-right\">Right aligned text.</p>\r\n<p class=\"text-justify\">Justified text.</p>\r\n<p class=\"text-nowrap\">No wrap text.</p>\r\n```\r\n![](https://img-blog.csdnimg.cn/img_convert/ea2a9f592bb57c267883a25351974094.png)\r\n### 7.2 改变大小写\r\n```html\r\n<p class=\"text-lowercase\">Lowercased text.</p>\r\n<p class=\"text-uppercase\">Uppercased text.</p>\r\n<p class=\"text-capitalize\">Capitalized text.</p>\r\n```\r\n### 7.3 常用标签查询网址\r\nhttps://v3.bootcss.com/css/#overview\r\n## 8：表格（table)\r\n* 模板代码\r\n```html\r\n<div class=\"container table-responsive\">\r\n        <table class=\"table table-bordered table-striped table-hover \">\r\n            <tr class=\"success\">\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n            </tr>\r\n            <tr>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n            </tr>\r\n            <tr>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n            </tr>\r\n        </table>\r\n    </div>\r\n```\r\n* 使用方法网址：[表格](https://v3.bootcss.com/css/#tables)\r\n### 8.1 把表格变成响应式表格\r\n* 通过给container所在的div添加table-responsive\r\n## 9：按钮\r\n* [参考网址](https://v3.bootcss.com/css/#buttons)\r\n* 添加类名 btn-block  会让按钮占一整行\r\n* 通过类名active使得按钮处于激活状态（被按的情况）\r\n* 添加类名 disabled  使得按钮处于禁用状态\r\n### 9.1 按钮模板\r\n```html\r\n<div class=\"container\">\r\n        <a class=\"btn btn-default\" href=\"#\" role=\"button\">Link</a>\r\n        <!-- 在导航和导航条上一般使用button -->\r\n        <button class=\"btn btn-default\" type=\"submit\">Button</button>\r\n        <input class=\"btn btn-default\" type=\"button\" value=\"Input\">\r\n        <input class=\"btn btn-default\" type=\"submit\" value=\"Submit\">\r\n        <button type=\"button\" class=\"btn btn-success\">（成功）Success</button>\r\n        <button type=\"button\" class=\"btn btn-primary btn-block btn-lg\">（大按钮）Large button</button>\r\n        <button type=\"button\" class=\"btn btn-success btn-lg\">（大按钮）Large button</button>\r\n\r\n        <!-- 把按钮变为块元素 -->\r\n        <button class=\"btn btn-success btn-block btn-md\">充满容器</button>\r\n        <!-- 使得按钮处于激活状态 -->\r\n        <button class=\"btn btn-success btn-block btn-md active\">充满容器</button>\r\n        <!-- 使按钮处于不可用状态 -->\r\n        <button class=\"btn btn-success btn-block btn-md disabled\">充满容器</button>\r\n    </div>\r\n```\r\n### 9.2 模板效果\r\n![](https://img-blog.csdnimg.cn/img_convert/2795f82d0d6d84c6fcb40443be50059b.png)\r\n## 10：图片\r\n|类名| 作用 |\r\n|--|--|\r\n| img-responsive  | 使图片支持响应式布局 |\r\n| center-block  | 让图片居中 |\r\n| img-rounded  | 使图片表现为圆角矩形 |\r\n| img-circle  | 使图片表现为圆形 |\r\n| img-thumbnail | 让图片表现为带相册框的矩形 |\r\n### 10.1 示例代码\r\n```html\r\n<div class=\"container\">\r\n        <img src=\"images/01-242x200.jpg\" class=\"img-responsive center-block img-rounded\">\r\n        <img src=\"images/01-242x200.jpg\" class=\"img-responsive center-block img-circle\">\r\n        <img src=\"images/01-242x200.jpg\" class=\"img-responsive center-block img-thumbnail\">\r\n    </div>\r\n```\r\n### 10.2 效果展示\r\n![](https://img-blog.csdnimg.cn/img_convert/72f137bf8b70db244f9d6d117422bc5f.png)\r\n## 11：辅助类\r\n### 11.1 关闭符号\r\n```html\r\n<button type=\"button\" class=\"close\" aria-label=\"Close\"><span aria-hidden=\"true\">&times;</span></button>\r\n```\r\n### 11.2 三角符号\r\n```html\r\n<span class=\"caret\"></span>\r\n```\r\n### 11.3 快速浮动\r\n|类名| 作用 |\r\n|--|--|\r\n| pull-left | 快速左浮动 |\r\n| pull-right | 快速右浮动 |\r\n### 11.4 让内容块居中\r\n|类名| 作用 |\r\n|--|--|\r\n| center-block | 内容块居中 |\r\n| text-center | 让div中的文本居中 |\r\n### 11.5 清除浮动\r\n|类名| 作用 |\r\n|--|--|\r\n| clearfix （这个类名是给父元素添加的）| 清除浮动 |\r\n## 12：响应式工具\r\n### 12.1 隐藏或显示内容\r\n* 通过添加如下类名，实现隐藏或显示内容（带星号的不要用）\r\n![](https://img-blog.csdnimg.cn/img_convert/331d8f4293b0f596489539a17b8c647a.png)\r\n## 13：缩略图\r\n### 13.1 仿BootStrap官网缩略图源码\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <link rel=\"stylesheet\" href=\"css/bootstrap.min.css\">\r\n    <style>\r\n        .thumbnail h3 {\r\n            color: #337ab7;\r\n        }\r\n        .thumbnail small {\r\n            font-size: 65%;\r\n            text-align: center;\r\n            line-height: 1;\r\n            font-weight: 400;\r\n        }\r\n        .thumbnail p {\r\n            text-align: center;\r\n        }\r\n    </style>\r\n</head>\r\n\r\n<body>\r\n    <div class=\"container\">\r\n        <div class=\"row\">\r\n            <div class=\"col-md-3\">\r\n                <div class=\"thumbnail\">\r\n                    <img src=\"images/BootStrap网站实例.png\" alt=\"...\">\r\n                    <div class=\"caption\">\r\n                        <h3 class=\"text-center\">优站精选<br>\r\n                            <small> Bootstrap 网站实例</small></h3>\r\n                        <p>Bootstrap 优站精选频道收集了众多基于 Bootstrap 构建、设计精美的、有创意的网站。</p>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <div class=\"col-md-3\">\r\n                <div class=\"thumbnail\">\r\n                    <img src=\"images/webpack.png\" alt=\"...\">\r\n                    <div class=\"caption\">\r\n                        <h3 class=\"text-center\">优站精选<br>\r\n                            <small> Bootstrap 网站实例</small></h3>\r\n                        <p>Bootstrap 优站精选频道收集了众多基于 Bootstrap 构建、设计精美的、有创意的网站。</p>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <div class=\"col-md-3\">\r\n                <div class=\"thumbnail\">\r\n                    <img src=\"images/react.png\" alt=\"...\">\r\n                    <div class=\"caption\">\r\n                        <h3 class=\"text-center\">优站精选<br>\r\n                            <small> Bootstrap 网站实例</small></h3>\r\n                        <p>Bootstrap 优站精选频道收集了众多基于 Bootstrap 构建、设计精美的、有创意的网站。</p>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <div class=\"col-md-3\">\r\n                <div class=\"thumbnail\">\r\n                    <img src=\"images/typescript.png\" alt=\"...\">\r\n                    <div class=\"caption\">\r\n                        <h3 class=\"text-center\">优站精选<br>\r\n                            <small> Bootstrap 网站实例</small></h3>\r\n                        <p>Bootstrap 优站精选频道收集了众多基于 Bootstrap 构建、设计精美的、有创意的网站。</p>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n        <div class=\"row\">\r\n            <div class=\"col-md-3\">\r\n                <div class=\"thumbnail\">\r\n                    <img src=\"images/svelte.png\" alt=\"...\">\r\n                    <div class=\"caption\">\r\n                        <h3 class=\"text-center\">优站精选<br>\r\n                            <small> Bootstrap 网站实例</small></h3>\r\n                        <p>Bootstrap 优站精选频道收集了众多基于 Bootstrap 构建、设计精美的、有创意的网站。</p>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <div class=\"col-md-3\">\r\n                <div class=\"thumbnail\">\r\n                    <img src=\"images/nextjs.png\" alt=\"...\">\r\n                    <div class=\"caption\">\r\n                        <h3 class=\"text-center\">优站精选<br>\r\n                            <small> Bootstrap 网站实例</small></h3>\r\n                        <p>Bootstrap 优站精选频道收集了众多基于 Bootstrap 构建、设计精美的、有创意的网站。</p>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <div class=\"col-md-3\">\r\n                <div class=\"thumbnail\">\r\n                    <img src=\"images/babeljs.png\" alt=\"...\">\r\n                    <div class=\"caption\">\r\n                        <h3 class=\"text-center\">优站精选<br>\r\n                            <small> Bootstrap 网站实例</small></h3>\r\n                        <p>Bootstrap 优站精选频道收集了众多基于 Bootstrap 构建、设计精美的、有创意的网站。</p>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <div class=\"col-md-3\">\r\n                <div class=\"thumbnail\">\r\n                    <img src=\"images/nodejs.png\" alt=\"...\">\r\n                    <div class=\"caption\">\r\n                        <h3 class=\"text-center\">优站精选<br>\r\n                            <small> Bootstrap 网站实例</small></h3>\r\n                        <p>Bootstrap 优站精选频道收集了众多基于 Bootstrap 构建、设计精美的、有创意的网站。</p>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n\r\n</body>\r\n\r\n</html>\r\n```\r\n### 13.2 实现效果\r\n![](https://img-blog.csdnimg.cn/img_convert/ce10f4cce318052a0e4ce11fd7e94c50.png)\r\n> 要想实现点击图片跳转到指定网页，给img标签添加一个a标签即可。\r\n\r\n## 14：仿BootStrap项目推荐页\r\n### 14.1 源代码\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <link rel=\"stylesheet\" href=\"css/bootstrap.min.css\">\r\n    <style>\r\n        .thumbnail h3 {\r\n            color: #337ab7;\r\n        }\r\n        .thumbnail small {\r\n            font-size: 65%;\r\n            text-align: center;\r\n            line-height: 1;\r\n            font-weight: 400;\r\n        }\r\n        .thumbnail p {\r\n            text-align: center;\r\n        }\r\n        .jumbotron {\r\n            position: relative;\r\n            color: #fff;\r\n            text-align: center;\r\n            background: linear-gradient(45deg, #020031, #6d3353);\r\n            text-shadow: 0 1px 3px rgb(0 0 0 / 40%), 0 0 30px rgb(0 0 0 / 8%);\r\n            box-shadow: inset 0 3px 7px rgb(0 0 0 / 20%), inset 0 -3px 7px rgb(0 0 0 / 20%);\r\n        }\r\n\r\n        .jumbotron h1 {\r\n            font-size: 90px;\r\n            font-weight: 700;\r\n            line-height: 1;\r\n        }\r\n\r\n        .jumbotron h2 {\r\n            font-size: 24px;\r\n            font-weight: 200;\r\n            line-height: 1.25;\r\n        }\r\n\r\n        .jumbotron:after {\r\n            content: '';\r\n            top: 0;\r\n            left: 0;\r\n            right: 0;\r\n            bottom: 0;\r\n            display: block;\r\n            background: url(./images/bootstrap-bgc.png) repeat 50%;\r\n            position: absolute;\r\n            opacity: .4;\r\n            background-size: 150px 150px;\r\n        }\r\n\r\n        .masthead {\r\n            padding: 90px 0 110px;\r\n        }\r\n\r\n        .projects-header {\r\n            width: 60%;\r\n            text-align: center;\r\n            font-weight: 200;\r\n            display: block;\r\n            margin: 60px auto 40px;\r\n        }\r\n\r\n        .page-header {\r\n            padding-bottom: 9px;\r\n            /* margin: 40px 0 20px; */\r\n            border-bottom: 1px solid #eee;\r\n        }\r\n\r\n        .page-header h2 {\r\n            display: block;\r\n            font-size: 42px;\r\n            letter-spacing: -1px;\r\n            margin-block-start: 0.83em;\r\n            /* margin-block-end: 0.83em; */\r\n            margin-inline-start: 0px;\r\n            margin-inline-end: 0px;\r\n            /* font-weight: bold; */\r\n        }\r\n\r\n        .page-header p {\r\n            margin: 0 0 10px;\r\n            display: block;\r\n            margin-block-start: 1em;\r\n            margin-block-end: 1em;\r\n            margin-inline-start: 0px;\r\n            margin-inline-end: 0px;\r\n        }\r\n    </style>\r\n</head>\r\n\r\n<body>\r\n    <div class=\"jumbotron masthead\">\r\n        <div class=\"container\">\r\n            <h1>Bootstrap</h1>\r\n            <h2>简洁、直观、强悍的前端开发框架，让web开发更迅速、简单。</h2>\r\n        </div>\r\n    </div>\r\n    <div class=\"container projects\">\r\n        <div class=\"projects-header page-header\">\r\n            <h2>Bootstrap相关优质项目推荐</h2>\r\n            <p>这些项目或者是对Bootstrap进行了有益的补充，或者是基于Bootstrap开发的</p>\r\n        </div>\r\n    </div>\r\n    <div class=\"container\">\r\n        <div class=\"row\">\r\n            <div class=\"col-md-3\">\r\n                <div class=\"thumbnail\">\r\n                    <a href=\"http://google.com\" target=\"_blank\"><img src=\"images/BootStrap网站实例.png\" alt=\"...\" ></a>\r\n                    <div class=\"caption\">\r\n                        <h3 class=\"text-center\">优站精选<br>\r\n                            <small> Bootstrap 网站实例</small></h3>\r\n                        <p>Bootstrap 优站精选频道收集了众多基于 Bootstrap 构建、设计精美的、有创意的网站。</p>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <div class=\"col-md-3\">\r\n                <div class=\"thumbnail\">\r\n                    <img src=\"images/webpack.png\" alt=\"...\">\r\n                    <div class=\"caption\">\r\n                        <h3 class=\"text-center\">优站精选<br>\r\n                            <small> Bootstrap 网站实例</small></h3>\r\n                        <p>Bootstrap 优站精选频道收集了众多基于 Bootstrap 构建、设计精美的、有创意的网站。</p>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <div class=\"col-md-3\">\r\n                <div class=\"thumbnail\">\r\n                    <img src=\"images/react.png\" alt=\"...\">\r\n                    <div class=\"caption\">\r\n                        <h3 class=\"text-center\">优站精选<br>\r\n                            <small> Bootstrap 网站实例</small></h3>\r\n                        <p>Bootstrap 优站精选频道收集了众多基于 Bootstrap 构建、设计精美的、有创意的网站。</p>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <div class=\"col-md-3\">\r\n                <div class=\"thumbnail\">\r\n                    <img src=\"images/typescript.png\" alt=\"...\">\r\n                    <div class=\"caption\">\r\n                        <h3 class=\"text-center\">优站精选<br>\r\n                            <small> Bootstrap 网站实例</small></h3>\r\n                        <p>Bootstrap 优站精选频道收集了众多基于 Bootstrap 构建、设计精美的、有创意的网站。</p>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n        <div class=\"row\">\r\n            <div class=\"col-md-3\">\r\n                <div class=\"thumbnail\">\r\n                    <img src=\"images/svelte.png\" alt=\"...\">\r\n                    <div class=\"caption\">\r\n                        <h3 class=\"text-center\">优站精选<br>\r\n                            <small> Bootstrap 网站实例</small></h3>\r\n                        <p>Bootstrap 优站精选频道收集了众多基于 Bootstrap 构建、设计精美的、有创意的网站。</p>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <div class=\"col-md-3\">\r\n                <div class=\"thumbnail\">\r\n                    <img src=\"images/nextjs.png\" alt=\"...\">\r\n                    <div class=\"caption\">\r\n                        <h3 class=\"text-center\">优站精选<br>\r\n                            <small> Bootstrap 网站实例</small></h3>\r\n                        <p>Bootstrap 优站精选频道收集了众多基于 Bootstrap 构建、设计精美的、有创意的网站。</p>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <div class=\"col-md-3\">\r\n                <div class=\"thumbnail\">\r\n                    <img src=\"images/babeljs.png\" alt=\"...\">\r\n                    <div class=\"caption\">\r\n                        <h3 class=\"text-center\">优站精选<br>\r\n                            <small> Bootstrap 网站实例</small></h3>\r\n                        <p>Bootstrap 优站精选频道收集了众多基于 Bootstrap 构建、设计精美的、有创意的网站。</p>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <div class=\"col-md-3\">\r\n                <div class=\"thumbnail\">\r\n                    <img src=\"images/nodejs.png\" alt=\"...\">\r\n                    <div class=\"caption\">\r\n                        <h3 class=\"text-center\">优站精选<br>\r\n                            <small> Bootstrap 网站实例</small></h3>\r\n                        <p>Bootstrap 优站精选频道收集了众多基于 Bootstrap 构建、设计精美的、有创意的网站。</p>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n</body>\r\n\r\n</html>\r\n```\r\n### 14.2 实现效果\r\n![](https://img-blog.csdnimg.cn/img_convert/80877ad5e19d88e08ce8132c75360174.png)\r\n## 15：表单\r\n### 15.1 基本模板\r\n```html\r\n<div class=\"container\">\r\n    <div class=\"col-md-5\">\r\n        <form>\r\n            <div class=\"form-group\">\r\n                <label for=\"exampleInputEmail1\">Email address</label>\r\n                <input type=\"username\" class=\"form-control\" id=\"exampleInputEmail1\" placeholder=\"Email\">\r\n            </div>\r\n            <div class=\"form-group\">\r\n                <label for=\"exampleInputPassword1\">Password</label>\r\n                <input type=\"password\" class=\"form-control\" id=\"exampleInputPassword1\" placeholder=\"Password\">\r\n            </div>\r\n            <div class=\"form-group\">\r\n                <label for=\"exampleInputFile\">File input</label>\r\n                <input type=\"file\" id=\"exampleInputFile\">\r\n                <p class=\"help-block\">Example block-level help text here.</p>\r\n            </div>\r\n            <div class=\"checkbox\">\r\n                <label>\r\n                    <input type=\"checkbox\"> Check me out\r\n                </label>\r\n            </div>\r\n            <button type=\"submit\" class=\"btn btn-default\">Submit</button>\r\n        </form>\r\n    </div>\r\n</div>\r\n```\r\n### 15.2 基本模板呈现的效果\r\n![](https://img-blog.csdnimg.cn/img_convert/78faf4734d27cc901832f5355126b555.png)\r\n* 其余表单样式参阅[表单](https://v3.bootcss.com/css/#forms)\r\n## 16：字体图标\r\n### 16.1 示例代码\r\n```html\r\n<button type=\"button\" class=\"btn btn-default\" aria-label=\"Left Align\">\r\n    <span class=\"glyphicon glyphicon-align-left\" aria-hidden=\"true\"></span>\r\n</button>\r\n\r\n<button type=\"button\" class=\"btn btn-default btn-lg\">\r\n    <span class=\"glyphicon glyphicon-star\" aria-hidden=\"true\"></span> Star\r\n</button>\r\n```\r\n### 16.2 示例效果\r\n![](https://img-blog.csdnimg.cn/img_convert/72b972a1bcc9b82748f9d18eb5a8e552.png)\r\n* 基础类 glyphicon 是一定要加的。\r\n* 改图标只用从库中选择类名然后添加上即可。\r\n* 通过给span单独加样式，可以在字体图标的基础上继续进行修改\r\n## 17：下拉菜单\r\n* 引入时要先引入jquery和bootstrap.js才可以使用\r\n### 17.1 模板代码\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <link rel=\"stylesheet\" href=\"css/bootstrap.min.css\">\r\n</head>\r\n<body>\r\n    <div class=\"container\">\r\n        <div class=\"dropdown\">\r\n            <button class=\"btn btn-default dropdown-toggle\" type=\"button\" id=\"dropdownMenu1\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"true\">\r\n              Dropdown\r\n              <span class=\"caret\"></span>\r\n            </button>\r\n            <ul class=\"dropdown-menu\" aria-labelledby=\"dropdownMenu1\">\r\n              <li><a href=\"#\">Action</a></li>\r\n              <li><a href=\"#\">Another action</a></li>\r\n              <li><a href=\"#\">Something else here</a></li>\r\n              <li role=\"separator\" class=\"divider\"></li>\r\n              <li><a href=\"#\">Separated link</a></li>\r\n            </ul>\r\n          </div>\r\n    </div>\r\n    <script src=\"js/jquery.min.js\"></script>\r\n    <script src=\"js/bootstrap.min.js\"></script>\r\n</body>\r\n</html>\r\n```\r\n### 17.2 模板效果\r\n![](https://img-blog.csdnimg.cn/img_convert/156a26de4c95f77c5297facb1cd0a1e7.png)\r\n## 18：按钮组\r\n### 18.1 示例代码\r\n```html\r\n<div class=\"btn-group\" role=\"group\" aria-label=\"...\">\r\n  <button type=\"button\" class=\"btn btn-default\">Left</button>\r\n  <button type=\"button\" class=\"btn btn-default\">Middle</button>\r\n  <button type=\"button\" class=\"btn btn-default\">Right</button>\r\n</div>\r\n```\r\n### 18.2 呈现效果\r\n![](https://img-blog.csdnimg.cn/img_convert/705a2385e24a2afadf2fe67bb73889ce.png)\r\n## 19：输入框组\r\n### 19.1 示例代码\r\n```html\r\n<div class=\"input-group\">\r\n        <span class=\"input-group-addon\" id=\"basic-addon1\">@</span>\r\n        <input type=\"text\" class=\"form-control\" placeholder=\"Username\" aria-describedby=\"basic-addon1\">\r\n    </div>\r\n\r\n    <div class=\"input-group\">\r\n        <input type=\"text\" class=\"form-control\" placeholder=\"Recipient's username\" aria-describedby=\"basic-addon2\">\r\n        <span class=\"input-group-addon\" id=\"basic-addon2\">@example.com</span>\r\n    </div>\r\n\r\n    <div class=\"input-group\">\r\n        <span class=\"input-group-addon\">$</span>\r\n        <input type=\"text\" class=\"form-control\" aria-label=\"Amount (to the nearest dollar)\">\r\n        <span class=\"input-group-addon\">.00</span>\r\n    </div>\r\n\r\n    <label for=\"basic-url\">Your vanity URL</label>\r\n    <div class=\"input-group\">\r\n        <span class=\"input-group-addon\" id=\"basic-addon3\">https://example.com/users/</span>\r\n        <input type=\"text\" class=\"form-control\" id=\"basic-url\" aria-describedby=\"basic-addon3\">\r\n    </div>\r\n```\r\n### 19.2 实现效果\r\n![](https://img-blog.csdnimg.cn/img_convert/f45827ce90c913e80eb83c41782a3c95.png)\r\n## 20：导航\r\n### 20.1 基本案例\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <link rel=\"stylesheet\" href=\"css/bootstrap.min.css\">\r\n</head>\r\n\r\n<body>\r\n    <div class=\"container\">\r\n        <ul class=\"nav nav-tabs\">\r\n            <li role=\"presentation\" class=\"active\"><a href=\"#\">Home</a></li>\r\n            <li role=\"presentation\"><a href=\"#\">Profile</a></li>\r\n            <li role=\"presentation\"><a href=\"#\">Messages</a></li>\r\n        </ul>\r\n    </div>\r\n\r\n\r\n\r\n    <script src=\"js/jquery.min.js\"></script>\r\n    <script src=\"js/bootstrap.min.js\"></script>\r\n    <script>\r\n        $('.nav-tabs a').click(function (e) {\r\n            e.preventDefault()\r\n            $(this).tab('show')\r\n        })\r\n    </script>\r\n</body>\r\n\r\n</html>\r\n```\r\n>注意：除了js要引入外，还要单加一个scripts标签，然后里面填上下面的代码,别忘了将类名修改为自己的导航的类名\r\n```html\r\n$('.nav-tabs a').click(function (e) {\r\n            e.preventDefault()\r\n            $(this).tab('show')\r\n        })\r\n```\r\n### 20.2 案例实现效果\r\n![](https://img-blog.csdnimg.cn/img_convert/a5e030a172c0085b81f5b86a08bbfce9.png)\r\n## 21：导航条\r\n### 21.1 示例代码\r\n\r\n### 21.2 实现效果\r\n![](https://img-blog.csdnimg.cn/img_convert/92c3c00344e282358dca8679fe57bbd4.png)\r\n## 22：分页与翻页\r\n### 22.1 模板代码\r\n```html\r\n<div class=\"container\">\r\n        <nav aria-label=\"Page navigation\">\r\n            <ul class=\"pagination pagination-lg\">\r\n                <li>\r\n                    <a href=\"#\" aria-label=\"Previous\">\r\n                        <span aria-hidden=\"true\">&laquo;</span>\r\n                    </a>\r\n                </li>\r\n                <li><a href=\"#\">1</a></li>\r\n                <li class=\"active\"><a href=\"#\">2</a></li>\r\n                <li><a href=\"#\">3</a></li>\r\n                <li class=\"disabled\"><a href=\"#\">4</a></li>\r\n                <li><a href=\"#\">5</a></li>\r\n                <li>\r\n                    <a href=\"#\" aria-label=\"Next\">\r\n                        <span aria-hidden=\"true\">&raquo;</span>\r\n                    </a>\r\n                </li>\r\n            </ul>\r\n        </nav>\r\n    </div>\r\n```\r\n### 22.2 实现效果\r\n![](https://img-blog.csdnimg.cn/img_convert/fb3b7adbc167cde86edb29efc58aa991.png)\r\n## 23：标签\r\n### 23.1 模板代码\r\n```html\r\n<h1>Example heading <span class=\"label label-default\">New</span></h1>\r\n<h1>Example heading <span class=\"label label-success\">New</span></h1>\r\n```\r\n### 23.2 模板效果\r\n![](https://img-blog.csdnimg.cn/img_convert/10c875cca39acb6bf9dc4c5365db3aae.png)\r\n## 24：徽章\r\n### 24.1 模板代码\r\n```html\r\n<div class=\"container\">\r\n    <a href=\"#\">Inbox <span class=\"badge\">42</span></a>\r\n\r\n    <button class=\"btn btn-primary\" type=\"button\">\r\n        Messages <span class=\"badge\">4</span>\r\n    </button>\r\n    <ul class=\"nav nav-pills\" role=\"tablist\">\r\n        <li role=\"presentation\" class=\"active\"><a href=\"#\">Home <span class=\"badge\">42</span></a></li>\r\n        <li role=\"presentation\"><a href=\"#\">Profile</a></li>\r\n        <li role=\"presentation\"><a href=\"#\">Messages <span class=\"badge\">3</span></a></li>\r\n      </ul>\r\n</div>\r\n```\r\n### 24.2 模板效果\r\n![](https://img-blog.csdnimg.cn/img_convert/c1dd45b6f5822fc5f79c8ee0750c1920.png)\r\n## 25：巨幕\r\n### 25.1 模板代码\r\n```html\r\n<div class=\"container\">\r\n    <div class=\"jumbotron\">\r\n        <h1>Hello, world!</h1>\r\n        <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Dicta, sapiente amet tempora veritatis voluptas\r\n            quis temporibus repudiandae ex nam similique.</p>\r\n        <p><a class=\"btn btn-primary btn-lg\" href=\"#\" role=\"button\">Learn more</a></p>\r\n    </div>\r\n</div>\r\n```\r\n### 25.2 模板效果\r\n![](https://img-blog.csdnimg.cn/img_convert/8f570f66fd30f59ff17d4ad4256b96cc.png)\r\n## 26：页头\r\n### 26.1 模板代码\r\n```html\r\n<div class=\"page-header\">\r\n    <h1>Example page header <small>Subtext for header</small></h1>\r\n</div>\r\n```\r\n### 26.2 模板效果\r\n![](https://img-blog.csdnimg.cn/img_convert/6cb81dbb75602131d827c573645ae01f.png)\r\n## 27：警告框\r\n### 27.1 模板代码\r\n```html\r\n<div class=\"container\">\r\n    <div class=\"alert alert-success\" role=\"alert\">Lorem ipsum dolor sit amet.</div>\r\n    <div class=\"alert alert-info\" role=\"alert\">Lorem ipsum dolor sit amet.</div>\r\n    <div class=\"alert alert-warning\" role=\"alert\">Lorem ipsum dolor sit amet.</div>\r\n    <div class=\"alert alert-danger\" role=\"alert\">Lorem ipsum dolor sit amet.</div>\r\n    <div class=\"alert alert-warning alert-dismissible\" role=\"alert\">\r\n        <button type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-label=\"Close\"><span\r\n                aria-hidden=\"true\">&times;</span></button>\r\n        <strong>Warning!</strong> Better check yourself, you're not looking too good.\r\n    </div>\r\n    <div class=\"alert alert-info\" role=\"alert\">\r\n        <a href=\"http://www.baidu.com\" class=\"alert-link\">http://www.baidu.com</a>\r\n    </div>\r\n</div>\r\n<script src=\"js/jquery.min.js\"></script>\r\n<script src=\"js/bootstrap.min.js\"></script>\r\n```\r\n### 27.2 模板效果\r\n![](https://img-blog.csdnimg.cn/img_convert/4d485e6263f60ee7b065239a0c043e55.png)\r\n## 28：进度条\r\n### 28.1 模板代码\r\n```html\r\n<div class=\"container\">\r\n    <div class=\"progress\">\r\n        <div class=\"progress-bar\" role=\"progressbar\" aria-valuenow=\"60\" aria-valuemin=\"0\" aria-valuemax=\"100\"\r\n            style=\"width: 60%;\">\r\n            <span class=\"sr-only\">60% Complete</span>\r\n        </div>\r\n    </div>\r\n    <div class=\"progress\">\r\n        <div class=\"progress-bar\" role=\"progressbar\" aria-valuenow=\"60\" aria-valuemin=\"0\" aria-valuemax=\"100\"\r\n            style=\"width: 60%;\">\r\n            60%\r\n        </div>\r\n    </div>\r\n</div>\r\n```\r\n### 28.2 模板效果\r\n![](https://img-blog.csdnimg.cn/img_convert/5f588b12a352a0d2eefd18fda65f4c5c.png)\r\n## 29：媒体对象\r\n### 29.1 模板代码\r\n```html\r\n<div class=\"container\">\r\n    <ul class=\"media-list\">\r\n        <li class=\"media\">\r\n          <div class=\"media-left\">\r\n            <a href=\"#\">\r\n              <img class=\"media-object\" src=\"images/02_64x64.jpg\" alt=\"...\">\r\n            </a>\r\n          </div>\r\n          <div class=\"media-body\">\r\n            <h4 class=\"media-heading\">Media heading</h4>\r\n            Lorem, ipsum dolor sit amet consectetur adipisicing elit. Eligendi, itaque!\r\n          </div>\r\n        </li>\r\n        <li class=\"media\">\r\n            <div class=\"media-left\">\r\n              <a href=\"#\">\r\n                <img class=\"media-object\" src=\"images/02_64x64.jpg\" alt=\"...\">\r\n              </a>\r\n            </div>\r\n            <div class=\"media-body\">\r\n              <h4 class=\"media-heading\">Media heading</h4>\r\n              Lorem, ipsum dolor sit amet consectetur adipisicing elit. Eligendi, itaque!\r\n            </div>\r\n          </li>\r\n          <li class=\"media\">\r\n            <div class=\"media-left\">\r\n              <a href=\"#\">\r\n                <img class=\"media-object\" src=\"images/02_64x64.jpg\" alt=\"...\">\r\n              </a>\r\n            </div>\r\n            <div class=\"media-body\">\r\n              <h4 class=\"media-heading\">Media heading</h4>\r\n              Lorem, ipsum dolor sit amet consectetur adipisicing elit. Eligendi, itaque!\r\n            </div>\r\n          </li>\r\n          <li class=\"media\">\r\n            <div class=\"media-left\">\r\n              <a href=\"#\">\r\n                <img class=\"media-object\" src=\"images/02_64x64.jpg\" alt=\"...\">\r\n              </a>\r\n            </div>\r\n            <div class=\"media-body\">\r\n              <h4 class=\"media-heading\">Media heading</h4>\r\n              Lorem, ipsum dolor sit amet consectetur adipisicing elit. Eligendi, itaque!\r\n            </div>\r\n          </li>\r\n      </ul>\r\n</div>\r\n<div class=\"container\">\r\n    <div class=\"media\">\r\n        <div class=\"media-left\">\r\n          <a href=\"#\">\r\n            <img class=\"media-object\" src=\"images/02_64x64.jpg\" alt=\"...\">\r\n          </a>\r\n        </div>\r\n        <div class=\"media-body\">\r\n          <h4 class=\"media-heading\">Media heading</h4>\r\n          ...\r\n        </div>\r\n      </div>\r\n</div>\r\n```\r\n### 29.2 模板效果\r\n![](https://img-blog.csdnimg.cn/img_convert/72335b6b79a626c18f3c24d7d4de02cc.png)\r\n## 30：列表组\r\n### 30.1 模板代码\r\n```html\r\n<div class=\"container\">\r\n    <div class=\"row\">\r\n        <div class=\"col-md-4\">\r\n            <ul class=\"list-group\">\r\n                <li class=\"list-group-item\">Cras justo odio</li>\r\n                <li class=\"list-group-item\">Dapibus ac facilisis in</li>\r\n                <li class=\"list-group-item\">Morbi leo risus</li>\r\n                <li class=\"list-group-item\">Porta ac consectetur ac</li>\r\n                <li class=\"list-group-item\">Vestibulum at eros</li>\r\n            </ul>\r\n        </div>\r\n        <div class=\"col-md-4\">\r\n            <ul class=\"list-group\">\r\n                <li class=\"list-group-item\">Cras justo odio</li>\r\n                <li class=\"list-group-item\">Dapibus ac facilisis in</li>\r\n                <li class=\"list-group-item\">Morbi leo risus</li>\r\n                <li class=\"list-group-item\">Porta ac consectetur ac</li>\r\n                <li class=\"list-group-item\">Vestibulum at eros</li>\r\n            </ul>\r\n        </div>\r\n        <div class=\"col-md-4\">\r\n            <ul class=\"list-group\">\r\n                <li class=\"list-group-item\">Cras justo odio</li>\r\n                <li class=\"list-group-item\">Dapibus ac facilisis in</li>\r\n                <li class=\"list-group-item\">Morbi leo risus</li>\r\n                <li class=\"list-group-item\">Porta ac consectetur ac</li>\r\n                <li class=\"list-group-item\">Vestibulum at eros</li>\r\n            </ul>\r\n        </div>\r\n    </div>\r\n</div>\r\n```\r\n### 30.2 模板效果\r\n![](https://img-blog.csdnimg.cn/img_convert/b3f26307fb4e2b73453d7b047d19b6de.png)\r\n## 31：面板\r\n### 31.1 模板代码\r\n```html\r\n<div class=\"container\">\r\n    <div class=\"panel panel-default\">\r\n        <div class=\"panel-body\">\r\n          Lorem ipsum dolor sit amet consectetur adipisicing elit. Itaque, voluptatum.\r\n        </div>\r\n      </div>\r\n      <div class=\"panel panel-default\">\r\n        <div class=\"panel-heading\">Panel heading without title</div>\r\n        <div class=\"panel-body\">\r\n          Lorem ipsum dolor sit amet consectetur adipisicing elit. Natus, eligendi.\r\n        </div>\r\n      </div>\r\n      \r\n      <div class=\"panel panel-success\">\r\n        <div class=\"panel-heading\">\r\n          <h3 class=\"panel-title\">Panel title</h3>\r\n        </div>\r\n        <div class=\"panel-body\">\r\n            Lorem ipsum dolor sit amet, consectetur adipisicing elit. Iusto facere, eveniet nulla voluptatem qui debitis libero officia error dolor labore quod illum, perferendis quibusdam voluptatum accusamus beatae cumque. Deserunt, laborum! Eum, inventore laudantium soluta voluptatibus, voluptas mollitia facere sint harum ad iste, ex eius ea atque porro iusto rem nostrum.\r\n        </div>\r\n      </div>\r\n      \r\n</div>\r\n<div class=\"container\">\r\n    <div class=\"panel panel-default\">\r\n        <!-- Default panel contents -->\r\n        <div class=\"panel-heading\">Panel heading</div>\r\n        <div class=\"panel-body\">\r\n          <p>Lorem ipsum dolor sit amet consectetur, adipisicing elit. Ullam quas et quaerat dolorem doloremque maxime sequi sunt optio nam quisquam!</p>\r\n        </div>\r\n      \r\n        <!-- Table -->\r\n        <table class=\"table table-bordered table-striped table-hover \">\r\n            <tr class=\"success\">\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n            </tr>\r\n            <tr>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n            </tr>\r\n            <tr>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n                <td>表格内容</td>\r\n            </tr>\r\n        </table>\r\n      </div>\r\n</div>\r\n```\r\n### 31.2 模板效果\r\n![](https://img-blog.csdnimg.cn/img_convert/28a17d20333aec5cbad21936b013aefe.png)\r\n## 32：轮播图\r\n### 32.1 模板代码\r\n```html\r\n<div class=\"container\" style=\"width: 50%;\">\r\n    <div id=\"carousel-example-generic\" class=\"carousel slide\" data-ride=\"carousel\">\r\n        <!-- Indicators -->\r\n        <ol class=\"carousel-indicators\">\r\n            <li data-target=\"#carousel-example-generic\" data-slide-to=\"0\" class=\"active\"></li>\r\n            <li data-target=\"#carousel-example-generic\" data-slide-to=\"1\"></li>\r\n            <li data-target=\"#carousel-example-generic\" data-slide-to=\"2\"></li>\r\n        </ol>\r\n\r\n        <!-- Wrapper for slides -->\r\n        <div class=\"carousel-inner\" role=\"listbox\">\r\n            <div class=\"item active\">\r\n                <img src=\"images/轮播图.jpg\" style=\"width: 100%; height: 100%;\">\r\n                <div class=\"carousel-caption\">\r\n                    <h3>第三张轮播图</h3>\r\n                    <p>这里是对轮播图的介绍</p>\r\n                </div>\r\n            </div>\r\n            <div class=\"item\">\r\n                <img src=\"images/轮播图.jpg\" style=\"width: 100%; height: 100%;\">\r\n                <div class=\"carousel-caption\">\r\n                    <h3>第三张轮播图</h3>\r\n                    <p>这里是对轮播图的介绍</p>\r\n                </div>\r\n            </div>\r\n            <div class=\"item\">\r\n                <img src=\"images/轮播图.jpg\" style=\"width: 100%; height: 100%;\">\r\n                <div class=\"carousel-caption\">\r\n                    <h3>第三张轮播图</h3>\r\n                    <p>这里是对轮播图的介绍</p>\r\n                </div>\r\n            </div>\r\n        </div>\r\n\r\n        <!-- Controls -->\r\n        <a class=\"left carousel-control\" href=\"#carousel-example-generic\" role=\"button\" data-slide=\"prev\">\r\n            <span class=\"glyphicon glyphicon-chevron-left\" aria-hidden=\"true\"></span>\r\n            <span class=\"sr-only\">Previous</span>\r\n        </a>\r\n        <a class=\"right carousel-control\" href=\"#carousel-example-generic\" role=\"button\" data-slide=\"next\">\r\n            <span class=\"glyphicon glyphicon-chevron-right\" aria-hidden=\"true\"></span>\r\n            <span class=\"sr-only\">Next</span>\r\n        </a>\r\n    </div>\r\n</div>\r\n<script src=\"js/jquery.min.js\"></script>\r\n<script src=\"js/bootstrap.min.js\"></script>\r\n```\r\n### 32.2 模板效果\r\n![](https://img-blog.csdnimg.cn/img_convert/e138c87c16837809bcd171300cd55f65.png)"
    },
    {
      "id": "/考查候选人正则基本功的面试题之《解析URL请求参数》",
      "metadata": {
        "permalink": "/blog/考查候选人正则基本功的面试题之《解析URL请求参数》",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/考查候选人正则基本功的面试题之《解析URL请求参数》.md",
        "source": "@site/blog\\考查候选人正则基本功的面试题之《解析URL请求参数》.md",
        "title": "考查候选人正则基本功的面试题之《解析URL请求参数》",
        "description": "需求描述",
        "date": "2021-01-12T00:00:00.000Z",
        "formattedDate": "2021年1月12日",
        "tags": [
          {
            "label": "面试题",
            "permalink": "/blog/tags/面试题"
          }
        ],
        "readingTime": 1.8,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Justin"
          }
        ],
        "frontMatter": {
          "title": "考查候选人正则基本功的面试题之《解析URL请求参数》",
          "date": "2021-01-12T00:00:00.000Z",
          "author": "Justin",
          "top": false,
          "cover": false,
          "categories": "面试题",
          "tags": [
            "面试题"
          ]
        },
        "prevItem": {
          "title": "一篇文章学会使用BootStrap",
          "permalink": "/blog/一篇文章学会使用BootStrap"
        },
        "nextItem": {
          "title": "西电中特复习重点",
          "permalink": "/blog/西电中特复习重点"
        }
      },
      "content": "## 需求描述\r\n>有一个字符串请求URL，我们需要将该字符串形式的URL中的请求参数转换为对象，相同key的value以数组形式进行呈现，没有value属性的参数，将value置为true。\r\n\r\n## 目标字符串\r\n`http://www.getui.com?user=superman&id=345&id=678&user=superman2`\r\n\r\n## 实现函数\r\n```js\r\nfunction parseParam(url) {\r\n    // 1. 将问号后面的字符提取出来\r\n    const paramStr = /.+\\?(.+)$/.exec(url)[1];\r\n    // 2. 使用&分割字符串\r\n    const paramArr = paramStr.split('&');\r\n    // 3. 创建要返回的对象\r\n    const paramObj = {};\r\n    // 4. 将每一个param存到对象中\r\n    for (let v of paramArr) {\r\n        // 5. 分为有等号还是没有等号两种情况\r\n        if (/=/.test(v)) {\r\n            // 有等号\r\n            // 将等号分割为key和value\r\n            let [key,value] = v.split('=');\r\n            // 对value进行解码\r\n            value = decodeURIComponent(value);\r\n            // 如果是数字字符串就将其转换为浮点数\r\n            value = /^\\d+$/.test(value) ? parseFloat(value) : value;\r\n            // 判断要返回的对象中是否已经有了相同的key，有则添加，没有则赋值\r\n            if (paramObj.hasOwnProperty(key)) {\r\n                paramObj[key] = [].concat(paramObj[key],value);\r\n            } else {\r\n                paramObj[key] = value;\r\n            }\r\n        } else {\r\n            // 没有等号\r\n            // 直接将这个param键对应的值置为true\r\n            paramObj[v] = true;\r\n        }\r\n    }\r\n    return paramObj\r\n}\r\n\r\nconsole.log(parseParam('http://www.getui.com?user=superman&id=345&id=678&user=superman2'));\r\n\r\n```\r\n\r\n## codeSandBox在线实现\r\n* [https://codesandbox.io/s/shou-xie-jie-xi-urlqing-qiu-can-shu-hmjv3?file=/index.html](https://codesandbox.io/s/shou-xie-jie-xi-urlqing-qiu-can-shu-hmjv3?file=/index.html)\r\n\r\n## 题目反思\r\n* 这道题需要我们准确掌握如何将问号后面字符串提取出来的正则表达式。\r\n* 需要熟练掌握数组基本API的使用。\r\n* 需要掌握concat的两个参数的用法。"
    },
    {
      "id": "/西电中特复习重点",
      "metadata": {
        "permalink": "/blog/西电中特复习重点",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/西电中特复习重点.md",
        "source": "@site/blog\\西电中特复习重点.md",
        "title": "西电中特复习重点",
        "description": "考题1",
        "date": "2021-01-03T00:00:00.000Z",
        "formattedDate": "2021年1月3日",
        "tags": [
          {
            "label": "读研生活",
            "permalink": "/blog/tags/读研生活"
          }
        ],
        "readingTime": 27.315,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "西电中特复习重点",
          "date": "2021-01-3",
          "categories": "读研生活",
          "tags": [
            "读研生活"
          ]
        },
        "prevItem": {
          "title": "考查候选人正则基本功的面试题之《解析URL请求参数》",
          "permalink": "/blog/考查候选人正则基本功的面试题之《解析URL请求参数》"
        },
        "nextItem": {
          "title": "西电密码学复习重点",
          "permalink": "/blog/西电密码学复习重点"
        }
      },
      "content": "## 考题1\r\n>中国特色社会主义是改革开放以来，党的全部理论和实践主题。\r\n>（1）：如何解读中国特色社会主义概念。（两个逻辑的统一和四位一体的统一）\r\n>（2）：中国特色社会主义进入了新时代，最主要的依据是社会的主要矛盾发生了变化，新时代的内涵和意义。\r\n\r\n（1）：\r\nPPT上的：\r\n* 中国特色社会主义概念的发展演变（方法论）\r\n![](https://img-blog.csdnimg.cn/img_convert/441fd4c94d11f7e2478e07e2ef65e21f.png)\r\n* 中国特色社会主义的基本内涵。（世界观和方法论）\r\n![](https://img-blog.csdnimg.cn/img_convert/040ca5f69f3b382381c6c8154d27b86e.png)\r\n* 中国特色社会主义的本质和特征。\r\n中国特色社会主义最本质的特征是中国共产党领导。\r\n![](https://img-blog.csdnimg.cn/img_convert/6bcfee785eac2a6293f70e9662cf2f43.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/a1f4a0869723f2c5e5cef3e9cf77609b.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/a700368843facb52076c98b7e4844592.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/91883fb606be2d61f5a9c78d9b90f7ed.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/e3ab30a3a72f1ffe37e7b8c5a6ca75fe.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/20c5875658237244428e3a392eb6f01e.png)\r\n## 参考答案\r\n（1）：中国特色社会主义，是科学社会主义理论逻辑和中国社会发展历史逻辑的辩证统一，是当代中国大踏步赶上时代、引领时代发展的康庄大道，是中国共产党和中国人民团结的旗帜、奋进的旗帜、胜利的旗帜，必须倍加珍惜、长期坚持、永不动摇。\r\n（2）：\r\n![](https://img-blog.csdnimg.cn/img_convert/0df1e576f16bd4a0fffd9b13c796027e.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/6e46047f8541522d127458086060f2d1.png)\r\n## 考题2\r\n>（1）：习近平新时代中国特色社会主义思想是如何产生的？习近平新时代中国特色社会主\t\t\t\t\t      义思想形成的历史条件。\r\n>（2）：习近平新时代中国特色社会主义思想的内容。\r\n>（3）：习近平新时代中国特色社会主义思想地位。\r\n\r\n## 参考答案：\r\n（1）：习近平新时代中国特色社会主义思想是在中国特色社会主义进入新时代、科学社会主义迈向新阶段、当今世界经历新变局、我们党面临执政新考验的历史条件下形成和发展起来的，是对马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观的继承和发展，是对中华优秀传统文化和革命文化、社会主义先进文化的传承和发展。\r\n\r\n（2）：习近平新时代中国特色社会主义思想的核心内容是“八个明确”和“十四个坚持”。\r\n\r\n　　“八个明确”，就是明确坚持和发展中国特色社会主义，总任务是实现社会主义现代化和中华民族伟大复兴，在全面建成小康社会的基础上，分两步走在本世纪中叶建成富强民主文明和谐美丽的社会主义现代化强国；明确新时代我国社会主要矛盾是人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾，必须坚持以人民为中心的发展思想，不断促进人的全面发展、全体人民共同富裕；明确中国特色社会主义事业总体布局是“五位一体”、战略布局是“四个全面”，强调坚定道路自信、理论自信、制度自信、文化自信；明确全面深化改革总目标是完善和发展中国特色社会主义制度、推进国家治理体系和治理能力现代化；明确全面推进依法治国总目标是建设中国特色社会主义法治体系、建设社会主义法治国家；明确党在新时代的强军目标是建设一支听党指挥、能打胜仗、作风优良的人民军队，把人民军队建设成为世界一流军队；明确中国特色大国外交要推动构建新型国际关系，推动构建人类命运共同体；明确中国特色社会主义最本质的特征是中国共产党领导，中国特色社会主义制度的最大优势是中国共产党领导，党是最高政治领导力量，提出新时代党的建设总要求，突出政治建设在党的建设中的重要地位。\r\n\r\n　　“十四个坚持”，就是坚持党对一切工作的领导，坚持以人民为中心，坚持全面深化改革，坚持新发展理念，坚持人民当家作主，坚持全面依法治国，坚持社会主义核心价值体系，坚持在发展中保障和改善民生，坚持人与自然和谐共生，坚持总体国家安全观，坚持党对人民军队的绝对领导，坚持“一国两制”和推进祖国统一，坚持推动构建人类命运共同体，坚持全面从严治党。\r\n\r\n　　“八个明确”、“十四个坚持”有机融合、有机统一，凝结着我们党坚持和发展中国特色社会主义的宝贵经验，反映了以习近平同志为核心的党中央对中国特色社会主义规律性认识的深化、拓展、升华，体现了理论与实际相结合、认识论和方法论相统一的鲜明特色。\r\n\r\n　　习近平新时代中国特色社会主义思想，体系严整、逻辑严密、内涵丰富、博大精深，闪耀着马克思主义真理光辉。这一思想贯通马克思主义哲学、政治经济学、科学社会主义，贯通历史、现实和未来，贯通改革发展稳定、内政外交国防、治党治国治军等各领域，既坚持了老祖宗，又讲了很多新话，使我们党对共产党执政规律、社会主义建设规律、人类社会发展规律的认识达到了新高度，为发展马克思主义作出了原创性贡献。\r\n（3）：习近平新时代中国特色社会主义思想，从理论和实践结合上系统回答了新时代坚持和发展什么样的中国特色社会主义、怎样坚持和发展中国特色社会主义这一重大时代课题，是马克思主义中国化最新成果，是当代中国马克思主义、21世纪马克思主义，是党和国家必须长期坚持的指导思想。深入学习贯彻习近平新时代中国特色社会主义思想，必须深刻认识领会这一思想的时代意义、理论意义、实践意义、世界意义。\r\n## 考题3\r\n>（1）：中国共产党的历史使命。（强调四个伟大）\r\n>（2）：新时代中国特色社会主义的总任务及战略安排。（社会主义现代化，两步走2035年，2050年）\r\n\r\n## 参考答案\r\n（1）：\r\n实现中华民族伟大复兴的中国梦是新时代中国共产党的历史使命。党的十九大报告鲜明提出，进入新时代，实现伟大梦想，必须进行伟大斗争、建设伟大工程、推进伟大事业。这就明确回答了在中国特色社会主义新时代，我们党和国家全部工作将围绕什么样的主线往前推进、向前发展。“四个伟大”紧密联系、相互贯通、相互作用，协调统一于新时代党和国家全部事业发展的伟大实践。\r\n（2）：\r\n总任务是实现社会主义现代化和中华民族伟大复兴，在全面建成小康社会的基础上，分两步走在2035年到本世纪中叶建成富强民主文明和谐美丽的社会主义现代化强国。\r\n战略安排：第一个阶段，从2020年到2035年，在全面建成小康社会的基础上，再奋斗十五年，基本实现社会主义现代化。第二个阶段，从2035年到本世纪中叶，在基本实现现代化的基础上，再奋斗十五年，把我国建成富强民主文明和谐美丽的社会主义现代化强国。这是新时代的战略安排，脚踏实地、登高望远，勾勒了奋进的目标，设定了前行的节奏，意义重大而深远。\r\n## 考题4\r\n>（1）：理解高质量发展新阶段，新发展理念。\r\n>（2）：19届五中全会强调的国内循环为主体，国内国外循环相互促进，\r\n>（3）：五中全会的核心精神就是三新，新阶段，新理念，新格局。\r\n>（2）：现代化经济体系的六个实现路径：在教材的哪一部分，以及准确表述。（看和青年学生相关的那个路径）\r\n## 参考答案\r\n（1）：\r\n* 推动高质量发展是保持经济持续健康发展的必然要求。粗放型经济发展方式不可持续，国内条件不支持，国际条件也不支持。粗放型会使得资源环境消耗成倍增加。\r\n* 适应我国社会主要矛盾新转化的必然选择。只有提升发展的质量和效益，才能破解发展中不平衡不协调的矛盾，更好的满足人民日益增长的美好生活的需要。\r\n* 为决胜全面小康、全面建设社会主义现代化强国提供了重要物质基础。\r\n* 推动高质量发展是遵循经济规律发展的必然要求。\r\n新发展理念：\r\n* 新发展理念是针对当前我国发展面临的突出问题和挑战提出的战略指引。\r\n* 新发展理念不是凭空得来的，是我们在深刻总结国内外发展经验教训的基础上形成的，也是在深刻分析国内外发展大势的基础上形成的，集中反映了我们党对经济社会发展规律认识的深化，也是针对我国发展中的突出矛盾和问题提出来的。\r\n（2）：\r\n![](https://img-blog.csdnimg.cn/img_convert/0467758e71342b33371a87b47532af1b.png)\r\n（3）：\r\n“十四五”规划建议的核心要义体现在三个“新”上，就是新发展阶段、新发展理念、新发展格局，三者紧密联系在一起，具有内在逻辑。\r\n![](https://img-blog.csdnimg.cn/img_convert/b3eb2ec11ec665095e3afc69ed33ec3b.png)\r\n（4）：\r\n\r\n第一，更高效益的经济发展速度。\r\n第二，更高质量的经济增长方式。\r\n第三，更平衡的区域和城乡发展格局。\r\n第四，更完善的市场经济体制。\r\n第五，更高水平的开放型经济。\r\n第六，更完善的现代化产业体系、空间布局结构和协调程度。\r\n## 考题5\r\n>（1）：中国特色社会主义政治发展道路到底是个什么道路？如何来理解这个道路？回到三个统一那个概念上，回到中国制度的显著优势上。中国特色社会主义政治发展道路的生成逻辑。\r\n>（2）：中国特色社会主义政治发展道路的价值和意义。（价值和意义一定要放在新时代中国的制度优势，给了世界其他发展中国家，可借鉴的发展模式）\r\n## 参考答案\r\n（1）：\r\n中国特色社会主义政治发展道路是5000多年中华民族先进文化的延续使然,实现了中国的发展道路、理论体系和制度安排的内在统一。\r\n中国特色社会主义政治发展道路，是近代以来中国人民长期奋斗历史逻辑、理论逻辑、实践逻辑的必然结果，是坚持党的本质属性、践行党的根本宗旨的必然要求。\r\n历史逻辑意味着，一个国家的政治发展道路要与本国历史文化传统相衔接，不能不顾本国历史文化传统，生搬硬套他人的制度模式；\r\n理论逻辑意味着，一个国家的政治发展道路总是在一定的理论指导下进行的。中国特色社会主义政治发展道路，是以马克思主义为指导、具有社会主义性质、适合中国国情的一整套政治制度和政治模式。\r\n实践是检验真理的唯一标准。中国特色社会主义政治发展道路，是中国共产党团结带领中国人民、立足中国政治实际进行长期不懈奋斗的实践创造，是人类民主政治发展史上具有标志性意义的中国智慧和中国方案。\r\n（2）：\r\n新时代中国特色社会主义具有坚强的政治优势\r\n    新时代中国特色社会主义的政治优势就是不断加强和改进中国共产党的领导。中国特色社会主义最本质的特征是中国共产党的领导，中国特色社会主义制度的最大优势是中国共产党的领导。\r\n    新时代中国特色社会主义具有卓越的制度优势\r\n    新时代中国特色社会主义的制度优势就是社会主义制度在我国的确立及取得的巨大成就。中国人民走上社会主义的建设道路并不是历史的偶然，社会主义制度在中国的确立有着坚实的阶级基础和社会历史根源。\r\n    新时代中国特色社会主义具有科学的理论优势\r\n    新时代中国特色社会主义的理论优势就是对马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观的继承和发展。十月革命一声炮响，给我们送来了马克思列宁主义。\r\n    给了世界其他发展中国家，可借鉴的发展模式。\r\n![](https://img-blog.csdnimg.cn/img_convert/8df8284301266ecbc70b4529616a058e.png)\r\n ## 考题6\r\n >（1）：文化自信的命题内涵。（内涵的三个概念）核心价值观的精神实质。（核心价值观到底是干什么的？）\r\n >（2）：如何理解文化自信是更基本更深沉更持久的力量？\r\n \r\n 答：\r\n （1）：文化自信的科学内涵与精神实质，即文化自信指的是由中华优秀传统文化、革命文化和社会主义先进文化构成的中国特色社会主义文化的自信，实质是以马克思主义为指导的中国特色社会主义先进文化的自信。\r\n （2）：\r\n ![](https://img-blog.csdnimg.cn/img_convert/819c9da4a3922dfa05148aa9e1ec4923.png)\r\n\r\n## 考题7\r\n>（1）：民生和民生领域在今天指的是哪些范围？\r\n>（2）：社会治理体制的基本表述。（社会治理体制朝哪个方向走？社会治理体制是党委领导，政府负责，公民参与，法治作为保障）\r\n>（3）：生态文明的价值遵循。（生态文明建设的价值指向，里面强调的两个概念，以人民为中心，坚持人与自然的和谐共生。）\r\n>（4）：生态文明的制度保障。（今天强调的五大制度，有产权，国土空间开发保护，资源总量管理和全面节约，资源有偿使用和补偿使用，生态文明 评价考核和责任追究。）\r\n\r\n答：\r\n（1）：优先发展教育事业，提高就业质量和人民收入水平，加强社会保障体系建设，坚决打赢脱贫攻坚战，实施健康中国战略。\r\n（2）：坚持完善党委领导、政府负责、社会协同、公众参与、法治保障的社会治理体制、提高社会治理社会化、法治化、智能化、专业化水平、推进社会治理精细化，打造共建共治共享的治理格局。\r\n（3）：“坚持人与自然和谐共生，以人民为中心”是新时代中国特色社会主义生态文明的价值遵循。\r\n（4）：制度保障：到2020年，构建起由自然资源资产产权制度、国土空间开发保护制度、空间规划体系、资源总量管理和全面节约制度、资源有偿使用和生态补偿制度、环境治理体系、环境治理和生态保护市场体系、生态文明绩效评价考核和责任追究制度等八项制度构成的产权清晰、多元参与、激励约束并重、系统完整的生态文明制度体系，推进生态文明领域国家治理体系和治理能力现代化，努力走向社会主义生态文明新时代。\r\n\r\n## 考题8\r\n>（1）：外部环境变化。（看到时代主题，从这个新变化中间的新变化凸显出的问题，中国与世界关系的新变化，中国与世界关系新的历史性变化，准确的表述包括字不能写错）\r\n>（2）：国际战略。（顶层设计，基本原则，战略布局，就是人类命运共同体与构建新型大国关系。）\r\n>（3）：如何理解党对一切工作的领导？（党的全面领导的内涵，政治思想，组织一定要弄清楚，全面领导的核心和方法。从严治党，今天政治建设是首位，理解权威和核心）\r\n>（4）：为什么在今天要强调两个维护。\r\n>（5）：党的领导是中国特色社会主义最本质的特征。如何理解？\r\n\r\n答：\r\n（1）：外部环境的变化：当前，人类社会正处在一个大发展大变革大调整时代，世界多极化、经济全球化、社会信息化、文化多样化深入发展，人类已经成为你中有我，我中有你的命运共同体。同时，我们也处在一个挑战频发的世界，地区热点持续动荡，恐怖主义蔓延肆虐，和平赤字，发展赤字、治理赤字是摆在全人类面前的挑战。\r\n（2）：构建人类命运共同体作为中国特色大国外交总目标的顶层设计。以公平正义作为新型国际关系的重要原则。\r\n一是以相互尊重作为新型国际关系的基本前提。中国历来主张各国自主选择发展道路，尊重彼此核心利益与重大关切；在对待各国不同文化上主张美人之美，美美与共，坚持求同存异和互学互鉴。\r\n\r\n　　二是以公平正义作为新型国际关系的重要原则。新型国际关系摒弃以强凌弱的丛林法则，推动国际关系民主化。中国主张不断推动增强发展中国家在国际制度和全球治理中的代表性和话语权，实现真正公平正义。\r\n\r\n　　三是以合作共赢作为新型国际关系的主要手段。某一国家单打独斗已无法应对当今越来越多的全球性、公共性和突发性挑战，国际社会携手合作才是最优选择。中国倡导以互利互惠增进全人类福祉，以合作共赢让各国共同分享彼此发展成果，实现责任共担，命运与共。\r\n\r\n　　四是以人类命运共同体作为新型国际关系的最终目标。中国共产党十九大报告明确提出中国外交的任务是要推动构建新型国际关系，推动构建人类命运共同体。构建新型国际关系和构建人类命运共同体是路径和目标的关系。人类命运共同体的理念超越国界、种族、肤色、文化的界限，打破社会制度和意识形态的藩篱，展示了一个充满希望的世界图景。\r\n（3）：\r\n![](https://img-blog.csdnimg.cn/img_convert/0eaa8f493d296d9a85f00320928c1e10.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/a65557cc23a79c1472041597df930132.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/43fa28efff31caf979239ce7c21e29fb.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/81693d7a2ef23a3496c326c5a45717d9.png)\r\n（4）：\r\n* 马克思主义政党的内在优势和建党规律。确立和维护无产阶级政党的领导核心，始终是马克思主义建党学说的一个基本观点。\r\n* 维护中央权威和核心是我们党的历史传统。\r\n* 维护中央权威和核心是世情党情国情民情所系。\r\n* 维护中央权威和核心是中国特色社会主义制度优势。\r\n一、坚持党的政治领导的必然要求\r\n　　党的正确而坚强的领导是党和国家事业健康发展的根本保证，回顾我们党成立以来的发展历程，坚持党的全面领导是最重要的一条经验。党旗帜鲜明地讲政治，首先要讲坚持党的全面领导；加强党的政治建设，首先要强化党的政治领导。\r\n二、严密党的组织体系的必然要求\r\n　　具有政治纪律和政治规矩的严格约束，是马克思主义政党先进本质的体现。中国共产党的严密组织体系建立在严格的纪律和规矩基础上。把政治属性作为党组织的根本属性，加强党的政治建设必须立足党的组织体系建设。“两个维护”对严密党的组织体系来说是一个极其重要的原则，必须从严密党的组织体系角度充分认识践行“两个维护”的重大意义。\r\n三、党员和领导干部党性锻炼的必然要求\r\n　　党的十九大把党的政治建设摆在首位，是以习近平同志为核心的党中央全面从严治党新的战略部署。从重点转变党的作风，到坚持以党的政治建设为统领，体现了新时代党的建设新的伟大工程向纵深推进的顶层思维和整体设计。\r\n\r\n（5）：\r\n![](https://img-blog.csdnimg.cn/img_convert/d94b116c2e58c6f5882a6e5af0d759cb.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/fba63e3db798340e8535065cc62b4d22.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/04a9c057abbafc49ebb0821b13e40a51.png)"
    },
    {
      "id": "/西电密码学复习重点",
      "metadata": {
        "permalink": "/blog/西电密码学复习重点",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/西电密码学复习重点.md",
        "source": "@site/blog\\西电密码学复习重点.md",
        "title": "西电密码学复习重点",
        "description": "考点范围",
        "date": "2020-12-28T00:00:00.000Z",
        "formattedDate": "2020年12月28日",
        "tags": [
          {
            "label": "密码学",
            "permalink": "/blog/tags/密码学"
          }
        ],
        "readingTime": 9.16,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "西电密码学复习重点",
          "date": "2020-12-28T00:00:00.000Z",
          "categories": "密码学",
          "tags": [
            "密码学"
          ]
        },
        "prevItem": {
          "title": "西电中特复习重点",
          "permalink": "/blog/西电中特复习重点"
        },
        "nextItem": {
          "title": "西电复杂网络重点",
          "permalink": "/blog/西电复杂网络重点"
        }
      },
      "content": "## 考点范围\r\n* 全部来自PPT中\r\n## 考试题型\r\n* 填空题（7 * 4 = 28分）\r\n* 计算+简单（7 * 8 = 56分）\r\n* 综合分析题（4小问  16分）\r\n## 考点1\r\n* 知道密码体制的分类\r\n![](https://img-blog.csdnimg.cn/img_convert/45371b335bff510d793fb6d549c5d698.png)\r\n* 常见的古典密码有哪些？\r\n\t* 凯撒密码\r\n\t* 仿射密码\r\n\t* 维吉尼亚密码\r\n* 这些古典密码的原理及其加解密（要知道凯撒密码是如何加解密的，仿射密码是如何加解密的，维吉尼亚密码是如何进行加解密的，这些加解密需要在网上寻找相关例题，可能考计算，不一定是PPT的原题！一定要慎重！！！）\r\n![](https://img-blog.csdnimg.cn/img_convert/de953335f3077dda16c099ca2c7eee73.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/61171582187155a8b84e605677780e98.png)\r\n* 仿射密码的加解密变换\r\n![](https://img-blog.csdnimg.cn/img_convert/412e5e89a34854c30a9dd9a163ea4be2.png)\r\n* 初等密码分析中，密码可能经受哪几类不同水平的攻击？（每一类都是基于怎样的信息来做分析的）**必须背会**\r\n![](https://img-blog.csdnimg.cn/img_convert/dd2f5c7c776d765741cf7d8c13e174a8.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/ca003b32041abaebb48abe506c155dde.png)\r\n* 信息安全三要素是什么？\r\n![](https://img-blog.csdnimg.cn/img_convert/6bde70ab525739216324d55ff95e0f35.png)\r\n* 两类密码体制及其本质区别是什么？\r\n![](https://img-blog.csdnimg.cn/img_convert/1dff44c2d2d744f66c192bf791f78a24.png)\r\n## 考点2\r\n* 流密码的基本概念（什么是流密码？）\r\n![](https://img-blog.csdnimg.cn/img_convert/a6ec94ebc500bbb241547c55d75e51ce.png)\r\n* 线性反馈移位寄存器（**必考**）\r\n![](https://img-blog.csdnimg.cn/img_convert/01ae69f1e6122d4ae455a9bb38e6b9f7.png)\r\n* 什么是m序列？\r\n![](https://img-blog.csdnimg.cn/img_convert/ca163813dcdb68a41bc128c05f508532.png)\r\n* m序列的破译（**这题考原题**）\r\n![](https://img-blog.csdnimg.cn/img_convert/ad071feac6ff2b141dada4208848606c.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/ad0110c4d13b2b336efb6e9b9006cfcb.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/e0d808f090f0f10e8a49682ea3479f44.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/684c30f6491f84fbcde9be6c04cfb0b0.png)\r\n* 线性反馈移位寄存器的递推关系\r\n![](https://img-blog.csdnimg.cn/img_convert/16939a55a092788ca9d36f1ab0bd48df.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/df92e2c1f309e7bbd549085fa5c34af3.png)\r\n* 什么是LFSR的特征多项式？\r\n![](https://img-blog.csdnimg.cn/img_convert/04f98735595edbc7f6222af4fb5bad29.png)\r\n## 考点3\r\n* 分组密码的基本概念\r\n![](https://img-blog.csdnimg.cn/img_convert/eaaa824a78fdfef63df3d3ac761bb4e1.png)\r\n* 分组密码和流密码的联系与区别\r\n\t* 相同点：流密码和分组密码同属于对称密码。\r\n\t* 不同点：\r\n\t\t1. 使用硬件实现时，流密码比分组密码简单快速，使用软件实现时分组密码比流密码更简单快速。\r\n\t\t2. 分组密码加解密算法固定，比流密码更容易实现标准化。\r\n\t\t3. 分组密码更容易实现同步。\r\n\t\t4. 分组密码是将明文分为若干组，每组长度固定，对于每一个明文组，采用设计好的算法进行加密解密。流密码是以最小单位比特作为一次加密、解密的操作元素，采用设计好的算法进行加密与解密操作。\r\n\t\t5. 分组密码是无记忆的，流密码是有记忆的。\r\n\t\t6. 分组密码算法的关键在于加解密算法，尽可能设计的复杂，但流密码的关键是密钥序列生成器的不可预测性。\r\n* 针对分组密码的攻击有哪些？（如何对分组密码进行攻击？）\r\n![](https://img-blog.csdnimg.cn/img_convert/e46ef820167928565feb666f1520652c.png)\r\n\r\n* 分组密码的安全性与稳定性\r\n\t* 安全性（分组密码应满足以下性质）\r\n\t\t* 混淆性：所设计的密码应使得明文、密文、密钥之间的依赖关系相当复杂，以至于这种依赖关系对密码分析者来说是无法利用的。\r\n\t\t* 扩散性：1：密钥的每一个比特影响密文的每一个比特，以防止对密钥进行逐段破解。2：明文的每一个比特影响密文的每一个比特，以便最充分的隐蔽明文。\r\n\t\t* 非线性度。\r\n\t* 稳定性：当部分密钥被破译后，分组密码仍有一定的抗攻击能力。\r\n* 分组密码的设计准则\r\n![](https://img-blog.csdnimg.cn/img_convert/bb5f246572848b84b05d0129ec45dced.png)\r\n* AES的轮函数有几个部件？每个部件的作用？\r\n\t* 轮密钥加：将轮密钥与明文按比特异或，轮密钥通过密钥扩展得到。\r\n\t* 行移位：实现一个 4x4 矩阵内部字节之间的置换。\r\n\t* 列混淆：利用 GF(28) 域上算术特性的一个代替。\r\n\t* 字节代换：通过 S 盒完成一个字节到另外一个字节的映射。\r\n* DES的轮函数有几个部分组成？\r\n答：轮函数F由3个部分组成：扩展置换（E盒），非线性代换（S盒）和线性置换（P盒）。\r\n* 分组密码的五种工作模式（**必考**）\r\n![](https://img-blog.csdnimg.cn/img_convert/910c33eed38a9e3c6a7dbf5c5fa4816f.png)\r\n* ECB模式的优缺点\r\n![](https://img-blog.csdnimg.cn/img_convert/6be99fda7e015d0a4591da21492d414c.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/56e8ca87ef8e0daaa9247ca8814eb954.png)\r\n## 考点4\r\n* 公钥密码的基本概念\r\n答：运用陷门单向函数原理编制的加密密钥公开，解密密钥保密的密码叫做公钥密码。\r\n* 公钥体制的基本原理是**陷门单向函数**。\r\n* 理解什么是陷门单向函数\r\n答：陷门单向函数是这样的单向函数：在不知陷门信息下，有f(x)求x是极为困难的，在知道陷门信息的条件下，由f(x)求x是易于实现的。\r\n* 能够举例说明哪些是实例是单向函数。\r\n![](https://img-blog.csdnimg.cn/img_convert/cb2b9a152f54e8c05769042005f478f2.png)\r\n* 掌握背包公钥算法的加解密（**此题定是一道计算题**，可以看看课本的例题）\r\n类似这种题：（争取都搞懂结合自己的背包公钥作业）\r\n![](https://img-blog.csdnimg.cn/img_convert/f9d996c5e83b1b01e39e548faa0a4fb4.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/7e26237651b719e2bf5d73b77a12c986.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/daeb4445b2e63382b7545a78f2f602fb.png)\r\n* RSA的密钥生成过程\r\n![](https://img-blog.csdnimg.cn/img_convert/16ba89ed89a1ff8a1bc41ead2f89c26b.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/4a5e87807fac8fa7dfb7d5524b97b609.png)\r\n* RSA的加解密过程\r\n![](https://img-blog.csdnimg.cn/img_convert/5dd6e3e2cc94951933ab94f6bcddf5ed.png)\r\n* 基于RSA的安全性\r\n![](https://img-blog.csdnimg.cn/img_convert/9fc20226dce7185c11f100d08108c54b.png)\r\n* RSA会遭到怎样的攻击？\r\n答：RSA 算法的安全性依赖于大整数分解的困难性。 最直接的攻击方法是分解 n 得到 p,q，进而基于 e 计算 d。\r\n* 看懂这个例题\r\n![](https://img-blog.csdnimg.cn/img_convert/e67ae15f51195d82654e19212f026a13.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/076fb31bddc4c80368b573b4afa5c75e.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/1df16020ef719cdfbb4ae17917efffea.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/dcc94fd23621a9b080c04416d247f1a1.png)\r\n* Rabin密码体制，这是当时第一个其安全性被证明等价于整数分解的困难性的非对称密码。\r\n*  EIgamal密码体制的优缺点：优点：更加安全，针对同样的明文，每次加密出的密文都不同。缺点：计算量特别大，而且密文会成倍的扩张。\r\n## 考点5\r\n* hash函数又叫散列函数\r\n* 设计hash函数的时候，什么样的函数不能作为哈希函数？\r\n![](https://img-blog.csdnimg.cn/img_convert/05c5970b519b192ac3b65602ce2a5ac1.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/3070ad7f1b27396f675f75a709484f43.png)\r\n* 哈希函数的性质有哪些？（**背会**）\r\n![](https://img-blog.csdnimg.cn/img_convert/046e054d32fe1b10afc9171e376512d7.png)\r\n* 什么是生日攻击？（生日碰撞）\r\n答：生日攻击就是利用散列函数发生碰撞的可能性，进行n次尝试直到找到一对碰撞的输入。\r\n* 哈希函数的用途\r\n\t* 公平提交方案\r\n\t* 简易身份识别\r\n\t* 数字签名的辅助函数\r\n* 数字签名具有什么样的性质？\r\n![](https://img-blog.csdnimg.cn/img_convert/c4d7d0552f78c9dcefb63eadfbe0ec4e.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/af3453d9f407fdf65371cdc91d121742.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/87db46fb2d4e74de9b19a0f9363d96bd.png)\r\n* 数字签名能用来做什么事情？\r\n答：1：用来做身份认证。2：防止合同被篡改。3：防止重放攻击。\r\n* RSA用于数字签名的流程\r\n![](https://img-blog.csdnimg.cn/img_convert/3184d39e97f7eae6b21643c88ac53c30.png)\r\n* RSA签名面临什么样的问题?\r\n答：RSA签名面临重放攻击的问题。\r\n* RSA签名是如何解决重放攻击的？\r\n![](https://img-blog.csdnimg.cn/img_convert/777145515dc3831ddffbbe45d6853fe8.png)\r\n* EIgamal签名的考题\r\n![](https://img-blog.csdnimg.cn/img_convert/e1e376abc8363d5d042a0b27433e4c9e.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/5e1c26f0b7cb6ebdfebf94a59822b9f2.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/a0cecc7529fa96ff82b81bf8d6056307.png)\r\n* Schnorr签名与EIgamal签名的不同点\r\n![](https://img-blog.csdnimg.cn/img_convert/53d2e1cbacccc978484a3fe0abd89b0f.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/13ef3fe1accf4c6a883fa90c2751456b.png)\r\n* 什么是盲签名？\r\n![](https://img-blog.csdnimg.cn/img_convert/80ab8047babd0b898e861fe62e33d028.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/9cf6b9188be17b53e0a67601031bae9c.png)\r\n## 考点6\r\n* 秘密共享方案的四种用途\r\n![](https://img-blog.csdnimg.cn/img_convert/7be82bdc12c900ae565482f71221b5c4.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/b727b805772297c95a6b731facb8e263.png)\r\n* 不经意传输的概念\r\n答：不经意传输协议，是一种可保护隐私的双方通信协议、接受者的隐私不被发送者所知道，使通信双方以一种选择模糊化的方式传送消息。\r\n![](https://img-blog.csdnimg.cn/img_convert/54694f9188eb7f55951b9a847a2400bb.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/df0d31d68ab3b7ff5ea60b75702bdc71.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/a56d2008d93e49be9a0a68769923776f.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/1e6a08cab668589cbcef19aa14047f4d.png)\r\n* 零知识证明的概念\r\n答：零知识证明指的是证明者能够在不向验证者提供任何有用的信息的情况下，使验证者相信某个论断是正确的。\r\n* 电子投票（也有可能考计算）\r\n![](https://img-blog.csdnimg.cn/img_convert/3c5722964b32ea16b8238d815f2259c6.png)\r\n## 考点7\r\n**密钥协商**一定会考，怎么考自己想（极有可能最后一道大题）"
    },
    {
      "id": "/西电复杂网络重点",
      "metadata": {
        "permalink": "/blog/西电复杂网络重点",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/西电复杂网络重点.md",
        "source": "@site/blog\\西电复杂网络重点.md",
        "title": "西电复杂网络重点",
        "description": "考试范围",
        "date": "2020-12-18T00:00:00.000Z",
        "formattedDate": "2020年12月18日",
        "tags": [
          {
            "label": "读研生活",
            "permalink": "/blog/tags/读研生活"
          }
        ],
        "readingTime": 11.455,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "西电复杂网络重点",
          "date": "2020-12-18T00:00:00.000Z",
          "categories": "读研生活",
          "tags": [
            "读研生活"
          ]
        },
        "prevItem": {
          "title": "西电密码学复习重点",
          "permalink": "/blog/西电密码学复习重点"
        },
        "nextItem": {
          "title": "字典合并问题",
          "permalink": "/blog/字典合并问题"
        }
      },
      "content": "## 考试范围\r\n* 全部来自PPT的内容\r\n## 考点1\r\n* 请用自己的语言表述什么是复杂网络？（**发散思维题**）\r\n答：复杂网络是指具有自组织、自相似、吸引子、小世界、无标度中部分或全部性质的网络称为复杂网络，复杂网络属于交叉学科，在“网络科学”、“脑科学”、“人工智能”、“计算机网络”等学科都或多或少的设计到复杂网络的相关知识。例如：“生物网络”、“蛋白质网络”、“神经网络”、“城市交通网络”、“社交网络”等都属于复杂网络的应用实例。\r\n* 复杂网络能够解决那些问题？\r\n答：可用于解决交通拥堵问题、病毒传播问题、社团现象、链路检测、网络攻击等问题。\r\n![](https://img-blog.csdnimg.cn/img_convert/ee6f987f6999f39f4769d466e1bd146b.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/1f311bcad31c6bfcd7e8942bba4a9a94.png)\r\n[Network Analysis 复杂网络分析总结](https://www.cnblogs.com/maybe2030/p/4665847.html#_label1)\r\n## 考点2\r\n* 如何去定义一个网络？\r\n答：网络是由若干节点和连接这些节点的链路构成，表示诸多对象及其相互联系。图是网络的数学表示。\r\n* \t网络有哪些属性和特征？\r\n答：网络里有节点和链路等属性。\r\n* 在一个具体的网络里面，每一个节点代表的是什么？每一条链代表什么？在具体的网络中会表述。\r\n![](https://img-blog.csdnimg.cn/img_convert/00a534eee68a89428dc72f4d88f74fde.png)\r\n* 图和网络在计算机中如何去表示？\r\n答：可以用矩阵去表示。\r\n* 如何去定义一个节点的度？(在有向网络和无向网络中)\r\n![](https://img-blog.csdnimg.cn/img_convert/7b06571ee2756d90586251eb01b90056.png)\r\n## 考点3\r\n* 什么是度分布？（度分布的概念）\r\n![](https://img-blog.csdnimg.cn/img_convert/ea59cfe158dbd07fcf65eb60f47bf096.png)\r\n* 下图是一种网络，请求出所有节点的度分布？（**计算题**）\r\n![](https://img-blog.csdnimg.cn/img_convert/f29f13cbb60b335e7cc44299452bc7a7.png)\r\n* 请写出什么是路径？（路径的概念）\r\n答：路径是一个节点序列，其中每个节点与下一个节点相邻。\r\n* 在网络中如何去计算节点之间的路径？（**计算题**）\r\n* 会计算最短路径。\r\n* 计算最短路径有哪些方法？\r\n答：通过Dijkstra迪杰斯特拉算法计算最短路径。kruscal克鲁斯卡尔算法，\r\n* 会使用一种算法计算网络专供所有节点的最短路径（**计算题**）。\r\n[参考文献：迪杰斯特拉算法](https://www.cnblogs.com/xxlong/p/5028981.html)\r\n![](https://img-blog.csdnimg.cn/img_convert/0e2dcdc69e0ad5a08eec592e6a0fa429.png)\r\n## 考点4\r\n* 会计算网络中任意一个节点的聚类系数。（**计算题**）\r\n![](https://img-blog.csdnimg.cn/img_convert/199227e04d671012ac832ca1d4584b83.png)\r\n![](https://img-blog.csdnimg.cn/img_convert/e565200bc44978cf5350a1dfddd9c731.png)\r\n* 下面这道题可能会考\r\n![](https://img-blog.csdnimg.cn/img_convert/f2399b20cc595a84409bd12fc453ad79.png)\r\n大致看看\r\n![](https://img-blog.csdnimg.cn/img_convert/02def27d71a2a0258e269e6c5900af98.png)\r\n## 考点5\r\n* 随机网络是什么？如何去构建随机网络？\r\n答：一个由N个节点组成的图，其中每对节点都以概率p连接，这样的网络叫做随机网络，两个节点之间连边与否不再是确定的事情，而是根据一个概率决定。\r\n* 一个随机网络的链路的条数是L，求其概率。\r\n![](https://img-blog.csdnimg.cn/img_convert/25d9ab8b2ed92d88dc11abdb95ef65ea.png)\r\n* 度分布是什么分布？\r\n答：泊松分布  （这个可能考）\r\n* 请解释下随机网络中的相变现象？（**简答题**）\r\n答：节点的概率值p初始时比较小，此时的网络只有少数的点连在一起，此时p的概率值存在一个相变点，一旦概率值p大于Pc(1/N),网路中的大多数节点就可以连在一起，出现一个最大连通子图。\r\n* 会计算相变点，kc=1,求pc。\r\n![](https://img-blog.csdnimg.cn/img_convert/40faeb2dc290060962d39b0b8eb5895c.png)\r\n## 考点6\r\n* 目标度网络中一个很重要的特征是什么？（**可能考简答题**）\r\n答：度的幂律分布，幂律分布指的是度分布在对数坐标系下，幂律分布表现为一条斜率为幂指数的负数的直线，此时有如下等式：\r\n![](https://img-blog.csdnimg.cn/img_convert/4cf694d2b5756d6248811dc8c3600ceb.png)\r\n此时γ就是斜率。\r\n---\r\n## 考点7\r\n* 如何去构建B-A网络？（**简答题**）\r\n1. 首先随机构造一个拥有m个节点的小规模网络。\r\n2. 在这个小的网络上，每次增加一个新的节点与m条边\r\n3. 每一条边要与新的节点和已有的节点相连。\r\n4. 偏好连接：已经存在的节点的度的值越大，其概率越大，一个新的节点与已有节点相连的概率如下图所示：\r\n\t![](https://img-blog.csdnimg.cn/img_convert/70d24af9d48fa8f8a048c0978abe803a.png)\r\n* B-A网络的两个特性\r\n1. 增长性\r\n2. 偏好连接性\r\n* 在B-A网络中 γ的值等于3\r\n![](https://img-blog.csdnimg.cn/img_convert/363f3f956631a6de4792cc7a6ca4f48d.png)\r\n## 考点8\r\n* 度相关性的概念\r\n![](https://img-blog.csdnimg.cn/img_convert/2f609bc2363c6e1638a6b25a8e97e286.png)\r\n* 刻画度相关性有三类：\r\n\t* 同配：hub节点倾向于连接hub节点。\r\n\t* 异配：hub节点喜欢连接非hub节点。\r\n\t* 中性：节点按照预期的随机概率去连接。\r\n* 如何去刻画，一个网络是哪一类？（**简答题**）\r\n1. 基于统计学的方法：在随机选择的边的两端找到j度和k度节点的概率（即Ejk）,通过热度图的方法绘制出来，通过图的特征来判断是同配还是异配的。\r\n![](https://img-blog.csdnimg.cn/img_convert/270075d9052ac1ebf7a693d30e6bb759.png)\r\n2. 使用一阶邻居的平均值的大小来判定。\r\n![](https://img-blog.csdnimg.cn/img_convert/5757c28ca498d60d90b60dc9bf971e28.png)\r\n4. 使用相关系数公式来判断（下面的公式是＜  近似等于  ＞）\r\n![](https://img-blog.csdnimg.cn/img_convert/27eb3425693c5097a8a2676da8b43b9f.png)\r\n## 考点9\r\n* 能够简述社团检测的概念。(**可能考思维发散题**)\r\n>定义1：普遍意义上的社团结构就是网络中一组连接紧密的节点所组成的团体，其内部连边紧密，与外部的连边相对稀疏。而社团检测就是利用各种方法将这些联系紧密的节点找出来，其应用非常广泛，例如针对社交网络可以利用社团检测找到社交圈，针对蛋白质网络可以找到蛋白质的特定功能模块等。社团检测任务包括静态网络社团检测以及动态网络社团检测。静态网络社团检测（dynamic community detection）需要考虑网络数据的特性对链接紧密的节点进行有监督或者无监督的聚类，普遍的方法包括机器学习中的非监督聚类方法、基于模块度的方法、谱方法、隐空间模型方法、概率模型方法等。而动态网络社团检测不仅需要考虑每个时间快照（snapshot）的节点链接紧密程度，还要考虑每个社团随时间的演化（community evolution）。\r\n\r\n>定义2：社团检测通常是指将网络中联系紧密的部分找出来，而这些部分就称之为社团[4]。社团内部联系稠密，而社团之间联系稀疏[5]。社团是复杂网络重要的结构特征之一，其往往对应于网络的基本功能单元。因此，通过检测社团结构，可能揭示网络的结构与功能之间的关联关系。此外，已有研究表明，复杂网络在社团层面上通常会显现出单个顶点或整个网络层面所不具备的一些特性[6]，因此，通过对网络社团结构的研究可能捕捉到复杂网络的更多有意义的特性。\r\n* 划分社团的依据是什么？\r\n答：一个社团的内部连接是十分紧密的。社团和社团之间的link是比较稀疏的。\r\n* 强社团和弱社团的概念。\r\n答：一个社团中任何一个顶点与社团内部顶点连接的度大于其与社团外部顶点连接的度。这样的成为强社团。一个社团中所有顶点与内部顶点的度之和大于社团中所有顶点与外部顶点连接的度之和。\r\n* 社团检测的方法主要有两大类：（**简答或者思维发散**）\r\n1. 自顶向下\r\n> * 定义相似矩阵\r\n> * 定义社团相似度（两个社团之间连边的平均相似度）\r\n> * 进行聚类，第一步：令每一个节点单独成为一个社团。第二步：找出最高相似度的两个社团进行合并，并重新计算社团相似度。第三步：重复第二步直到所有节点合并成一个社团。\r\n> 建立树状图：精确描述节点被分配至社团的顺序。\r\n2. 自底向上\r\n> * 定义中心度。\r\n> * 层次聚类。\r\n* 网络的鲁棒性。\r\n答：鲁棒性的评价，在一个网络中如果移走网络中的少量节点或边后网络中的绝大部分节点仍是连通的，那么称这个网络具有鲁棒性。无标度网络对随机节点故障具有极高的鲁棒性。\r\n## 考点10\r\n* 病毒感染的状态分类\r\n1. 易感染状态S：一个个体在感染前为该状态。\r\n2. 感染状态I：处于该状态的个体，有一定的概率会感染其它个体。\r\n3. 移出状态R：该状态也叫免疫状态，当一个个体经过一个完整的感染周期后，该个体不会再次被感染。\r\n* 熟记下面的三种模型\r\n4. SI模型\r\n![](https://img-blog.csdnimg.cn/img_convert/6b5ff09de372c094bbc8c23cf28c6fe2.png)\r\n5. SIS模型\r\n感染者还能够回到易感染状态。\r\n7. SIR模型\r\n![](https://img-blog.csdnimg.cn/img_convert/158fac475e2f43b88e33576b8526f7f3.png)"
    },
    {
      "id": "/字典合并问题",
      "metadata": {
        "permalink": "/blog/字典合并问题",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/字典合并问题.md",
        "source": "@site/blog\\字典合并问题.md",
        "title": "字典合并问题",
        "description": "问题介绍",
        "date": "2020-10-17T00:00:00.000Z",
        "formattedDate": "2020年10月17日",
        "tags": [
          {
            "label": "python",
            "permalink": "/blog/tags/python"
          }
        ],
        "readingTime": 1.145,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "字典合并问题",
          "date": "2020-10-17T00:00:00.000Z",
          "categories": "python",
          "tags": [
            "python"
          ]
        },
        "prevItem": {
          "title": "西电复杂网络重点",
          "permalink": "/blog/西电复杂网络重点"
        },
        "nextItem": {
          "title": "前端知识学习41——CSS3新特性",
          "permalink": "/blog/前端知识学习41——CSS3新特性"
        }
      },
      "content": "## 问题介绍\r\n有时候我们需要将两个字典进行合并，我们需要相同的键的值，合并成一个列表。\r\n\r\n## 代码\r\n```python\r\ndic_a = {\"key1\":1,\"key5\":2}\r\n\r\ndic_b = {\"key1\":3,\"key4\":4}\r\nprint(\"合并前的字典1是{}\".format(dic_a))\r\nprint(\"合并前的字典2是{}\".format(dic_b))\r\n# 实现的目标是 \"key2\":[2,3]\r\nresult_dic = {}\r\n'''\r\n核心思路：\r\n        1：遍历字典1和字典2的每一个键\r\n        2：如果两个字典的键是一样的，就给新字典的该键赋值为空列表\r\n            然后空列表依次添加字典1和字典2 的值，然后将最后的值赋值给原字典\r\n        3：如果两个字典的键不同，则分别将键值对加到新列表中\r\n'''\r\nfor k,v in dic_a.items():\r\n    for m,n in dic_b.items():\r\n        if k == m:\r\n            result_dic[k] = []\r\n            result_dic[k].append(dic_a[k])\r\n            result_dic[k].append(dic_b[k])\r\n            dic_a[k] = result_dic[k]\r\n            dic_b[k] = result_dic[k]\r\n        else:\r\n            result_dic[k] = dic_a[k]\r\n            result_dic[m] = dic_b[m]\r\n    # if k in dic_b.keys():\r\n        \r\n\r\nprint(\"合并后的字典是{}.\".format(result_dic))\r\n```\r\n\r\n## 结果\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201017104613.png)"
    },
    {
      "id": "/前端知识学习41——CSS3新特性",
      "metadata": {
        "permalink": "/blog/前端知识学习41——CSS3新特性",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习41——CSS3新特性.md",
        "source": "@site/blog\\前端知识学习41——CSS3新特性.md",
        "title": "前端知识学习41——CSS3新特性",
        "description": "1：属性选择器",
        "date": "2020-10-16T00:00:00.000Z",
        "formattedDate": "2020年10月16日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 3.315,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习41——CSS3新特性",
          "date": "2020-10-16T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "字典合并问题",
          "permalink": "/blog/字典合并问题"
        },
        "nextItem": {
          "title": "Visual Studio使用方法",
          "permalink": "/blog/Visual Studio使用方法"
        }
      },
      "content": "## 1：属性选择器\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201016165708.png)\r\n\r\n* 权重不一样的时候，听权重大的。\r\n* 权重一样的时候，谁在后面听谁的。\r\n* 类选择器，属性选择器和伪类选择器权重都是10。\r\n\r\n## 2：结构伪类选择器\r\n* 在使用结构伪类选择器的时候一定要注意前面有空格。\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201016170001.png)\r\n\r\n### 示例代码\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201016170025.png)\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201016170113.png)\r\n\r\n## 3：nth-child与nth-of-type的区别\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201016170223.png)\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201016170232.png)\r\n\r\n>nth-of-type会将熊大给选出来，这就是二者的主要区别，因为nth-of-type会先选类型，然后进行定位。\r\n\r\n### 总结\r\n* nth-of-type先选类型\r\n* nth-child 先选序号\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201016170513.png)\r\n\r\n## 4：伪元素\r\n>伪元素选择器可以帮助我们利用CSS创建新标签元素，而不需要HTML标签，从而简化HTML结构。\r\n\r\n```\r\n::before   # 在元素内部的前面插入内容\r\n::after    # 在元素内部的后面插入内容\r\n```\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201016172827.png)\r\n\r\n### 为什么叫伪元素？\r\n>答：因为这个元素在文档树中是找不到的，所以我们称之为伪元素。\r\n\r\n### 注意事项\r\n* before和after创建的是行内元素，不能给宽高。\r\n* before和after必须有content属性\r\n\r\n### 准确理解什么是内容的前面和后面\r\n\r\n#### 代码\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201016173525.png)\r\n\r\n#### 效果图\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201016173540.png)\r\n\r\n### 伪元素选择器使用场景1：伪元素字体图标\r\n#### 实现目标\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201016173727.png)\r\n\r\n#### 伪元素选择器使用阿里字体图标库使用步骤\r\n* 1：下载字体图标相关代码\r\n* 2：使用link进行引入\r\n* 3：在伪元素选择器里修改两个位置，一个是content改成图标的代号，另一个是加上font-family\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201016174344.png)\r\n\r\n**伪元素也是父元素的子元素**\r\n\r\n### 伪元素选择器使用场景2：仿土豆效果\r\n#### 实现目标\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201016175249.png)\r\n\r\n#### 代码\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <style>\r\n        .tudou {\r\n            position: relative;\r\n            width: 444px;\r\n            height: 320px;\r\n            background-color: aqua;\r\n            margin: 30px auto;\r\n\r\n        }\r\n        .tudou img {\r\n            width: 100%;\r\n            height: 100%;\r\n        }\r\n        .tudou::before {\r\n            content: '';\r\n            visibility: hidden;\r\n            position: absolute;\r\n            width: 100%;\r\n            height: 100%;\r\n            background: rgba(0,0,0,0.3) url(images/arr.png) center no-repeat\r\n        }\r\n        .tudou:hover::before {\r\n            visibility: visible;    \r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"tudou\">\r\n        <!-- <div class=\"mask\"></div> -->\r\n        <img src=\"images/tudou.jpg\" alt=\"\">\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n\r\n### 伪元素使用场景3：伪元素清除浮动\r\n#### 四种清除浮动的方法\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201016175420.png)\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201016175430.png)\r\n\r\n## 5：CSS3盒子模型：border-box\r\n```css\r\nbox-sizing:border-box;\r\n```\r\n>上面这行代码会使得padding和border不会撑开盒子。\r\n\r\n## 6：图片模糊处理\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201016175644.png)\r\n\r\n```css\r\nfilter:blur(5px);  # 数值越大，图片越模糊\r\n```\r\n\r\n## 7：calc函数\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201016175755.png)\r\n\r\n>这里的100%指的是父盒子的宽度。\r\n\r\n## 8：过渡属性\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201016175851.png)\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201016175902.png)\r\n\r\n```css\r\ntransition:height 1s,width 1s;\r\ntransition:all 1s;\r\n```\r\n\r\n>上面的两种写法都会使得宽和高同时发生变化。\r\n\r\n### 过渡练习（进度条）\r\n#### 代码\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201016180113.png)\r\n\r\n#### 实现效果图\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201016180135.png)"
    },
    {
      "id": "/Visual Studio使用方法",
      "metadata": {
        "permalink": "/blog/Visual Studio使用方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Visual Studio使用方法.md",
        "source": "@site/blog\\Visual Studio使用方法.md",
        "title": "Visual Studio使用方法",
        "description": "1：解决方案与项目的关系",
        "date": "2020-10-13T00:00:00.000Z",
        "formattedDate": "2020年10月13日",
        "tags": [
          {
            "label": "Visual Studio",
            "permalink": "/blog/tags/visual-studio"
          }
        ],
        "readingTime": 0.91,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Visual Studio使用方法",
          "date": "2020-10-13T00:00:00.000Z",
          "categories": "Visual Studio",
          "tags": [
            "Visual Studio"
          ]
        },
        "prevItem": {
          "title": "前端知识学习41——CSS3新特性",
          "permalink": "/blog/前端知识学习41——CSS3新特性"
        },
        "nextItem": {
          "title": "归并排序",
          "permalink": "/blog/归并排序"
        }
      },
      "content": "## 1：解决方案与项目的关系\r\n* 解决方案里面是包含项目的。\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201012102419.png)\r\n* 一个解决方案里可以包含多个项目，当我们下次打开这个解决方案的时候，会自动含有这些项目。\r\n* 点击生成解决方案会把这个解决方案下面的所有项目进行生成。\r\n\r\n## 2：编译\r\n编译就是分别对解决方案里的每一个项目点击生成。\r\n\r\n## 3：运行\r\n可以点击 调试里面的开始执行。（也可以直接使用快捷键Ctrl + F5）\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201012103513.png)\r\n\r\n## 4：重置窗口布局\r\n当你把窗口各种视图弄混乱的时候，可以选择重置窗口布局。\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201012105144.png)"
    },
    {
      "id": "/归并排序",
      "metadata": {
        "permalink": "/blog/归并排序",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/归并排序.md",
        "source": "@site/blog\\归并排序.md",
        "title": "归并排序",
        "description": "归并排序的核心思想",
        "date": "2020-10-13T00:00:00.000Z",
        "formattedDate": "2020年10月13日",
        "tags": [
          {
            "label": "算法基础",
            "permalink": "/blog/tags/算法基础"
          }
        ],
        "readingTime": 2.17,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "归并排序",
          "date": "2020-10-13T00:00:00.000Z",
          "categories": "算法基础",
          "tags": [
            "算法基础"
          ]
        },
        "prevItem": {
          "title": "Visual Studio使用方法",
          "permalink": "/blog/Visual Studio使用方法"
        },
        "nextItem": {
          "title": "费马素性检验算法",
          "permalink": "/blog/费马素性检验算法"
        }
      },
      "content": "```html\r\n<h1 style = \"text-align:center;\">归并排序</h1>\r\n```\r\n\r\n## 归并排序的核心思想\r\n* 归并排序主要采用的是分治法的思想\r\n* 归并排序用到了递归思想\r\n\r\n## 归并排序图解\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201010103750.png)\r\n\r\n## 算法步骤\r\n* 1：判断列表的长度（如果列表的长度=1，返回列表，这也是递归的终止条件）\r\n* 2：使用长度整除2 ，将列表分割为两部分\r\n* 3：左边的部分调用递归\r\n* 4：右边的部分也调用递归\r\n* 5：递归调用结束完成了分治法中“分”的思想\r\n* 6：定义左右两边的下标指针\r\n* 7：定义一个空的列表（用来存放最终结果）\r\n* 8：使用while循环（条件是：只有左边和右边的指针都没有遍历到最后才进入循环）\r\n* 9：谁小谁加到列表中，然后指针加1\r\n* 10：最后将没有遍历完的部分统统加到列表的最后\r\n* 11：返回最终列表\r\n\r\n## 实现代码\r\n```python\r\n\r\ndef Merge_sort(data):\r\n    \r\n    # 递归排序主要应用的是分治法的思想\r\n    # 首先进行的是 分的思想\r\n    length = len(data)\r\n    # //是整除的意思   9//2  == 4\r\n\r\n    if length <= 1:\r\n        return data\r\n    mid = length // 2   \r\n    left_list = data[:mid]\r\n    right_list = data[mid:]\r\n\r\n    # 调用递归\r\n    left_li = Merge_sort(left_list)\r\n    right_li = Merge_sort(right_list)\r\n\r\n    # 定义 左右两边的下标指针\r\n    left_pointer,right_pointer = 0,0\r\n\r\n    result = []\r\n    while left_pointer < len(left_li) and right_pointer < len(right_li):\r\n        if left_li[left_pointer] < right_li[right_pointer]:\r\n            result.append(left_li[left_pointer])\r\n            left_pointer = left_pointer + 1\r\n        else:\r\n            result.append(right_li[right_pointer])\r\n            right_pointer = right_pointer + 1\r\n\r\n    result = result + left_li[left_pointer:]\r\n    result = result + right_li[right_pointer:]\r\n\r\n    return result\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    L1 = [54, 26, 93, 17, 77, 31, 17, 55, 20]\r\n    print(\"排序前: \", L1)\r\n    L1 = Merge_sort(L1)\r\n    print('排序后: ', L1)\r\n```\r\n\r\n## 参考视频\r\n[黑马python数据结构与算法系列课程](https://www.bilibili.com/video/BV1p441167Wc?p=46)"
    },
    {
      "id": "/费马素性检验算法",
      "metadata": {
        "permalink": "/blog/费马素性检验算法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/费马素性检验算法.md",
        "source": "@site/blog\\费马素性检验算法.md",
        "title": "费马素性检验算法",
        "description": "一、Fermat素性检测算法介绍",
        "date": "2020-10-13T00:00:00.000Z",
        "formattedDate": "2020年10月13日",
        "tags": [
          {
            "label": "密码学",
            "permalink": "/blog/tags/密码学"
          }
        ],
        "readingTime": 3.505,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "费马素性检验算法",
          "date": "2020-10-13T00:00:00.000Z",
          "categories": "密码学",
          "tags": [
            "密码学"
          ]
        },
        "prevItem": {
          "title": "归并排序",
          "permalink": "/blog/归并排序"
        },
        "nextItem": {
          "title": "Python交换两个元素是同步的",
          "permalink": "/blog/Python交换两个元素是同步的"
        }
      },
      "content": "```html\r\n<h1 style = \"text-align:center;\">Fermat素性检验算法</h1>\r\n```\r\n\r\n## 一、Fermat素性检测算法介绍\r\n### 重要参数：\r\n* 1：待检测的大数（来自文件data.txt）\r\n* 2：安全参数K，从控制台输入\r\n\r\n### 算法步骤\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201013194405.png)\r\n\r\n## 二、Miracl环境配置\r\n* 下载并解压Miracl压缩包\r\n* 新建一个miracl文件夹，并将压缩包里所有的单文件（包括文件夹中的文件）拷贝到miracl目录中。\r\n* 打开VS2015,新建空项目\r\n* 将miracl文件夹中的所有文件复制到工程目录中，和工程源文件放在一起。\r\n* 在空白项目里添加以下头文件 \"miracl.h\"和\"mirdef.h\"以及以mr开头.c结尾的文件\r\n* 右键 项目 属性 重新生成即可完成编译。\r\n\r\n## 三、miracl基本函数\r\nmirsys（初始化miracl内存空间）、mirvar（big数初始化）、cinnum（大数的输入）、cotnum（大数的输出）、decr（大数与int数相减）、bigrand（生成随机big数）、egcd（计算两个大数的最大公因数）、compare（比较两个大数的大小）、powmod（计算大数之间的指数次方模值，如am-1(mod m)）、mirexit（清理miracl内存空间）\r\n\r\n## 四、C语言实现\r\n```c\r\n#include<stdio.h>\r\n#include<math.h>\r\n#include<stdlib.h>\r\n#include \"miracl.h\"\r\n\r\nint main()\r\n{\r\n\tint k;\r\n\tFILE *fp = NULL;\r\n\tchar fileName[80];\r\n\tdouble probability = 0;\r\n\tmiracl *mip = mirsys(500, 10); //初始化miracl系统\r\n\tbig m = mirvar(0);\r\n\tbig a = mirvar(0);\r\n\tbig g = mirvar(0);\r\n\tbig r = mirvar(0);\r\n\tbig temp = mirvar(0);\r\n\tbig one = mirvar(1);\r\n\r\n\tprintf(\"****************Fermat素性检测算法START******************\\n\\n\");\r\n\t//数据初始化：从文件中读取大数，从控制台获取安全参数k\r\n\t//printf(\"请输入待检测大数存放的文件名（含路径）:\");\r\n\t//scanf(\"%s\", fileName);\r\n\t//printf(\"载入大数中..............\\n\");\r\n\r\n\tif ((fp = fopen(\"E:\\\\VS2015\\\\PRO\\\\test\\\\test\\\\data.txt\", \"r+\")) == NULL) {\r\n\t\tprintf(\"载入大数失败！\\n\");\r\n\t\tsystem(\"pause\");\r\n\t\texit(1);\r\n\t}\r\n\tcinnum(m, fp);\r\n\tprintf(\"载入成功！待检测的大数为：\\n\");\r\n\tcotnum(m, stdout);\r\n\tprintf(\"\\n现在请输入安全参数k:\");\r\n\tscanf(\"%d\", &k);\r\n\r\n\t//处理逻辑\r\n\tfor (int i = 1; i <= k; i++) {\r\n\t\tprintf(\"\\n**************Fermat素性检测第%d轮****************\\n\", i);\r\n\r\n\t\t//随机选取整数a\r\n\t\tdo {\r\n\t\t\tdecr(m, 1, temp);\r\n\t\t\tbigrand(temp, a);\r\n\t\t} while (compare(a, one) != 1);\r\n\t\tprintf(\"\\n第%d轮生成的随机数a(2=<a=<m-2)为：\\n\", i);\r\n\t\tcotnum(a, stdout);\r\n\t\tprintf(\"\\n\");\r\n\r\n\t\t//计算g\r\n\t\tegcd(m, a, g);\r\n\t\tprintf(\"第%d轮m和a的最大公因数g为：\", i);\r\n\t\tcotnum(g, stdout);\r\n\t\tprintf(\"\\n\");\r\n\t\tif (compare(g, one)) {\r\n\t\t\tprintf(\"第%d轮检验失败:a和m不互素，故m为合数\\n\", i);\r\n\t\t\tsystem(\"pause\");\r\n\t\t\texit(0);\r\n\t\t}\r\n\r\n\t\t//计算r\r\n\t\tpowmod(a, temp, m, r);\r\n\t\tprintf(\"第%d轮用于验证Fermat小定理的r为：\", i);\r\n\t\tcotnum(r, stdout);\r\n\t\tprintf(\"\\n\");\r\n\t\tif (compare(r, one)) {\r\n\t\t\tprintf(\"第%d次检验失败:求解出来的r不等于1，故m为合数\\n\", i);\r\n\t\t\tsystem(\"pause\");\r\n\t\t\texit(0);\r\n\t\t}\r\n\r\n\t\t//打印结果\r\n\t\tprobability = 1 - pow(0.5, i);\r\n\t\tprintf(\"第%d次检验成功：m为素数的概率为：%6.4f\\n\", i, probability);\r\n\r\n\t}\r\n\tprintf(\"\\n****************Fermat素性检测算法END******************\\n\");\r\n\tfclose(fp);\r\n\tmirexit();\r\n\tsystem(\"pause\");\r\n\treturn 0;\r\n}\r\n```\r\n## 五、测试效果\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201013195430.png)\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201013195451.png)\r\n\r\n## 六、测试素数来源\r\n[随机小素数](https://primes.utm.edu/lists/small/small.html?tdsourcetag=s_pctim_aiomsg#100)"
    },
    {
      "id": "/Python交换两个元素是同步的",
      "metadata": {
        "permalink": "/blog/Python交换两个元素是同步的",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Python交换两个元素是同步的.md",
        "source": "@site/blog\\Python交换两个元素是同步的.md",
        "title": "Python交换两个元素是同步的",
        "description": "python中交换两个元素是同步的！！！",
        "date": "2020-10-09T00:00:00.000Z",
        "formattedDate": "2020年10月9日",
        "tags": [
          {
            "label": "python",
            "permalink": "/blog/tags/python"
          }
        ],
        "readingTime": 0.21,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Python交换两个元素是同步的",
          "date": "2020-10-09T00:00:00.000Z",
          "categories": "python",
          "tags": [
            "python"
          ]
        },
        "prevItem": {
          "title": "费马素性检验算法",
          "permalink": "/blog/费马素性检验算法"
        },
        "nextItem": {
          "title": "Python倒序遍历列表的方法",
          "permalink": "/blog/Python倒序遍历列表的方法"
        }
      },
      "content": "python中交换两个元素是同步的！！！\r\n```python\r\na[i],a[i-1] = a[i-1],a[i]\r\n```\r\n上面的例子，假如a[i] = 3 , a[i-1] = 2，那么交换之后，a[i-1] = 3,a[i] = 2"
    },
    {
      "id": "/Python倒序遍历列表的方法",
      "metadata": {
        "permalink": "/blog/Python倒序遍历列表的方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Python倒序遍历列表的方法.md",
        "source": "@site/blog\\Python倒序遍历列表的方法.md",
        "title": "Python倒序遍历列表的方法",
        "description": "方法1：使用列表切片",
        "date": "2020-10-09T00:00:00.000Z",
        "formattedDate": "2020年10月9日",
        "tags": [
          {
            "label": "python",
            "permalink": "/blog/tags/python"
          }
        ],
        "readingTime": 0.08,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Python倒序遍历列表的方法",
          "date": "2020-10-09T00:00:00.000Z",
          "categories": "python",
          "tags": [
            "python"
          ]
        },
        "prevItem": {
          "title": "Python交换两个元素是同步的",
          "permalink": "/blog/Python交换两个元素是同步的"
        },
        "nextItem": {
          "title": "插入排序",
          "permalink": "/blog/插入排序"
        }
      },
      "content": "## 方法1：使用列表切片\r\n```python\r\na = []\r\na[::-1]\r\n```"
    },
    {
      "id": "/插入排序",
      "metadata": {
        "permalink": "/blog/插入排序",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/插入排序.md",
        "source": "@site/blog\\插入排序.md",
        "title": "插入排序",
        "description": "插入排序的核心思想",
        "date": "2020-10-09T00:00:00.000Z",
        "formattedDate": "2020年10月9日",
        "tags": [
          {
            "label": "算法基础",
            "permalink": "/blog/tags/算法基础"
          }
        ],
        "readingTime": 3.155,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "插入排序",
          "date": "2020-10-09T00:00:00.000Z",
          "categories": "算法基础",
          "tags": [
            "算法基础"
          ]
        },
        "prevItem": {
          "title": "Python倒序遍历列表的方法",
          "permalink": "/blog/Python倒序遍历列表的方法"
        },
        "nextItem": {
          "title": "前端知识学习32——精灵图",
          "permalink": "/blog/前端知识学习32——精灵图"
        }
      },
      "content": "## 插入排序的核心思想\r\n1：从第二个元素开始依次进行遍历，假设前面的元素已经是有序的。\r\n2：第i个元素和第i-1个元素进行比较，如果第i个元素比较小，就对两者进行交换位置。\r\n3：交换完之后，继续和前面的进行比较，直到遇到比自己小的元素，停止交换。\r\n\r\n>推荐参考 网络版代码\r\n\r\n## 时间复杂度\r\n最优时间复杂度：O(N)\r\n最坏时间复杂度：O(N^2)\r\n\r\n## 代码（网络版）\r\n```python\r\n# -*- coding:utf-8 -*-\r\n'''\r\n实现思路：\r\n        1：从第二个元素开始遍历列表\r\n        2：i 代表的是元素的下标\r\n        3：当i大于0的时候进入循环\r\n        4：如果后边的元素小于前面的元素，就进行交换元素\r\n        5：下标前移，继续判断下标所在元素和下标前面的那个元素\r\n        重要：python中如何实现交换两个元素\r\n'''\r\n# 定义插入排序函数\r\ndef insert_sort(data):\r\n    \r\n    # 从第二个元素开始遍历列表\r\n    for i in range(1,len(data)):\r\n        # 这里的i是下标\r\n        while i > 0:\r\n            if data[i] < data[i-1]:\r\n                data[i],data[i-1] = data[i-1],data[i]\r\n                i = i - 1\r\n            else:\r\n                break\r\n    return data\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    \r\n    L1 = [54, 26, 93, 17, 77, 31, 17, 55, 20]\r\n    print(\"排序前: \", L1)\r\n    insert_sort(L1)\r\n    print('排序后: ', L1)\r\n```\r\n\r\n## 代码（自己写的）\r\n```python\r\n# -*- coding:utf-8 -*-\r\n# 定义插入排序函数\r\n'''\r\n思路总结：\r\n        1：遍历列表里的每一个下标\r\n        2：从下标获得值，并赋值给临时变量x\r\n        3：创建一个新的列表，这个列表用来存放临时变量x值前面的序号\r\n        4：如果序号大于0，倒着遍历上面获取的序号的值\r\n        5：如果大于临时变量后移1个，把临时变量放到后移的那个元素的位置，直到不大于临时变量\r\n        重要：python中如何实现列表倒序遍历\r\n'''\r\ndef insert_sort(data):\r\n    \r\n    # 遍历列表里的每一个值  复制给一个临时变量x\r\n    for i in range(len(data)):\r\n        # 此时的i就是列表的下标  x就是赋值给的临时变量\r\n        x = data[i]\r\n        # 这个列表存放 x前面值的序号\r\n        list1 = []\r\n        # 寻找插入位置  将其他元素后移        \r\n        if i > 0:\r\n            for j in range(0,i):\r\n                list1.append(j)\r\n            for v in list1[::-1]:\r\n                if data[v] > x:\r\n                    data[v+1] = data[v]\r\n                    data[v] = x\r\n    return data\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    \r\n    L1 = [54, 26, 93, 17, 77, 31, 17, 55, 20]\r\n    print(\"排序前: \", L1)\r\n    insert_sort(L1)\r\n    print('排序后: ', L1)\r\n```\r\n\r\n## 视频参考\r\n[视频参考](https://www.bilibili.com/video/BV1Q54y1e7ou/?spm_id_from=trigger_reload)"
    },
    {
      "id": "/前端知识学习32——精灵图",
      "metadata": {
        "permalink": "/blog/前端知识学习32——精灵图",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习32——精灵图.md",
        "source": "@site/blog\\前端知识学习32——精灵图.md",
        "title": "前端知识学习32——精灵图",
        "description": "1：为什么需要精灵图技术？",
        "date": "2020-10-05T00:00:00.000Z",
        "formattedDate": "2020年10月5日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 2.52,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习32——精灵图",
          "date": "2020-10-05T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "插入排序",
          "permalink": "/blog/插入排序"
        },
        "nextItem": {
          "title": "前端知识学习33——字体图标",
          "permalink": "/blog/前端知识学习33——字体图标"
        }
      },
      "content": "## 1：为什么需要精灵图技术？\r\n当网页中的图像，过多的时候，服务器就会频繁的接收和发送请求图片，造成服务器请求压力过大，大大降低页面的加载速度。为了有效的减少服务器发送请求和接收的次数，提高页面的加载速度，出现了CSS精灵技术。\r\n\r\n## 2：精灵图的核心原理\r\n将网页中的一些小的背景图片，整合到一张大图中，这样服务器只需要一次请求就可以了。\r\n\r\n## 3: 精灵技术的目的\r\n有效的减少服务器接收和发送请求的次数，提高页面的加载速度。\r\n\r\n## 4：使用精灵图的注意事项\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005113730.png)\r\n\r\n## 5：精灵图核心总结\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005113800.png)\r\n\r\n## 6：精灵图的使用\r\n* 使用FireWorks软件测出需要的小图片的大小和X,Y值然后使用background :url添加。\r\n* 使用background: position填上坐标即可。\r\n\r\n## FireWorks使用步骤\r\n* 打开图片\r\n* 锁定图层\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005114024.png)\r\n\r\n* 使用切片工具，圈出你想要的精灵图\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005114051.png)\r\n\r\n* 查看宽高与X,Y\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005114112.png)\r\n\r\n## 王者荣耀精灵图示例代码\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <style>\r\n        .box1 {\r\n            width: 58px;\r\n            height: 58px;\r\n            /* background-color: aqua; */\r\n            margin: 100px auto;\r\n            background: url(images/sprites.png);\r\n            /* X轴 与 Y轴 */\r\n            background-position: -184px 0;\r\n        }\r\n        .box2 {\r\n            width: 25px;\r\n            height: 25px;\r\n            margin: 0 auto;\r\n            background: url(images/sprites.png);\r\n            /* X轴 与 Y轴 */\r\n            background-position: -156px -106px;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"box1\">\r\n\r\n    </div>\r\n    <div class=\"box2\"></div>\r\n</body>\r\n</html>\r\n```\r\n\r\n## 效果展示\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005114217.png)\r\n\r\n## 使用精灵图拼出自己的名字\r\n\r\n### 精灵图展示\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005114248.png)\r\n\r\n## 代码展示\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <style>\r\n        .name {\r\n            width: 660px;\r\n            margin: 100px auto;\r\n        }\r\n        span {\r\n            display: inline-block;\r\n            width: 106px;\r\n            height: 111px;\r\n            background: url(images/abcd.jpg);\r\n        }\r\n        .j {\r\n            /* margin-left: 50%; */\r\n            background-position: -389px -139px;\r\n        }\r\n        .u {\r\n            background-position: -475px -419px;\r\n        }\r\n        .s {\r\n            background-position: -254px -413px;\r\n        }\r\n        .t {\r\n            background-position: -368px -408px;\r\n        }\r\n        .i {\r\n            width: 63px;\r\n            height: 108px;\r\n            background-position: -325px -140px;\r\n        }\r\n        .n {\r\n            background-position: -252px -271px;\r\n        }\r\n\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"name\">\r\n        <span class=\"j\"></span>\r\n        <span class=\"u\"></span>\r\n        <span class=\"s\"></span>\r\n        <span class=\"t\"></span>\r\n        <span class=\"i\"></span>\r\n        <span class=\"n\"></span>\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n\r\n## 效果展示\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005114345.png)"
    },
    {
      "id": "/前端知识学习33——字体图标",
      "metadata": {
        "permalink": "/blog/前端知识学习33——字体图标",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习33——字体图标.md",
        "source": "@site/blog\\前端知识学习33——字体图标.md",
        "title": "前端知识学习33——字体图标",
        "description": "1：字体图标的产生",
        "date": "2020-10-05T00:00:00.000Z",
        "formattedDate": "2020年10月5日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 0.97,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习33——字体图标",
          "date": "2020-10-05T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "前端知识学习32——精灵图",
          "permalink": "/blog/前端知识学习32——精灵图"
        },
        "nextItem": {
          "title": "前端知识学习34——CSS三角",
          "permalink": "/blog/前端知识学习34——CSS三角"
        }
      },
      "content": "## 1：字体图标的产生\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005114504.png)\r\n\r\n## 2：字体图标的优点\r\n* 轻量级\r\n* 灵活性\r\n* 兼容性\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005114535.png)\r\n\r\n## 3：字体图标的使用步骤\r\n* 1：字体图标的下载\r\n* 2：字体图标的引入\r\n* 3：字体图标的追加\r\n\r\n## 4：字体图标的下载\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005114735.png)\r\n\r\n> 推荐第二个\r\n\r\n## 5：字体图标的引入\r\n>以阿里iconfont库为例\r\n\r\n* 首先选中图标，所有图标库\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005114832.png)\r\n\r\n* 选中你想要的图标，然后下载代码\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005114856.png)\r\n\r\n* 将压缩包解压，然后改个名字（这个无所谓的），放到和我们html文档的同一级目录，在html页面中引入。\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005115019.png)\r\n\r\n从iconfont.css文件中将类名进行导入，即可实现可视化。\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005115108.png)\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005115119.png)\r\n\r\n## 参考视频\r\n[参考视频](https://www.bilibili.com/video/BV1NA411e7kD?from=search&seid=1916568929390771025)"
    },
    {
      "id": "/前端知识学习34——CSS三角",
      "metadata": {
        "permalink": "/blog/前端知识学习34——CSS三角",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习34——CSS三角.md",
        "source": "@site/blog\\前端知识学习34——CSS三角.md",
        "title": "前端知识学习34——CSS三角",
        "description": "1：设置盒子的宽高为0",
        "date": "2020-10-05T00:00:00.000Z",
        "formattedDate": "2020年10月5日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 0.32,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习34——CSS三角",
          "date": "2020-10-05T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "前端知识学习33——字体图标",
          "permalink": "/blog/前端知识学习33——字体图标"
        },
        "nextItem": {
          "title": "前端知识学习35——用户界面样式",
          "permalink": "/blog/前端知识学习35——用户界面样式"
        }
      },
      "content": "## 1：设置盒子的宽高为0\r\n\r\n## 2：设置border的上下左右 颜色为透明\r\n\r\n## 3：想要箭头向右的三角形\r\n```css\r\nboder-left: 10px sloid red\r\n```\r\n\r\n## 代码\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005115532.png)\r\n\r\n## 实际效果图\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005115548.png)\r\n\r\n## 京东CSS三角实现\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005115607.png)\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005115613.png)"
    },
    {
      "id": "/前端知识学习35——用户界面样式",
      "metadata": {
        "permalink": "/blog/前端知识学习35——用户界面样式",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习35——用户界面样式.md",
        "source": "@site/blog\\前端知识学习35——用户界面样式.md",
        "title": "前端知识学习35——用户界面样式",
        "description": "1：鼠标样式",
        "date": "2020-10-05T00:00:00.000Z",
        "formattedDate": "2020年10月5日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 0.37,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习35——用户界面样式",
          "date": "2020-10-05T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "前端知识学习34——CSS三角",
          "permalink": "/blog/前端知识学习34——CSS三角"
        },
        "nextItem": {
          "title": "前端知识学习36——Vertical-align属性应用",
          "permalink": "/blog/前端知识学习36——Vertical-align属性应用"
        }
      },
      "content": "## 1：鼠标样式\r\n>设置在对象上移动的鼠标指针采用何种系统预定义的样式。\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005115936.png)\r\n\r\n## 2：表单轮廓\r\n取消表单轮廓\r\n```CSS\r\ninput {\r\n    /* 取消表单轮廓 */\r\n    outline: none;\r\n}\r\n```\r\n\r\n## 3：防止拖拽文本域\r\n```CSS\r\ntextarea {\r\n    resize: none;\r\n}\r\n```"
    },
    {
      "id": "/前端知识学习36——Vertical-align属性应用",
      "metadata": {
        "permalink": "/blog/前端知识学习36——Vertical-align属性应用",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习36——Vertical-align属性应用.md",
        "source": "@site/blog\\前端知识学习36——Vertical-align属性应用.md",
        "title": "前端知识学习36——Vertical-align属性应用",
        "description": "1：应用场景",
        "date": "2020-10-05T00:00:00.000Z",
        "formattedDate": "2020年10月5日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 0.805,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习36——Vertical-align属性应用",
          "date": "2020-10-05T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "前端知识学习35——用户界面样式",
          "permalink": "/blog/前端知识学习35——用户界面样式"
        },
        "nextItem": {
          "title": "前端知识学习37——溢出的文字省略号显示",
          "permalink": "/blog/前端知识学习37——溢出的文字省略号显示"
        }
      },
      "content": "## 1：应用场景\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005161756.png)\r\n\r\n>认识底线，基线，中线，和顶线。（图片和文字默认的是基线对齐）\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005161844.png)\r\n\r\n## 2：主要使用场景\r\n>让文字和图片对齐\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005161945.png)\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005162124.png)\r\n\r\n`代码`\r\n```css\r\nvertical-align: middle;\r\n```\r\n\r\n## 3：图片底侧有空白区域的解决方案\r\n>问题描述：给img标签加上父盒子，并且给这个父盒子边框，我们发现图片底侧是有一部分空白的区域。\r\n\r\n* 解决方案1：给img标签加上vertical-align: bottom\r\n* 解决方案2：给img标签加上vertical-align: middle\r\n* 解决方案3：将img标签转换为块级元素 display: block"
    },
    {
      "id": "/前端知识学习37——溢出的文字省略号显示",
      "metadata": {
        "permalink": "/blog/前端知识学习37——溢出的文字省略号显示",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习37——溢出的文字省略号显示.md",
        "source": "@site/blog\\前端知识学习37——溢出的文字省略号显示.md",
        "title": "前端知识学习37——溢出的文字省略号显示",
        "description": "1：需求描述",
        "date": "2020-10-05T00:00:00.000Z",
        "formattedDate": "2020年10月5日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 0.42,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习37——溢出的文字省略号显示",
          "date": "2020-10-05T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "前端知识学习36——Vertical-align属性应用",
          "permalink": "/blog/前端知识学习36——Vertical-align属性应用"
        },
        "nextItem": {
          "title": "前端知识学习38——常见的布局技巧",
          "permalink": "/blog/前端知识学习38——常见的布局技巧"
        }
      },
      "content": "## 1：需求描述\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005162755.png)\r\n\r\n## 2：单行文本溢出显示省略号\r\n>必须满足三个条件\r\n\r\n* 1：强制在一行内显示文本: white-space :nowrap;\r\n* 2：超出的部分隐藏: overflow: hidden\r\n* 3：文字用省略号替代超出的部分：text-overflow:ellipsis;\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005163032.png)\r\n\r\n## 3：多行文本溢出显示省略号\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005163124.png)\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005163136.png)"
    },
    {
      "id": "/前端知识学习38——常见的布局技巧",
      "metadata": {
        "permalink": "/blog/前端知识学习38——常见的布局技巧",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习38——常见的布局技巧.md",
        "source": "@site/blog\\前端知识学习38——常见的布局技巧.md",
        "title": "前端知识学习38——常见的布局技巧",
        "description": "1：margin负值的巧妙运用",
        "date": "2020-10-05T00:00:00.000Z",
        "formattedDate": "2020年10月5日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 2.15,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习38——常见的布局技巧",
          "date": "2020-10-05T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "前端知识学习37——溢出的文字省略号显示",
          "permalink": "/blog/前端知识学习37——溢出的文字省略号显示"
        },
        "nextItem": {
          "title": "前端知识学习39——CSS绘制梯形",
          "permalink": "/blog/前端知识学习39——CSS绘制梯形"
        }
      },
      "content": "## 1：margin负值的巧妙运用\r\n### 1.1 为了防止两个盒子都加上边框，此时颜色变粗的情况\r\n>可以给每一个盒子加上margin-left:-1px;\r\n\r\n### 1.2 让每一个鼠标经过的盒子的边框都显示出边框的颜色\r\n* 盒子没有定位的情况下：加上相对定位，因为相对定位提高了一个层级，会压住其他盒子。\r\n* 盒子有定位的情况下：使用层叠顺序z-index: 1\r\n\r\n## 2：文字环绕浮动巧妙运用\r\n>浮动的元素不会压住下面的文字\r\n\r\n* 需求图：\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005164152.png)\r\n\r\n`代码`\r\n```css\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <style>\r\n        * {\r\n            margin: 0;\r\n            padding: 0;\r\n        }\r\n        .box {\r\n            width: 300px;\r\n            height: 70px;\r\n            background-color: #fff;\r\n            margin: 0 auto;\r\n            padding: 5px;\r\n        }\r\n        .pic {\r\n            float: left;\r\n            width: 120px;\r\n            height: 60px;\r\n            margin-right: 5px;\r\n        }\r\n        .pic img {\r\n            width: 100%;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"box\">\r\n        <div class=\"pic\">\r\n            <img src=\"images/img.png\" alt=\"\">\r\n        </div>\r\n        <p>【集锦】热身赛-巴西0-1秘鲁 内马尔替补两人血染赛场</p>\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n\r\n## 3：行内块巧妙运用\r\n>需求图：\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005164326.png)\r\n\r\n>注意事项：\r\n* 行内块元素之间本身就有一定的距离。\r\n* 1：首先将a标签转换为行内块元素\r\n* 2：设置水平居中和垂直居中\r\n* 3：对“上一页”和“下一页”单独设置宽度\r\n\r\n## 代码\r\n```css\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <style>\r\n        .box {\r\n            text-align: center;\r\n        }\r\n        .box a {\r\n            display: inline-block;\r\n            width: 36px;\r\n            height: 36px;\r\n            background-color: #f7f7f7;\r\n            border: 1px solid #ccc;\r\n            text-decoration: none;\r\n            /* 水平居中 */\r\n            text-align: center;\r\n            /* 垂直居中 */\r\n            line-height: 36px;\r\n            color: #333;\r\n            font-size: 14px;\r\n\r\n        }\r\n        .box .prev,\r\n        .box .next {\r\n            width: 63px;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"box\">\r\n        <a href=\"#\" class=\"next\">&gt;&gt;下一页</a>\r\n        <a href=\"#\">2</a>\r\n        <a href=\"#\">3</a>\r\n        <a href=\"#\">4</a>\r\n        <a href=\"#\">5</a>\r\n        <a href=\"#\">6</a>\r\n        <a href=\"#\">7</a>\r\n        <a href=\"#\" class=\"prev\">&lt;&lt;上一页</a>\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n## 实现效果\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005164609.png)"
    },
    {
      "id": "/前端知识学习39——CSS绘制梯形",
      "metadata": {
        "permalink": "/blog/前端知识学习39——CSS绘制梯形",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习39——CSS绘制梯形.md",
        "source": "@site/blog\\前端知识学习39——CSS绘制梯形.md",
        "title": "前端知识学习39——CSS绘制梯形",
        "description": "1：制作一个直角三角形",
        "date": "2020-10-05T00:00:00.000Z",
        "formattedDate": "2020年10月5日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 1.15,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习39——CSS绘制梯形",
          "date": "2020-10-05T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "前端知识学习38——常见的布局技巧",
          "permalink": "/blog/前端知识学习38——常见的布局技巧"
        },
        "nextItem": {
          "title": "前端知识学习40——Html5新特性",
          "permalink": "/blog/前端知识学习40——Html5新特性"
        }
      },
      "content": "## 1：制作一个直角三角形\r\n### 实现步骤\r\n* 将原本大盒子的宽度和高度都设置为0\r\n* 给每一个边都设置px\r\n* 将下边和左边的边框的宽度设置为0\r\n* 将上边的宽度设置更大一些，并且将颜色设置为透明\r\n\r\n### 实现代码\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005165424.png)\r\n\r\n### 实现效果图\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005165451.png)\r\n\r\n## 2：梯形的实现步骤\r\n\r\n### 效果图展示\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005165544.png)\r\n\r\n### 代码\r\n```css\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <style>\r\n        .box {\r\n            width: 0;\r\n            height: 0;\r\n            border-width: 100px 50px 0 0;\r\n            border-color: transparent red transparent transparent;\r\n            border-style: solid;\r\n        }\r\n        .price {\r\n            width: 160px;\r\n            height: 24px;\r\n            line-height: 24px;\r\n            border: 1px solid red;\r\n            margin: 0 auto;\r\n        }\r\n        .miaosha {\r\n            position: relative;\r\n            float: left;\r\n            width: 90px;\r\n            height: 100%;\r\n            background-color: red;\r\n            text-align: center;\r\n            color: #fff;\r\n            font-weight: 700;\r\n        }\r\n        .miaosha i {\r\n            position: absolute;\r\n            right: 0;\r\n            width: 0;\r\n            height: 0;\r\n            border-color: transparent #fff transparent transparent;\r\n            border-width: 24px 12px 0 0;\r\n            border-style: solid;\r\n        }\r\n        .orign {\r\n            font-size: 12px;\r\n            color: gray;\r\n            text-decoration: line-through;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"box\"></div>\r\n    <div class=\"price\">\r\n        <span class=\"miaosha\">￥1650\r\n            <i></i>\r\n        </span>\r\n        <span class=\"orign\">￥5650</span>\r\n    </div>\r\n</body>\r\n</html>\r\n```"
    },
    {
      "id": "/前端知识学习40——Html5新特性",
      "metadata": {
        "permalink": "/blog/前端知识学习40——Html5新特性",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习40——Html5新特性.md",
        "source": "@site/blog\\前端知识学习40——Html5新特性.md",
        "title": "前端知识学习40——Html5新特性",
        "description": "1：新增语义化标签",
        "date": "2020-10-05T00:00:00.000Z",
        "formattedDate": "2020年10月5日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 1.61,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习40——Html5新特性",
          "date": "2020-10-05T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "前端知识学习39——CSS绘制梯形",
          "permalink": "/blog/前端知识学习39——CSS绘制梯形"
        },
        "nextItem": {
          "title": "Word中有序编号第二行顶格的设置方法",
          "permalink": "/blog/Word中有序编号第二行顶格的设置方法"
        }
      },
      "content": "## 1：新增语义化标签\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005165759.png)\r\n\r\n## 2：新增视频标签\r\n### 注意事项\r\n* 1：尽量使用mp4格式\r\n* 2：假如给video标签设置宽高不起作用的话，可以给其设置一个父盒子，然后给父盒子指定宽高。\r\n\r\n### 常见属性\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005165932.png)\r\n\r\n* 谷歌浏览器的自动播放被禁了，要想自动播放必须加上muted属性，也就是说必须静音播放。\r\n* poster属性是当用户在进行加载等待的时候显示的画面。\r\n* controls是显示控件\r\n\r\n## 3：新增音频标签（audio）\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005170237.png)\r\n\r\n## 4：新增input属性\r\n>下列的属性必须放在form表单中。\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005170315.png)\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005170336.png)\r\n\r\n## 5：新增表单属性\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201005170352.png)\r\n\r\n* 1：required属性表示，当用户输入为空的时候，提示用户必须输入内容。\r\n* 2：placehold属性，表示当用户输入前表单里的提示内容。\r\n* 3：autofocus属性，表示用户刷新界面后，光标直接定位到表单中。\r\n* 4：autocomplete属性默认是打开的，也就是说记录用户提交的内容，当用户下次提交的时候，自动进行提示，当使用autocomplete= \"off\"的时候可以关闭。（此时的input标签必须有name）\r\n* 5：multiple属性可以让用户一次提交多个文件。"
    },
    {
      "id": "/Word中有序编号第二行顶格的设置方法",
      "metadata": {
        "permalink": "/blog/Word中有序编号第二行顶格的设置方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Word中有序编号第二行顶格的设置方法.md",
        "source": "@site/blog\\Word中有序编号第二行顶格的设置方法.md",
        "title": "Word中有序编号第二行顶格的设置方法",
        "description": "如何让word中有序编号第二行顶格？",
        "date": "2020-10-04T00:00:00.000Z",
        "formattedDate": "2020年10月4日",
        "tags": [
          {
            "label": "Word",
            "permalink": "/blog/tags/word"
          }
        ],
        "readingTime": 0.39,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Word中有序编号第二行顶格的设置方法",
          "date": "2020-10-04T00:00:00.000Z",
          "categories": "Word",
          "tags": [
            "Word"
          ]
        },
        "prevItem": {
          "title": "前端知识学习40——Html5新特性",
          "permalink": "/blog/前端知识学习40——Html5新特性"
        },
        "nextItem": {
          "title": "摘要的四个组成要素",
          "permalink": "/blog/摘要的四个组成要素"
        }
      },
      "content": "## 如何让word中有序编号第二行顶格？\r\n效果图如下：\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201004102827.png)\r\n\r\n## 解决步骤\r\n* 1：选中相关文本，点击 调整列表缩进\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201004102930.png)\r\n\r\n* 2：将文本缩进置为0\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201004103037.png)\r\n\r\n### 参考博客\r\n[Word技巧：如何让带编号的段落第二行顶头排版？](https://www.jianshu.com/p/9e9f547e65b2)"
    },
    {
      "id": "/摘要的四个组成要素",
      "metadata": {
        "permalink": "/blog/摘要的四个组成要素",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/摘要的四个组成要素.md",
        "source": "@site/blog\\摘要的四个组成要素.md",
        "title": "摘要的四个组成要素",
        "description": "摘要的四个组成要素",
        "date": "2020-10-04T00:00:00.000Z",
        "formattedDate": "2020年10月4日",
        "tags": [
          {
            "label": "论文",
            "permalink": "/blog/tags/论文"
          }
        ],
        "readingTime": 0.18,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "摘要的四个组成要素",
          "date": "2020-10-04T00:00:00.000Z",
          "categories": "论文",
          "tags": [
            "论文"
          ]
        },
        "prevItem": {
          "title": "Word中有序编号第二行顶格的设置方法",
          "permalink": "/blog/Word中有序编号第二行顶格的设置方法"
        },
        "nextItem": {
          "title": "前端知识学习29——CSS之定位",
          "permalink": "/blog/前端知识学习29——CSS之定位"
        }
      },
      "content": "## 摘要的四个组成要素\r\n* 1：背景介绍\r\n* 2：方法介绍\r\n* 3：实验结果\r\n* 4：总结\r\n\r\n## 摘要实例（英文版）\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20201004160600.png)"
    },
    {
      "id": "/前端知识学习29——CSS之定位",
      "metadata": {
        "permalink": "/blog/前端知识学习29——CSS之定位",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习29——CSS之定位.md",
        "source": "@site/blog\\前端知识学习29——CSS之定位.md",
        "title": "前端知识学习29——CSS之定位",
        "description": "1：为什么需要定位？",
        "date": "2020-09-26T00:00:00.000Z",
        "formattedDate": "2020年9月26日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 4.54,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习29——CSS之定位",
          "date": "2020-09-26T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "摘要的四个组成要素",
          "permalink": "/blog/摘要的四个组成要素"
        },
        "nextItem": {
          "title": "前端知识学习30——淘宝焦点图布局",
          "permalink": "/blog/前端知识学习30——淘宝焦点图布局"
        }
      },
      "content": "## 1：为什么需要定位？\r\n>定位可以让盒子自由的在某个盒子内部移动位置，或者固定在屏幕的某一个位置，并且可以压住其他盒子。\r\n\r\n## 2：定位的组成\r\n```\r\n定位 = 定位模式 + 边偏移\r\n```\r\n## 2.1：定位模式\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200926165020.png)\r\n\r\n## 2.2：边偏移\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200926165048.png)\r\n\r\n## 3：静态定位\r\n* 静态定位 = 无定位（不需要边偏移）\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200926165137.png)\r\n\r\n## 4：相对定位\r\n>相对定位的三个特点：\r\n\r\n* 相对定位是相对自身原本的位置进行移动，x轴和y轴都是参照原本的位置进行移动的。\r\n* 相对定位是不脱离标准流的，移动后原本的位置继续占用。\r\n* 相对定位会使得元素提升一个等级，也就是说如果和别的元素重叠的话，会盖住别的元素。\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200926165415.png)\r\n\r\n## 5：绝对定位\r\n* 绝对定位是相对于它的祖先元素而言的，假如祖先元素没有定位，或者没有祖先元素，则是以浏览器为参照点的。\r\n* 如果祖先元素有定位（固定，绝对，相对定位等），则以最近一级的父元素为参考点。\r\n* 绝对定位脱离标准流，不在占有原来的位置。\r\n* 绝对定位会使得行内元素变为块元素，可以给宽高。\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200926165905.png)\r\n\r\n## 6：什么时候用绝对定位，什么时候用相对定位？\r\n> 子级要是绝对定位的话，父级用相对定位。子级采用绝对定位的原因在于子级不能占用位置，而父级采用相对定位的原因在于父级要占用位置。这就是子绝父相的由来。\r\n\r\n`记住口诀：子绝父相`\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200926170418.png)\r\n\r\n## 7：固定定位\r\n>固定定位就是你的鼠标移动，但是某一元素依然在固定的位置上。\r\n\r\n**特点：**\r\n* 以浏览器的可视窗口为参照点。\r\n* 与父元素没有任何关系\r\n* 不随着浏览器的滚动条而滚动\r\n* 固定定位不占用原来的位置，相当于一种绝对定位。\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200926170655.png)\r\n\r\n## 8：固定定位小技巧：固定到版心的右侧\r\n>算法：先让固定定位走到浏览器可视窗口的一半，然后margin-left: \r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200926170836.png)\r\n\r\n## 9：粘性定位\r\n>粘性定位是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。粘性定位的父盒子不能设置以下几种情况：\r\n\r\n* 父元素不能设置overflow: hidden或者overflow: auto属性。\r\n* 必须指定 边偏移\r\n* 父元素的高度不能低于sticky元素的高度\r\n* sticky元素仅在其父元素内生效\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200926171223.png)\r\n\r\n## 10：定位总结\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200926171245.png)\r\n\r\n## 11：定位的叠放顺序\r\n>假如，两个定位相遇就会遇到一个谁在上面的问题，这就涉及到一个叠放顺序的问题。\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200926171349.png)\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200926171359.png)\r\n\r\n## 12：定位的特殊特性\r\n* 1：行内元素加上固定定位或者绝对定位，可以设置宽高。\r\n* 2：块级元素如果设置固定定位或者绝对定位，如果不给宽高，默认是内容的大小。\r\n* 3：脱离标准流的盒子，不会触发外边距合并的问题（浮动，绝对定位，固定定位）\r\n* 4：浮动元素会压住下面标准流的盒子，但是不会压住下面的文字，这也就是浮动设置的初衷是为了方便文字环绕的实现。\r\n* 5：绝对定位或者固定定位会压住下面标准流的所有内容。\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200926171954.png)"
    },
    {
      "id": "/前端知识学习30——淘宝焦点图布局",
      "metadata": {
        "permalink": "/blog/前端知识学习30——淘宝焦点图布局",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习30——淘宝焦点图布局.md",
        "source": "@site/blog\\前端知识学习30——淘宝焦点图布局.md",
        "title": "前端知识学习30——淘宝焦点图布局",
        "description": "1：布局分析",
        "date": "2020-09-26T00:00:00.000Z",
        "formattedDate": "2020年9月26日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 1.1,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习30——淘宝焦点图布局",
          "date": "2020-09-26T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "前端知识学习29——CSS之定位",
          "permalink": "/blog/前端知识学习29——CSS之定位"
        },
        "nextItem": {
          "title": "前端知识学习31——元素的显示与隐藏",
          "permalink": "/blog/前端知识学习31——元素的显示与隐藏"
        }
      },
      "content": "## 1：布局分析\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200926173758.png)\r\n\r\n## 2：代码\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <style>\r\n        * {\r\n            margin: 0;\r\n            padding: 0;\r\n        }\r\n        li {\r\n            list-style: none;\r\n        }\r\n        .tb-promo {\r\n            position: relative;\r\n            width: 520px;\r\n            height: 280px;\r\n            background-color: aqua;\r\n            margin: 100px auto;\r\n        }\r\n        .prev {\r\n            position: absolute;\r\n            left: 0;\r\n            top: 50%;\r\n            width: 20px;\r\n            height: 30px;\r\n            background-color: rgba(0,0,0,0.3);\r\n            margin-top: -15px;\r\n            text-align: center;\r\n            line-height: 30px;\r\n            text-decoration: none;\r\n            color: #fff;\r\n            border-top-right-radius: 15px;\r\n            border-bottom-right-radius: 15px;\r\n        }\r\n        .next {\r\n            position: absolute;\r\n            right: 0;\r\n            top: 50%;\r\n            width: 20px;\r\n            height: 30px;\r\n            background-color: rgba(0,0,0,0.3);\r\n            margin-top: -15px;\r\n            text-align: center;\r\n            line-height: 30px;\r\n            text-decoration: none;\r\n            color: #fff;\r\n            border-top-left-radius: 15px;\r\n            border-bottom-left-radius: 15px;\r\n        }\r\n        .promo-nav {\r\n            position: absolute;\r\n            bottom: 15px;\r\n            left: 50%;\r\n            background-color: aqua;\r\n            width: 70px;\r\n            height: 13px;\r\n            margin-left: -35px;\r\n            /*白色半透明*/\r\n            background-color: rgba(255,255,255,0.3);\r\n            border-radius: 7px;\r\n        }\r\n        .promo-nav li {\r\n            float: left;\r\n            width: 8px;\r\n            height: 8px;\r\n            background-color: #fff;\r\n            border-radius: 50%;\r\n            margin: 3px;\r\n        }\r\n        .promo-nav .selected {\r\n            background-color: orange;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <!-- 大盒子 -->\r\n    <div class=\"tb-promo\">\r\n        <img src=\"images/爱上潮流名店.jpg\" alt=\"\">\r\n        <!-- 左侧按钮 -->\r\n        <a href=\"#\" class=\"prev\"> &lt; </a>\r\n        <!-- 右侧按钮 -->\r\n        <a href=\"#\" class=\"next\"> &gt; </a>\r\n        <!-- 小圆点 -->\r\n        <ul class=\"promo-nav\">\r\n            <li class=\"selected\"></li>\r\n            <li></li>\r\n            <li></li>\r\n            <li></li>\r\n            <li></li>\r\n        </ul>\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n## 3：示例图\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200926173939.png)"
    },
    {
      "id": "/前端知识学习31——元素的显示与隐藏",
      "metadata": {
        "permalink": "/blog/前端知识学习31——元素的显示与隐藏",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习31——元素的显示与隐藏.md",
        "source": "@site/blog\\前端知识学习31——元素的显示与隐藏.md",
        "title": "前端知识学习31——元素的显示与隐藏",
        "description": "1：display",
        "date": "2020-09-26T00:00:00.000Z",
        "formattedDate": "2020年9月26日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 0.91,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习31——元素的显示与隐藏",
          "date": "2020-09-26T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "前端知识学习30——淘宝焦点图布局",
          "permalink": "/blog/前端知识学习30——淘宝焦点图布局"
        },
        "nextItem": {
          "title": "前端知识学习28——学成在线首页案例",
          "permalink": "/blog/前端知识学习28——学成在线首页案例"
        }
      },
      "content": "## 1：display\r\n* display: none\r\n隐藏所在元素，不占位置。\r\n\r\n* display: block\r\n转换为块级元素，同时显示元素。\r\n\r\n## 2：visibility\r\n* visibility: visible\r\n元素可视\r\n\r\n* visibility: hidden\r\n元素隐藏，继续占有位置\r\n\r\n## 3：overflow\r\n* overflow: hidden\r\n溢出隐藏\r\n\r\n* overflow：scroll\r\n溢出的部分可以使用滚动条进行滚动\r\n\r\n* overflow: auto \r\n溢出的时候，显示滚动条，不溢出的时候，不显示滚动条。\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200926174900.png)\r\n\r\n## 代码展示\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <style>\r\n        .tudou {\r\n            position: relative;\r\n            width: 444px;\r\n            height: 320px;\r\n            background-color: aqua;\r\n            margin: 30px auto;\r\n\r\n        }\r\n        .tudou img {\r\n            width: 100%;\r\n            height: 100%;\r\n        }\r\n        .mask {\r\n            visibility: hidden;\r\n            position: absolute;\r\n            width: 100%;\r\n            height: 100%;\r\n            background: rgba(0,0,0,0.3) url(images/arr.png) center no-repeat\r\n        }\r\n        .tudou:hover .mask {\r\n            visibility: visible;    \r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"tudou\">\r\n        <div class=\"mask\"></div>\r\n        <img src=\"images/tudou.jpg\" alt=\"\">\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n## 效果图\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200926175031.png)"
    },
    {
      "id": "/前端知识学习28——学成在线首页案例",
      "metadata": {
        "permalink": "/blog/前端知识学习28——学成在线首页案例",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习28——学成在线首页案例.md",
        "source": "@site/blog\\前端知识学习28——学成在线首页案例.md",
        "title": "前端知识学习28——学成在线首页案例",
        "description": "1：html代码",
        "date": "2020-09-07T00:00:00.000Z",
        "formattedDate": "2020年9月7日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 10.485,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习28——学成在线首页案例",
          "date": "2020-09-07T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "前端知识学习31——元素的显示与隐藏",
          "permalink": "/blog/前端知识学习31——元素的显示与隐藏"
        },
        "nextItem": {
          "title": "嵌套块元素塌陷问题",
          "permalink": "/blog/嵌套块元素塌陷问题"
        }
      },
      "content": "## 1：html代码\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>学成在线首页</title>\r\n    <link rel=\"stylesheet\" href=\"style.css\">\r\n    \r\n</head>\r\n<body>\r\n    <!-- 头部区域开始了 -->\r\n    <div class=\"header w\">\r\n        <div class=\"logo\">\r\n            <img src=\"images/logo.png\" alt=\"\">\r\n        </div>\r\n        <!-- 导航栏部分 -->\r\n        <div class=\"nav\">\r\n            <ul>\r\n                <li><a href=\"#\">首页</a></li>\r\n                <li><a href=\"#\">课程</a></li>\r\n                <li><a href=\"#\">职业规划</a></li>\r\n            </ul>\r\n        </div>\r\n        <!-- 搜索模块 -->\r\n        <div class=\"search\">\r\n            <input type=\"text\" value=\"输入关键词\">\r\n            <button><img src=\"images/fa-search.png\" height=\"42px\" alt=\"\"></button>\r\n        </div>\r\n        <!-- 用户模块 -->\r\n        <div class=\"user\">\r\n            <img src=\"images/20130502185029_EkKYh拷贝.png\" alt=\"\">\r\n            qq-Justin\r\n        </div>\r\n    </div>\r\n    <!-- 头部区域结束了 -->\r\n    \r\n    <!-- banner部分开始了 -->\r\n    <div class=\"banner\">\r\n        <!-- 版心 -->\r\n        <div class=\"w\">\r\n            <div class=\"subnav\">\r\n                <ul>\r\n                    <li><a href=\"#\">前端开发<span>></span></a></li>\r\n                    <li><a href=\"#\">后端开发<span>></span></a></li>\r\n                    <li><a href=\"#\">移动开发<span>></span></a></li>\r\n                    <li><a href=\"#\">人工智能<span>></span></a></li>\r\n                    <li><a href=\"#\">商业预测<span>></span></a></li>\r\n                    <li><a href=\"#\">云计算&大数据<span>></span></a></li>\r\n                    <li><a href=\"#\">运维&测试<span>></span></a></li>\r\n                    <li><a href=\"#\">UI设计<span>></span></a></li>\r\n                    <li><a href=\"#\">产品<span>></span></a></li>\r\n                </ul>\r\n            </div>\r\n            <!-- 课程模块 -->\r\n            <div class=\"course\">\r\n                <h2>我的课程表</h2>\r\n                <div class=\"body\">\r\n                    <ul>\r\n                        <li>\r\n                            <h4>继续学习 程序语言设计</h4>\r\n                            <p>正在学习-使用对象</p>\r\n                        </li>\r\n                        <li>\r\n                            <h4>继续学习 程序语言设计</h4>\r\n                            <p>正在学习-使用对象</p>\r\n                        </li>\r\n                        <li>\r\n                            <h4>继续学习 程序语言设计</h4>\r\n                            <p>正在学习-使用对象</p>\r\n                        </li>\r\n                        <a href=\"#\" class=\"more\">全部课程</a>\r\n                    </ul>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n    <!-- banner部分结束了 -->\r\n\r\n    <!-- 精品推荐模块开始了 -->\r\n    <div class=\"goods w\">\r\n        <h3>精品推荐</h3>\r\n        <ul>\r\n            <li><a href=\"#\">JQuery</a></li>\r\n            <li><a href=\"#\">Spark</a></li>\r\n            <li><a href=\"#\">MySQL</a></li>\r\n            <li><a href=\"#\">JavaWeb</a></li>\r\n            <li><a href=\"#\">MySQL</a></li>\r\n            <li><a href=\"#\">JavaWeb</a></li>\r\n        </ul>\r\n        <a href=\"#\" class=\"mod\">修改兴趣</a>\r\n    </div>\r\n    <!-- 精品推荐模块结束了 -->\r\n\r\n    <!-- box核心内容开始 -->\r\n    <div class=\"box w\">\r\n        <div class=\"box-hd\">\r\n            <h3>精品推荐</h3>\r\n            <a href=\"#\">查看全部</a>\r\n        </div>\r\n        <div class=\"box-bd\">\r\n            <ul>\r\n                <li>\r\n                    <img src=\"images/图层133.png\" alt=\"\">\r\n                    <h4>\r\n                        Think PHP 5.0 博客系统实战项目演练\r\n                    </h4>\r\n                    <div class=\"info\">\r\n                        <span>高级</span>   •  1125人在学习\r\n                    </div>\r\n                </li>\r\n                <li>\r\n                    <img src=\"images/图层133.png\" alt=\"\">\r\n                    <h4>\r\n                        Think PHP 5.0 博客系统实战项目演练\r\n                    </h4>\r\n                    <div class=\"info\">\r\n                        <span>高级</span>   •  1125人在学习\r\n                    </div>\r\n                </li>\r\n                <li>\r\n                    <img src=\"images/图层133.png\" alt=\"\">\r\n                    <h4>\r\n                        Think PHP 5.0 博客系统实战项目演练\r\n                    </h4>\r\n                    <div class=\"info\">\r\n                        <span>高级</span>   •  1125人在学习\r\n                    </div>\r\n                </li>\r\n                <li>\r\n                    <img src=\"images/图层133.png\" alt=\"\">\r\n                    <h4>\r\n                        Think PHP 5.0 博客系统实战项目演练\r\n                    </h4>\r\n                    <div class=\"info\">\r\n                        <span>高级</span>   •  1125人在学习\r\n                    </div>\r\n                </li>\r\n                <li>\r\n                    <img src=\"images/图层133.png\" alt=\"\">\r\n                    <h4>\r\n                        Think PHP 5.0 博客系统实战项目演练\r\n                    </h4>\r\n                    <div class=\"info\">\r\n                        <span>高级</span>   •  1125人在学习\r\n                    </div>\r\n                </li>\r\n                <li>\r\n                    <img src=\"images/图层133.png\" alt=\"\">\r\n                    <h4>\r\n                        Think PHP 5.0 博客系统实战项目演练\r\n                    </h4>\r\n                    <div class=\"info\">\r\n                        <span>高级</span>   •  1125人在学习\r\n                    </div>\r\n                </li>\r\n                <li>\r\n                    <img src=\"images/图层133.png\" alt=\"\">\r\n                    <h4>\r\n                        Think PHP 5.0 博客系统实战项目演练\r\n                    </h4>\r\n                    <div class=\"info\">\r\n                        <span>高级</span>   •  1125人在学习\r\n                    </div>\r\n                </li>\r\n                <li>\r\n                    <img src=\"images/图层133.png\" alt=\"\">\r\n                    <h4>\r\n                        Think PHP 5.0 博客系统实战项目演练\r\n                    </h4>\r\n                    <div class=\"info\">\r\n                        <span>高级</span>   •  1125人在学习\r\n                    </div>\r\n                </li>\r\n                <li>\r\n                    <img src=\"images/图层133.png\" alt=\"\">\r\n                    <h4>\r\n                        Think PHP 5.0 博客系统实战项目演练\r\n                    </h4>\r\n                    <div class=\"info\">\r\n                        <span>高级</span>   •  1125人在学习\r\n                    </div>\r\n                </li>\r\n                <li>\r\n                    <img src=\"images/图层133.png\" alt=\"\">\r\n                    <h4>\r\n                        Think PHP 5.0 博客系统实战项目演练\r\n                    </h4>\r\n                    <div class=\"info\">\r\n                        <span>高级</span>   •  1125人在学习\r\n                    </div>\r\n                </li>\r\n            </ul>\r\n        </div>\r\n    </div>\r\n    <!-- box核心内容结束 -->\r\n\r\n    <!-- 编程入门开始 -->\r\n    <div class=\"door w\">\r\n        <div class=\"left1\">\r\n            编程入门\r\n        </div>\r\n        <div class=\"mid\">\r\n            <ul>\r\n                <li class=\"hot\">热门</li>\r\n                <li>初级</li>\r\n                <li>中级</li>\r\n                <li>高级</li>\r\n            </ul>\r\n        </div>\r\n        <div class=\"right1\">\r\n            查看全部\r\n        </div>\r\n    </div>\r\n    <!-- 编程入门结束 -->\r\n\r\n    <!-- 快乐编程板块开始 -->\r\n    <div class=\"happy w\">\r\n        <div class=\"left1\">\r\n            <img src=\"images/椭圆6拷贝16.png\" alt=\"\">\r\n        </div>\r\n        <div class=\"righttop\">\r\n            <img src=\"images/图层155.png\" alt=\"\">\r\n        </div>\r\n        <div class=\"rightbotoom\">\r\n            <ul>\r\n                <li>\r\n                    <img src=\"images/图层145.png\" alt=\"\">\r\n                    <h5>Android Hybrid APP开发实战 H5+原生！</h5>\r\n                    <p><span>高级  </span>•  1125人在学习</p>\r\n                </li>\r\n                <li>\r\n                    <img src=\"images/图层145.png\" alt=\"\">\r\n                    <h5>Android Hybrid APP开发实战 H5+原生！</h5>\r\n                    <p><span>高级  </span>•  1125人在学习</p>\r\n                </li>\r\n                <li>\r\n                    <img src=\"images/图层145.png\" alt=\"\">\r\n                    <h5>Android Hybrid APP开发实战 H5+原生！</h5>\r\n                    <p><span>高级  </span>•  1125人在学习</p>\r\n                </li>\r\n                <li>\r\n                    <img src=\"images/图层145.png\" alt=\"\">\r\n                    <h5>Android Hybrid APP开发实战 H5+原生！</h5>\r\n                    <p><span>高级  </span>•  1125人在学习</p>\r\n                </li>\r\n            </ul>\r\n        </div>\r\n    </div>\r\n    <!-- 快乐编程板块结束 -->\r\n\r\n    <!-- footer模块开始了 -->\r\n    <div class=\"footer\">\r\n        <div class=\"w\">\r\n            <div class=\"xuecheng\">\r\n                <img src=\"images/logo.png\" alt=\"\">\r\n                <p>学成在线致力于普及中国最好的教育它与中国一流大学和机构合作提供在线课程。<br>\r\n                    © 2017年XTCG Inc.保留所有权利。-沪ICP备15025210号</p>\r\n                <a href=\"#\">下载APP</a>\r\n            </div>\r\n            <div class=\"links\">\r\n                <dl>\r\n                    <dt>关于学成网</dt>\r\n                    <dd><a href=\"#\">关于</a></dd>\r\n                    <dd><a href=\"#\">管理团队</a></dd>\r\n                    <dd><a href=\"#\">工作机会</a></dd>\r\n                    <dd><a href=\"#\">客户服务</a></dd>\r\n                    <dd><a href=\"#\">帮助</a></dd>\r\n                </dl>\r\n                <dl>\r\n                    <dt>新手指南</dt>\r\n                    <dd><a href=\"#\">如何注册</a></dd>\r\n                    <dd><a href=\"#\">如何选课</a></dd>\r\n                    <dd><a href=\"#\">如何拿到毕业证</a></dd>\r\n                    <dd><a href=\"#\">学分是什么</a></dd>\r\n                    <dd><a href=\"#\">考试未通过怎么办</a></dd>\r\n                </dl>\r\n                <dl>\r\n                    <dt>合作伙伴</dt>\r\n                    <dd><a href=\"#\">合作机构</a></dd>\r\n                    <dd><a href=\"#\">合作导师</a></dd>\r\n                </dl>\r\n            </div>\r\n        </div>  \r\n    </div>\r\n    <!-- footer模块结束了 -->\r\n</body>\r\n</html>\r\n```\r\n\r\n## 2：CSS代码\r\n```css\r\n* {\r\n    margin: 0;\r\n    padding: 0;  \r\n}\r\n\r\n/* 宽度类   调用这个类可以实现宽度1200px并且居中 */\r\n.w {\r\n    width: 1200px;\r\n    margin: 0 auto;\r\n}\r\na {\r\n    text-decoration: none;\r\n}\r\nli {\r\n    list-style: none;\r\n}\r\n\r\n/* header区域 */\r\n.header {\r\n    height: 42px;\r\n    /* background-color: pink; */\r\n    margin: 30px auto;\r\n}\r\n\r\n.logo {\r\n    float: left;\r\n    width: 198px;\r\n    height: 42px;\r\n    /* background-color: purple; */\r\n}\r\n\r\n.nav {\r\n    float: left;\r\n    margin-left: 60px;\r\n}\r\n.nav ul li {\r\n    float: left;\r\n    margin: 0 11px;\r\n}\r\n\r\n.nav ul li a{\r\n    display: block;\r\n    height: 42px;\r\n    padding: 0 10px;\r\n    line-height: 42px;\r\n    font-size: 18px;\r\n    color: #050505;\r\n}\r\n\r\n.nav ul li a:hover {\r\n    border-bottom: 2px solid #00a4ff;\r\n    color: aqua\r\n}\r\nbody{\r\n    background-color: #f3f5f7;\r\n    height: 3000px;\r\n}\r\n/* 搜索模块 */\r\n.search {\r\n    float: left;\r\n    width: 411px;\r\n    height: 42px;\r\n    \r\n    background-color: aqua;\r\n    margin-left: 70px;\r\n}\r\n.search input {\r\n    float: left;\r\n    line-height: 42px;\r\n    width: 340px;\r\n    height: 40px;\r\n    border: 1px solid #00a4ff;\r\n    border-right: none;\r\n    font-size: 14px;\r\n    color: #bfbfbf;\r\n    padding-left: 20px;\r\n}\r\n\r\n.search button {\r\n    width: 50px;\r\n    height: 42px;\r\n    float: left;\r\n    border: 0;\r\n    /* background-color: blue; */\r\n}\r\n\r\n.user {\r\n    float: right;\r\n    line-height: 42px;\r\n    margin-right: 36px;\r\n    font-size: 14px;\r\n    color: #666666;\r\n}\r\n\r\n/* banner区域开始 */\r\n.banner {\r\n    height: 420px;\r\n    background-color: #1c036c;\r\n}\r\n.banner .w {\r\n    height: 420px;\r\n    /* background-color: aqua; */\r\n    background: url(images/banner2.png) no-repeat top center;\r\n}\r\n.subnav {\r\n    float: left;\r\n    width: 190px;\r\n    height: 420px;\r\n    /* 设置半透明颜色 */\r\n    background-color: rgb(0, 0, 0,0.3);\r\n}\r\n.subnav ul li {\r\n    height: 45px;\r\n    line-height: 45px;\r\n    padding: 0 20px;\r\n}\r\n.subnav ul li a {\r\n    font-size: 14px;\r\n    color: #fff;\r\n}\r\n.subnav ul li a span{\r\n    float: right;\r\n}\r\n.subnav ul li a:hover {\r\n    color: #00a4ff;\r\n}\r\n.course {\r\n    width: 230px;\r\n    height: 300px;\r\n    /* 浮动的盒子不会有外边距塌陷的问题 */\r\n    margin-top: 50px;\r\n    background-color: #fff;\r\n    float: right;\r\n}\r\n.course h2 {\r\n    font-size: 18px;\r\n    height: 48px;\r\n    background-color: #9bceea;\r\n    color: #ffffff;\r\n    text-align: center;\r\n    line-height: 48px;\r\n}\r\n.course .body {\r\n    padding: 0 20px;\r\n    background-color: #fff;\r\n}\r\n.course .body ul li {\r\n    padding: 14px 0;\r\n    border-bottom: 1px solid #ccc;\r\n}\r\n.course h4 {\r\n    font-size: 16px;\r\n    color: #4e4e4e;\r\n}\r\n.course p {\r\n    font-size: 12px;\r\n    color: #a5a5a5;\r\n}\r\n.body .more {\r\n    display: block;\r\n    font-size: 16px;\r\n    color: #00a4ff;\r\n    height: 40px;\r\n    line-height: 40px;\r\n    text-align: center;\r\n    border: 1px solid #00a4ff;\r\n    /* 加粗 */\r\n    font-weight: 700;\r\n    margin-top: 6px;\r\n}\r\n\r\n/* 精品推荐模块 */\r\n.goods {\r\n    height: 60px;\r\n    background-color: #fff;\r\n    box-shadow: 0 2px 3px 3px rgb(0, 0, 0,0.1);\r\n    margin-top: 8px;\r\n    line-height: 60px;\r\n}\r\n.goods h3 {\r\n    font-size: 16px;\r\n    color: #00a4ff;\r\n    float: left;\r\n    margin-left: 35px;\r\n    margin-right: 30px;\r\n}\r\n.goods ul li {\r\n    float: left;\r\n}\r\n.goods ul li a{\r\n    padding: 0 35px;\r\n    font-size: 16px;\r\n    color: #050505;\r\n    border-left: 1px solid #ccc;\r\n}\r\n.goods .mod {\r\n    float: right;\r\n    margin-right: 27px;\r\n    font-size: 14px;\r\n    color: #00a4ff;\r\n}\r\n\r\n.box {\r\n    margin-top: 35px;\r\n}\r\n.box .box-hd {\r\n    height: 40px;\r\n}\r\n.box .box-bd {\r\n    height: 549px;\r\n}\r\n.box .box-hd h3{\r\n    float: left;\r\n    font-size: 20px;\r\n    color: #494949;\r\n}\r\n.box .box-hd a{\r\n    float: right;\r\n    margin-top: 10px;\r\n    margin-right: 33px;\r\n    font-size: 12px;\r\n}\r\n/* 把ul修改的足够宽，这样就不会换行了 */\r\n.box-bd ul {\r\n    width: 1220px;\r\n}\r\n.box-bd ul li {\r\n    float: left;\r\n    width: 228px;\r\n    height: 271px;\r\n    background-color: #ffffff;\r\n    margin-right: 15px;\r\n    margin-bottom: 14px;\r\n}\r\n.box-bd ul li img {\r\n    width: 100%;\r\n}\r\n.box-bd ul li h4 {\r\n    font-size: 14px;\r\n    color: #050505;\r\n    margin-left: 24px;\r\n    margin-right: 20px;\r\n    margin-top: 24px;\r\n    /* 文字不加粗 */\r\n    font-weight: 400;\r\n}\r\n.box-bd ul li .info{\r\n    font-size: 12px;\r\n    color: #999999;\r\n    margin-left: 24px;\r\n    margin-right: 20px;\r\n    margin-top: 20px;\r\n}\r\n.box-bd ul li .info span{\r\n    color: #ff7c2d;\r\n}\r\n\r\n/* 编程入门模块开始了 */\r\n.door {\r\n    height: 66px;\r\n}\r\n\r\n.door .left1 {\r\n    float: left;\r\n    font-size: 20px;\r\n    color: #494949;\r\n    margin-top: 23px;\r\n}\r\n.door .mid ul {\r\n    margin-top: 23px;\r\n    margin-left: 353px;\r\n    line-height: 66px;\r\n}\r\n.door .mid ul li{\r\n    float: left;\r\n    margin-right: 70px;\r\n    font-size: 16px;\r\n    color: #868686;\r\n}\r\n.door .mid ul  .hot {\r\n    color: #00a4ff;\r\n}\r\n.door .right1 {\r\n    line-height: 66px;\r\n    float: right;\r\n    font-size: 12px;\r\n    color: #a5a5a5;\r\n    margin-right: 32px;\r\n}\r\n/* 编程入门模块结束了 */\r\n\r\n/* 快乐编程模块开始了 */\r\n.happy {\r\n    background-color: #f3f5f7;\r\n    height: 392px;\r\n}\r\n.happy .left1 {\r\n    float: left;\r\n    width: 228px;\r\n    height: 100%;\r\n    background-color: #825dc9;\r\n}\r\n.happy .righttop {\r\n    float: right;\r\n    width: 956px;\r\n    height: 100px;\r\n    background-color: #fdecdc;\r\n}\r\n\r\n.happy .rightbotoom ul li {\r\n   float: left;\r\n   width: 228px;\r\n   height: 270px;\r\n   background-color: #ffffff;\r\n   margin-left: 15px;\r\n   margin-top: 22px;\r\n}\r\n.happy .rightbotoom ul li img {\r\n    width: 100%;\r\n}\r\n.happy .rightbotoom ul li h5{\r\n    font-size: 14px;\r\n    color: #050505;\r\n    margin-left: 22px;\r\n    margin-top: 24px;\r\n}\r\n.happy .rightbotoom ul li p {\r\n    font-size: 12px;\r\n    color: #999999;\r\n    margin-left: 22px;\r\n    margin-top: 20px;\r\n}\r\n.happy .rightbotoom ul li p span {\r\n    color: #ff7c2d;\r\n}\r\n/* 快乐编程模块结束 */\r\n\r\n/* footer模块开始了 */\r\n.footer {\r\n    height: 415px;\r\n    background-color: #fff;\r\n    margin-top: 40px;\r\n    overflow: hidden;\r\n}\r\n.footer .xuecheng {\r\n    float: left;\r\n    margin-top: 32px;\r\n    padding-left: 19px;\r\n}\r\n.footer .xuecheng p {\r\n    color: #666666;\r\n    font-size: 12px;\r\n    margin-top: 24px;\r\n}\r\n.footer .xuecheng a{\r\n    display: block;\r\n    width: 120px;\r\n    height: 36px;\r\n    border: 1px solid #00a4ff;\r\n    margin-top: 17px;\r\n    line-height: 36px;\r\n    text-align: center;\r\n    color: #00a4ff;\r\n    font-size: 16px;\r\n}\r\n.footer .links {\r\n    margin-top: 34px;\r\n    margin-right: 31px;\r\n    float: right;\r\n}\r\n.footer .links dl {\r\n    float: left;\r\n    margin-left: 110px;\r\n    \r\n}\r\n.footer .links dt {\r\n    font-size: 16px;\r\n    color: #333333;\r\n    margin-bottom: 15px;\r\n}\r\n.footer .links dd {\r\n    font-size: 12px;\r\n    color: #333333;\r\n}\r\n/* footer模块结束了 */\r\n```\r\n\r\n## 3：效果图\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200907101151.png)"
    },
    {
      "id": "/嵌套块元素塌陷问题",
      "metadata": {
        "permalink": "/blog/嵌套块元素塌陷问题",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/嵌套块元素塌陷问题.md",
        "source": "@site/blog\\嵌套块元素塌陷问题.md",
        "title": "嵌套块元素塌陷问题",
        "description": "1: 子元素的外边距传递给父元素的情况",
        "date": "2020-09-07T00:00:00.000Z",
        "formattedDate": "2020年9月7日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 0.71,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "嵌套块元素塌陷问题",
          "date": "2020-09-07T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "前端知识学习28——学成在线首页案例",
          "permalink": "/blog/前端知识学习28——学成在线首页案例"
        },
        "nextItem": {
          "title": "前端知识学习19——CSS盒子模型",
          "permalink": "/blog/前端知识学习19——CSS盒子模型"
        }
      },
      "content": "## 1: 子元素的外边距传递给父元素的情况\r\n当父元素没有设置上外边距的情况下，给子元素设置上外边距，此时子元素设置的上外边距不会生效，但是父元素会生效。\r\n## 2：父元素和子元素同时设置上外边距\r\n此时父元素设置的上外边距的值是两者中较大的一个，并且给子元素设置的上外边距是无效的。\r\n## 解决方案\r\n给父元素添加以下代码\r\n```css\r\noverflow: hidden;\r\n```"
    },
    {
      "id": "/前端知识学习19——CSS盒子模型",
      "metadata": {
        "permalink": "/blog/前端知识学习19——CSS盒子模型",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习19——CSS盒子模型.md",
        "source": "@site/blog\\前端知识学习19——CSS盒子模型.md",
        "title": "前端知识学习19——CSS盒子模型",
        "description": "1.盒子模型的组成",
        "date": "2020-09-01T00:00:00.000Z",
        "formattedDate": "2020年9月1日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 2.21,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习19——CSS盒子模型",
          "date": "2020-09-01T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "嵌套块元素塌陷问题",
          "permalink": "/blog/嵌套块元素塌陷问题"
        },
        "nextItem": {
          "title": "机器学习——决策树",
          "permalink": "/blog/机器学习——决策树"
        }
      },
      "content": "## 1.盒子模型的组成\r\n```\r\n内容 + padding + border + margin\r\n```\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200530185501.png)\r\n\r\n## 2.边框\r\n### 边框的组成\r\n```\r\n边框宽度 + 边框样式 + 边框颜色\r\n```\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200530185637.png)\r\n\r\n### 边框样式\r\n* solid 实线\r\n* dashed 虚线\r\n* dotted 点线\r\n\r\n### 边框简写\r\n```\r\nborder: 5px solid red\r\n```\r\n### 细线边框\r\n```\r\nborder-collapse: collapse\r\n<!-- 让两个边框之间的线变细，这个必须在table标签中使用 -->\r\n```\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200530185927.png)\r\n\r\n## 3.内边距 padding\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200530190004.png)\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200530190010.png)\r\n\r\n> 假如盒子被内边距padding给撑大了，可以使用宽高 - 内边距的大小。来保证和效果图大小一致。\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200530190159.png)\r\n\r\n### 新浪导航栏案例\r\n#### 代码\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <style>\r\n        .nav {\r\n            border-top: 3px solid #ff8500;\r\n            border-bottom: 1px solid #edeef0;\r\n            height: 41px;\r\n            background-color: #fcfcfc;\r\n            \r\n            \r\n        }\r\n        a {\r\n            display: inline-block;\r\n            font-size: 12px;\r\n            text-decoration: none;\r\n            line-height: 41px;\r\n            color: #4c4c4c;\r\n            padding: 0 20px;\r\n        }\r\n        a:hover {\r\n            background-color: #eee;\r\n            color: red;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"nav\">\r\n        <a href=\"#\">新浪导航</a>\r\n        <a href=\"#\">手机导航网</a>\r\n        <a href=\"#\">移动客户端</a>\r\n        <a href=\"#\">微博</a>\r\n        <a href=\"#\">游戏王</a>\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n#### 应用效果\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200530190345.png)\r\n\r\n## 4.外边距 margin\r\n### 为什么需要margin?\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200530190432.png)\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200530190443.png)\r\n\r\n### 块元素水平居中\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200530190524.png)\r\n\r\n### 行内元素或者行内块元素水平居中的方法\r\n* 给其父元素添加 text-align: center\r\n\r\n### 外边距合并\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200530190643.png)\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200530190707.png)\r\n\r\n>合并受影响的是垂直方向的，水平方向的不受影响,垂直外边距的合并问题：之影响两个盒子的垂直方向，不影响水平方向，两个都是正，取较大值，一正一负进行加和，两个都是负，取绝对值较大的那个。\r\n\r\n### 嵌套块元素垂直外边距塌陷\r\n* 父元素和子元素同时有margin-top的时候，以最大的那个为准\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200530190902.png)\r\n\r\n#### 解决方案\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200530190952.png)\r\n\r\n### 清除内外边距\r\n* 在body里面写内容的时候，浏览器会默认给我们添加一个内边距和外边距\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200530191101.png)"
    },
    {
      "id": "/机器学习——决策树",
      "metadata": {
        "permalink": "/blog/机器学习——决策树",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/机器学习——决策树.md",
        "source": "@site/blog\\机器学习——决策树.md",
        "title": "机器学习——决策树",
        "description": "1：信息熵的意义",
        "date": "2020-08-29T00:00:00.000Z",
        "formattedDate": "2020年8月29日",
        "tags": [
          {
            "label": "机器学习",
            "permalink": "/blog/tags/机器学习"
          }
        ],
        "readingTime": 0.285,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "机器学习——决策树",
          "date": "2020-08-29T00:00:00.000Z",
          "categories": "机器学习",
          "tags": [
            "机器学习"
          ]
        },
        "prevItem": {
          "title": "前端知识学习19——CSS盒子模型",
          "permalink": "/blog/前端知识学习19——CSS盒子模型"
        },
        "nextItem": {
          "title": "使用正则表达式匹配CVE编号",
          "permalink": "/blog/使用正则表达式匹配CVE编号"
        }
      },
      "content": "## 1：信息熵的意义\r\n信息熵代表不确定性，信息熵越大不确定性就越大。\r\n\r\n## 2：在决策树算法中，总是选择信息增益最大的作为我们的根节点\r\n\r\n## 3："
    },
    {
      "id": "/使用正则表达式匹配CVE编号",
      "metadata": {
        "permalink": "/blog/使用正则表达式匹配CVE编号",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/使用正则表达式匹配CVE编号.md",
        "source": "@site/blog\\使用正则表达式匹配CVE编号.md",
        "title": "使用正则表达式匹配CVE编号",
        "description": "",
        "date": "2020-08-27T00:00:00.000Z",
        "formattedDate": "2020年8月27日",
        "tags": [
          {
            "label": "python",
            "permalink": "/blog/tags/python"
          }
        ],
        "readingTime": 0.015,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "使用正则表达式匹配CVE编号",
          "date": "2020-08-27T00:00:00.000Z",
          "categories": "python",
          "tags": [
            "python"
          ]
        },
        "prevItem": {
          "title": "机器学习——决策树",
          "permalink": "/blog/机器学习——决策树"
        },
        "nextItem": {
          "title": "生成2的n次方个不同的01组合",
          "permalink": "/blog/生成2的n次方个不同的01组合"
        }
      },
      "content": "```\r\nCVE-\\d{4}-\\d{4,7}\r\n```"
    },
    {
      "id": "/生成2的n次方个不同的01组合",
      "metadata": {
        "permalink": "/blog/生成2的n次方个不同的01组合",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/生成2的n次方个不同的01组合.md",
        "source": "@site/blog\\生成2的n次方个不同的01组合.md",
        "title": "生成2的n次方个不同的01组合",
        "description": "需求",
        "date": "2020-08-19T00:00:00.000Z",
        "formattedDate": "2020年8月19日",
        "tags": [
          {
            "label": "C语言",
            "permalink": "/blog/tags/c语言"
          }
        ],
        "readingTime": 0.635,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "生成2的n次方个不同的01组合",
          "date": "2020-08-19T00:00:00.000Z",
          "categories": "C语言",
          "tags": [
            "C语言"
          ]
        },
        "prevItem": {
          "title": "使用正则表达式匹配CVE编号",
          "permalink": "/blog/使用正则表达式匹配CVE编号"
        },
        "nextItem": {
          "title": "Kali-Linux-2020-2安装流程详解",
          "permalink": "/blog/Kali-Linux-2020-2安装流程详解"
        }
      },
      "content": "## 需求\r\n我们要生成2的n次方个01组合，以2的5为例我们需要生成32个不同的01组合。\r\n## 代码\r\n```c\r\n#include <stdio.h>\r\n\r\nint box[6];\r\n\r\nvoid dfs(int step) {\r\n    if(step == 6) {\r\n        for(int i = 1; i <= 5; i++) {\r\n            printf(\"%d\", box[i]);\r\n        }\r\n        printf(\"\\n\");\r\n        return;\r\n    }\r\n    for(int i = 0; i <= 1; i++) {\r\n        box[step] = i;\r\n        dfs(step + 1);\r\n    }\r\n}\r\n\r\nint main() {\r\n    dfs(1);\r\n    return 0;\r\n}\r\n```\r\n\r\n>生成2的6次方个，只用把step改为7 i<=6即可\r\n\r\n## 在线运行C语言的网站\r\n[C在线工具](https://c.runoob.com/compile/11)"
    },
    {
      "id": "/Kali-Linux-2020-2安装流程详解",
      "metadata": {
        "permalink": "/blog/Kali-Linux-2020-2安装流程详解",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Kali-Linux-2020-2安装流程详解.md",
        "source": "@site/blog\\Kali-Linux-2020-2安装流程详解.md",
        "title": "Kali-Linux-2020-2安装流程详解",
        "description": "因为linux的缓冲区溢出实验，需要在虚拟机的平台上使用linux，所以特地决定使用Kali-linux来进行安装实验。",
        "date": "2020-08-09T00:00:00.000Z",
        "formattedDate": "2020年8月9日",
        "tags": [
          {
            "label": "linux",
            "permalink": "/blog/tags/linux"
          }
        ],
        "readingTime": 0.715,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Kali-Linux-2020-2安装流程详解",
          "date": "2020-08-09T00:00:00.000Z",
          "categories": "linux",
          "tags": [
            "linux"
          ]
        },
        "prevItem": {
          "title": "生成2的n次方个不同的01组合",
          "permalink": "/blog/生成2的n次方个不同的01组合"
        },
        "nextItem": {
          "title": "python中yield的用法",
          "permalink": "/blog/python中yield的用法"
        }
      },
      "content": ">因为linux的缓冲区溢出实验，需要在虚拟机的平台上使用linux，所以特地决定使用Kali-linux来进行安装实验。\r\n\r\n## [主要参考博客](https://www.cnblogs.com/yzxag/p/12386917.html)\r\n## 安装过程中主要遇到的问题\r\n主要是出现如下错误：\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200809134309.png)\r\n后来经过我的反思，我认为是因为在这一步需要安装很多的软件，这些软件很多来自外网，所以那需要开启全局代理进行翻墙，同时使用如下办法。\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200809134426.png)\r\n\r\n>方法来源与 上述的博客"
    },
    {
      "id": "/python中yield的用法",
      "metadata": {
        "permalink": "/blog/python中yield的用法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/python中yield的用法.md",
        "source": "@site/blog\\python中yield的用法.md",
        "title": "python中yield的用法",
        "description": "yield执行步骤",
        "date": "2020-07-28T00:00:00.000Z",
        "formattedDate": "2020年7月28日",
        "tags": [
          {
            "label": "python",
            "permalink": "/blog/tags/python"
          }
        ],
        "readingTime": 0.84,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "python中yield的用法",
          "date": "2020-07-28T00:00:00.000Z",
          "categories": "python",
          "tags": [
            "python"
          ]
        },
        "prevItem": {
          "title": "Kali-Linux-2020-2安装流程详解",
          "permalink": "/blog/Kali-Linux-2020-2安装流程详解"
        },
        "nextItem": {
          "title": "更改Pycharm字体大小的步骤",
          "permalink": "/blog/更改Pycharm字体大小的步骤"
        }
      },
      "content": "## yield执行步骤\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200728182906.png)\r\n\r\n* 1：执行foo函数，打印starting...\r\n* 2: foo函数返回的是一个迭代器，此时的g是可以迭代的，所以print(next(g))打印的是4\r\n* 3：正常打印20个*\r\n* 4：第二次执行next(g)的时候，从上次yield结束的位置继续，此时res变量获得的是None,因为4已经返回了。\r\n* 5：因为foo函数里有while循环，所以会继续返回一个4\r\n含有yield的函数直接实例化的时候，里面不会被执行的。使用next才开始执行。\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200728191529.png)\r\n\r\nsend函数相当于在暂停的那个位置给补充一个数。"
    },
    {
      "id": "/更改Pycharm字体大小的步骤",
      "metadata": {
        "permalink": "/blog/更改Pycharm字体大小的步骤",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/更改Pycharm字体大小的步骤.md",
        "source": "@site/blog\\更改Pycharm字体大小的步骤.md",
        "title": "更改Pycharm字体大小的步骤",
        "description": "步骤1",
        "date": "2020-07-27T00:00:00.000Z",
        "formattedDate": "2020年7月27日",
        "tags": [
          {
            "label": "python",
            "permalink": "/blog/tags/python"
          }
        ],
        "readingTime": 0.12,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "更改Pycharm字体大小的步骤",
          "date": "2020-07-27T00:00:00.000Z",
          "categories": "python",
          "tags": [
            "python"
          ]
        },
        "prevItem": {
          "title": "python中yield的用法",
          "permalink": "/blog/python中yield的用法"
        },
        "nextItem": {
          "title": "歌单测试",
          "permalink": "/blog/歌单测试"
        }
      },
      "content": "## 步骤1\r\n点击 File->Settings\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200727195125.png)\r\n## 步骤2\r\n点击Editor下面的Font进行修改\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200727195241.png)"
    },
    {
      "id": "/歌单测试",
      "metadata": {
        "permalink": "/blog/歌单测试",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/歌单测试.md",
        "source": "@site/blog\\歌单测试.md",
        "title": "歌单测试",
        "description": "采用的是meting的方式",
        "date": "2020-06-19T00:00:00.000Z",
        "formattedDate": "2020年6月19日",
        "tags": [
          {
            "label": "hexo",
            "permalink": "/blog/tags/hexo"
          }
        ],
        "readingTime": 0.28,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "歌单测试",
          "date": "2020-06-19T00:00:00.000Z",
          "categories": "hexo",
          "tags": [
            "hexo"
          ]
        },
        "prevItem": {
          "title": "更改Pycharm字体大小的步骤",
          "permalink": "/blog/更改Pycharm字体大小的步骤"
        },
        "nextItem": {
          "title": "前端知识学习24——文字阴影与盒子阴影",
          "permalink": "/blog/前端知识学习24——文字阴影与盒子阴影"
        }
      },
      "content": ">采用的是meting的方式\r\n\r\n## 1：百度 + id\r\n{% meting \"677026134\" \"baidu\" \"song\" %}\r\n[百度音乐网址](http://music.taihe.com/)\r\n\r\n## 2：网易 + 歌单\r\n{% meting \"60198\" \"netease\" \"playlist\" %}\r\n[网易云音乐](https://music.163.com/)\r\n\r\n## 3：网易 + id\r\n{% meting \"1325711221\" \"netease\" \"song\" %}"
    },
    {
      "id": "/前端知识学习24——文字阴影与盒子阴影",
      "metadata": {
        "permalink": "/blog/前端知识学习24——文字阴影与盒子阴影",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习24——文字阴影与盒子阴影.md",
        "source": "@site/blog\\前端知识学习24——文字阴影与盒子阴影.md",
        "title": "前端知识学习24——文字阴影与盒子阴影",
        "description": "1:盒子阴影",
        "date": "2020-06-17T00:00:00.000Z",
        "formattedDate": "2020年6月17日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 0.245,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习24——文字阴影与盒子阴影",
          "date": "2020-06-17T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "歌单测试",
          "permalink": "/blog/歌单测试"
        },
        "nextItem": {
          "title": "前端知识学习25——浮动",
          "permalink": "/blog/前端知识学习25——浮动"
        }
      },
      "content": "## 1:盒子阴影\r\n>书写规则：\r\n\r\n```\r\nbox-shadow: 10px 10px 10px 10px black;\r\n默认的就是outset但是outset是不允许写的\r\n```\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200617083357.png)\r\n\r\n## 2:文字阴影\r\n>书写规则\r\n\r\n```\r\ntext-shadow: 3px 3px 3px blue;\r\n```\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200617083504.png)"
    },
    {
      "id": "/前端知识学习25——浮动",
      "metadata": {
        "permalink": "/blog/前端知识学习25——浮动",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习25——浮动.md",
        "source": "@site/blog\\前端知识学习25——浮动.md",
        "title": "前端知识学习25——浮动",
        "description": "1:为什么需要浮动？",
        "date": "2020-06-17T00:00:00.000Z",
        "formattedDate": "2020年6月17日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 2.725,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习25——浮动",
          "date": "2020-06-17T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "前端知识学习24——文字阴影与盒子阴影",
          "permalink": "/blog/前端知识学习24——文字阴影与盒子阴影"
        },
        "nextItem": {
          "title": "前端知识学习26——常见的网页布局",
          "permalink": "/blog/前端知识学习26——常见的网页布局"
        }
      },
      "content": "## 1:为什么需要浮动？\r\n>假如，我们需要三个div盒子并排排列，仅仅使用display: inline block的话，盒子中间会有缝隙。使用浮动会消除这一点。\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200617083908.png)\r\n\r\n## 2：传统网页布局的三种方式\r\n```\r\n标准流 + 浮动 + 定位\r\n```\r\n\r\n## 3：网页布局的准则\r\n* 第一准则：块级元素纵向排列找标准流，多个块级元素横向排列找浮动。\r\n* 第二准则：先设置盒子大小，然后设置盒子的位置。\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200617084435.png)\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200617084442.png)\r\n\r\n## 4：什么是浮动？\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200617084519.png)\r\n\r\n## 5：浮动特性\r\n* 浮动元素会脱离标准流。\r\n* 浮动的元素会一行内显示，并且顶部对齐。\r\n* 浮动的元素会具有行内块元素的特性，比如，行内元素不能给宽高，但是通过浮动之后可以实现。\r\n* 浮动的盒子不再保留原先的位置。\r\n* 浮动的盒子相当于飞起来了，不再占位。\r\n\r\n## 6：浮动元素经常搭配标准流的父元素\r\n>先用标准流的父元素进行上下排列，之后内部子元素采取浮动排列左右位置。\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200617085102.png)\r\n\r\n## 7：浮动的两个注意点\r\n>1：浮动会影响后面的标准流，但是不会影响前面的标准流。\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200617085356.png)\r\n\r\n## 8：浮动布局练习\r\n### 实现效果1\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200617085444.png)\r\n\r\n### 代码\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <style>\r\n        * {\r\n            margin: 0;\r\n            padding: 0;\r\n        }\r\n        li {\r\n            list-style: none;\r\n        }\r\n        .box {\r\n            width: 1226px;\r\n            height: 285px;\r\n            background-color: pink;\r\n            margin: 0 auto;\r\n        }\r\n        .box li {\r\n            width: 296px;\r\n            height: 285px;\r\n            background-color: purple;\r\n            float: left;\r\n            margin-right: 14px;\r\n        }\r\n        .box .last {\r\n            margin-right: 0;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"box\">\r\n        <li>1</li>\r\n        <li>2</li>\r\n        <li>3</li>\r\n        <li class=\"last\">3</li>\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n>注意点：\r\n>1：标签之间的权重问题\r\n>2：最后一个盒子加上margin-right会掉下来，去掉即可。\r\n\r\n### 实现效果2\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200617085643.png)\r\n\r\n### 代码\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <style>\r\n        .box {\r\n            width: 1226px;\r\n            height: 615px;\r\n            background-color: pink;\r\n            margin: 0 auto;\r\n        }\r\n        .left {\r\n            float: left;\r\n            width: 234px;\r\n            height: 615px;\r\n            background-color: purple;\r\n        }\r\n        .right {\r\n            float: left;\r\n            width: 992px;\r\n            height: 615px;\r\n            background-color: skyblue;\r\n        }\r\n        .right div {\r\n            width: 234px;\r\n            height: 300px;\r\n            background-color: yellow;\r\n            float: left;\r\n            margin-left: 14px;\r\n            margin-bottom: 14px;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"box\">\r\n        <div class=\"left\">左青龙</div>\r\n        <div class=\"right\">\r\n            <div>1</div>\r\n            <div>2</div>\r\n            <div>3</div>\r\n            <div>4</div>\r\n            <div>5</div>\r\n            <div>6</div>\r\n            <div>7</div>\r\n            <div>8</div>\r\n        </div>\r\n    </div>\r\n</body>\r\n</html>\r\n```"
    },
    {
      "id": "/前端知识学习26——常见的网页布局",
      "metadata": {
        "permalink": "/blog/前端知识学习26——常见的网页布局",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习26——常见的网页布局.md",
        "source": "@site/blog\\前端知识学习26——常见的网页布局.md",
        "title": "前端知识学习26——常见的网页布局",
        "description": "布局方式1",
        "date": "2020-06-17T00:00:00.000Z",
        "formattedDate": "2020年6月17日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 0.53,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习26——常见的网页布局",
          "date": "2020-06-17T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "前端知识学习25——浮动",
          "permalink": "/blog/前端知识学习25——浮动"
        },
        "nextItem": {
          "title": "前端知识学习27——清除浮动",
          "permalink": "/blog/前端知识学习27——清除浮动"
        }
      },
      "content": "## 布局方式1\r\n1：先采用标准流对大盒子进行布局。\r\n2：大盒子内部的小盒子采用浮动进行布局。\r\n\r\n## 案例\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200617085954.png)\r\n\r\n## 代码\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <style>\r\n        * {\r\n            margin: 0;\r\n            padding: 0;\r\n        }\r\n        .top {\r\n            height: 50px;\r\n            background-color: aqua;\r\n        }\r\n        .banner {\r\n            width: 1000px;\r\n            height: 200px;\r\n            background-color: blue;\r\n            margin: 10px auto;\r\n        }\r\n        .box {\r\n            width: 1000px;\r\n            height: 200px;\r\n            background-color: skyblue;\r\n            margin: 10px auto;\r\n        }\r\n        .box li {\r\n            list-style: none;\r\n            width: 240px;\r\n            height: 200px;\r\n            background-color: red;\r\n            float: left;\r\n            margin-right: 13.3px;\r\n        }\r\n        .box .last {\r\n            margin-right: 0;\r\n        }\r\n        .footer {\r\n            height: 500px;\r\n            background-color: violet;\r\n            margin: 10px auto;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"top\">top</div>\r\n    <div class=\"banner\">banner</div>\r\n    <div class=\"box\">\r\n        <ul>\r\n            <li>1</li>\r\n            <li>2</li>\r\n            <li>3</li>\r\n            <li class=\"last\">4</li>\r\n        </ul>\r\n    </div>\r\n    <div class=\"footer\">fooer</div>\r\n</body>\r\n</html>\r\n```"
    },
    {
      "id": "/前端知识学习27——清除浮动",
      "metadata": {
        "permalink": "/blog/前端知识学习27——清除浮动",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习27——清除浮动.md",
        "source": "@site/blog\\前端知识学习27——清除浮动.md",
        "title": "前端知识学习27——清除浮动",
        "description": "1:为什么要清除浮动？",
        "date": "2020-06-17T00:00:00.000Z",
        "formattedDate": "2020年6月17日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 1.75,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习27——清除浮动",
          "date": "2020-06-17T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "前端知识学习26——常见的网页布局",
          "permalink": "/blog/前端知识学习26——常见的网页布局"
        },
        "nextItem": {
          "title": "了凡四训读书笔记",
          "permalink": "/blog/了凡四训读书笔记"
        }
      },
      "content": "## 1:为什么要清除浮动？\r\n>有的父盒子不方便给高度，当父盒子没有高度的时候，且里面的子元素又是浮动，这时候父盒子的高度会变成0.\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200617090612.png)\r\n\r\n## 2：清除浮动的本质\r\n>清除浮动的本质是清除浮动元素造成的影响。如果父盒子本身有高度，则不需要清除浮动。清除浮动之后，父盒子就会根据子盒子自动检测高度。父盒子有了高度就不会影响下面的标准流了。\r\n\r\n## 3：清除浮动的语法\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200617091319.png)\r\n\r\n## 4：清除浮动的四种方法\r\n### 4.1额外标签法\r\n>在最后一个浮动元素末尾添加一个空标签，这个标签必须是块级元素，然后给这个块级元素添加样式clear: both\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200617091650.png)\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200617091657.png)\r\n\r\n### 4.2父元素overflow\r\n>给父元素添加overflow: hidden\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200617091811.png)\r\n\r\n### 4.3 after伪元素法\r\n```css\r\n.clearfix:after {\r\n    content: \"\";\r\n    display: block;\r\n    height: 0;\r\n    clear: both;\r\n    visibility: hidden;\r\n}\r\n.clearfix {\r\n    *zoom: 1;\r\n}\r\n```\r\n>只用给父元素的类名里添加一个 clearfix并且将上述样式代码写上即可。\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200617092238.png)\r\n\r\n### 4.4 双伪元素\r\n```css\r\n.clearfix:before,\r\n.clearfix:after {\r\n    content: \"\";\r\n    display: table;\r\n}\r\n.clearfix:after {\r\n    clear:both;\r\n}\r\n.clearfix {\r\n    *zoom:1;\r\n}\r\n```\r\n>只用给父元素的类名里添加 clearfix 并且将上述样式代码写上即可。\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200617092617.png)\r\n\r\n## 5：清除浮动总结\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200617092654.png)"
    },
    {
      "id": "/了凡四训读书笔记",
      "metadata": {
        "permalink": "/blog/了凡四训读书笔记",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/了凡四训读书笔记.md",
        "source": "@site/blog\\了凡四训读书笔记.md",
        "title": "了凡四训读书笔记",
        "description": "了凡四训这本书，是中国明朝袁了凡先生所作的家训，教戒他的儿子袁天启，认识命运的真相，明辨善恶的标准，改过迁善的方法，以及行善积德谦虚种种的效验；",
        "date": "2020-06-14T00:00:00.000Z",
        "formattedDate": "2020年6月14日",
        "tags": [
          {
            "label": "读书笔记",
            "permalink": "/blog/tags/读书笔记"
          }
        ],
        "readingTime": 5.075,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "了凡四训读书笔记",
          "date": "2020-06-14T00:00:00.000Z",
          "categories": "读书笔记",
          "tags": [
            "读书笔记"
          ]
        },
        "prevItem": {
          "title": "前端知识学习27——清除浮动",
          "permalink": "/blog/前端知识学习27——清除浮动"
        },
        "nextItem": {
          "title": "给Hexo博客添加CDN失利的教训",
          "permalink": "/blog/给Hexo博客添加CDN失利的教训"
        }
      },
      "content": ">了凡四训这本书，是中国明朝袁了凡先生所作的家训，教戒他的儿子袁天启，认识命运的真相，明辨善恶的标准，改过迁善的方法，以及行善积德谦虚种种的效验；\r\n\r\n## 第一章 立命之学\r\n1：**断恶修善，灾消福来。** 乃为改造命运的原理。勿以善小而不为，勿以恶小而为之。\r\n2：**命有己立，福由己求。** 佛经里说：一个人要求富贵就得富贵，要求儿女就得儿女，要求长寿就得长寿。可见命运是掌握在我们自己的手中，自己怎么做，命运就会怎么变。所以，勿怨天尤人，相信命运就掌握在自己的手中，你想要什么样的命运就去做什么样的事。\r\n3：**种福种祸，全在自己的内心。** 六祖慧能大师说：所有各种的福田，都决定在各人的心里。福离不开心，心外没有福田可寻，所以种福种祸，全在自己的内心。只要从心里去求福，没有感应不到的。\r\n4：**从前的一切一切，譬如昨日，已经死了；以后的一切一切，譬如今日，刚刚出生；** 常常想自己，所做跟所为，合不合天道，求祸与求福，全在你自己呀。\r\n5：**每天反省自己的过失。** 一个人必须要每天知道自己有过失，才能天天改过，若是一天不知道自己的过失，就一天安安逸逸的算自己没过失。如果每天都无过可改，就是每天都没有进步；天底下聪明俊秀的人实在不少，然而他们道德上不肯用功去修，事业不能用功去做；就只为了因循两个字，得过且过，不想前进，所以才耽搁了他们的一生。\r\n### 总结：了凡先生的立命之学根本就在于命由己立，福由己求，多做善事，只要向心中所求前进，就会求得。每天反省自己的过失，以求精进，切不可，得过且过。\r\n\r\n## 第二章 改过之法\r\n>过则勿惮改，人有了过失，就一定要去改正，人非圣贤孰能无过。\r\n\r\n1：**有羞耻心** \r\n2：**有戒慎恐惧心** 我们纵然在幽暗之处犯过，大家虽然不容易发觉，但天地鬼神却像镜子般地照着我们，看得实在非常清楚。所犯的罪业若是重大，必定会降下许多灾祸；就算是轻的过失，也会减损现有的福报。我们怎么可以不惧怕呢？一个人只要还有一口气存在，就算犯了满天的大罪恶，都还可以悔改；古人有一辈子都在作恶，到了临命终前却能悔悟过来，萌发一个善的念头，于是得到了善终的果报。这就是说，只要能够发出一个勇猛坚决的善念，就足以洗刷一生所积下的罪恶呀！譬如上千年的幽暗山谷，只要有一盏灯光照射进去，那么这千年来的黑暗就可以完全除去。所以过失不论是久远前犯的，还是最近才犯的，只有能够改过，才是最可贵的。\r\n3：**发起勇猛心** 人在犯过之后，不能够改正的原因，大都因为得过且过、退堕畏缩。我们必须在明白过失以后，立即痛下决心改正过来，不可以延迟、疑惑，更不应当犹豫不决，东等西等，不敢下定决心。\r\n4: **观心断念** 最高明的改过方法，是从修心下工夫，当下就可以使心地清净；每当心里刚动了个坏念头时，就能够立刻觉察到，然后马上让这种念头消失，过失自然不会再产生。\r\n### 总结：了凡先生的改过之法核心在于三心：羞耻心，敬畏心，勇猛心。"
    },
    {
      "id": "/给Hexo博客添加CDN失利的教训",
      "metadata": {
        "permalink": "/blog/给Hexo博客添加CDN失利的教训",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/给Hexo博客添加CDN失利的教训.md",
        "source": "@site/blog\\给Hexo博客添加CDN失利的教训.md",
        "title": "给Hexo博客添加CDN失利的教训",
        "description": "折腾历程",
        "date": "2020-06-04T00:00:00.000Z",
        "formattedDate": "2020年6月4日",
        "tags": [
          {
            "label": "hexo",
            "permalink": "/blog/tags/hexo"
          }
        ],
        "readingTime": 1.255,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "给Hexo博客添加CDN失利的教训",
          "date": "2020-06-04T00:00:00.000Z",
          "categories": "hexo",
          "tags": [
            "hexo"
          ]
        },
        "prevItem": {
          "title": "了凡四训读书笔记",
          "permalink": "/blog/了凡四训读书笔记"
        },
        "nextItem": {
          "title": "HP笔记本播放视频前几秒没音",
          "permalink": "/blog/HP笔记本播放视频前几秒没音"
        }
      },
      "content": "## 折腾历程\r\n昨天，我发现博客有时候进不去了，我的第一反应是,会不会是因为我的博客中图片太大，导致的加载太慢，我于是乎使用CDN加速来尝试，尝试了cloudflaer和Nodecahe感觉并没有变快，反而更慢，于是改回了原本coding部署的形式，但是由于DNS解析不是太熟练，加之，DNS解析需要时间才能生效，折腾了一天最后连进都进不去了，于是没办法了只好重建一个coding项目重新部署，发现还是卡顿，于是只剩最后一个办法了，那就是从coding转到Github转完之后，发现可以流畅运行。\r\n\r\n## 问题根源\r\n问题根源在于coding服务器并不稳定，我感觉可能是刚开始性能还可以，到了一定时期，为了让用户充值腾讯COS，故意让你变卡，这一点得到了coding客服的默认。"
    },
    {
      "id": "/HP笔记本播放视频前几秒没音",
      "metadata": {
        "permalink": "/blog/HP笔记本播放视频前几秒没音",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/HP笔记本播放视频前几秒没音.md",
        "source": "@site/blog\\HP笔记本播放视频前几秒没音.md",
        "title": "HP笔记本播放视频前几秒没音",
        "description": "问题描述",
        "date": "2020-06-03T00:00:00.000Z",
        "formattedDate": "2020年6月3日",
        "tags": [
          {
            "label": "debug",
            "permalink": "/blog/tags/debug"
          }
        ],
        "readingTime": 0.635,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "HP笔记本播放视频前几秒没音",
          "date": "2020-06-03T00:00:00.000Z",
          "categories": "debug",
          "tags": [
            "debug"
          ]
        },
        "prevItem": {
          "title": "给Hexo博客添加CDN失利的教训",
          "permalink": "/blog/给Hexo博客添加CDN失利的教训"
        },
        "nextItem": {
          "title": "网络安全下的深度学习资料汇总",
          "permalink": "/blog/网络安全下的深度学习资料汇总"
        }
      },
      "content": "## 问题描述\r\n惠普笔记本有时候会出现这样的问题：即有时候打开视频的时候，前几秒的声音是听不到的，后来发现是下面的情况。\r\n\r\n## 原因\r\n声音延迟2s的具体原因是Realtek的省电管理出现问题，为了节省电量Realtek在不工作时会自动关闭，导致每次启动Realtek时都需要重新加载，所以说会出现声音延迟1~2s的问题。\r\n\r\n## 解决方案\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200603101127.png)"
    },
    {
      "id": "/网络安全下的深度学习资料汇总",
      "metadata": {
        "permalink": "/blog/网络安全下的深度学习资料汇总",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/网络安全下的深度学习资料汇总.md",
        "source": "@site/blog\\网络安全下的深度学习资料汇总.md",
        "title": "网络安全下的深度学习资料汇总",
        "description": "文章来源",
        "date": "2020-06-03T00:00:00.000Z",
        "formattedDate": "2020年6月3日",
        "tags": [
          {
            "label": "网络安全",
            "permalink": "/blog/tags/网络安全"
          }
        ],
        "readingTime": 0.185,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "网络安全下的深度学习资料汇总",
          "date": "2020-06-03T00:00:00.000Z",
          "categories": "网络安全",
          "tags": [
            "网络安全"
          ]
        },
        "prevItem": {
          "title": "HP笔记本播放视频前几秒没音",
          "permalink": "/blog/HP笔记本播放视频前几秒没音"
        },
        "nextItem": {
          "title": "centos7报错Selinux failed to解决方案",
          "permalink": "/blog/centos7报错Selinux failed to解决方案"
        }
      },
      "content": "## 文章来源\r\n[如何玩转网络安全下的深度学习？最全的学习资料清单看这里](https://www.leiphone.com/news/201701/RdVHBwh9y0kuvTGJ.html)\r\n\r\n## 数据源\r\n[SecRepo.com](http://www.secrepo.com/)"
    },
    {
      "id": "/centos7报错Selinux failed to解决方案",
      "metadata": {
        "permalink": "/blog/centos7报错Selinux failed to解决方案",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/centos7报错Selinux failed to解决方案.md",
        "source": "@site/blog\\centos7报错Selinux failed to解决方案.md",
        "title": "centos7报错Selinux failed to解决方案",
        "description": "下面这篇文章亲测有效",
        "date": "2020-06-02T00:00:00.000Z",
        "formattedDate": "2020年6月2日",
        "tags": [
          {
            "label": "linux",
            "permalink": "/blog/tags/linux"
          }
        ],
        "readingTime": 0.34,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "centos7报错Selinux failed to解决方案",
          "date": "2020-06-02T00:00:00.000Z",
          "categories": "linux",
          "tags": [
            "linux"
          ]
        },
        "prevItem": {
          "title": "网络安全下的深度学习资料汇总",
          "permalink": "/blog/网络安全下的深度学习资料汇总"
        },
        "nextItem": {
          "title": "linux之文件权限",
          "permalink": "/blog/linux之文件权限"
        }
      },
      "content": ">下面这篇文章亲测有效\r\n\r\n[原文地址](https://blog.51cto.com/qulei616/1933840)\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200602151320.png)\r\n\r\n注意第四步也是要做的，我刚开始忘了做了，以为能正常运行就行了，没想到第二天还是报错了，所以一定要四步都执行到位。"
    },
    {
      "id": "/linux之文件权限",
      "metadata": {
        "permalink": "/blog/linux之文件权限",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/linux之文件权限.md",
        "source": "@site/blog\\linux之文件权限.md",
        "title": "linux之文件权限",
        "description": "分清 r w x -",
        "date": "2020-06-02T00:00:00.000Z",
        "formattedDate": "2020年6月2日",
        "tags": [
          {
            "label": "linux",
            "permalink": "/blog/tags/linux"
          }
        ],
        "readingTime": 0.255,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "linux之文件权限",
          "date": "2020-06-02T00:00:00.000Z",
          "categories": "linux",
          "tags": [
            "linux"
          ]
        },
        "prevItem": {
          "title": "centos7报错Selinux failed to解决方案",
          "permalink": "/blog/centos7报错Selinux failed to解决方案"
        },
        "nextItem": {
          "title": "linux之末行模式",
          "permalink": "/blog/linux之末行模式"
        }
      },
      "content": "## 分清 r w x -\r\n* r :   读\r\n* w :   写\r\n* x ：  可执行\r\n```\r\n- 代表的是文件的意思\r\n```\r\n\r\n## 文件权限的显示\r\n```\r\nls -l\r\n```\r\n\r\n## 权限的含义\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200602210708.png)\r\n\r\n## 修改权限\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200602210728.png)"
    },
    {
      "id": "/linux之末行模式",
      "metadata": {
        "permalink": "/blog/linux之末行模式",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/linux之末行模式.md",
        "source": "@site/blog\\linux之末行模式.md",
        "title": "linux之末行模式",
        "description": "1:进入末行模式",
        "date": "2020-06-02T00:00:00.000Z",
        "formattedDate": "2020年6月2日",
        "tags": [
          {
            "label": "linux",
            "permalink": "/blog/tags/linux"
          }
        ],
        "readingTime": 0.38,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "linux之末行模式",
          "date": "2020-06-02T00:00:00.000Z",
          "categories": "linux",
          "tags": [
            "linux"
          ]
        },
        "prevItem": {
          "title": "linux之文件权限",
          "permalink": "/blog/linux之文件权限"
        },
        "nextItem": {
          "title": "linux之用户与用户组",
          "permalink": "/blog/linux之用户与用户组"
        }
      },
      "content": "## 1:进入末行模式\r\n* 在命令行模式下 输入英文状态下的 : 即可\r\n\r\n## 2：末行模式的基本指令\r\n- :q  退出\r\n- :q! 强制退出，不保存\r\n- :w  保存不退出\r\n- :wq 保存并退出\r\n* :%s/old/new/g  全局替换，将旧的变成新的\r\n* :set nu  显示行号"
    },
    {
      "id": "/linux之用户与用户组",
      "metadata": {
        "permalink": "/blog/linux之用户与用户组",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/linux之用户与用户组.md",
        "source": "@site/blog\\linux之用户与用户组.md",
        "title": "linux之用户与用户组",
        "description": "用户的账户和id存放的位置",
        "date": "2020-06-02T00:00:00.000Z",
        "formattedDate": "2020年6月2日",
        "tags": [
          {
            "label": "linux",
            "permalink": "/blog/tags/linux"
          }
        ],
        "readingTime": 0.565,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "linux之用户与用户组",
          "date": "2020-06-02T00:00:00.000Z",
          "categories": "linux",
          "tags": [
            "linux"
          ]
        },
        "prevItem": {
          "title": "linux之末行模式",
          "permalink": "/blog/linux之末行模式"
        },
        "nextItem": {
          "title": "壁纸推荐",
          "permalink": "/blog/壁纸推荐"
        }
      },
      "content": "## 用户的账户和id存放的位置\r\n```\r\n/etc/passwd\r\n```\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200602210048.png)\r\n\r\n## gedit命令\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200602210107.png)\r\n\r\n## 添加用户\r\n```\r\nuseradd + 用户名\r\n```\r\n## 新建用户并加入到特定用户组中\r\n```\r\nuseradd -g root 用户名\r\n```\r\n* 将“用户名” 加入root用户组，同时home目录下也会添加这个用户的\r\n\r\n## 切换用户\r\n```\r\nsu - 用户名\r\n```\r\n## 添加用户组\r\n```\r\ngroupadd 名字\r\n```\r\n## 判断一个用户所属的用户组\r\n```\r\nid + 用户名\r\n```\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200602153354.png)"
    },
    {
      "id": "/壁纸推荐",
      "metadata": {
        "permalink": "/blog/壁纸推荐",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/壁纸推荐.md",
        "source": "@site/blog\\壁纸推荐.md",
        "title": "壁纸推荐",
        "description": "必应壁纸网站",
        "date": "2020-06-02T00:00:00.000Z",
        "formattedDate": "2020年6月2日",
        "tags": [
          {
            "label": "优秀鉴赏",
            "permalink": "/blog/tags/优秀鉴赏"
          }
        ],
        "readingTime": 0.065,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "壁纸推荐",
          "date": "2020-06-02T00:00:00.000Z",
          "categories": "优秀鉴赏",
          "tags": [
            "优秀鉴赏"
          ]
        },
        "prevItem": {
          "title": "linux之用户与用户组",
          "permalink": "/blog/linux之用户与用户组"
        },
        "nextItem": {
          "title": "忘记Centos7密码的解决方案",
          "permalink": "/blog/忘记Centos7密码的解决方案"
        }
      },
      "content": "## 必应壁纸网站\r\n[必应壁纸](https://bing.ioliu.cn/)\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200602112626.png)"
    },
    {
      "id": "/忘记Centos7密码的解决方案",
      "metadata": {
        "permalink": "/blog/忘记Centos7密码的解决方案",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/忘记Centos7密码的解决方案.md",
        "source": "@site/blog\\忘记Centos7密码的解决方案.md",
        "title": "忘记Centos7密码的解决方案",
        "description": "今天，在学习修改用户名的密码的时候，使用小键盘写的密码，最后我发现原来没有打开小键盘锁，以后再进行linux系统的操作的时候，一定不能使用小键盘。",
        "date": "2020-06-01T00:00:00.000Z",
        "formattedDate": "2020年6月1日",
        "tags": [
          {
            "label": "linux",
            "permalink": "/blog/tags/linux"
          }
        ],
        "readingTime": 0.66,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "忘记Centos7密码的解决方案",
          "date": "2020-06-01T00:00:00.000Z",
          "categories": "linux",
          "tags": [
            "linux"
          ]
        },
        "prevItem": {
          "title": "壁纸推荐",
          "permalink": "/blog/壁纸推荐"
        },
        "nextItem": {
          "title": "前端知识学习20——PS的基本操作",
          "permalink": "/blog/前端知识学习20——PS的基本操作"
        }
      },
      "content": "今天，在学习修改用户名的密码的时候，使用小键盘写的密码，最后我发现原来没有打开小键盘锁，以后再进行linux系统的操作的时候，一定不能使用小键盘。\r\n## 1：在下述界面按下e\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200601182419.png)\r\n\r\n## 2:修改下面两处\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200601182509.png)\r\n\r\n## 3：按下\r\n```\r\n ctrl + x\r\n```\r\n## 4: 输入\r\n```\r\n passwd root\r\n```\r\n## 5:连续两次输入密码\r\n不要使用小键盘\r\n## 6：一直回车\r\n## 重启即可，不用管其他的什么Selinux"
    },
    {
      "id": "/前端知识学习20——PS的基本操作",
      "metadata": {
        "permalink": "/blog/前端知识学习20——PS的基本操作",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习20——PS的基本操作.md",
        "source": "@site/blog\\前端知识学习20——PS的基本操作.md",
        "title": "前端知识学习20——PS的基本操作",
        "description": "1.按键",
        "date": "2020-05-30T00:00:00.000Z",
        "formattedDate": "2020年5月30日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 0.05,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习20——PS的基本操作",
          "date": "2020-05-30T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "忘记Centos7密码的解决方案",
          "permalink": "/blog/忘记Centos7密码的解决方案"
        },
        "nextItem": {
          "title": "前端知识学习21——小米商城（闪购模块）",
          "permalink": "/blog/前端知识学习21——小米商城（闪购模块）"
        }
      },
      "content": "## 1.按键\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200530191212.png)\r\n\r\n## 2.图示\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200530191226.png)"
    },
    {
      "id": "/前端知识学习21——小米商城（闪购模块）",
      "metadata": {
        "permalink": "/blog/前端知识学习21——小米商城（闪购模块）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习21——小米商城（闪购模块）.md",
        "source": "@site/blog\\前端知识学习21——小米商城（闪购模块）.md",
        "title": "前端知识学习21——小米商城（闪购模块）",
        "description": "样例",
        "date": "2020-05-30T00:00:00.000Z",
        "formattedDate": "2020年5月30日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 1.215,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习21——小米商城（闪购模块）",
          "date": "2020-05-30T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "前端知识学习20——PS的基本操作",
          "permalink": "/blog/前端知识学习20——PS的基本操作"
        },
        "nextItem": {
          "title": "前端知识学习22——品优购快报案例",
          "permalink": "/blog/前端知识学习22——品优购快报案例"
        }
      },
      "content": "## 样例\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200530191330.png)\r\n\r\n## 结构分析\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200530191344.png)\r\n\r\n## 谨记两点\r\n* margin不会撑大盒子，但是padding会\r\n* 没有宽度属性的话，padding不会撑开盒子的宽度，这里的宽度属性指的是和padding在同一个标签样式里的。\r\n\r\n## 代码\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title></title>\r\n    <style>\r\n        * {\r\n            margin: 0;\r\n            padding: 0;\r\n        }\r\n        body {\r\n            /* 整个界面的背景颜色 */\r\n            background-color: #f5f5f5;\r\n        }\r\n        .box,\r\n        .box2 {\r\n            width: 296px;\r\n            height: 427px;\r\n            background-color: #fafafa;\r\n            /* 让块元素水平居中 */\r\n            /* 上外边距100px */\r\n            margin: 100px auto;\r\n            border-top: 1px solid #ffac13;\r\n            text-align: center;\r\n        }\r\n        \r\n        .box img, \r\n        .box2 img {\r\n            width: 100%;\r\n        }\r\n           \r\n        .name {\r\n            color: #202020;\r\n            text-align: center;\r\n            font-size: 17px;\r\n            font-family: \"微软雅黑\";\r\n        }\r\n        .function {\r\n            font-size: 15px;\r\n            color: #adadad;\r\n            text-align: center;\r\n            font-family: \"微软雅黑\";\r\n            margin-top: 6px;\r\n        }\r\n        span {\r\n            display: inline-block;\r\n            margin-top: 12px;\r\n        }\r\n        .price {\r\n            color: #fa6509;\r\n        }\r\n        .old_price {\r\n            color: #afafaf;\r\n            text-decoration: line-through;\r\n        }\r\n        .box,\r\n        .box2 {\r\n            display: inline-block;\r\n        } \r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"box\">\r\n        <img src=\"images/01.jpg\" alt=\"\">\r\n        <p class=\"name\">小米小爱音箱 万能遥控板 黑色</p>\r\n        <p class=\"function\">传统家电秒变智能</p>\r\n        <span class=\"price\">149元</span><span class=\"old_price\">199元</span>\r\n    </div>\r\n    <div class=\"box2\">\r\n        <img src=\"images/01.jpg\" alt=\"\">\r\n        <p class=\"name\">小米小爱音箱 万能遥控板 黑色</p>\r\n        <p class=\"function\">传统家电秒变智能</p>\r\n        <span class=\"price\">149元</span><span class=\"old_price\">199元</span>\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n## 实现效果\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200530191553.png)"
    },
    {
      "id": "/前端知识学习22——品优购快报案例",
      "metadata": {
        "permalink": "/blog/前端知识学习22——品优购快报案例",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习22——品优购快报案例.md",
        "source": "@site/blog\\前端知识学习22——品优购快报案例.md",
        "title": "前端知识学习22——品优购快报案例",
        "description": "代码",
        "date": "2020-05-30T00:00:00.000Z",
        "formattedDate": "2020年5月30日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 0.795,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习22——品优购快报案例",
          "date": "2020-05-30T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "前端知识学习21——小米商城（闪购模块）",
          "permalink": "/blog/前端知识学习21——小米商城（闪购模块）"
        },
        "nextItem": {
          "title": "前端知识学习23——圆角边框",
          "permalink": "/blog/前端知识学习23——圆角边框"
        }
      },
      "content": "## 代码\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>品优购快报</title>\r\n    <style>\r\n        * {\r\n            margin: 0;\r\n            padding: 0;\r\n        }\r\n        .box {\r\n            width: 375px;\r\n            height: 248px;\r\n            background-color: #fdfefd;\r\n            border: 1px solid #757573;\r\n            margin: 30px auto;\r\n        }\r\n        .box1 {\r\n            font-size: 20px;\r\n            color: #8a8080;\r\n            height: 47px;\r\n            width: 375px;\r\n            border-bottom: 1px dotted #757573;\r\n            line-height: 47px;\r\n            text-indent: 22px;\r\n            /* 因为没有宽度，所以padding不会撑开盒子 */\r\n            /* padding-left: 22px; */\r\n        }\r\n        li {\r\n            list-style: none;\r\n            color: #8a8080;\r\n            line-height: 33px;\r\n            font-weight: 600;\r\n        }\r\n        ul {\r\n            \r\n            margin-top: 18px;\r\n            padding-left: 30px;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <table>\r\n        <div class=\"box\">\r\n            <div class=\"box1\">\r\n                <p>品优购快报</p>\r\n            </div>\r\n            <div class=\"box2\">\r\n                <ul>\r\n                    <li>【特惠】 爆款耳机5折秒！</li>\r\n                    <li>【特惠】 母亲节，健康好礼低至5折！</li>\r\n                    <li>【特惠】 爆款耳机5折秒！</li>\r\n                    <li>【特惠】 9.9元洗100张照片！</li>\r\n                    <li>【特惠】 长虹智能空调立省1000</li>\r\n                </ul>\r\n            </div>\r\n        </div>\r\n    </table>  \r\n</body>\r\n</html>\r\n```\r\n## 实现效果\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200530191715.png)"
    },
    {
      "id": "/前端知识学习23——圆角边框",
      "metadata": {
        "permalink": "/blog/前端知识学习23——圆角边框",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习23——圆角边框.md",
        "source": "@site/blog\\前端知识学习23——圆角边框.md",
        "title": "前端知识学习23——圆角边框",
        "description": "基本概念",
        "date": "2020-05-30T00:00:00.000Z",
        "formattedDate": "2020年5月30日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 0.225,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习23——圆角边框",
          "date": "2020-05-30T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "前端知识学习22——品优购快报案例",
          "permalink": "/blog/前端知识学习22——品优购快报案例"
        },
        "nextItem": {
          "title": "前端知识学习17——CSS背景",
          "permalink": "/blog/前端知识学习17——CSS背景"
        }
      },
      "content": "## 基本概念\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200530191812.png)\r\n\r\n## 变成圆形\r\n* border-radius = 正方形边长/2\r\n\r\n## 变成圆角矩形\r\n* border-radius = 长方形宽 / 2\r\n\r\n## 分别给四个角设置曲度\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200530192014.png)"
    },
    {
      "id": "/前端知识学习17——CSS背景",
      "metadata": {
        "permalink": "/blog/前端知识学习17——CSS背景",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习17——CSS背景.md",
        "source": "@site/blog\\前端知识学习17——CSS背景.md",
        "title": "前端知识学习17——CSS背景",
        "description": "1.背景图片",
        "date": "2020-05-27T00:00:00.000Z",
        "formattedDate": "2020年5月27日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 1.25,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习17——CSS背景",
          "date": "2020-05-27T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "前端知识学习23——圆角边框",
          "permalink": "/blog/前端知识学习23——圆角边框"
        },
        "nextItem": {
          "title": "前端知识学习18——CSS的三大特性",
          "permalink": "/blog/前端知识学习18——CSS的三大特性"
        }
      },
      "content": "## 1.背景图片\r\n* backgroud-image\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200527214955.png)\r\n\r\n## 2.背景平铺\r\n* backgroud-repeat\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200527215028.png)\r\n\r\n## 3.背景图片位置\r\n* background-positon\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200527215047.png)\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200527215130.png)\r\n\r\n> 使用img标签难以控制位置，使用背景图片便于掌控位置\r\n\r\n## 4.文字图片小案例\r\n### 代码\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <style>\r\n        h3 {\r\n            width: 170px;\r\n            height: 40px;\r\n            background-image: url(images/icon.png);\r\n            background-repeat: no-repeat;\r\n            text-indent: 4em;\r\n            background-position: left;\r\n            line-height: 40px;\r\n            font-weight: normal;\r\n            font-size: 14px;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <h3>\r\n        成长守护平台  \r\n    </h3>\r\n</body>\r\n</html>\r\n```\r\n### 实现效果\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200527215335.png)\r\n\r\n## 5.背景固定\r\n* backgroud-attachment\r\n* 背景固定后，背景是固定不动的，滚动的是其他的位置\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200527215423.png)\r\n\r\n## 6.背景颜色半透明\r\n* 透明度，越小越透明\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200527215516.png)\r\n\r\n## 7.背景总结\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200527215540.png)\r\n\r\n## 8.五彩导航栏案例\r\n### 代码\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <style>\r\n        .nav a {\r\n            display: inline-block;\r\n            width: 120px;\r\n            height: 58px;\r\n            background-color: pink;\r\n            \r\n            text-decoration: none;\r\n            line-height: 50px;\r\n            text-align: center;\r\n            color: #fff;\r\n        }\r\n        .nav .bg1 {\r\n            background-image: url(images/bg1.png);\r\n        }\r\n        .nav .bg1:hover {\r\n            background-image: url(images/bg11.png);\r\n        }\r\n        .nav .bg2 {\r\n            background-image: url(images/bg2.png);\r\n        }\r\n        .nav .bg2:hover {\r\n            background-image: url(images/bg22.png);\r\n        }\r\n        .nav .bg3 {\r\n            background-image: url(images/bg3.png);\r\n        }\r\n        .nav .bg3:hover {\r\n            background-image: url(images/bg11.png);\r\n        }\r\n        .nav .bg4 {\r\n            background-image: url(images/bg4.png);\r\n        }\r\n        .nav .bg4:hover {\r\n            background-image: url(images/bg22.png);\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"nav\">\r\n        <a href=\"#\" class=\"bg1\">五彩导航</a>\r\n        <a href=\"#\" class=\"bg2\">五彩导航</a>\r\n        <a href=\"#\" class=\"bg3\">五彩导航</a>\r\n        <a href=\"#\" class=\"bg4\">五彩导航</a>\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n### 实现效果\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200527215657.png)"
    },
    {
      "id": "/前端知识学习18——CSS的三大特性",
      "metadata": {
        "permalink": "/blog/前端知识学习18——CSS的三大特性",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习18——CSS的三大特性.md",
        "source": "@site/blog\\前端知识学习18——CSS的三大特性.md",
        "title": "前端知识学习18——CSS的三大特性",
        "description": "1.层叠性",
        "date": "2020-05-27T00:00:00.000Z",
        "formattedDate": "2020年5月27日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 0.95,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习18——CSS的三大特性",
          "date": "2020-05-27T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "前端知识学习17——CSS背景",
          "permalink": "/blog/前端知识学习17——CSS背景"
        },
        "nextItem": {
          "title": "前端知识学习14——CSS元素显示模式",
          "permalink": "/blog/前端知识学习14——CSS元素显示模式"
        }
      },
      "content": "## 1.层叠性\r\n* 样式冲突的情况下，后写的会把先写的覆盖掉\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200527215930.png)\r\n\r\n## 2.继承性\r\n* 给父标签添加样式，子标签也会被修改\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200527220024.png)\r\n\r\n* 行高的继承：\r\n\r\n>font-size和font-family必须同时有，否则不起作用。注意font-size和font可不一样，font最少要给它两个属性font-size给一个属性都可以了。\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200527220210.png)\r\n\r\n## 3.优先级\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200527220239.png)\r\n\r\n* 优先级最高的：\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200527220342.png)\r\n\r\n* 理解：继承过来权重为0。\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200527220415.png)\r\n\r\n* 特例：\r\n>给body标签下的a标签修改颜色，不起作用，因为a继承body标签后，权重为零，浏览器默认给添加了下划线和蓝色的样式。\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200527220528.png)\r\n\r\n* 复合选择器权重叠加的问题：\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200527220604.png)\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200527220622.png)"
    },
    {
      "id": "/前端知识学习14——CSS元素显示模式",
      "metadata": {
        "permalink": "/blog/前端知识学习14——CSS元素显示模式",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习14——CSS元素显示模式.md",
        "source": "@site/blog\\前端知识学习14——CSS元素显示模式.md",
        "title": "前端知识学习14——CSS元素显示模式",
        "description": "1.块元素",
        "date": "2020-05-26T00:00:00.000Z",
        "formattedDate": "2020年5月26日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 0.485,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习14——CSS元素显示模式",
          "date": "2020-05-26T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "前端知识学习18——CSS的三大特性",
          "permalink": "/blog/前端知识学习18——CSS的三大特性"
        },
        "nextItem": {
          "title": "前端知识学习15——简版小米侧边栏的实现",
          "permalink": "/blog/前端知识学习15——简版小米侧边栏的实现"
        }
      },
      "content": "## 1.块元素\r\n* 一行放一个，可以给宽度和高度\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200526104715.png)\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200526104725.png)\r\n\r\n## 2.行内元素\r\n* 一行可以有多个行内元素，不能给宽高\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200526104814.png)\r\n\r\n## 3.行内块元素\r\n* 一行可以放多个，可一个给宽高\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200526104852.png)\r\n\r\n## 4.元素显示模式的转换\r\n* display:blcok 转为块元素\r\n* display:inline 转为行内元素\r\n* display:inline-block 转为行内块元素\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200526104957.png)"
    },
    {
      "id": "/前端知识学习15——简版小米侧边栏的实现",
      "metadata": {
        "permalink": "/blog/前端知识学习15——简版小米侧边栏的实现",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习15——简版小米侧边栏的实现.md",
        "source": "@site/blog\\前端知识学习15——简版小米侧边栏的实现.md",
        "title": "前端知识学习15——简版小米侧边栏的实现",
        "description": "代码",
        "date": "2020-05-26T00:00:00.000Z",
        "formattedDate": "2020年5月26日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 0.575,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习15——简版小米侧边栏的实现",
          "date": "2020-05-26T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "前端知识学习14——CSS元素显示模式",
          "permalink": "/blog/前端知识学习14——CSS元素显示模式"
        },
        "nextItem": {
          "title": "前端知识学习16——单行文字垂直居中",
          "permalink": "/blog/前端知识学习16——单行文字垂直居中"
        }
      },
      "content": "## 代码\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <style>\r\n        a {\r\n            /* 转换为块级元素 */\r\n            display: block;\r\n            text-decoration: none;\r\n            background-color: #535759;\r\n            color: white;\r\n            width: 210px;\r\n            height: 40px;\r\n            font-size: 14px;\r\n            text-indent: 2em;\r\n            line-height: 40px;\r\n        }\r\n        a:hover {\r\n            background-color: #ff6f00;\r\n        }\r\n    </style>\r\n</head>\r\n\r\n<body>\r\n    <a href=\"#\">手机 电话卡</a>\r\n    <a href=\"#\">电视 盒子</a>\r\n    <a href=\"#\">笔记本 平板</a>\r\n    <a href=\"#\">出行 穿戴</a>\r\n    <a href=\"#\">智能 路由器</a>\r\n    <a href=\"#\">健康 儿童</a>\r\n    <a href=\"#\">耳机 音响</a>\r\n</body>\r\n\r\n</html>\r\n```\r\n## 效果展示\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200526105157.png)"
    },
    {
      "id": "/前端知识学习16——单行文字垂直居中",
      "metadata": {
        "permalink": "/blog/前端知识学习16——单行文字垂直居中",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习16——单行文字垂直居中.md",
        "source": "@site/blog\\前端知识学习16——单行文字垂直居中.md",
        "title": "前端知识学习16——单行文字垂直居中",
        "description": "理论基础",
        "date": "2020-05-26T00:00:00.000Z",
        "formattedDate": "2020年5月26日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 0.16,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习16——单行文字垂直居中",
          "date": "2020-05-26T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "前端知识学习15——简版小米侧边栏的实现",
          "permalink": "/blog/前端知识学习15——简版小米侧边栏的实现"
        },
        "nextItem": {
          "title": "LeetCode——01.两数之和",
          "permalink": "/blog/LeetCode——01.两数之和"
        }
      },
      "content": "## 理论基础\r\n```\r\n行高 = 上边距 + 文字高度 + 下边距\r\n```\r\n## 解决方案\r\n```\r\n行高 = 盒子的高度\r\n```\r\n## 代码\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200526105424.png)\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200526105434.png)"
    },
    {
      "id": "/LeetCode——01.两数之和",
      "metadata": {
        "permalink": "/blog/LeetCode——01.两数之和",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——01.两数之和.md",
        "source": "@site/blog\\LeetCode——01.两数之和.md",
        "title": "LeetCode——01.两数之和",
        "description": "第一题（两数之和）",
        "date": "2020-05-25T00:00:00.000Z",
        "formattedDate": "2020年5月25日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.8,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "LeetCode——01.两数之和",
          "date": "2020-05-25T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "前端知识学习16——单行文字垂直居中",
          "permalink": "/blog/前端知识学习16——单行文字垂直居中"
        },
        "nextItem": {
          "title": "LeetCode——02.整数反转",
          "permalink": "/blog/LeetCode——02.整数反转"
        }
      },
      "content": "## 第一题（两数之和）\r\n```python\r\nclass Solution(object):\r\n    def twoSum(self, nums, target):\r\n        \"\"\"\r\n        :type nums: List[int]\r\n        :type target: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        # 定义一个空的字典  字典里对应的是      \"值\":\"序号\"\r\n        d = {}\r\n        # index指的是下标，element指的是值，enumerate返回的是索引和值\r\n        for index,element in enumerate(nums):\r\n            # 判断是否在字典里 是判断的  键  ，也就是说判断的是值\r\n            if (target - element) in d:\r\n                # 在的话 一方面返回字典里的一个数的下标，另一方面返回的是列表里的数的下标\r\n                return [index,d[target - element]]\r\n            # 不在的话，将  \"值\":\"序号\"  添加到字典中\r\n            else:\r\n                d[element] = index\r\n```"
    },
    {
      "id": "/LeetCode——02.整数反转",
      "metadata": {
        "permalink": "/blog/LeetCode——02.整数反转",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/LeetCode——02.整数反转.md",
        "source": "@site/blog\\LeetCode——02.整数反转.md",
        "title": "LeetCode——02.整数反转",
        "description": "第7题（整数反转）",
        "date": "2020-05-25T00:00:00.000Z",
        "formattedDate": "2020年5月25日",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/blog/tags/leet-code"
          }
        ],
        "readingTime": 0.825,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "LeetCode——02.整数反转",
          "date": "2020-05-25T00:00:00.000Z",
          "categories": "LeetCode",
          "tags": [
            "LeetCode"
          ]
        },
        "prevItem": {
          "title": "LeetCode——01.两数之和",
          "permalink": "/blog/LeetCode——01.两数之和"
        },
        "nextItem": {
          "title": "python——split和join函数",
          "permalink": "/blog/python——split和join函数"
        }
      },
      "content": "## 第7题（整数反转）\r\n```python\r\ndef reverse(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: int\r\n        \"\"\"\r\n        # 无论正负先转为正数\r\n        integ = abs(x)\r\n        # 定义返回的结果\r\n        result = 0\r\n        # 只要正数不为零就进入循环\r\n        while integ != 0:\r\n            # 取出最后一位\r\n            last_num = integ % 10\r\n            # 去掉最后一位\r\n            integ = integ // 10\r\n            # 组合反转后的数字，因为最后一位和导数第二位有大致十倍的关系\r\n            result = result * 10 + last_num\r\n        # 使得输出的数据符合特定区间 否则返回0\r\n        if x > 0:\r\n            if result <= 2**31 - 1:\r\n                return result\r\n            else:\r\n                return 0\r\n        else:\r\n            if -result < -(2**31):\r\n                return 0\r\n            else:\r\n                return (-result)\r\n```"
    },
    {
      "id": "/python——split和join函数",
      "metadata": {
        "permalink": "/blog/python——split和join函数",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/python——split和join函数.md",
        "source": "@site/blog\\python——split和join函数.md",
        "title": "python——split和join函数",
        "description": "代码：",
        "date": "2020-05-25T00:00:00.000Z",
        "formattedDate": "2020年5月25日",
        "tags": [
          {
            "label": "python",
            "permalink": "/blog/tags/python"
          }
        ],
        "readingTime": 0.375,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "python——split和join函数",
          "date": "2020-05-25T00:00:00.000Z",
          "categories": "python",
          "tags": [
            "python"
          ]
        },
        "prevItem": {
          "title": "LeetCode——02.整数反转",
          "permalink": "/blog/LeetCode——02.整数反转"
        },
        "nextItem": {
          "title": "python——切片操作",
          "permalink": "/blog/python——切片操作"
        }
      },
      "content": "代码：\r\n```python\r\na = \"to be or not to be\"\r\n\r\n# 不指定的话，按照空格进行分开\r\nprint(a.split())\r\n# 给定字符的话，这个字符不要了  相当于把\"be\"换成,\r\nprint(a.split(\"be\"))\r\n\r\n# join()  按照join前面的进行组合\r\nb = [\"张三\",\"李四\",\"哆啦A梦\"]\r\nprint(\"+\".join(b))\r\nprint(\"\".join(b))\r\n```\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200525214410.png)"
    },
    {
      "id": "/python——切片操作",
      "metadata": {
        "permalink": "/blog/python——切片操作",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/python——切片操作.md",
        "source": "@site/blog\\python——切片操作.md",
        "title": "python——切片操作",
        "description": "1.字符串切片操作",
        "date": "2020-05-25T00:00:00.000Z",
        "formattedDate": "2020年5月25日",
        "tags": [
          {
            "label": "python",
            "permalink": "/blog/tags/python"
          }
        ],
        "readingTime": 0.12,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "python——切片操作",
          "date": "2020-05-25T00:00:00.000Z",
          "categories": "python",
          "tags": [
            "python"
          ]
        },
        "prevItem": {
          "title": "python——split和join函数",
          "permalink": "/blog/python——split和join函数"
        },
        "nextItem": {
          "title": "python——运算符",
          "permalink": "/blog/python——运算符"
        }
      },
      "content": "## 1.字符串切片操作\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200525182526.png)\r\n* 技巧：包头不包尾\r\n* [::-1]  即倒着排列"
    },
    {
      "id": "/python——运算符",
      "metadata": {
        "permalink": "/blog/python——运算符",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/python——运算符.md",
        "source": "@site/blog\\python——运算符.md",
        "title": "python——运算符",
        "description": "符号 //的作用",
        "date": "2020-05-25T00:00:00.000Z",
        "formattedDate": "2020年5月25日",
        "tags": [
          {
            "label": "python",
            "permalink": "/blog/tags/python"
          }
        ],
        "readingTime": 0.165,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "python——运算符",
          "date": "2020-05-25T00:00:00.000Z",
          "categories": "python",
          "tags": [
            "python"
          ]
        },
        "prevItem": {
          "title": "python——切片操作",
          "permalink": "/blog/python——切片操作"
        },
        "nextItem": {
          "title": "python——zip和enumerate",
          "permalink": "/blog/python——zip和enumerate"
        }
      },
      "content": "## 符号 //的作用\r\n* 取整除 - 返回商的整数部分（向下取整）\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200525150938.png)\r\n\r\n## 符号abs的作用\r\n* 取绝对值"
    },
    {
      "id": "/python——zip和enumerate",
      "metadata": {
        "permalink": "/blog/python——zip和enumerate",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/python——zip和enumerate.md",
        "source": "@site/blog\\python——zip和enumerate.md",
        "title": "python——zip和enumerate",
        "description": "zip函数",
        "date": "2020-05-24T00:00:00.000Z",
        "formattedDate": "2020年5月24日",
        "tags": [
          {
            "label": "python",
            "permalink": "/blog/tags/python"
          }
        ],
        "readingTime": 0.15,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "python——zip和enumerate",
          "date": "2020-05-24T00:00:00.000Z",
          "categories": "python",
          "tags": [
            "python"
          ]
        },
        "prevItem": {
          "title": "python——运算符",
          "permalink": "/blog/python——运算符"
        },
        "nextItem": {
          "title": "python——输出方式总结",
          "permalink": "/blog/python——输出方式总结"
        }
      },
      "content": "## zip函数\r\n>简单的讲，zip就是两两绑定\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200524212414.png)\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200524212504.png)\r\n## enumerate函数\r\n>返回下标和内容\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200524213032.png)\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200524213443.png)"
    },
    {
      "id": "/python——输出方式总结",
      "metadata": {
        "permalink": "/blog/python——输出方式总结",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/python——输出方式总结.md",
        "source": "@site/blog\\python——输出方式总结.md",
        "title": "python——输出方式总结",
        "description": "python输出方式总结",
        "date": "2020-05-24T00:00:00.000Z",
        "formattedDate": "2020年5月24日",
        "tags": [
          {
            "label": "python",
            "permalink": "/blog/tags/python"
          }
        ],
        "readingTime": 1.175,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "python——输出方式总结",
          "date": "2020-05-24T00:00:00.000Z",
          "categories": "python",
          "tags": [
            "python"
          ]
        },
        "prevItem": {
          "title": "python——zip和enumerate",
          "permalink": "/blog/python——zip和enumerate"
        },
        "nextItem": {
          "title": "python——集合",
          "permalink": "/blog/python——集合"
        }
      },
      "content": "## python输出方式总结\r\n\r\n### 1.使用 % 的方式  特点：一一对应\r\n```python\r\nprint(\"努力学习%s,努力工作%s\" %(\"11\",\"22\"))\r\n```\r\n### 2.使用format方法\r\n```python\r\n# 2.1 默认顺序替换，按照默认顺序进行 一一对应\r\nprint(\"{}提高生产力,{}提高能力\".format(\"pyhton\",\"python\"))\r\n\r\n# 2.2 进行数字替换 0里面填的是666   1里面填的是888\r\nprint(\"{1}提高生产力,{0}提高能力\".format(\"666\",\"888\"))\r\n\r\n# 2.3 进行字符替换\r\nprint(\"{a}自律，{b}自强，{c}努力\".format(a = \"王五\" , b= \"张三\" , c = \"李四\"))\r\n\r\n# 2.4 打印组合类型（列表等）\r\nlistx = [1,2,3,4,5]\r\nprint(\"这是一个列表:{}\".format(listx))\r\n# 打印列表中的某一项\r\nprint(\"列表中的第三项：{}\".format(listx[2]))\r\n\r\n# 2.5 调用函数\r\nimport math\r\n# 函数要赋值给一个变量，让这个变量去调用\r\nprint(\"π的值是：{a.pi}\".format(a = math))\r\n\r\n# 2.6 精度控制\r\nprint(\"π的小数点后三位是：{:.3f}\".format(math.pi))\r\n```\r\n### 输出效果：\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200524183558.png)"
    },
    {
      "id": "/python——集合",
      "metadata": {
        "permalink": "/blog/python——集合",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/python——集合.md",
        "source": "@site/blog\\python——集合.md",
        "title": "python——集合",
        "description": "集合的两种创建方式",
        "date": "2020-05-24T00:00:00.000Z",
        "formattedDate": "2020年5月24日",
        "tags": [
          {
            "label": "python",
            "permalink": "/blog/tags/python"
          }
        ],
        "readingTime": 0.72,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "python——集合",
          "date": "2020-05-24T00:00:00.000Z",
          "categories": "python",
          "tags": [
            "python"
          ]
        },
        "prevItem": {
          "title": "python——输出方式总结",
          "permalink": "/blog/python——输出方式总结"
        },
        "nextItem": {
          "title": "parsel解析爬虫时正则匹配的问题",
          "permalink": "/blog/parsel解析爬虫时正则匹配的问题"
        }
      },
      "content": "## 集合的两种创建方式\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200524125715.png)\r\n* 集合是无序的\r\n* 集合里面相同的元素只保留一个\r\n* set会将字符串进行分开保存\r\n## 集合的基本操作符\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200524161237.png)\r\n\r\n## 利用集合进行数据去重\r\n```python\r\n# 利用集合进行数据去重\r\n\r\n# 定义一个带有重复元素的列表\r\nlist_1 = [1,1,2,2,3,4,5,5]\r\n# 将这个列表变成一个集合\r\nset_1 = set(list_1)\r\n# 再将集合变成列表  这样一来一回，就实现了去重操作\r\nnew_list = list(set_1)\r\n\r\nprint(\"去重后的列表是：{}\".format(new_list))\r\n```\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200524191542.png)"
    },
    {
      "id": "/parsel解析爬虫时正则匹配的问题",
      "metadata": {
        "permalink": "/blog/parsel解析爬虫时正则匹配的问题",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/parsel解析爬虫时正则匹配的问题.md",
        "source": "@site/blog\\parsel解析爬虫时正则匹配的问题.md",
        "title": "parsel解析爬虫时正则匹配的问题",
        "description": "今天，在进行parsel的正则匹配的时候，发现怎么都匹配不上,下面这样的字符。",
        "date": "2020-05-23T00:00:00.000Z",
        "formattedDate": "2020年5月23日",
        "tags": [
          {
            "label": "爬虫",
            "permalink": "/blog/tags/爬虫"
          },
          {
            "label": "python",
            "permalink": "/blog/tags/python"
          }
        ],
        "readingTime": 0.535,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "parsel解析爬虫时正则匹配的问题",
          "date": "2020-05-23T00:00:00.000Z",
          "categories": "爬虫",
          "tags": [
            "爬虫",
            "python"
          ]
        },
        "prevItem": {
          "title": "python——集合",
          "permalink": "/blog/python——集合"
        },
        "nextItem": {
          "title": "快速判断列表是否为空",
          "permalink": "/blog/快速判断列表是否为空"
        }
      },
      "content": "今天，在进行parsel的正则匹配的时候，发现怎么都匹配不上,下面这样的字符。\r\n```\r\n&nbsp;&nbsp;\r\n```\r\n经过反复的头脑风暴和不断的测试，我发现，使用下面的方法可以实现\r\n先使用\r\n```\r\nsel.css('font::text').getall()\r\n```\r\n把该函数匹配到的字符进行输出，我发现是下面这样的。\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200523122632.png)\r\n也就是说nbsp变成了\\xa0\r\n## 解决办法：\r\n```\r\nsel.re(r'\\n \\n\\xa0\\xa0(.*?)<br>')\r\n```"
    },
    {
      "id": "/快速判断列表是否为空",
      "metadata": {
        "permalink": "/blog/快速判断列表是否为空",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/快速判断列表是否为空.md",
        "source": "@site/blog\\快速判断列表是否为空.md",
        "title": "快速判断列表是否为空",
        "description": "今天在写爬虫的时候，需要判断列表是否为空，这个有时候很重要。",
        "date": "2020-05-23T00:00:00.000Z",
        "formattedDate": "2020年5月23日",
        "tags": [
          {
            "label": "python",
            "permalink": "/blog/tags/python"
          }
        ],
        "readingTime": 0.245,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "快速判断列表是否为空",
          "date": "2020-05-23T00:00:00.000Z",
          "categories": "python",
          "tags": [
            "python"
          ]
        },
        "prevItem": {
          "title": "parsel解析爬虫时正则匹配的问题",
          "permalink": "/blog/parsel解析爬虫时正则匹配的问题"
        },
        "nextItem": {
          "title": "爬取猫眼电影排行榜被重定向",
          "permalink": "/blog/爬取猫眼电影排行榜被重定向"
        }
      },
      "content": "今天在写爬虫的时候，需要判断列表是否为空，这个有时候很重要。\r\n## 切入正题\r\n```python\r\nbool(len(list_name) == 0)\r\n```\r\n如果结果是True，那说明是空列表"
    },
    {
      "id": "/爬取猫眼电影排行榜被重定向",
      "metadata": {
        "permalink": "/blog/爬取猫眼电影排行榜被重定向",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/爬取猫眼电影排行榜被重定向.md",
        "source": "@site/blog\\爬取猫眼电影排行榜被重定向.md",
        "title": "爬取猫眼电影排行榜被重定向",
        "description": "今天上午，在学习多线程爬虫的时候，原本想爬取猫眼电影榜单的时候，反复遇到重定向的问题，后来经过系统性的排查发现是问题处在了U-A伪装上面。",
        "date": "2020-05-22T00:00:00.000Z",
        "formattedDate": "2020年5月22日",
        "tags": [
          {
            "label": "爬虫",
            "permalink": "/blog/tags/爬虫"
          }
        ],
        "readingTime": 0.585,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "爬取猫眼电影排行榜被重定向",
          "date": "2020-05-22T00:00:00.000Z",
          "categories": "爬虫",
          "tags": [
            "爬虫"
          ]
        },
        "prevItem": {
          "title": "快速判断列表是否为空",
          "permalink": "/blog/快速判断列表是否为空"
        },
        "nextItem": {
          "title": "hexo博客中添加音乐的办法",
          "permalink": "/blog/hexo博客中添加音乐的办法"
        }
      },
      "content": "今天上午，在学习多线程爬虫的时候，原本想爬取猫眼电影榜单的时候，反复遇到重定向的问题，后来经过系统性的排查发现是问题处在了U-A伪装上面。\r\n### 解决方案\r\n1.使用下面的User-Agent\r\n```\r\nheaders = {\r\n            'user-agent': 'Mozilla / 5.0(Windows NT 10.0; WOW64) AppleWebKit / 537.36(KHTML, likeGecko) Chrome / 53.0.2785.104Safari / 537.36Core / 1.53.4882.400QQBrowser / 9.7.13059.400'\r\n}\r\n```\r\n2.不使用User-Agent\r\n```\r\n简直就是玄学啊！\r\n```\r\n#### 参考博客\r\nhttps://www.cnblogs.com/yocichen/p/11812637.html"
    },
    {
      "id": "/hexo博客中添加音乐的办法",
      "metadata": {
        "permalink": "/blog/hexo博客中添加音乐的办法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/hexo博客中添加音乐的办法.md",
        "source": "@site/blog\\hexo博客中添加音乐的办法.md",
        "title": "hexo博客中添加音乐的办法",
        "description": "参考博客",
        "date": "2020-05-21T00:00:00.000Z",
        "formattedDate": "2020年5月21日",
        "tags": [
          {
            "label": "hexo",
            "permalink": "/blog/tags/hexo"
          }
        ],
        "readingTime": 0.375,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "hexo博客中添加音乐的办法",
          "date": "2020-05-21T00:00:00.000Z",
          "categories": "hexo",
          "tags": [
            "hexo"
          ]
        },
        "prevItem": {
          "title": "爬取猫眼电影排行榜被重定向",
          "permalink": "/blog/爬取猫眼电影排行榜被重定向"
        },
        "nextItem": {
          "title": "倩女幽魂之人间情观后感",
          "permalink": "/blog/倩女幽魂之人间情观后感"
        }
      },
      "content": "[参考博客](http://cxjiang.top/2017/04/22/hexo-music/)\r\n{% aplayer \"倩女幽魂\" \"张国荣\" \"http://music.163.com/song/media/outer/url?id=188175.mp3\" \"http://p1.music.126.net/cmvsHFnVKXO409hZdrbacA==/102254581395221.jpg\" %}\r\n* 图片在网易云音乐里找地址\r\n* 音乐外链在[音乐外链网址mp3生成](http://music.xf1433.com/)\r\n---\r\n\r\n优先选下面的这个，并选择网易云的。\r\n* 音乐外链在[音乐直链搜索](https://music.liuzhijin.cn/)"
    },
    {
      "id": "/倩女幽魂之人间情观后感",
      "metadata": {
        "permalink": "/blog/倩女幽魂之人间情观后感",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/倩女幽魂之人间情观后感.md",
        "source": "@site/blog\\倩女幽魂之人间情观后感.md",
        "title": "倩女幽魂之人间情观后感",
        "description": "{% aplayer \"倩女幽魂\" \"张国荣\" \"http//p1.music.126.net/cmvsHFnVKXO409hZdrbacA==/102254581395221.jpg\" %}",
        "date": "2020-05-21T00:00:00.000Z",
        "formattedDate": "2020年5月21日",
        "tags": [
          {
            "label": "电影鉴赏",
            "permalink": "/blog/tags/电影鉴赏"
          }
        ],
        "readingTime": 0.775,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "倩女幽魂之人间情观后感",
          "date": "2020-05-21T00:00:00.000Z",
          "categories": "电影鉴赏",
          "tags": [
            "电影鉴赏"
          ]
        },
        "prevItem": {
          "title": "hexo博客中添加音乐的办法",
          "permalink": "/blog/hexo博客中添加音乐的办法"
        },
        "nextItem": {
          "title": "前端知识学习12——Emmet语法",
          "permalink": "/blog/前端知识学习12——Emmet语法"
        }
      },
      "content": "{% aplayer \"倩女幽魂\" \"张国荣\" \"http://music.163.com/song/media/outer/url?id=188175.mp3\" \"http://p1.music.126.net/cmvsHFnVKXO409hZdrbacA==/102254581395221.jpg\" %}\r\n无意中看到《倩女幽魂之人间情》这部影片，也是2020年新拍的，看完之后感觉非常不错，从故事情节上来说和原版的进行比较，我个人感觉节奏比较快，我挺喜欢这种节奏的，特效也特别好，特别是燕赤霞的扮演者（元华老师），重新找回来童年的回忆，结尾的张国荣唱的《倩女幽魂主题曲》也是相当的经典。相当不错的电影，希望国产剧能够越来越好。\r\n![](https://cdn.staticdn.net/2020/05/04/JYIZymjUG1VNAgX.png)\r\n![](https://cdn.staticdn.net/2020/05/04/R9JCyVOS2wtYmcK.png)\r\n![](https://cdn.staticdn.net/2020/05/04/6z1PZGlNmCWehn4.png)"
    },
    {
      "id": "/前端知识学习12——Emmet语法",
      "metadata": {
        "permalink": "/blog/前端知识学习12——Emmet语法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习12——Emmet语法.md",
        "source": "@site/blog\\前端知识学习12——Emmet语法.md",
        "title": "前端知识学习12——Emmet语法",
        "description": "1.标签名快速进行补全",
        "date": "2020-05-20T00:00:00.000Z",
        "formattedDate": "2020年5月20日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 0.65,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习12——Emmet语法",
          "date": "2020-05-20T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "倩女幽魂之人间情观后感",
          "permalink": "/blog/倩女幽魂之人间情观后感"
        },
        "nextItem": {
          "title": "前端知识学习13——复合选择器",
          "permalink": "/blog/前端知识学习13——复合选择器"
        }
      },
      "content": "### 1.标签名快速进行补全\r\n```\r\n标签名 + tab\r\n```\r\n### 2.生成多个相同的标签\r\n```\r\ndiv*3 + tab\r\n```\r\n### 3.快速生成父子级关系标签\r\n```\r\nul>li   #注意这里没有空格\r\n```\r\n### 4.快速生成兄弟标签\r\n```\r\ndiv+p \r\n```\r\n### 5.快速生成带类名或者id名的标签\r\n```\r\n.demo+tab\r\n#demo+tab\r\n```\r\n### 6.快速生成带有顺序的标签\r\n```\r\n通过$\r\n.demo0$*3 + tab\r\n```\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200520215547.png)\r\n\r\n### 7.快速给标签中添加内容\r\n```\r\n.demo{当时打广告}\r\n```\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200520215634.png)\r\n\r\n### Emmet语法总结\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200520215657.png)"
    },
    {
      "id": "/前端知识学习13——复合选择器",
      "metadata": {
        "permalink": "/blog/前端知识学习13——复合选择器",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习13——复合选择器.md",
        "source": "@site/blog\\前端知识学习13——复合选择器.md",
        "title": "前端知识学习13——复合选择器",
        "description": "1.后代选择器",
        "date": "2020-05-20T00:00:00.000Z",
        "formattedDate": "2020年5月20日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 0.855,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习13——复合选择器",
          "date": "2020-05-20T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "前端知识学习12——Emmet语法",
          "permalink": "/blog/前端知识学习12——Emmet语法"
        },
        "nextItem": {
          "title": "GitHub+PicGo+jsDelivr搭建高速稳定免费图床",
          "permalink": "/blog/GitHub+PicGo+jsDelivr搭建高速稳定免费图床"
        }
      },
      "content": "## 1.后代选择器\r\n* 只修改ol下的li标签\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200520215907.png)\r\n\r\n## 2.子选择器\r\n* 用>表示，注意区分子选择器和后代选择器的区别\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200520215951.png)\r\n\r\n>区别：后代选择器会将该标签下面的所有标签选中，但是子选择器只会将子标签选中。\r\n\r\n## 3.并集选择器\r\n* 同时选中多个标签（中间用逗号隔开，一般竖着写标签）\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200520220046.png)\r\n\r\n## 4.伪类选择器\r\n### 4.1链接伪类选择器\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200520220133.png)\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200520220142.png)\r\n\r\n>（在这里有一个顺序要注意，那就是请按照LVHA的顺序进行编写）\r\n\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200520220204.png)\r\n\r\n### 4.2 focus伪类选择器\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200520220235.png)\r\n\r\n## 复合选择器总结：\r\n![](https://jiapeiyang.oss-cn-beijing.aliyuncs.com/img/20200520220249.png)"
    },
    {
      "id": "/GitHub+PicGo+jsDelivr搭建高速稳定免费图床",
      "metadata": {
        "permalink": "/blog/GitHub+PicGo+jsDelivr搭建高速稳定免费图床",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/GitHub+PicGo+jsDelivr搭建高速稳定免费图床.md",
        "source": "@site/blog\\GitHub+PicGo+jsDelivr搭建高速稳定免费图床.md",
        "title": "GitHub+PicGo+jsDelivr搭建高速稳定免费图床",
        "description": "图床推荐：",
        "date": "2020-05-19T00:00:00.000Z",
        "formattedDate": "2020年5月19日",
        "tags": [
          {
            "label": "hexo",
            "permalink": "/blog/tags/hexo"
          }
        ],
        "readingTime": 0.23,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "GitHub+PicGo+jsDelivr搭建高速稳定免费图床",
          "date": "2020-05-19T00:00:00.000Z",
          "categories": "hexo",
          "tags": [
            "hexo"
          ]
        },
        "prevItem": {
          "title": "前端知识学习13——复合选择器",
          "permalink": "/blog/前端知识学习13——复合选择器"
        },
        "nextItem": {
          "title": "前端知识学习08——CSS字体属性",
          "permalink": "/blog/前端知识学习08——CSS字体属性"
        }
      },
      "content": "图床推荐：\r\n## [实现流程](https://leehoward.cn/2019/11/23/github+picgo+jsdelivr%E6%90%AD%E5%BB%BA%E9%AB%98%E9%80%9F%E7%A8%B3%E5%AE%9A%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A/#%E6%96%B0%E5%BB%BA%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93 \"大佬的博客\")\r\n[视频教程](https://www.youtube.com/watch?v=CIvbmioHB3s)\r\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/CIvbmioHB3s\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\r\n\r\n### [小设图床](https://www.shejibiji.com/shejiimg/)\r\n### [Hidove图床](https://img.abcyun.co/)\r\n测试：\r\n![](https://p.pstatp.com/origin/fe92000267f2bdf9b214)"
    },
    {
      "id": "/前端知识学习08——CSS字体属性",
      "metadata": {
        "permalink": "/blog/前端知识学习08——CSS字体属性",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习08——CSS字体属性.md",
        "source": "@site/blog\\前端知识学习08——CSS字体属性.md",
        "title": "前端知识学习08——CSS字体属性",
        "description": "1.设置字体类型",
        "date": "2020-05-19T00:00:00.000Z",
        "formattedDate": "2020年5月19日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 0.345,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习08——CSS字体属性",
          "date": "2020-05-19T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "GitHub+PicGo+jsDelivr搭建高速稳定免费图床",
          "permalink": "/blog/GitHub+PicGo+jsDelivr搭建高速稳定免费图床"
        },
        "nextItem": {
          "title": "前端知识学习09——文本属性",
          "permalink": "/blog/前端知识学习09——文本属性"
        }
      },
      "content": "## 1.设置字体类型\r\n#### font-family\r\n![](https://cdn.jsdelivr.net/gh/1120637483/image/20200519091705.png)\r\n\r\n## 2.设置字体大小\r\n#### font-size\r\n![](https://gitee.com/justin2/pic/raw/master/20200519092024.png)\r\n\r\n## 3.设置字体粗细\r\n#### font-weight\r\n![](https://gitee.com/justin2/pic/raw/master/20200519092102.png)\r\n![](https://gitee.com/justin2/pic/raw/master/20200519092119.png)\r\n\r\n## 4.设置字体倾斜\r\n#### font-style: italic\r\n![](https://gitee.com/justin2/pic/raw/master/20200519092202.png)\r\n\r\n## 5.字体复合属性（注意顺序不能颠倒）\r\n![](https://gitee.com/justin2/pic/raw/master/20200519092251.png)\r\n![](https://gitee.com/justin2/pic/raw/master/20200519092319.png)\r\n\r\n## 6.字体属性总结\r\n![](https://gitee.com/justin2/pic/raw/master/20200519092340.png)"
    },
    {
      "id": "/前端知识学习09——文本属性",
      "metadata": {
        "permalink": "/blog/前端知识学习09——文本属性",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习09——文本属性.md",
        "source": "@site/blog\\前端知识学习09——文本属性.md",
        "title": "前端知识学习09——文本属性",
        "description": "1.文本颜色",
        "date": "2020-05-19T00:00:00.000Z",
        "formattedDate": "2020年5月19日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 0.505,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习09——文本属性",
          "date": "2020-05-19T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "前端知识学习08——CSS字体属性",
          "permalink": "/blog/前端知识学习08——CSS字体属性"
        },
        "nextItem": {
          "title": "前端知识学习10——CSS的引入方式",
          "permalink": "/blog/前端知识学习10——CSS的引入方式"
        }
      },
      "content": "## 1.文本颜色\r\n`color`\r\n![](https://gitee.com/justin2/pic/raw/master/20200519092457.png)\r\n\r\n## 2.对齐文本\r\n`text-align`\r\n![](https://gitee.com/justin2/pic/raw/master/20200519092531.png)\r\n\r\n## 3.装饰文本（添加下划线，删除下划线）\r\n`text-decoration`\r\n\r\n### 添加下划线\r\n![](https://gitee.com/justin2/pic/raw/master/20200519092700.png)\r\n\r\n### 删除下划线\r\n![](https://gitee.com/justin2/pic/raw/master/20200519092713.png)\r\n\r\n### 装饰文本总结\r\n![](https://gitee.com/justin2/pic/raw/master/20200519092739.png)\r\n\r\n## 4.文本缩进\r\n`text-indent`\r\n![](https://gitee.com/justin2/pic/raw/master/20200519092828.png)\r\n\r\n`2em代表2个文字大小`\r\n![](https://gitee.com/justin2/pic/raw/master/20200519092851.png)\r\n\r\n## 5.行间距\r\n```\r\n行间距 = 上间距 + 文本高度 + 下间距\r\n```\r\n\r\n![](https://gitee.com/justin2/pic/raw/master/20200519092940.png)\r\n\r\n## 6.文本属性总结\r\n![](https://gitee.com/justin2/pic/raw/master/20200519093005.png)"
    },
    {
      "id": "/前端知识学习10——CSS的引入方式",
      "metadata": {
        "permalink": "/blog/前端知识学习10——CSS的引入方式",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习10——CSS的引入方式.md",
        "source": "@site/blog\\前端知识学习10——CSS的引入方式.md",
        "title": "前端知识学习10——CSS的引入方式",
        "description": "1.内部样式表",
        "date": "2020-05-19T00:00:00.000Z",
        "formattedDate": "2020年5月19日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 0.415,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习10——CSS的引入方式",
          "date": "2020-05-19T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "前端知识学习09——文本属性",
          "permalink": "/blog/前端知识学习09——文本属性"
        },
        "nextItem": {
          "title": "前端知识学习11——新闻案例",
          "permalink": "/blog/前端知识学习11——新闻案例"
        }
      },
      "content": "## 1.内部样式表\r\n![](https://gitee.com/justin2/pic/raw/master/20200519093119.png)\r\n\r\n## 2.行内样式表（在标签里面直接加上style）\r\n![](https://gitee.com/justin2/pic/raw/master/20200519093148.png)\r\n\r\n## 3.外部样式表\r\n步骤：\r\n```\r\n1：新建一个CSS文件，并将样式写进去。\r\n2：这个CSS文件，里面不用写style\r\n3：使用link标签引入CSS文件\r\n```\r\n![](https://gitee.com/justin2/pic/raw/master/20200519093234.png)\r\n\r\n## CSS引入方式总结\r\n![](https://gitee.com/justin2/pic/raw/master/20200519093302.png)"
    },
    {
      "id": "/前端知识学习11——新闻案例",
      "metadata": {
        "permalink": "/blog/前端知识学习11——新闻案例",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习11——新闻案例.md",
        "source": "@site/blog\\前端知识学习11——新闻案例.md",
        "title": "前端知识学习11——新闻案例",
        "description": "心得体会：给图片加居中是没有效果的，可以给它的父级标签加居中。",
        "date": "2020-05-19T00:00:00.000Z",
        "formattedDate": "2020年5月19日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 3.655,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习11——新闻案例",
          "date": "2020-05-19T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "前端知识学习10——CSS的引入方式",
          "permalink": "/blog/前端知识学习10——CSS的引入方式"
        },
        "nextItem": {
          "title": "如何掌控你的自由时间",
          "permalink": "/blog/如何掌控你的自由时间"
        }
      },
      "content": ">心得体会：给图片加居中是没有效果的，可以给它的父级标签加居中。\r\n\r\n* 效果展示：\r\n\r\n![](https://p.pstatp.com/origin/fee0000313c8f5ec5f2b)\r\n* 代码展示\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\r\n    <title>Document</title>\r\n    <style>\r\n       body {\r\n           /* 28px指的是行高 16px指的是字体的大小 */\r\n           font: 16px/28px \"微软雅黑\";\r\n       }\r\n       h1 {\r\n           text-align: center;\r\n           font-weight: normal;\r\n       }\r\n       .gray {\r\n           color: #888888;\r\n            text-align: center;\r\n            font-size: 15px;\r\n            \r\n       }\r\n       a {\r\n           text-decoration: none;\r\n       }\r\n       .search {\r\n           color: #888888;\r\n       }\r\n       p {\r\n           text-indent: 2em;\r\n       }\r\n    </style>\r\n</head>\r\n<body>\r\n        <h1>北方高温明日达鼎盛 京津冀多地地表温度将超60℃</h1>\r\n        <div class=\"gray\">\r\n            2019-07-03 16:31:47 来源: <a href=\"#\">中国天气网</a>\r\n            <input type=\"text\" value=\"请输入查询条件\" class=\"search\"> <button value=\"搜索\">搜索</button>     \r\n        </div>\r\n        <hr>\r\n\r\n        <p>中国天气网讯 今天（3日），华北、黄淮多地出现高温天气，截至下午2点，北京、天津、郑州等地气温突破35℃。预报显示，今后三天（3-5日），这一带的高温天气将继续发酵，高温范围以及强度将在4日达到鼎盛，预计北京、天津、石家庄、济南等地明天的最高气温有望突破38℃，其中北京和石家庄的最高气温还有望创今年以来的新高。</p>\r\n        \r\n        <h4>气温41.4℃！地温66.5！北京强势迎七月首个高温日</h4>\r\n        <p>今天，华北、黄淮一带的高温持续发酵，截至今天下午2点，陕西北部、山西西南部、河北南部、北京、天津、山东西部、河南北部最高气温已普遍超过35℃。大城市中，北京、天津、郑州均迎来高温日。</p>\r\n        <p style=\"text-align: center;\">\r\n            <img src=\"images/pic.jpeg\" alt=\"\">\r\n        </p>\r\n        <p>在阳光暴晒下，地表温度也逐渐走高。今天下午2点，华北黄淮大部地区的地表温度都在50℃以上，部分地区地表温度甚至超过60℃。其中，河北衡水地表温度高达68.3℃，天津站和北京站附近的地表温度分别高达66.6℃和66.5℃。</p>\r\n        \r\n        <h4>明日热度再升级！京津冀携手冲击38℃+</h4>\r\n        <p>中国天气网气象分析师王伟跃介绍，明天（4日），华北、黄淮地区35℃以上的高温天气还将继续升级，并进入鼎盛阶段，高温强度和范围都将发展到最强。 明天，北京南部、天津大部、河北中部和南部、山东中部和西部、山西南部局地、河南北部、东北部分地区的最高气温都将达到或超过35℃。</p>\r\n        \r\n        <p>不过，专家提醒，济南被雨水天气完美绕开，因此未来一周，当地的高温还会天天上岗。在此提醒当地居民注意防暑降温，防范持续高温带来的各种不利影响。（文/张慧 数据支持/王伟跃 胡啸 审核/刘文静 张方丽）</p>\r\n       \r\n        <p style=\"font-size: 12px; color: #888888;\">本文来源：中国天气网 责任编辑：刘京_NO5631</p>\r\n       \r\n</body>\r\n</html>\r\n```"
    },
    {
      "id": "/如何掌控你的自由时间",
      "metadata": {
        "permalink": "/blog/如何掌控你的自由时间",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/如何掌控你的自由时间.md",
        "source": "@site/blog\\如何掌控你的自由时间.md",
        "title": "如何掌控你的自由时间",
        "description": "<video src='http://mov.bn.netease.com/open-movie/nos/mp4/2017/01/03/SC8U8K7BC_shd.mp4'",
        "date": "2020-05-18T00:00:00.000Z",
        "formattedDate": "2020年5月18日",
        "tags": [
          {
            "label": "电影鉴赏",
            "permalink": "/blog/tags/电影鉴赏"
          }
        ],
        "readingTime": 0.475,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "如何掌控你的自由时间",
          "date": "2020-05-18T00:00:00.000Z",
          "categories": "电影鉴赏",
          "tags": [
            "电影鉴赏"
          ]
        },
        "prevItem": {
          "title": "前端知识学习11——新闻案例",
          "permalink": "/blog/前端知识学习11——新闻案例"
        },
        "nextItem": {
          "title": "激活PyCharm的方法",
          "permalink": "/blog/激活PyCharm的方法"
        }
      },
      "content": "<video src='http://mov.bn.netease.com/open-movie/nos/mp4/2017/01/03/SC8U8K7BC_shd.mp4' \r\n       type='video/mp4' \r\n       controls='controls'  \r\n       preload=\"auto\"\r\n       width='100%' \r\n       height='100%'>\r\n</video>\r\n时间总是有的，就算我们在忙，还是有时间做重要的事，而当我们关注重要的事情的时候，我们就能用我们拥有的时间，打造我们想要的生活。\r\n\r\n---\r\n总结：\r\n<ol>\r\n    <li>列出重要的事项</li>\r\n    <li>优先处理重要的事</li>\r\n    <li>有时间规划</li>\r\n</ol>"
    },
    {
      "id": "/激活PyCharm的方法",
      "metadata": {
        "permalink": "/blog/激活PyCharm的方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/激活PyCharm的方法.md",
        "source": "@site/blog\\激活PyCharm的方法.md",
        "title": "激活PyCharm的方法",
        "description": "今天发现了一个快速激活PyCharm的方法",
        "date": "2020-05-17T00:00:00.000Z",
        "formattedDate": "2020年5月17日",
        "tags": [
          {
            "label": "python",
            "permalink": "/blog/tags/python"
          }
        ],
        "readingTime": 0.28,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "激活PyCharm的方法",
          "date": "2020-05-17T00:00:00.000Z",
          "categories": "python",
          "tags": [
            "python"
          ]
        },
        "prevItem": {
          "title": "如何掌控你的自由时间",
          "permalink": "/blog/如何掌控你的自由时间"
        },
        "nextItem": {
          "title": "前端知识学习07——CSS基础选择器",
          "permalink": "/blog/前端知识学习07——CSS基础选择器"
        }
      },
      "content": "## 今天发现了一个快速激活PyCharm的方法\r\n1：打开下面的网站\r\n[www.lookdiv.com](http://www.lookdiv.com/)\r\n2: 输入密钥\r\nlookdiv.com\r\n3：点击获取激活码\r\n4：粘贴到指定位置即可\r\n![](https://gitee.com/justin2/pic/raw/master/20200517205116.png)\r\n## 亲测2020-5-17 有效！"
    },
    {
      "id": "/前端知识学习07——CSS基础选择器",
      "metadata": {
        "permalink": "/blog/前端知识学习07——CSS基础选择器",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习07——CSS基础选择器.md",
        "source": "@site/blog\\前端知识学习07——CSS基础选择器.md",
        "title": "前端知识学习07——CSS基础选择器",
        "description": "CSS选择器进行样式书写的时候，都是在head标签里的style标签里进行的。",
        "date": "2020-05-15T00:00:00.000Z",
        "formattedDate": "2020年5月15日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 1.535,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习07——CSS基础选择器",
          "date": "2020-05-15T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "激活PyCharm的方法",
          "permalink": "/blog/激活PyCharm的方法"
        },
        "nextItem": {
          "title": "前端知识学习06——注册小案例",
          "permalink": "/blog/前端知识学习06——注册小案例"
        }
      },
      "content": ">CSS选择器进行样式书写的时候，都是在head标签里的style标签里进行的。\r\n\r\n## 1. 标签选择器\r\n* 将标签名作为选择器，修改后所有的这种标签的样式都被修改了\r\n\r\n![](https://gitee.com/justin2/pic/raw/master/20200515172037.png)\r\n![](https://gitee.com/justin2/pic/raw/master/20200515172049.png)\r\n\r\n## 2. 类选择器\r\n* 在标签中添加class名字，然后在style标签里使用 （.名字）\r\n* div盒子里只能使用backgroud-color，我第一次使用color的时候，是无反应的，所以以后在写的时候，如果遇到无效的情况，可以尝试将这两种进行切换\r\n\r\n![](https://gitee.com/justin2/pic/raw/master/20200515172200.png)\r\n\r\n>下面的是标签选择器\r\n\r\n![](https://gitee.com/justin2/pic/raw/master/20200515172346.png)\r\n\r\n### 2.1 多类名\r\n* 使用多类名，可以使我们的标签受到多个类的影响，也可以将相同的样式集中到一个类中。\r\n\r\n![](https://gitee.com/justin2/pic/raw/master/20200515172554.png)\r\n\r\n## 3. id选择器\r\n* id选择器和类选择器的区别在于，id选择器原则上在一个html页面中只允许出现1次，这样可以防止后端JS调用的时候，防止出错。\r\n\r\n![](https://gitee.com/justin2/pic/raw/master/20200515172710.png)\r\n\r\n## 4. 通配符选择器\r\n\r\n* 通配符选择器会将所有标签进行选中\r\n\r\n![](https://gitee.com/justin2/pic/raw/master/20200515172757.png)\r\n\r\n## 5. 基础选择器总结\r\n* 熟记下面四种基础选择器的特点\r\n\r\n![](https://gitee.com/justin2/pic/raw/master/20200515172917.png)"
    },
    {
      "id": "/前端知识学习06——注册小案例",
      "metadata": {
        "permalink": "/blog/前端知识学习06——注册小案例",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习06——注册小案例.md",
        "source": "@site/blog\\前端知识学习06——注册小案例.md",
        "title": "前端知识学习06——注册小案例",
        "description": "代码",
        "date": "2020-05-14T00:00:00.000Z",
        "formattedDate": "2020年5月14日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 2.24,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习06——注册小案例",
          "date": "2020-05-14T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "前端知识学习07——CSS基础选择器",
          "permalink": "/blog/前端知识学习07——CSS基础选择器"
        },
        "nextItem": {
          "title": "python——创建excel并导入数据",
          "permalink": "/blog/python——创建excel并导入数据"
        }
      },
      "content": "### 代码\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>注册表单案例</title>\r\n</head>\r\n<body>\r\n    <h4>青春不常在，请珍惜时间！</h4>\r\n    <table width = \"500px\"  cellspacing = \"0\">\r\n        <!-- 性别 -->\r\n        <tr>\r\n            <td>性别：</td>\r\n            <td>\r\n                <input type=\"radio\" name=\"sex\" id=\"sex1\">  <label for=\"sex1\"><img src=\"images/man.jpg\"> 男</label>  \r\n                <input type=\"radio\" name=\"sex\" id=\"sex2\">  <label for=\"sex2\"><img src=\"images/women.jpg\"> 女</label>\r\n            </td>\r\n        </tr>\r\n        <!-- 生日 -->\r\n        <tr>\r\n            <td>生日：</td>\r\n            <td>\r\n                <select name=\"\" id=\"\" >\r\n                    <option value=\"\">--请选择年份--</option>\r\n                    <option value=\"\">1995</option>\r\n                    <option value=\"\">1996</option>\r\n                    <option value=\"\">1997</option>\r\n                    <option value=\"\">1998</option>\r\n                </select>\r\n                <select name=\"\" id=\"\" >\r\n                    <option value=\"\">--请选择月份--</option>\r\n                    <option value=\"\">1</option>\r\n                    <option value=\"\">2</option>\r\n                    <option value=\"\">3</option>\r\n                    <option value=\"\">4</option>\r\n                </select>\r\n                <select name=\"\" id=\"\" >\r\n                    <option value=\"\">--请选择日--</option>\r\n                    <option value=\"\">1</option>\r\n                    <option value=\"\">2</option>\r\n                    <option value=\"\">3</option>\r\n                    <option value=\"\">4</option>\r\n                </select>\r\n            </td>\r\n        </tr>\r\n        <!-- 所在地区 -->\r\n        <tr>\r\n            <td>所在地区</td>\r\n            <td><input type=\"text\" value=\"请输入您在的地区\"></td>\r\n        </tr>\r\n        <!-- 婚姻状况 -->\r\n        <tr>\r\n            <td>婚姻状况</td>\r\n            <td>\r\n                <input type=\"radio\" name=\"marriage\" id=\"\"> 未婚\r\n                <input type=\"radio\" name=\"marriage\" id=\"\"> 已婚\r\n                <input type=\"radio\" name=\"marriage\" id=\"\"> 离婚                \r\n            </td>\r\n        </tr>\r\n        <!-- 学历 -->\r\n        <tr>\r\n            <td>学历</td>\r\n            <td><input type=\"text\" value=\"请输入您的学历状况\"></td>\r\n        </tr>\r\n        <!-- 喜欢的类型 -->\r\n        <tr>\r\n            <td>喜欢的类型：</td>\r\n            <td>\r\n                <input type=\"checkbox\" name=\"\" id=\"\"> 妩媚的\r\n                <input type=\"checkbox\" name=\"\" id=\"\"> 可爱的\r\n                <input type=\"checkbox\" name=\"\" id=\"\"> 小鲜肉\r\n                <input type=\"checkbox\" name=\"\" id=\"\"> 老腊肉\r\n                <input type=\"checkbox\" checked = \"checked\"> 都喜欢\r\n            </td>\r\n        </tr>\r\n        <!-- 自我介绍 -->\r\n        <tr>\r\n            <td>自我介绍</td>\r\n            <td><textarea >自我介绍</textarea></td>\r\n        </tr>\r\n        <!-- 免费注册 -->\r\n        <tr>\r\n            <td></td>\r\n            <td><input type=\"submit\" value=\"免费注册\"></td>\r\n        </tr>\r\n        <!-- 默认同意条款 -->\r\n        <tr>\r\n            <td></td>\r\n            <td>\r\n                <input type=\"checkbox\" checked = \"checked\"> 我同意注册条款和会员加入标准\r\n            </td>\r\n        </tr>\r\n        <!-- 立即登录 -->\r\n        <tr>\r\n            <td></td>\r\n            <td>\r\n                <a href=\"#\">我是至尊VIP，赶紧让我登录！</a>\r\n            </td>\r\n        </tr>\r\n        <!-- 用户承诺 -->\r\n        <tr>\r\n            <td></td>\r\n            <td>\r\n                <h4>我承诺：</h4>\r\n                <ul>\r\n                    <li>年满18岁、单身</li>\r\n                    <li>抱着严肃的态度</li>\r\n                    <li>真诚寻找另一半</li>\r\n                </ul>\r\n            </td>\r\n        </tr>\r\n    </table>\r\n</body>\r\n</html>\r\n```\r\n### 效果图：\r\n![](https://gitee.com/justin2/pic/raw/master/20200514192334.png)\r\n\r\n### 代码分析\r\n上图是在table标签中里的td写的，最后把border去掉即可。"
    },
    {
      "id": "/python——创建excel并导入数据",
      "metadata": {
        "permalink": "/blog/python——创建excel并导入数据",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/python——创建excel并导入数据.md",
        "source": "@site/blog\\python——创建excel并导入数据.md",
        "title": "python——创建excel并导入数据",
        "description": "",
        "date": "2020-05-13T00:00:00.000Z",
        "formattedDate": "2020年5月13日",
        "tags": [
          {
            "label": "python",
            "permalink": "/blog/tags/python"
          }
        ],
        "readingTime": 0.515,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "python——创建excel并导入数据",
          "date": "2020-05-13T00:00:00.000Z",
          "categories": "python",
          "tags": [
            "python"
          ]
        },
        "prevItem": {
          "title": "前端知识学习06——注册小案例",
          "permalink": "/blog/前端知识学习06——注册小案例"
        },
        "nextItem": {
          "title": "python——去除字典中相同值的项",
          "permalink": "/blog/python——去除字典中相同值的项"
        }
      },
      "content": "```python\r\n# 创建一个excel workbook对象\r\nbook = openpyxl.Workbook()\r\n# 产生一个sheet\r\nsh = book.active\r\n# 修改当前sheet标题为 漏洞数据信息表\r\nsh.title = '特殊文本信息表'\r\n# 根据名称获取某个sheet对象\r\nsh = book['特殊文本信息表']\r\n# 写入A1  此处可以设置循环\r\nsh['A' + str(flag)] = cve_column[i].value\r\n\r\n# 以指定文件名进行保存\r\nbook.save(\"特殊文本.xlsx\")\r\n```"
    },
    {
      "id": "/python——去除字典中相同值的项",
      "metadata": {
        "permalink": "/blog/python——去除字典中相同值的项",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/python——去除字典中相同值的项.md",
        "source": "@site/blog\\python——去除字典中相同值的项.md",
        "title": "python——去除字典中相同值的项",
        "description": "这里的去除，并不单单指的是删除值，而是把这个键值对都删了，只保留相同值的第一个",
        "date": "2020-05-13T00:00:00.000Z",
        "formattedDate": "2020年5月13日",
        "tags": [
          {
            "label": "python",
            "permalink": "/blog/tags/python"
          }
        ],
        "readingTime": 0.66,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "python——去除字典中相同值的项",
          "date": "2020-05-13T00:00:00.000Z",
          "categories": "python",
          "tags": [
            "python"
          ]
        },
        "prevItem": {
          "title": "python——创建excel并导入数据",
          "permalink": "/blog/python——创建excel并导入数据"
        },
        "nextItem": {
          "title": "python——打开excel表并获取其中的某一列",
          "permalink": "/blog/python——打开excel表并获取其中的某一列"
        }
      },
      "content": "这里的去除，并不单单指的是删除值，而是把这个键值对都删了，只保留相同值的第一个\r\n#### 核心代码\r\n```python\r\n# 创建一个集合\r\nvalues=set()\r\n# 将字典所有的 键 转换为列表，并进行遍历\r\nfor key in list(new_dic.keys()):\r\n    # 将每一个键的值取出来赋给val\r\n    val = new_dic[key]\r\n    # 如何取出的值在集合里，就把键值对删掉\r\n    if val in values: \r\n        del new_dic[key]\r\n    # 如果不在，就把这个值添加到集合中去   \r\n    else:\r\n        values.add(val)\r\n```"
    },
    {
      "id": "/python——打开excel表并获取其中的某一列",
      "metadata": {
        "permalink": "/blog/python——打开excel表并获取其中的某一列",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/python——打开excel表并获取其中的某一列.md",
        "source": "@site/blog\\python——打开excel表并获取其中的某一列.md",
        "title": "python——打开excel表并获取其中的某一列",
        "description": "打开excel文件，并获取具体的某列",
        "date": "2020-05-13T00:00:00.000Z",
        "formattedDate": "2020年5月13日",
        "tags": [
          {
            "label": "python",
            "permalink": "/blog/tags/python"
          }
        ],
        "readingTime": 0.44,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "python——打开excel表并获取其中的某一列",
          "date": "2020-05-13T00:00:00.000Z",
          "categories": "python",
          "tags": [
            "python"
          ]
        },
        "prevItem": {
          "title": "python——去除字典中相同值的项",
          "permalink": "/blog/python——去除字典中相同值的项"
        },
        "nextItem": {
          "title": "python——抛出所有异常",
          "permalink": "/blog/python——抛出所有异常"
        }
      },
      "content": "打开excel文件，并获取具体的某列\r\n```python\r\n# 导入我们的xlsx文件\r\nwb = openpyxl.load_workbook(\"vig_all.xlsx\")\r\n\r\n# 打开具体的某一个表\r\nws = wb.get_sheet_by_name(\"Sheet\")\r\n\r\n# cve列\r\ncve_column = ws['C']\r\n\r\n# desciprtion列\r\ndes_column = ws['G']\r\n```\r\n后续我们可以使用循环，获取每一个具体的单元格\r\n```python\r\n# 遍历每一个CVE编号\r\nfor i in range(len(cve_column)):\r\n```"
    },
    {
      "id": "/python——抛出所有异常",
      "metadata": {
        "permalink": "/blog/python——抛出所有异常",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/python——抛出所有异常.md",
        "source": "@site/blog\\python——抛出所有异常.md",
        "title": "python——抛出所有异常",
        "description": "使用下面的格式即可：",
        "date": "2020-05-13T00:00:00.000Z",
        "formattedDate": "2020年5月13日",
        "tags": [
          {
            "label": "python",
            "permalink": "/blog/tags/python"
          }
        ],
        "readingTime": 0.18,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "python——抛出所有异常",
          "date": "2020-05-13T00:00:00.000Z",
          "categories": "python",
          "tags": [
            "python"
          ]
        },
        "prevItem": {
          "title": "python——打开excel表并获取其中的某一列",
          "permalink": "/blog/python——打开excel表并获取其中的某一列"
        },
        "nextItem": {
          "title": "前端知识学习02——基础标签",
          "permalink": "/blog/前端知识学习02——基础标签"
        }
      },
      "content": "使用下面的格式即可：\r\n```python\r\n    try:\r\n        if bool(re.search(r\"\\** REJECT \\**\",des_column[i].value)):\r\n            print(des_column[i].value)\r\n            sh['A' + str(flag)] = cve_column[i].value\r\n            sh['B' + str(flag)] = des_column[i].value\r\n            flag = flag + 1\r\n    except Exception :\r\n        pass\r\n```"
    },
    {
      "id": "/前端知识学习02——基础标签",
      "metadata": {
        "permalink": "/blog/前端知识学习02——基础标签",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习02——基础标签.md",
        "source": "@site/blog\\前端知识学习02——基础标签.md",
        "title": "前端知识学习02——基础标签",
        "description": "1. 标题标签",
        "date": "2020-05-13T00:00:00.000Z",
        "formattedDate": "2020年5月13日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 2.11,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习02——基础标签",
          "date": "2020-05-13T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "python——抛出所有异常",
          "permalink": "/blog/python——抛出所有异常"
        },
        "nextItem": {
          "title": "前端知识学习03——表格标签",
          "permalink": "/blog/前端知识学习03——表格标签"
        }
      },
      "content": "## 1. 标题标签\r\n* h1 - h6共六级标题\r\n* 标题标签独占一行\r\n\r\n![](https://cdn.jsdelivr.net/gh/1120637483/image/20200513160947.png)\r\n\r\n## 2. 段落标签与换行标签\r\n* p标签是段落标签\r\n* br标签是换行标签\r\n* 两个段落标签之间会空一行\r\n\r\n## 3. 文本格式化标签\r\n![](https://cdn.jsdelivr.net/gh/1120637483/image/20200513161252.png)\r\n\r\n## 4. div标签与span标签\r\n* 一个div标签和p标签一样也是独占一行的\r\n* div和span的区别在于：一行只能放一个div，但是一行可以放多个span\r\n\r\n![](https://cdn.jsdelivr.net/gh/1120637483/image/20200513161449.png)\r\n\r\n## 5. 图像标签\r\n* img标签代表的是图像标签\r\n* 图像标签必须写的属性是src属性\r\n* 填写路径的时候注意 (../) 代表的是上一级\r\n* width和height属性一般情况下只用修改一个，如果都修改会造成图像比例失真\r\n* title属性指的是当鼠标移动到这个图像上的时候，图像显示的内容\r\n\r\n![](https://cdn.jsdelivr.net/gh/1120637483/image/20200513161943.png)\r\n\r\n## 6. 超链接标签\r\n* a标签即超链接标签\r\n* 超链接标签里的href属性指的是要跳转的地址\r\n* target属性指的是打开窗口的方式，当该属性的值为_blank的时候，默认打开新的窗口\r\n* 当超链接指向我们的项目文件夹中的某一个文件的时候，可以实现下载该文件的功能\r\n\r\n![](https://cdn.jsdelivr.net/gh/1120637483/image/20200513162322.png)\r\n\r\n* a标签里嵌套img标签，使得图像能够自动跳转到指定的网页中\r\n\r\n### 6.1 锚点链接\r\n* 通过锚点链接可以快速的定位到网页中的某一位置\r\n* 锚点链接的href属性和目标链接的id是相关联的\r\n\r\n![](https://cdn.jsdelivr.net/gh/1120637483/image/20200513162551.png)\r\n\r\n## 7. 特殊字符\r\n![](https://cdn.jsdelivr.net/gh/1120637483/image/20200513162633.png)\r\n\r\n## 笔记记录：\r\n![](https://cdn.jsdelivr.net/gh/1120637483/image/20200513162831.png)"
    },
    {
      "id": "/前端知识学习03——表格标签",
      "metadata": {
        "permalink": "/blog/前端知识学习03——表格标签",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习03——表格标签.md",
        "source": "@site/blog\\前端知识学习03——表格标签.md",
        "title": "前端知识学习03——表格标签",
        "description": "1. 表格标签",
        "date": "2020-05-13T00:00:00.000Z",
        "formattedDate": "2020年5月13日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 0.7,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习03——表格标签",
          "date": "2020-05-13T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "前端知识学习02——基础标签",
          "permalink": "/blog/前端知识学习02——基础标签"
        },
        "nextItem": {
          "title": "前端知识学习04——列表标签",
          "permalink": "/blog/前端知识学习04——列表标签"
        }
      },
      "content": "## 1. 表格标签\r\n* table标签指的是表格标签\r\n\r\n![](https://cdn.jsdelivr.net/gh/1120637483/image/20200513163238.png)\r\n\r\n* 一定要注意好table标签中tr和td table三者的嵌关系\r\n\r\n![](https://cdn.jsdelivr.net/gh/1120637483/image/20200513163424.png)\r\n\r\n### 1.1 表头单元格标签\r\n* th 代表的是加粗 依然嵌套在tr里\r\n\r\n![](https://cdn.jsdelivr.net/gh/1120637483/image/20200513163540.png)\r\n\r\n### 1.2 表格属性\r\n* 下面提到的属性都是写在table这个标签里面的\r\n\r\n![](https://cdn.jsdelivr.net/gh/1120637483/image/20200513163647.png)\r\n![](https://cdn.jsdelivr.net/gh/1120637483/image/20200513163701.png)\r\n\r\n* 注意哪一个是cellpadding与cellspacing之间的关系\r\n\r\n![](https://cdn.jsdelivr.net/gh/1120637483/image/20200513163738.png)\r\n\r\n### 1.3 thead与tbody与table三者的关系\r\n![](https://cdn.jsdelivr.net/gh/1120637483/image/20200513163829.png)\r\n\r\n### 1.4 合并单元格\r\n![](https://cdn.jsdelivr.net/gh/1120637483/image/20200513163909.png)\r\n![](https://cdn.jsdelivr.net/gh/1120637483/image/20200513163923.png)\r\n>上面的三个步骤缺一不可"
    },
    {
      "id": "/前端知识学习04——列表标签",
      "metadata": {
        "permalink": "/blog/前端知识学习04——列表标签",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习04——列表标签.md",
        "source": "@site/blog\\前端知识学习04——列表标签.md",
        "title": "前端知识学习04——列表标签",
        "description": "1. 列表标签",
        "date": "2020-05-13T00:00:00.000Z",
        "formattedDate": "2020年5月13日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 0.59,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习04——列表标签",
          "date": "2020-05-13T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "前端知识学习03——表格标签",
          "permalink": "/blog/前端知识学习03——表格标签"
        },
        "nextItem": {
          "title": "前端知识学习05——表单标签",
          "permalink": "/blog/前端知识学习05——表单标签"
        }
      },
      "content": "## 1. 列表标签\r\n### 1.1 无序列表\r\n* 无序列表可以用ul标签来表示\r\n* ul标签里只能放li标签，但是li标签中可以放其他的标签\r\n\r\n![](https://gitee.com/justin2/pic/raw/master/20200513180358.png)\r\n\r\n### 1.2 有序列表\r\n* 有序列表可以用ol标签来进行表示\r\n\r\n![](https://gitee.com/justin2/pic/raw/master/20200513180448.png)\r\n\r\n### 1.3 自定义列表\r\n>自定义列表的例子\r\n\r\n![](https://gitee.com/justin2/pic/raw/master/20200513180517.png)\r\n\r\n* 自定义列表由 dl dt dd组成，注意理清三者之间的关系\r\n\r\n![](https://gitee.com/justin2/pic/raw/master/20200513180605.png)\r\n\r\n### 1.4 列表总结\r\n![](https://gitee.com/justin2/pic/raw/master/20200513180630.png)"
    },
    {
      "id": "/前端知识学习05——表单标签",
      "metadata": {
        "permalink": "/blog/前端知识学习05——表单标签",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习05——表单标签.md",
        "source": "@site/blog\\前端知识学习05——表单标签.md",
        "title": "前端知识学习05——表单标签",
        "description": "表单标签",
        "date": "2020-05-13T00:00:00.000Z",
        "formattedDate": "2020年5月13日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 1.09,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习05——表单标签",
          "date": "2020-05-13T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "前端知识学习04——列表标签",
          "permalink": "/blog/前端知识学习04——列表标签"
        },
        "nextItem": {
          "title": "如何将NEXT主题的文章目录自动编号去掉",
          "permalink": "/blog/如何将NEXT主题的文章目录自动编号去掉"
        }
      },
      "content": "## 表单标签\r\n### 1.表单标签的组成\r\n```\r\n表单 = 表单控件 + 提示信息 + 表单域\r\n```\r\n\r\n* 图解表单的组成：\r\n\r\n![](https://gitee.com/justin2/pic/raw/master/20200513180912.png)\r\n\r\n#### 1.1 表单域\r\n* 表单域由form标签组成\r\n* 注意其action,method,name三个属性\r\n\r\n![](https://gitee.com/justin2/pic/raw/master/20200513181049.png)\r\n\r\n#### 1.2 表单控件\r\n> 表单控件主要由input,select,textarea三种组成\r\n\r\n![](https://gitee.com/justin2/pic/raw/master/20200513181222.png)\r\n\r\n##### 1.2.1 input表单元素\r\n* 主要使用的是input的下面的这些属性\r\n* 当使用radio单选按钮的时候，必须给所有的单选按钮设置统一的name，这样才能够实现多选一\r\n\r\n![](https://gitee.com/justin2/pic/raw/master/20200513181433.png)\r\n![](https://gitee.com/justin2/pic/raw/master/20200513181320.png)\r\n![](https://gitee.com/justin2/pic/raw/master/20200513181456.png)\r\n\r\n##### 1.2.2 label标签\r\n* 当我们点击该标签的时候，会跳转到其对应的表单元素上，for对应的是id，简单的来说，就是扩大了我们的点积面积\r\n\r\n![](https://gitee.com/justin2/pic/raw/master/20200513181615.png)\r\n![](https://gitee.com/justin2/pic/raw/master/20200513181623.png)\r\n\r\n##### 1.2.3 select下拉表单\r\n* 主要由select与option组成\r\n![](https://gitee.com/justin2/pic/raw/master/20200513181719.png)\r\n![](https://gitee.com/justin2/pic/raw/master/20200513181726.png)\r\n\r\n##### 1.2.4 textarea文本域标签\r\n![](https://gitee.com/justin2/pic/raw/master/20200513181750.png)"
    },
    {
      "id": "/如何将NEXT主题的文章目录自动编号去掉",
      "metadata": {
        "permalink": "/blog/如何将NEXT主题的文章目录自动编号去掉",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/如何将NEXT主题的文章目录自动编号去掉.md",
        "source": "@site/blog\\如何将NEXT主题的文章目录自动编号去掉.md",
        "title": "如何将NEXT主题的文章目录自动编号去掉",
        "description": "解决方案",
        "date": "2020-05-13T00:00:00.000Z",
        "formattedDate": "2020年5月13日",
        "tags": [
          {
            "label": "hexo",
            "permalink": "/blog/tags/hexo"
          }
        ],
        "readingTime": 0.12,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "如何将NEXT主题的文章目录自动编号去掉",
          "date": "2020-05-13T00:00:00.000Z",
          "categories": "hexo",
          "tags": [
            "hexo"
          ]
        },
        "prevItem": {
          "title": "前端知识学习05——表单标签",
          "permalink": "/blog/前端知识学习05——表单标签"
        },
        "nextItem": {
          "title": "前端知识学习01——HTML基本概念",
          "permalink": "/blog/前端知识学习01——HTML基本概念"
        }
      },
      "content": "### 解决方案\r\n#### 只需将next主题配置文件下的number置为false即可。\r\n![](https://cdn.jsdelivr.net/gh/1120637483/image/20200513120134.png)"
    },
    {
      "id": "/前端知识学习01——HTML基本概念",
      "metadata": {
        "permalink": "/blog/前端知识学习01——HTML基本概念",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/前端知识学习01——HTML基本概念.md",
        "source": "@site/blog\\前端知识学习01——HTML基本概念.md",
        "title": "前端知识学习01——HTML基本概念",
        "description": "web标准",
        "date": "2020-05-09T00:00:00.000Z",
        "formattedDate": "2020年5月9日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/blog/tags/前端"
          }
        ],
        "readingTime": 0.125,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "前端知识学习01——HTML基本概念",
          "date": "2020-05-09T00:00:00.000Z",
          "categories": "前端",
          "tags": [
            "前端"
          ]
        },
        "prevItem": {
          "title": "如何将NEXT主题的文章目录自动编号去掉",
          "permalink": "/blog/如何将NEXT主题的文章目录自动编号去掉"
        },
        "nextItem": {
          "title": "木鱼水心评《忠犬八公》观后感",
          "permalink": "/blog/木鱼水心评《忠犬八公》观后感"
        }
      },
      "content": "## web标准\n![](https://cdn.jsdelivr.net/gh/1120637483/image/20200509152959.png)\n## 单标签与双标签：\n![](https://cdn.jsdelivr.net/gh/1120637483/image/20200509153138.png)\n## VSCode快速生成HTML骨架：\n```\n! + tab键\n```"
    },
    {
      "id": "/木鱼水心评《忠犬八公》观后感",
      "metadata": {
        "permalink": "/blog/木鱼水心评《忠犬八公》观后感",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/木鱼水心评《忠犬八公》观后感.md",
        "source": "@site/blog\\木鱼水心评《忠犬八公》观后感.md",
        "title": "木鱼水心评《忠犬八公》观后感",
        "description": "小八告诉我们忠诚的意义，我们不应该忘记爱过的每一个人，每个人类可能都觉得自己是理性的，也崇尚着这种理性。可是，有些事情，比如爱，人似乎无法遵循理性。比如，人不会根据每个人的能力做一个评分表，然后去把身边的人评一个分，随后决定这些人值不值得自己去爱。又比如，两个各方面完全一模一样的人，但如果有一个人先和自己接触，人类也会倾向于更喜欢那个先来的人，哪怕后一个比前一个有更多的优点。",
        "date": "2020-05-09T00:00:00.000Z",
        "formattedDate": "2020年5月9日",
        "tags": [
          {
            "label": "电影鉴赏",
            "permalink": "/blog/tags/电影鉴赏"
          }
        ],
        "readingTime": 3.42,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "木鱼水心评《忠犬八公》观后感",
          "date": "2020-05-09T00:00:00.000Z",
          "categories": "电影鉴赏",
          "tags": [
            "电影鉴赏"
          ]
        },
        "prevItem": {
          "title": "前端知识学习01——HTML基本概念",
          "permalink": "/blog/前端知识学习01——HTML基本概念"
        },
        "nextItem": {
          "title": "本科答辩记录",
          "permalink": "/blog/本科答辩记录"
        }
      },
      "content": "<iframe src=\"//player.bilibili.com/player.html?aid=10836390&bvid=BV1ix411Y7pN&cid=17889388&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\r\n\r\n> 小八告诉我们忠诚的意义，我们不应该忘记爱过的每一个人，每个人类可能都觉得自己是理性的，也崇尚着这种理性。可是，有些事情，比如爱，人似乎无法遵循理性。比如，人不会根据每个人的能力做一个评分表，然后去把身边的人评一个分，随后决定这些人值不值得自己去爱。又比如，两个各方面完全一模一样的人，但如果有一个人先和自己接触，人类也会倾向于更喜欢那个先来的人，哪怕后一个比前一个有更多的优点。\r\n>爱是一种驯养，两个人花长的时间彼此付出，驯养其实有两个要素，一是在一万个人中挑出一个人，二是与她相处很长时间。狐狸曾对小王子说，在你驯养我之前，你还只是一个小男孩，和其他千万的小男孩一样，而我对你来说，也只是一只狐狸，和其他千万只狐狸一样。但是，如果你驯养了我，我们就互不可缺少了，对我，你是世界上唯一的，对你，我也是世界上唯一的，我甚至会喜欢那风吹麦浪的声音，因为它让我想起了你金黄色的头发。帕克和小八的爱何尝不是这样那？他们在车站遇到彼此，让他们从千万个选择中找到彼此，随后，他们彼此相处。在这之前，他们互相都只是普通的路人，但是在这之后，就不是了。并不是因为他们比别人更优秀，而是他们彼此驯养。\r\n>帕克爱着小八，视其为生命中极重要的朋友和伴侣。但小八爱自己的主人帕克，却是把他当成自己生命的全部。\r\n>但凡与爱相关，都不是可以用理性来解释的。\r\n>但我相信，一定有一些神秘而精巧的如同树叶下的光影一般的缘分在我们看不到的地方影响着什么。比如，为什么帕克偏偏遇到了小八，为什么小八在车站找到了帕克那？又或者，为什么我们会爱上一个人那？\r\n>小八用它一生的时间讲述了爱的含义，这种爱不是任何能够用理性或者逻辑所能解释穷尽的，所有的背后，应该有一个神秘的意义。而那种意义是我们说不清楚，但又知道确实有的这份爱指的我们投入赞美之心。"
    },
    {
      "id": "/本科答辩记录",
      "metadata": {
        "permalink": "/blog/本科答辩记录",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/本科答辩记录.md",
        "source": "@site/blog\\本科答辩记录.md",
        "title": "本科答辩记录",
        "description": "今天是2020-5-8，今天上午12点多，通过了本科论文答辩，前几天一直没睡好，总算答辩通过了，在答辩的时候，老师们都很好，只是简单的聊天，并没有提出什么问题，让我轻松过关，感谢今天的答辩老师。",
        "date": "2020-05-09T00:00:00.000Z",
        "formattedDate": "2020年5月9日",
        "tags": [
          {
            "label": "个人回忆录",
            "permalink": "/blog/tags/个人回忆录"
          }
        ],
        "readingTime": 0.965,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "本科答辩记录",
          "date": "2020-05-09T00:00:00.000Z",
          "categories": "个人回忆录",
          "tags": [
            "个人回忆录"
          ]
        },
        "prevItem": {
          "title": "木鱼水心评《忠犬八公》观后感",
          "permalink": "/blog/木鱼水心评《忠犬八公》观后感"
        },
        "nextItem": {
          "title": "文件命名参考",
          "permalink": "/blog/文件命名参考"
        }
      },
      "content": "今天是2020-5-8，今天上午12点多，通过了本科论文答辩，前几天一直没睡好，总算答辩通过了，在答辩的时候，老师们都很好，只是简单的聊天，并没有提出什么问题，让我轻松过关，感谢今天的答辩老师。\r\n>* 时燕妮老师\r\n>* 王赞老师\r\n>* 邓浩老师\r\n>* 王青林老师\r\n>* 秦勉老师\r\n***\r\n今天的顺利通过我感觉有一个重要的因素，就是因为我在答辩过程中，添加了三个视频讲解，稍后会上传到指定文件中，以作存档。[云盘地址](https://pan.baidu.com/s/1H-e4CWcAEBfEbSAwRo2vxQ)\r\n***\r\n准备了好多问题，都没有用上，哈哈！\r\n![](https://cdn.jsdelivr.net/gh/1120637483/image/57a3352beef44d7014792045009d57a.jpg)\r\n![](https://cdn.jsdelivr.net/gh/1120637483/image/78ce0a0ffd56457ff9846a7a0be36db.jpg)\r\n![](https://cdn.jsdelivr.net/gh/1120637483/image/1180eec4bbec83e024cd2e0caaf656a.jpg)\r\n![](https://cdn.jsdelivr.net/gh/1120637483/image/b409a53a008754997b2cb687051e787.jpg)\r\n![](https://cdn.jsdelivr.net/gh/1120637483/image/0e6ae43f1522f225d4f8f07035659e8.jpg)\r\n---\r\n时老师，说可能可以推优，甚是感动！"
    },
    {
      "id": "/文件命名参考",
      "metadata": {
        "permalink": "/blog/文件命名参考",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/文件命名参考.md",
        "source": "@site/blog\\文件命名参考.md",
        "title": "文件命名参考",
        "description": "在对一系列的文档进行命名的时候，可以参考下面的这种方式：",
        "date": "2020-05-05T00:00:00.000Z",
        "formattedDate": "2020年5月5日",
        "tags": [
          {
            "label": "效率",
            "permalink": "/blog/tags/效率"
          }
        ],
        "readingTime": 0.135,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "文件命名参考",
          "date": "2020-05-05T00:00:00.000Z",
          "categories": "效率",
          "tags": [
            "效率"
          ]
        },
        "prevItem": {
          "title": "本科答辩记录",
          "permalink": "/blog/本科答辩记录"
        },
        "nextItem": {
          "title": "给hexo博客加入阅读全文",
          "permalink": "/blog/给hexo博客加入阅读全文"
        }
      },
      "content": "在对一系列的文档进行命名的时候，可以参考下面的这种方式：\r\n![](https://gitee.com/justin2/pic/raw/master/20200505163556.png)"
    },
    {
      "id": "/给hexo博客加入阅读全文",
      "metadata": {
        "permalink": "/blog/给hexo博客加入阅读全文",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/给hexo博客加入阅读全文.md",
        "source": "@site/blog\\给hexo博客加入阅读全文.md",
        "title": "给hexo博客加入阅读全文",
        "description": "经过反复测试，亲测这篇博客有效！",
        "date": "2020-05-05T00:00:00.000Z",
        "formattedDate": "2020年5月5日",
        "tags": [
          {
            "label": "hexo",
            "permalink": "/blog/tags/hexo"
          }
        ],
        "readingTime": 0.135,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "给hexo博客加入阅读全文",
          "date": "2020-05-05T00:00:00.000Z",
          "categories": "hexo",
          "tags": [
            "hexo"
          ]
        },
        "prevItem": {
          "title": "文件命名参考",
          "permalink": "/blog/文件命名参考"
        },
        "nextItem": {
          "title": "快速下载到高清电影的方法",
          "permalink": "/blog/快速下载到高清电影的方法"
        }
      },
      "content": "经过反复测试，亲测这篇博客有效！\r\n[next7.6版本关于设置阅读全文](https://blog.csdn.net/CHENGXUYUAN09/article/details/103408380)\r\n![](https://gitee.com/justin2/pic/raw/master/20200505110325.png)"
    },
    {
      "id": "/快速下载到高清电影的方法",
      "metadata": {
        "permalink": "/blog/快速下载到高清电影的方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/快速下载到高清电影的方法.md",
        "source": "@site/blog\\快速下载到高清电影的方法.md",
        "title": "快速下载到高清电影的方法",
        "description": "1：使用聚BT检索到相关地址。（也可以直接谷歌 电影名+磁力进行搜索，这个效率有时候更高）",
        "date": "2020-05-04T00:00:00.000Z",
        "formattedDate": "2020年5月4日",
        "tags": [
          {
            "label": "效率",
            "permalink": "/blog/tags/效率"
          }
        ],
        "readingTime": 0.39,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "快速下载到高清电影的方法",
          "date": "2020-05-04T00:00:00.000Z",
          "categories": "效率",
          "tags": [
            "效率"
          ]
        },
        "prevItem": {
          "title": "给hexo博客加入阅读全文",
          "permalink": "/blog/给hexo博客加入阅读全文"
        },
        "nextItem": {
          "title": "Next主题阅读次数不显示的原因",
          "permalink": "/blog/Next主题阅读次数不显示的原因"
        }
      },
      "content": "1：使用[聚BT](https://jubt.net/cn/index.html)检索到相关地址。（也可以直接谷歌 电影名+磁力进行搜索，这个效率有时候更高）\r\n2：使用黑科在线进行高速下载。\r\n3：直接通过某些DB网站进行在线观看。（让专业的人做更专业的事情）"
    },
    {
      "id": "/Next主题阅读次数不显示的原因",
      "metadata": {
        "permalink": "/blog/Next主题阅读次数不显示的原因",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Next主题阅读次数不显示的原因.md",
        "source": "@site/blog\\Next主题阅读次数不显示的原因.md",
        "title": "Next主题阅读次数不显示的原因",
        "description": "解决流程：",
        "date": "2020-05-03T00:00:00.000Z",
        "formattedDate": "2020年5月3日",
        "tags": [
          {
            "label": "debug",
            "permalink": "/blog/tags/debug"
          },
          {
            "label": "hexo",
            "permalink": "/blog/tags/hexo"
          }
        ],
        "readingTime": 0.575,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Next主题阅读次数不显示的原因",
          "date": "2020-05-03T00:00:00.000Z",
          "categories": "debug",
          "tags": [
            "debug",
            "hexo"
          ]
        },
        "prevItem": {
          "title": "快速下载到高清电影的方法",
          "permalink": "/blog/快速下载到高清电影的方法"
        },
        "nextItem": {
          "title": "Git基础指令",
          "permalink": "/blog/Git基础指令"
        }
      },
      "content": "解决流程：\r\n1：我首先根据这篇博客[Hexo博客Next主题添加统计文章阅读量功能](https://bjtu-hxs.github.io/2018/06/12/leancloud-config/)进行了相关设置。\r\n2：出现了一个问题，就是阅读次数后面没有数字显示。\r\n3：经过我的反复尝试，终于我发现原来并不需要将下面的置为true。\r\n```\r\nleancloud_visitors:\r\n  enable: false\r\n```\r\n4: 只需要将valine下的这行代码进行修改即可。\r\n```\r\nvaline:\r\n  visitor: true\r\n```"
    },
    {
      "id": "/Git基础指令",
      "metadata": {
        "permalink": "/blog/Git基础指令",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Git基础指令.md",
        "source": "@site/blog\\Git基础指令.md",
        "title": "Git基础指令",
        "description": "指令的含义",
        "date": "2020-05-02T00:00:00.000Z",
        "formattedDate": "2020年5月2日",
        "tags": [
          {
            "label": "Git",
            "permalink": "/blog/tags/git"
          }
        ],
        "readingTime": 1.225,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Git基础指令",
          "date": "2020-05-02T00:00:00.000Z",
          "categories": "Git",
          "tags": [
            "Git"
          ]
        },
        "prevItem": {
          "title": "Next主题阅读次数不显示的原因",
          "permalink": "/blog/Next主题阅读次数不显示的原因"
        },
        "nextItem": {
          "title": "Hexo博客使用gitee图片无法正常显示解决",
          "permalink": "/blog/Hexo博客使用gitee图片无法正常显示解决"
        }
      },
      "content": "## 指令的含义\r\n|创建分支|git branch name|切换到name分支\r\n|---|---|---|\r\n|切换分支|git checkout name|Head指向name\r\n|提交分支|git commit|每一次提交都会包含当前指向的分支|\r\n|合并分支1|git merge 名字|将merge后面的分支合并到当前所在的分支，也就是*指向的分支|\r\n|合并分支2|git rebase 名字|合并到名字的后面|\r\n|分离HEAD|git checkout 名字|这里的 名字 指的是HEAD指向的分支指向的位置|\r\n\r\n* **git commit** ：只提交暂存区的文件，也就是说只提交status下是绿色的文件\r\n* **git reset** ：将绿色的文件，重新变为红色，想当于撤销的操作。\r\n* **git status** ：查看暂存区的工作状态，存在绿色的话，说明还没有提交到本地库\r\n* 提交的格式选择(尽量选择下面这种格式,引号里相当于是注释)\r\n![](https://i.loli.net/2020/05/02/KnpPLcZ2u7oMONC.png)\r\n* **git log**：查看历史的提交记录\r\n*"
    },
    {
      "id": "/Hexo博客使用gitee图片无法正常显示解决",
      "metadata": {
        "permalink": "/blog/Hexo博客使用gitee图片无法正常显示解决",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Hexo博客使用gitee图片无法正常显示解决.md",
        "source": "@site/blog\\Hexo博客使用gitee图片无法正常显示解决.md",
        "title": "Hexo博客使用gitee图片无法正常显示解决",
        "description": "经过系统性的排查问题，原因在于gitee不支持大于1M的图片公开访问，访问这样的图片需要登录，这也就是为什么Chrome浏览器正常（因为你登录了），其他浏览器都无法访问的原因。",
        "date": "2020-05-02T00:00:00.000Z",
        "formattedDate": "2020年5月2日",
        "tags": [
          {
            "label": "debug",
            "permalink": "/blog/tags/debug"
          },
          {
            "label": "hexo",
            "permalink": "/blog/tags/hexo"
          }
        ],
        "readingTime": 0.355,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Hexo博客使用gitee图片无法正常显示解决",
          "date": "2020-05-02T00:00:00.000Z",
          "categories": "debug",
          "tags": [
            "debug",
            "hexo"
          ]
        },
        "prevItem": {
          "title": "Git基础指令",
          "permalink": "/blog/Git基础指令"
        },
        "nextItem": {
          "title": "OneNote快速传图到博客",
          "permalink": "/blog/OneNote快速传图到博客"
        }
      },
      "content": "经过系统性的排查问题，原因在于gitee不支持大于1M的图片公开访问，访问这样的图片需要登录，这也就是为什么Chrome浏览器正常（因为你登录了），其他浏览器都无法访问的原因。"
    },
    {
      "id": "/OneNote快速传图到博客",
      "metadata": {
        "permalink": "/blog/OneNote快速传图到博客",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/OneNote快速传图到博客.md",
        "source": "@site/blog\\OneNote快速传图到博客.md",
        "title": "OneNote快速传图到博客",
        "description": "直接在OneNote里复制框框即可",
        "date": "2020-05-02T00:00:00.000Z",
        "formattedDate": "2020年5月2日",
        "tags": [
          {
            "label": "hexo",
            "permalink": "/blog/tags/hexo"
          },
          {
            "label": "论文答辩",
            "permalink": "/blog/tags/论文答辩"
          }
        ],
        "readingTime": 0.065,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "OneNote快速传图到博客",
          "date": "2020-05-02T00:00:00.000Z",
          "categories": "hexo",
          "tags": [
            "hexo",
            "论文答辩"
          ]
        },
        "prevItem": {
          "title": "Hexo博客使用gitee图片无法正常显示解决",
          "permalink": "/blog/Hexo博客使用gitee图片无法正常显示解决"
        },
        "nextItem": {
          "title": "GitHub 的 Pull Request 是指什么意思？",
          "permalink": "/blog/GitHub 的 Pull Request 是指什么意思？"
        }
      },
      "content": ">直接在OneNote里复制框框即可\r\n![](https://i.loli.net/2020/05/02/R7mMUivV9jdTaCh.png)"
    },
    {
      "id": "/GitHub 的 Pull Request 是指什么意思？",
      "metadata": {
        "permalink": "/blog/GitHub 的 Pull Request 是指什么意思？",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/GitHub 的 Pull Request 是指什么意思？.md",
        "source": "@site/blog\\GitHub 的 Pull Request 是指什么意思？.md",
        "title": "GitHub 的 Pull Request 是指什么意思？",
        "description": "本文由 简悦 SimpRead 转码， 原文地址 https://www.zhihu.com/question/21682976 beepony",
        "date": "2020-04-30T00:00:00.000Z",
        "formattedDate": "2020年4月30日",
        "tags": [
          {
            "label": "Git",
            "permalink": "/blog/tags/git"
          }
        ],
        "readingTime": 5.745,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "GitHub 的 Pull Request 是指什么意思？",
          "date": "2020-04-30T00:00:00.000Z",
          "categories": "Git",
          "tags": [
            "Git"
          ]
        },
        "prevItem": {
          "title": "OneNote快速传图到博客",
          "permalink": "/blog/OneNote快速传图到博客"
        },
        "nextItem": {
          "title": "Git整体结构图",
          "permalink": "/blog/Git整体结构图"
        }
      },
      "content": "> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 https://www.zhihu.com/question/21682976 ![](https://pic2.zhimg.com/1e5f01079_xs.jpg)beepony\r\n\r\n我尝试用类比的方法来解释一下 pull reqeust。想想我们中学考试，老师改卷的场景吧。你做的试卷就像仓库，你的试卷肯定会有很多错误，就相当于程序里的 bug。老师把你的试卷拿过来，相当于先 fork。在你的卷子上做一些修改批注，相当于 git commit。最后把改好的试卷给你，相当于发 pull request，你拿到试卷重新改正错误，相当于 merge。\r\n\r\n当你想更正别人仓库里的错误时，要走一个流程：  \r\n\r\n1.  先 fork 别人的仓库，相当于拷贝一份，相信我，不会有人直接让你改修原仓库的\r\n2.  clone 到本地分支，做一些 bug fix\r\n3.  发起 pull request 给原仓库，让他看到你修改的 bug\r\n4.  原仓库 review 这个 bug，如果是正确的话，就会 merge 到他自己的项目中\r\n\r\n至此，整个 pull request 的过程就结束了。\r\n\r\n理解了 pull request 的含义和流程，具体操作也就简单了。以 Github 排名最高的 [https://github.com/twbs/bootstrap](https://link.zhihu.com/?target=https%3A//github.com/twbs/bootstrap) 为例说明。  \r\n1. 先点击 fork 仓库，项目现在就在你的账号下了\r\n\r\n![](https://pic3.zhimg.com/50/0d01d6aa4cc4330c525347e5b0a0ecb8_hd.jpg)![](https://pic3.zhimg.com/0d01d6aa4cc4330c525347e5b0a0ecb8_r.jpg)  \r\n![](https://pic1.zhimg.com/50/6aaed35908e74de871fcbed7c5affb0e_hd.jpg)![](https://pic1.zhimg.com/6aaed35908e74de871fcbed7c5affb0e_r.jpg)2. 在你自己的机器上 git clone 这个仓库，切换分支（也可以在 master 下），做一些修改。  \r\n\r\n```\r\n~  git clone https://github.com/beepony/bootstrap.git\r\n~  cd bootstrap\r\n~  git checkout -b test-pr\r\n~  git add . && git commit -m \"test-pr\"\r\n~  git push origin test-pr\r\n```\r\n\r\n3. 完成修改之后，回到 test-pr 分支，点击旁边绿色的 Compare & pull request 按钮  \r\n\r\n![](https://pic2.zhimg.com/50/3e1ac7f58774a79a5dd6bf8e852e4199_hd.jpg)![](https://pic2.zhimg.com/3e1ac7f58774a79a5dd6bf8e852e4199_r.jpg)4. 添加一些注释信息，确认提交  \r\n![](https://pic3.zhimg.com/50/f5ed68dfe4d60fe90e2fb22ec1933006_hd.jpg)![](https://pic3.zhimg.com/f5ed68dfe4d60fe90e2fb22ec1933006_r.jpg)5. 仓库作者看到，你提的确实是对的，就会 merge，合并到他的项目中\r\n\r\n以上就是 pull reqesut 的整个流程，希望对你有帮助～\r\n\r\n参考文档：  \r\n[Fork A Repo - User Documentation](https://link.zhihu.com/?target=https%3A//help.github.com/articles/fork-a-repo/)  \r\n[Using pull requests](https://link.zhihu.com/?target=https%3A//help.github.com/articles/using-pull-requests/)  \r\n[Creating a pull request](https://link.zhihu.com/?target=https%3A//help.github.com/articles/creating-a-pull-request/)![](https://pic2.zhimg.com/19ed62ad9_xs.jpg) 王赟 Maigo​\r\n\r\n我从单纯的语言学角度解释一下为什么 “pull request” 这个词组这么令人费解。\r\n\r\n先说正确的理解：pull request 是一个 request，它的目的是让别人 pull 你的东西。\r\n\r\n然而 pull 和 request 两个名词直接相连构成偏正短语，二者之间具体是什么关系是不确定的。\r\n\r\n**思考**：water hose, rubber hose, fire hose, garden hose 这四个短语中，两个词之间分别是什么关系？\r\n\r\n我第一次看到 pull request 这个词组的时候，误以为这个 request 的目的是请求别人允许自己 pull 别人的东西。\r\n\r\n另外，pull 和 request 还都有动词义，放到一起的时候，还可能被误解成动宾短语（pull 作动词，request 作名词）。\r\n\r\n英语中很多单词有多种词性，另外对一串名词直接相连构成词组的句法又比较宽容，这两个性质容易被滥用，造成沟通上的不便。  \r\n恰好汉语也具有这两个特点——你把上文中的 “pull request” 都换成“拉取请求”，看看是不是依然成立？\r\n\r\n当然，熟悉了 GitHub 的工作流程后，你可能就不再感觉 pull request 这个词组有歧义或是费解了。\r\n\r\n这是专业知识消除歧义的典型例子。\r\n\r\n![](https://pic1.zhimg.com/aadd7b895_xs.jpg)匿名用户有一个仓库，叫 Repo A。你如果要往里贡献代码，首先要 Fork 这个 Repo，于是在你的 Github 账号下有了一个 Repo A2,。然后你在这个 A2 下工作，Commit，push 等。然后你希望原始仓库 Repo A 合并你的工作，你可以在 Github 上发起一个 Pull Request，意思是请求 Repo A 的所有者从你的 A2 合并分支。如果被审核通过并正式合并，这样你就为项目 A 做贡献了![](https://pic4.zhimg.com/04d3c071d_xs.jpg)程墨 Morgan\r\n\r\n使用过 git 的应该都知道 git pull，这个命名相当于连续执行两个命令 git fetch 然后 git merge。所以，pull request 的意思就是一个 “请求”（request），请对方做一个 git fetch 拿到 request 中的代码 commits，然后 git merge 一下到某个分支上。\r\n\r\npull request 简称 PR，是 github 的概念，不是 git 的概念，所以也不是立刻出结果的，需要有人去同意完成这个 PR，当然同意完成 PR 的可以是自己，也可以拒绝 PR。\r\n\r\n现实项目中，即使自己对某个 repo 的特定分枝有写入权限，也可以提 PR 来修改，因为这是 code review 的一种方式，让团队的其他人看一看改的咋样。![](https://pic2.zhimg.com/6d2ebe6e9bcee3b86a081a67b843f929_xs.jpg)冯斐我改了你们的代码，你们拉回去看看吧 ！！！"
    },
    {
      "id": "/Git整体结构图",
      "metadata": {
        "permalink": "/blog/Git整体结构图",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Git整体结构图.md",
        "source": "@site/blog\\Git整体结构图.md",
        "title": "Git整体结构图",
        "description": "*",
        "date": "2020-04-30T00:00:00.000Z",
        "formattedDate": "2020年4月30日",
        "tags": [
          {
            "label": "Git",
            "permalink": "/blog/tags/git"
          }
        ],
        "readingTime": 0.025,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Git整体结构图",
          "date": "2020-04-30T00:00:00.000Z",
          "categories": "Git",
          "tags": [
            "Git"
          ]
        },
        "prevItem": {
          "title": "GitHub 的 Pull Request 是指什么意思？",
          "permalink": "/blog/GitHub 的 Pull Request 是指什么意思？"
        },
        "nextItem": {
          "title": "提高效率的win10操作",
          "permalink": "/blog/提高效率的win10操作"
        }
      },
      "content": "![](https://gitee.com/justin2/pic/raw/master/20200430193359.png)\r\n***\r\n![](https://gitee.com/justin2/pic/raw/master/20200430193925.png)\r\n***\r\n![](https://gitee.com/justin2/pic/raw/master/20200430194632.png)"
    },
    {
      "id": "/提高效率的win10操作",
      "metadata": {
        "permalink": "/blog/提高效率的win10操作",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/提高效率的win10操作.md",
        "source": "@site/blog\\提高效率的win10操作.md",
        "title": "提高效率的win10操作",
        "description": "快速恢复被关闭的网页",
        "date": "2020-04-30T00:00:00.000Z",
        "formattedDate": "2020年4月30日",
        "tags": [
          {
            "label": "效率",
            "permalink": "/blog/tags/效率"
          }
        ],
        "readingTime": 0.37,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "提高效率的win10操作",
          "date": "2020-04-30T00:00:00.000Z",
          "categories": "效率",
          "tags": [
            "效率"
          ]
        },
        "prevItem": {
          "title": "Git整体结构图",
          "permalink": "/blog/Git整体结构图"
        },
        "nextItem": {
          "title": "远程修改git仓库中的文件内容",
          "permalink": "/blog/远程修改git仓库中的文件内容"
        }
      },
      "content": "## 快速恢复被关闭的网页\r\n```\r\nCtrl + Shift + T\r\n```\r\n>等价于网页中的撤销操作\r\n## 经常访问的文件夹怎么快速打开？\r\n答：加入到快速访问。\r\n## 快速找到复制过的内容\r\n答：使用ditto\r\n\r\n默认快捷键:\r\n``` \r\nCtrl + `\r\n```"
    },
    {
      "id": "/远程修改git仓库中的文件内容",
      "metadata": {
        "permalink": "/blog/远程修改git仓库中的文件内容",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/远程修改git仓库中的文件内容.md",
        "source": "@site/blog\\远程修改git仓库中的文件内容.md",
        "title": "远程修改git仓库中的文件内容",
        "description": "新建一个文件夹，并在这个文件夹中将远程仓库克隆下来。",
        "date": "2020-04-30T00:00:00.000Z",
        "formattedDate": "2020年4月30日",
        "tags": [
          {
            "label": "Git",
            "permalink": "/blog/tags/git"
          }
        ],
        "readingTime": 1.165,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "远程修改git仓库中的文件内容",
          "date": "2020-04-30T00:00:00.000Z",
          "categories": "Git",
          "tags": [
            "Git"
          ]
        },
        "prevItem": {
          "title": "提高效率的win10操作",
          "permalink": "/blog/提高效率的win10操作"
        },
        "nextItem": {
          "title": "13 款内容收集整理利器，打造你专属的个人知识库标注利器总结",
          "permalink": "/blog/13 款内容收集整理利器，打造你专属的个人知识库标注利器总结"
        }
      },
      "content": "## 新建一个文件夹，并在这个文件夹中将远程仓库克隆下来。\r\n![](https://gitee.com/justin2/pic/raw/master/20200430095035.png)\r\n## 进入我们要修改的文件夹（这点很重要）\r\n![](https://gitee.com/justin2/pic/raw/master/20200430095049.png)\r\n## 查看我们当前所在的分支\r\n![](https://gitee.com/justin2/pic/raw/master/20200430095111.png)\r\n## 查看远程仓库的状态\r\n![](https://gitee.com/justin2/pic/raw/master/20200430095125.png)\r\n## 修改远程仓库中文件的内容\r\n![](https://gitee.com/justin2/pic/raw/master/20200430095139.png)\r\n## 查看远程仓库的状态\r\n![](https://gitee.com/justin2/pic/raw/master/20200430095151.png)\r\n## 加入暂存区\r\n![](https://gitee.com/justin2/pic/raw/master/20200430095201.png)\r\n## 远程提交（引号里是自己的）\r\n![](https://gitee.com/justin2/pic/raw/master/20200430095214.png)\r\n## 推送上去\r\n![](https://gitee.com/justin2/pic/raw/master/20200430095224.png)\r\n\r\n>由于使用的是Gitee因此要输入用户名和密码，今天用了好久才发现，原来我的Gitee的用户名是我的手机号\r\n## 如果出现问题，可以参考下面的解决办法（推荐方案2）\r\n方案1：\r\n![](https://gitee.com/justin2/pic/raw/master/20200430093026.png)\r\n方案2：\r\n![](https://gitee.com/justin2/pic/raw/master/20200430093729.png)\r\n>总结下：当出现上述的问题的时候，是因为远程仓库发生了变化，本地需要先更新才可以继续上传。"
    },
    {
      "id": "/13 款内容收集整理利器，打造你专属的个人知识库标注利器总结",
      "metadata": {
        "permalink": "/blog/13 款内容收集整理利器，打造你专属的个人知识库标注利器总结",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/13 款内容收集整理利器，打造你专属的个人知识库标注利器总结.md",
        "source": "@site/blog\\13 款内容收集整理利器，打造你专属的个人知识库标注利器总结.md",
        "title": "13 款内容收集整理利器，打造你专属的个人知识库标注利器总结",
        "description": "本文由 简悦 SimpRead 转码， 原文地址 https://juejin.im/entry/59daed136fb9a00a652b3e57",
        "date": "2020-04-29T00:00:00.000Z",
        "formattedDate": "2020年4月29日",
        "tags": [
          {
            "label": "优秀鉴赏",
            "permalink": "/blog/tags/优秀鉴赏"
          }
        ],
        "readingTime": 14.24,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "13 款内容收集整理利器，打造你专属的个人知识库标注利器总结",
          "date": "2020-04-29T00:00:00.000Z",
          "categories": "优秀鉴赏",
          "tags": [
            "优秀鉴赏"
          ]
        },
        "prevItem": {
          "title": "远程修改git仓库中的文件内容",
          "permalink": "/blog/远程修改git仓库中的文件内容"
        },
        "nextItem": {
          "title": "Chrome浏览器的拓展程序的安装位置",
          "permalink": "/blog/Chrome浏览器的拓展程序的安装位置"
        }
      },
      "content": "> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 https://juejin.im/entry/59daed136fb9a00a652b3e57\r\n\r\n在浏览大量资讯的过程，大家有可能遇到这样的使用场景:  \r\n\r\n*   如何保存网页的文章内容；\r\n*   希望可以即时对保存下来的内容进行标注；\r\n*   文章太长了，我想迟点再精读，或者想转移到手机端阅读；\r\n*   手上有 Kindle 设备，希望将长文章转移到电子阅读设备上再阅读；\r\n\r\n我个人在信息收集、资讯阅读上也都会碰到上面这些问题。在这篇文章里，我将向大家推荐一些实用的网页内容（书签）收集、管理的工具利器。\r\n\r\n收集工具\r\n----\r\n\r\n### Pocket & Instapaper\r\n\r\n![][img-0]\r\n\r\n这两款工具面世之后，「活生生」地创造了一个使用场景：Read It Later 稍后读。[Pocket](https://getpocket.com/) 和 [Instapaper](https://www.instapaper.com/) 常常被大家拉在一起进行比较选择，两款成熟的工具都值得推荐给追求稳定、有跨平台需求、看重文章阅读体验的用户。\r\n\r\n![][img-1]\r\n\r\n**Pocket** 支持主流的 [iOS](https://itunes.apple.com/app/read-it-later-pro/id309601447)、[Android](https://play.google.com/store/apps/details?id=com.ideashower.readitlater.pro)、[macOS](https://itunes.apple.com/app/pocket/id568494494)，浏览器插件支持 Firefox(2017 年 2 月，Pocket 被 Mozilla 收购)、[Chrome](https://chrome.google.com/webstore/detail/niloccemoadcdkdjlinkgdfekeahmflj)、[Safari](https://safari-extensions.apple.com/details/?id=com.ideashower.pocket.safari-ET279A6R5N)、 [Opera](https://addons.opera.com/en/extensions/details/pocket-formerly-read-it-later/)、Bookmarklets，古老的 Blackberry、Windows Phone 平台也有第三方 Apps 支持，可以说 Pocket 是内容搜集工具中支持平台较为全面的应用。Pocket 在阅读上也有不错的体验，可调节的阅读设置包括了衬线体、字体大小，阅读条目背景色。另一特色是 2015 年 8 月发布的 v6.0 版本中集成了推荐功能，由于仅涉及英文语境的推荐内容，对于中文用户吸引力并不是很强。\r\n\r\n![][img-2]\r\n\r\n**Instapaper** 并不像 Pocket 那样「变态般」支持各种平台，目前支持 [iOS](https://itunes.apple.com/us/app/instapaper/id288545208)、[Android](https://play.google.com/store/apps/details?id=com.instapaper.android)、[Kindle](https://www.instapaper.com/user)、Bookmarklets。我个人也曾经分享一篇名为「 [围绕 Instapaper 打造阅读流程](https://sspai.com/post/37010)」，Instapaper 在阅读体验上有着很不错的表现，包括条目管理页面智能分析了阅读文章需要的大概市场、阅读版面控制（提供四种字体、字体大小、边栏宽度控制、阅读背景色）、离线保存本地方式（Kindle、ePub、Printable、RSS Feed）。Instapaper 用户可以再文章内容的某些字段通过划线标颜色的方式进行简单标注，隐私方面竟然也提供了 Delete Account 删除帐户选项。\r\n\r\nPocket 和 Instapaper 最大的区别在于（个人观点）条目管理方式。Pocket 使用了标签化管理（一篇文章可添加多个标签）。在点入某个标签的情况，Pocket 默认展示了未读条目，可通过标签旁边的下拉选项切换至添加到收藏夹、存档列表。Instapaper 则采用了文件夹的管理方式，每个文件夹都会直接显示出全部阅读条目（并不区分未读和已读）。\r\n\r\n*   [这才是我想要的文章管理方式：稍后读 Pocket 功能详解](https://sspai.com/post/28556)\r\n*   [谈谈稍后读：Instapaper 可能被忽略的功能](https://sspai.com/post/28611)\r\n*   [新希望还是大结局 — Instapaper 全免费](https://sspai.com/post/31047)\r\n\r\n### 收趣\r\n\r\n![][img-3]\r\n\r\n国产稍后读的代表之一[收趣](https://shouqu.me/)（之前名字叫收趣云书签），提供了 [iOS](https://itunes.apple.com/cn/app/shou-qu-yun-shu-qian-sui-pian/id1072254626)、[Android](https://coolapk.com/apk/com.shouqu.bookmarklife)、[Chrome](https://chrome.google.com/webstore/detail/shouqu/ofmcnfnfchmhlchdifeobmjjhmkijpnf)、 [Firefox](http://shouqu.me/extensions/shouqu.1.3.0.xpi)、[Safari](http://shouqu.me/extensions/shouqu.1.2.2.safariextz)、Bookmarklets。收趣可按照分类或者阅读状态对保存条目进行管理，提供了从 Pocket 同步到应用本身的入口，方便用户数据迁移。收趣的特色功能在于移动端丰富的收藏方式，包括账号绑定转发到微信、微博 @保存到收趣、系统分享、复制链接。\r\n\r\n不过吐槽的是，收趣 Web 平台并不存储文章内容本身，类似是升级版的书签管理器，用户需要跳转至网页本身来阅读保存的文章内容。而移动客户端支持无需文章跳转阅读、语音朗读、热门收藏排行榜、关注趣友的社交功能，另外，其导出备份功能仅对收趣会员开放。\r\n\r\n*   [稍后阅读有新姿势，整理信息的又一种便利方式 #收趣云书签](https://sspai.com/post/36700)\r\n\r\n### Pinboard\r\n\r\n![][img-4]\r\n\r\n由于本人从未使用过 [Pinboard](https://pinboard.in/)，所以应用的功能介绍来源于官网和少楠分享文「[互联网匠人作品：「反社交」的书签服务 Pinboard.in](https://sspai.com/post/38532)」。\r\n\r\nPinboard 收费 11 刀 / 年，支持主流浏览器插件、主流手机平台 16 款客户端，以及 9 个桌面客户端，并且为开发者提供了 6 种编程语言接口。Pinboard 支持 RSS 输出，任意格式的导入和导出，帮助用户把浏览器书签、Twitter 账户，或者 Instapaper/Pocket 等流行服务同步。Pinboard 提供了全文存档服务，可以保存你书签里面的所有内容，并自动检查死链。这样即使保存书签的来源丢失，用户依旧可以访问。\r\n\r\n*   [互联网匠人作品：「反社交」的书签服务 Pinboard.in](https://sspai.com/post/38532)\r\n\r\n### Send to Kindle\r\n\r\n![][img-5]\r\n\r\n如果用户手上有 Kindle 设备，可以尝试 Amazon 出品的收集小工具 [Send to Kindle](https://www.amazon.com/gp/sendtokindle)，支持 [macOS](https://www.amazon.com/gp/sendtokindle/mac)、[Windows](https://www.amazon.com/gp/sendtokindle/pc)、 [Android](https://www.amazon.com/gp/sendtokindle/android)、[Chrome](https://chrome.google.com/webstore/detail/send-to-kindle-for-google/cgdjpilhipecahhcilnafpblkieebhea)、[Firefox](https://addons.mozilla.org/en-US/firefox/addon/sendtokindle)。以 Chrome 版本为例，Send to Kindle 插件提供了发送、预览功能，支持将任何网页内容快速发送至后台绑定的 Kindle 设备账号，用户可以通过 Kindle 设备和 Kindle App 即可随时阅读保存内容。Send to Kindle 很好解决了通过 Kindle 设备阅读，。比较遗憾的是，Send to Kindle 支持的平台版本有很多都没有持续更新，Chrome 版本最新更新时间是 2015 年 9 月。\r\n\r\n*   [如何更好地使用 Kindle](https://sspai.com/post/40333)\r\n\r\n### 简悦\r\n\r\n![][img-6]\r\n\r\n9 月 4 日，[简悦](http://ksria.com/simpread/)经历了十六个版本迭代之后， v1.0.3 版本正式发布，终于有了一款可以替代 Clearly（2015 年 12 月已宣布停止开发） 的 Chrome 插件。新版简悦支持导出到各大生产力，解决了优化网页阅读体验之后的存储问题。目前用户可将剪辑内容导出到本地（PDF、PNG 文件）、Pocket、Linnk、Dropbox、Onenote、Google Drive、印象笔记 / Evernote 以及 Kindle 设备。\r\n\r\n*   [简悦 1.0.3，让你离知识再近一步](https://sspai.com/post/40754)\r\n\r\n### 浏览器阅读列表\r\n\r\n如果不喜欢额外安装应用 Apps 或者浏览器插件，那么推荐给这些用户使用部分浏览器本身内部集成的功能，目前包括 Safari、Firefox、Microsoft Edge 集成这一功能。以 Firefox for Android 版本为例，Firefox 将自动识别网页文章是否支持阅读模式，如果支持的话会在地址栏出现书本的标志，点击进入阅读模式，Firefox 支持背景颜色、字体大小、衬线体的调节选项，显示阅读时长。大家将文章保存为书签后，切换到移动书签页面，可以看到阅读列表的选项，实现了保存列表同步、离线保存的功能。\r\n\r\n![][img-7]\r\n\r\n浏览器集成的阅读列表功能，更多是扮演了「临时工」的角色，方便不喜欢安装任何应用的用户，保存下来的文章只能通过浏览器自身平台来同步。\r\n\r\n*   [iOS 基础教程： 系统自带的稍后读，Safari 「阅读列表」使用指南](https://sspai.com/post/26657)\r\n\r\n[](#标注利器)标注利器\r\n=============\r\n\r\n上面介绍了几款便利的文章收集工具，如果用户希望在收集工具中边阅读边做好标注工作的话，下面收罗了三款实用工具。\r\n\r\n### Liner\r\n\r\n> Read, Highlight, and Share\r\n\r\n![][img-8]\r\n\r\n上面是 [Liner](https://getliner.com/) 官方给出的三个关键词。Liner 支持 [Chrome](https://chrome.google.com/webstore/detail/liner-private-webpdf-high/bmhcbmnbenmcecpmpepghooflbehcack)、[Safari](http://getliner.com/download/safari/)、 [iOS](https://itunes.apple.com/app/appName/id955395198?)。Liner 提供了友好的中文化界面，安装好浏览器插件后，通过快捷键可对网页内容直接进行在线标注和评论，。Liner 还支持将用户生成好的标注网页以超链接方式发送分享给好友，或者输出到 Evernote、OneNote、Googl Drive、TXT File、Email。除了标注功能之外，Liner 可以与 Pocket、Instapaper 同步，以及支持标注上传 PDF 文件。Liner 高级版（4.99 美元 / 月、49.99 美元 / 年）支持更多标注颜色、高级搜索、无限数量文件夹管理。\r\n\r\n*   [LINER，让你能对网页内容方便地「划重点」](https://sspai.com/post/38798)\r\n\r\n### OneNote Web Clipper\r\n\r\n![][img-9]\r\n\r\n微软 OneNote 定位更偏向于快速的笔记记录，不过它提供的浏览器插件 OneNote Web Clipper [Chrome](https://chrome.google.com/webstore/detail/onenote-web-clipper/gojbdfnpnhogfdgjbigejoaolejmgdhk) 、[Firefox](https://addons.mozilla.org/en-US/firefox/addon/onenote-clipper/) 版本适合快速保存网页内容，以整页、区域、文章、书签共四种方式保存网页内容，可以剪辑的内容还包括了在线或本地 PDF 文件、网页上的任意图像、YouTube 或 Vimeo 视频。插件本身提供了标注功能，方便直接在剪辑内容上实现划线标注的操作。由于关联了 OneNote 应用，所以可以随时在[各大平台](https://www.onenote.com/)上方便阅读保存内容。\r\n\r\n### Lumioapp\r\n\r\n> highlight what matters\r\n\r\n![][img-10]\r\n\r\nLumioapp 号称随意标注你喜欢的任何内容，应用支持 [Chrome](https://chrome.google.com/webstore/detail/lumio-highlight-what-matt/hgomdfbclcjpeecbjckbbojbmmjegpek)、[iOS](https://itunes.apple.com/us/app/lumio-reader-highlights-images-pdf-bookmarks/id1238047029)。Lumioapp 会对网页中的图像、视频、PDF 内容自动识别并提示可单独保存下来，通过 Facebook、Twitter、Email 或者复制链接的方式分享给好友，在保存网页内容之后还可以单独添加 note 私人笔记内容。Lumioapp 以卡片或者收藏夹的条目整理方式，提供 Open in reader 的阅读器来单独阅读保存内容。官方表示未来会支持 Android、Safari、Firefox、Edge 平台。\r\n\r\n自动化和集中管理工具\r\n----------\r\n\r\n在面对各种各样的资讯阅读工具，除了使用上面提到的保存、标注工具，对内容进行剪辑、标注、保存之外，如何解决 rss 、稍后读阅读工具的内容自动化输出，下面推荐三款工具正好解决了整个问题。\r\n\r\n### Wallabag\r\n\r\n![][img-11]\r\n\r\nWallabag 支持 [Firefox](https://addons.mozilla.org/zh-CN/firefox/addon/wallabagger/)、[Chrome](https://chrome.google.com/webstore/detail/wallabagger/gbmgphmejlcoihgedabhgjdkcahacjlj)、[Opera](https://addons.opera.com/en/extensions/details/wallabagger/?display=en)、 [Android](https://play.google.com/store/apps/details?id=fr.gaulupeau.apps.InThePoche)、[iOS](https://itunes.apple.com/app/wallabag-2/id1170800946?mt=8)、[Windows Phone](https://www.microsoft.com/store/apps/wallabag/9nblggh11646)，除了具备常规的文章剪辑保存的功能外，亮点还在于支持 Pocket、Readability、Instapaper、Pinboard，以及导入 Firefox、Chrome 浏览器的书签，集中管理各类的阅读条目。\r\n\r\n### IFTTT\r\n\r\n![][img-12]\r\n\r\n自动化工具的代表之一 [IFTTT](https://ifttt.com/) 方便将 Pocket、Instapaper、Pinboard 等稍后读应用自动化实现保存到笔记应用、发送 Email、云存储、分享至各大社交平台，极大减少了用户操作的步骤。推荐大家前往 [IFTTT Bookmarking](https://ifttt.com/search/query/Bookmarking) 分类页面，即可看到各种好玩的连接小程序。\r\n\r\n*   [王掌柜带你玩转 Zapier - Zapier vs. IFTTT](https://sspai.com/post/39258)\r\n\r\n### Workflow\r\n\r\n![][img-13]\r\n\r\n提到自动化流程工具怎能不提及今年被苹果收到的 [Workflow](https://workflow.is/)，我 π 已经分享过多篇神级的[文章系列](https://sspai.com/post/tag/workflow)，其中 JailbreakHum 的「[用 Workflow 按格式批量导出稍候读中的内容](https://sspai.com/post/38213)」就是利用了 Workflow 把 Pocket 存储的内容按格式批量导出，方便大家将某个标签文章整理、分享。\r\n\r\n*   [少数派 Workflow Gallery](http://workflow.sspai.com/#/main/workflow)\r\n\r\n[](#总结)总结\r\n=========\r\n\r\n回到文章的开始部分，内容保存、管理衍生出了稍后读、剪辑标注的工具，然后 IFTTT、Workflow 又很好地解决了每款工具之间如何实现自动化操作、集中化管理的问题。这篇分享文并没有介绍像 [EndNote](http://endnote.com/)、[Zotero](https://www.zotero.org/)、[Papers](https://www.readcube.com/papers/) 等专业类的文献收集管理工具，同样有诸如  [Linnk](https://linnk.net/)、[Raindrop.io](https://raindrop.io/)、[Diigo](https://www.diigo.com/)、[Evernote](https://evernote.com/intl/zh-cn/)、[Emailthis](https://www.emailthis.me/)、[Larder](https://larder.io/) 等等优秀的收集标注应用，希望这篇工具合辑帮助大家做好网页内容剪辑、管理利用，同时欢迎各位在少数派投稿分享更多出色的内容收集整理利器。\r\n\r\n[img-0]:data:image/webp;base64,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\r\n\r\n[img-1]:data:image/webp;base64,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\r\n\r\n[img-2]:data:image/webp;base64,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\r\n\r\n[img-3]:data:image/webp;base64,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\r\n\r\n[img-4]:data:image/webp;base64,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\r\n\r\n[img-5]:data:image/webp;base64,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\r\n\r\n[img-6]:data:image/webp;base64,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\r\n\r\n[img-7]:data:image/webp;base64,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\r\n\r\n[img-8]:data:image/webp;base64,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\r\n\r\n[img-9]:data:image/webp;base64,UklGRhRIAABXRUJQVlA4IAhIAACQQwGdASrMAvMBPpFEnUslo6MipFTZyLASCWVu3N1kz5+/DxdOzh4TnVlz5i7yXGSBquTOm5GSFfB2//J/xXpe8t9+fz/S7/md7Xvf/D8qTozzyf9T1ofq/e++bHzMfUpvcu9WZCF9/8m/03+K/13iD5pvcvtn8lV8f4X++81P5597P3n9/90X9h+wfj7+2fznoEfmH9E/1X3CfSW+gcC+3P1v/mf5f1/Pw/+f/mvVL7UewB5jeDJ+T/7XsB/z//AftX7zH+j+4HpU/ZP9r7Cv9D/wHp2+zj94///7uf7TE6jMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzaIiIiIiIiIiIiIiIiIiIiIiIiIiIiJPA7tgz/60mWvgsbInOz1IpCQ3LCcQJxiB7u7yQ9EwNHY7vYmU9bpU+BuDeeTc1Lv8jd81ZSFeclZxLO/I+snd9TQqSyO0sTXhY2WW7nUlSfOQtNt3+M2gwhH5/2wBSGmpTvSfv8ZmDY43nzfK2ILKTIWlRBAA8YQx1F1FnArdrym+EncjtiGII03Wsps70lcDW3wLcQIp3HGeRy4fKlZk3jM6DLP7Fiae1aU+3AY8OE/DETkPieE17NtroD5dkBLvXRp+4SMH9++8n/RMDtckDAPoWn2MrPV3h96jlF4xjGLs14pnwdZi5qAOoB6ia6tMM8dNCyZ6fySQFl7s6td37761bjzHow0YRJ4Y//m9b7jb5WxBY2sk48PJ02SbDTXFihfuiGn0hmIRXB4GTnWSmmPo4W4nGvsaBVr7GeMLLEMSUk3TcmHg/IOXXAD2aDEwVl//3JfSSmGOXPc/hemPn8T7cgFuW9Upa8AAyZwIe64S/yBrAZZNM4QYVXxohu98/M+53D7THIQXQ38eM6hzXE5qnygyzsomUFuhoSRdDpYrJPAIMtSGag2BOIkDBrr9opZCEVgse2UKLGpIAUcHt5sCBwtNa8GQdpBpSATLc5hkZ3/r5GrB0PZV6HqHOIy/aGbYceuQFqzL0j0cpmUzMNTtSTfIw6T6gEbsLh0z5Adc4THKC3aXhjHrx06kc/4Ft/OlSB904vI0Z/9aBeLAax8dkdnhG62PA0cy3jb++r7BJ1oSQkwZb8COZW0eX+HCbV8WKQX25KlvKNfwausbSZzJxxtWZb8LiDzeWpVv0e55JNRjBYWFNERZFlTUx/SgtdGrsdcfai3v6BQnsyLiil5Or9Q/X86cIdLql1z31ReFqNv5rJtOrWi5OfrokE76bt10EZSX5ERD9zmn3oux/SggiHyfvDDHmbwrvK2H7mcyFfM3WYE/jK0wWnMoXXkEV/aHv4B5nILjuUyHZmZl4XkkofAOYjsJt27mdoUsXB3diMpQWQT3U5Z7epViqplHvoqEX8/aU2C0j4gQ3wHRAy+0FbDeAqXWHs+OrC7wZs6QFaBfwVF9yW0BOAsOJWtfK8ZLRGIZZ/lVVSVVQv9+cv6QhVHSKruRufltCdPPjrj2LKzrugkRgUVrDRRDXftaNlir6SYTV57+SjR4jCQ0DhN8I1WnKkhcwVoYTTusOVh82XyNpMmex8mGpC9l2a6m6cRcMTTfbhu6tT9RE1jjqmimt5NY8knpDC3z6Tj7LQuoSJC1m830IglhP0z8BPkSPiLYAPBbF1vS0xfNtVVlYHByauhOYQ+HgipQBO4bVhODoIBCK2JidzXIgS80xKVNdVsODFkD9GUoCfRvPqqsRdUC6oF1DVVVWLKs7v6zGJaHFBd4MlYCzMzMzMzMzMzMzMzMzMzMzMzgVu7u7qox5iu8zMzMzMviuLWUQpSm3d3d3d3d3d3hZuqqqeatKZlMC/0tVr8mlI4FjoEu+9bDsYKDX4mUK/s3NqqWgXcPNwXeq5w2LqmMl5jvDhqMfFkAsLwP1Ocwi4TutZhspv5BybIIjcnfKVU0lwoZyQYstZKAJvyv6aBpjHw+kUiYBVw5iTWG9DBXPOF2DKDMzMzRu0iIh8vyY+jIpAT9ewQYsEC/ydoYI1QbiNKXYL2u1AsHkuhB2EDDG77MspGQ8uqYSpg7uJ3RdIfz2zczym5cSdOJ8GaMZJk/+m7zroLknN5E0klHj6YytQNgEBd8wVbsQJbLDmQjx9RolsI6STJqBfSYtyIxFcoBqGmjWiJuGV06R7OL6vMCNSSU9oU7u7vYmVVVTxfVSHERDdGMwrFCyTwDVP1+4ytp2jLLZpIZpT33e7Wecy3AKxdMGfPo1D4W87xmHPsYTiKaICNGgXarjUDqlkUiTSfiBB7CaYhHZX++w4jEtTGG96Xv53cETBU20nkg1/xkIVYg2Hm/5yITaZnHGalskqkGAvgFVoEUEPr9tycTvG2eROuMzMzevAAAAAXACZou9Sy/fsJBrTEBXBF1FWvtTc2ZTDoWWzS+rycAJmZmZ+KzMy0KYaxQpkTUTLHrnV0fOSGSpp8rA822UcN3NZzAxvs2iPqIBYeP+TlyWWkREm1zIrgeVmA5DP1QzZIkOY1cfY6swDOs1mlbFjP9AVk9GejMYnPlWOjbvFBd3b5Po417QnsfVV+SyWgDwKACPVV2f5vBaFZzEMtAHpNVkmXzXixWZ1jej2jNjZqSZ8En55esEvCGf5dsZcO54Yt7ZnocPzD54CIG+kOZPLoskouXRSAFMagsjjh6YnA/RP29qRB8+m+5Dcltf9GqmJ9RX76C39ljlzI7GO9VkdY1nVplTw4E8iSkE/PkM/bLkj5uLOoncST/H9gUJRCSPh+GEL/uJyBWrEm2+cmAdbjLu7xDkqqog6VODWYZ6SiEgVvYvwaoLdjqjolS7gKXisqvRb9lALDfTgKQ8SB+Ygz+l7ie58kCrU/DDIkaCqQgBvsk9kxW51Gabos/tAETPjlHr0TmVWNNRFQp6fqRDd2+RNl7SF+El4Si9gwicUp6VLyRvDDd53iHDGWaGEsvSlPzj/CeMxvBHUf7wx72djrn5uPlch6s1Ej+e5hF/Pr/BNpj5kEEMmv6NjbGV4Nov/AB1xfFRnlSWM726eRt3igu7u8/1GJ8OoLaNVKZEcEDYcSffgGxZVRR6CqqyazMzMzMzMzMzMzMzWyvIc6qqqrD2qqq/i2ZmZmZmG3km0HXwTzvqW5ujabHVYGsWuRTm/oF1UzlYfEtA88jCqUC8PX27u7u7u7xQXd3d3d3b6VpESQx95x0cGbzp7nb6jdnFJa1urF/SVsCZyPEJTQOCE4ybWLWIlFBbrteNZ/h8YoyEWOc84eKW1O8fEACO51lKf3/cfbTnW6EtE3eNtkr9vEJAfJ2RsjFSRpASTZVVZf6aXbjBgw6ey1GCXs8NTtcUTAzTzGZmZmZmZ/SREREREQv+fYoSHxLGYm4cEOlghMlFc0isgPCYbGboU9vxPMh28ft3d3d3d4oLu7u7u7u8/0yZmdtgD68zgqqqqqrEKRpwAD+6J3//mPv+Mv+Mvj9//gX1U907kAAAAAAANIEYAAAAAAAAAAAAAAAB+WJmWAvprVZ1UO8K0oc6pdQG9m5kl9hQ7PnpYLeW2FePZPXgRWqWNt/6qEy5IJQmFhyxxAh/1C79Gv1ae43sjK4sh8PjBzFSiCu6pF+WQ6RWytWBYNASYoVYg8+OFXXkeQPZmgVX4M/t1i6VLxN0WBglwxYVfjXjC1wsHhvEN+b1KwpVko4HkYVV1vjBP5Gsc8gnQrvsvLasRvHQ8zNzE05PjlbEit6k/CILtomMAHUxK2BBQGZ0ClG/BGvJqe6iwTYMPK+1s27GlN2GBkGx7fZIG61BNOsAdVCzk86kvVcZlapr4SnUa6Jxrq8tzcHVCTIgcUodrZ+Ik0Py03G2ZMTkTeBa53QGPc8X0vg1tV1IP2dKUeCmbHHgFUSOywCk3OUDwtKn+TPdMz8dv78FfXGmeY12Qb0CsfXflvuJ7k3dHT8dxcms3daapAke/k6gTAI04RkwbMbwxVo1wRqaHQM/3u//guPKpmzR5gWZho5kzqhOBXtXYvkokrF6r7lEDcva7IVwAqFa55oHMbbvFEox9MIvhei1cor/rzPDZrg+mGco2V0/6krb7fWgJSY7l3v8xucRdDdc7fP715B6ssCXfDlQlXaUD/D4nHSii1/bixJz9SHfBHKT+iforSjTRbj66Rn8B50Oqf7tkoTPOe3pOUdf0uz77QAfKPwlq2PHaikF1sOUn2/6ssrGkjO+pQBYj8IVvVE6GrdZbKkid2pA9V48do42/U7YIWOz9vg5/UcMA41mHrsjQFPkmpDAao22svma2xQy1RC9ReNYSFzQf1IK7LcFRqUPNMgT1tCrXkN8JKuLWP1sjcR4FP/pZ1suX/ukX5T2HiVgUANWcw+0mjwQ/vFCQczfwDBr0VWef2S7A/8qdHTnE9KAw1zUHIUXxr+oG1MOXx2cZF0uQo24MgKQIXnqhMHaofCkizgmxQxOdVGZFVX0VpUlx5scZbuP5ZopBGIL+tskjugmsfG+aZqZcKZPSFtU7Dya5dfUzT0aBgLbKSqByNPmavXbgpUN7KWyUcJUBBPgIMPKpns/lswNfmmeFne1fsQsr4ArrP8VBllXACIdP/giKa7SDqS3kNxa2RcuJBx8v5J9Rl9EkKrCjTfN+PWgeG4i4qnkhDGXlX2CBtspByIDP8JJthY9JVkhg5iM12y9G4q1kAhU47HPEdZCqF909fvROu7kHt3lE5ogbGBYOrlsHBjpT+D3DVciU6hYuD6kxAcC32NDojvsxOeoUqUnEUcIn373QerYNlmDf4N0XYuTPR3qV9ybQlSFVHwAfOymU+PdX7JcvKjImZWX2aiyYt47pQXhEuOKHpvchvNeSB6ekJEKmalGhqUrCw4hEbBjAJNVv18mxRdsqM3Ljnz35/C4flMo9hL4gMT6vqpesHxRhYGazA6911+K0qohMHoctWI4EpW6zQoy5JA0QrA2WLgaw7hzrFWkBy0nYkC2383iIHvrpp+lIBOYX/ooWesfqJzMFtkuUHtypUWTeZKl6Ea/5/fT6WLpG78WKhh2k8u4QKmol6Zgb3KL8oqt+DgNSl02kjtcp5gucithifr2+YW1fLH3DeLdBceMT+jZx9zJ57w4OJZWI6eVY0l3ZrGOTQyBHdWAOLYBi8czZog1XB23jcj3FXwjQ4Q7KaBe1FXQjx3rQrxN34aZF6eYkruSgDOY7DfYu28aOB2VCvuF3MiqCB3TqzyaZZmqHRcLSwx+LHJH8rvzGHsWDDi/An+DmG851UHuf0eO8ybVwqYGarQI9leyWjuNTKA2UISOsTt+TuNb6DOLSMiCMsArwUpp4lNOfI48mrEW0DuORGfdgvvQXSvja1McTXAC9rQ2yEwryR4nhKgAPWuhRnYagXgBqV0NWmY8rDFqtLXm+niotvK8vxHCf+urcepZ9nRdTLTFH4yhIKxMKFz2Dx5vFbSuohR+HcEEI1Xp2FKVZRyN/Goy6V7YMAJAF4PTuUPryQrCZl0f/ERMwcVbWSSQMS9MOd/6bzxMxGUXbOO1tjthpN66TKDp64FBUqrhMzPqafApAqYpJTpeR7GRXcH5brVHC+2cvurM8c3ulLFf7QEFoZG+KVpQV9bYFhQR/kKKwO/D9DHE0Li2mf1LsKywxpi1NhLVYefpbEuX7N/4EiNMs9O+t3R6cJsVztVWIx5UhfjcMf4ZTel1+61jheWdxS5JwUgSQPtKSaEJozWbUuctjZbT693YD5AeNEtWcq62AuY0I2ekB2h9U77O/cOtbnrDDPdbfhIBtv0Gg4QMxLI9SPXZADvvJBXY2uYPTv+BPBMoxyjvnKB7nynOm0ScNCl6t9hlVLq5TUypURMyIOBQiv2TR/c/1F5ACQmCU4NnBbl43eL2ax68VRW9JQQt0rWFUlQBduEq/IOyBQbJAJf6WUi0Y9aC9LD/S7a8clu9dDre5T74PZ/mdFtL+c4iQ3f9VGz1GuVNl3gqiMtPeNH0sSWeSZJ7pLrY7md2+WLUjgxQTGC1ty/K5db2r/zWsUJ+2nAcFKOaDnDAiBbZWvK+MVic2yGrUB1gpn1L5AsQvpaFz2BroZBgFKdeJNrF5vd7Q4tnFItBZXN9GORYHsL5bAfdzn8Fuw6S+zmlIdNWcHgF2XHkigQ8PguPE/HqbZyqTQoIApt9JznqCjvxQ7roFllh5bfJtQvTC9hfTvnuOwqP7aV4LUlITyyefZzRJyZ6zOE2B9SfI5ZZWT2TA9ZN4w08ZPVQ2k3X2qmRhR/Tz0NSB0dNhy6i08IquDBbmSYoCST0Sq0hG2hvE4IeaZJV44GJFq5cNmMtIL9e/DvA+0G4oHQRcYII6V1D/psF+7G9GbCTPKE8RHxonFUtLa4FHCSSOIhQdqg0+DzlsSzZugk4XIeVDVen0NXLU9O7jQwuI7FmFPxbibDib8yBmcqBMyopXYDsI0F63+kFIOB3JM8v+N2yYZ98Ich5pcnSIk9fgcwg0sy3w90m4yqwA+m+vZOCzgeOJawgOb4JhHxCscQFOu7IXtQwMYE827yD38Tel8WUsnHhMLnnFWB6sXon/ESEDrGpbZeSZ1MP4iuMY3JCJFLwOizrm4E/6pBSLcAcnwp1Yh1mlc6LpZO+d2PyduKHuvHYFXtmKxh11knT6BTYVkYeAlxb6l91FFiBOtbuoWXC7luKZt7gg0aKmHxH/5VXFlQfiHWkO4viL0XtVYk8Dr//T1cnmTDbdBAT1fPD3dJ7aWgqARJToCD6cE+yhiOu9+Xwo8ThORUt1kjD8RvlqTnn4b6klb3FWd52SHzOZoIhOduqSrimkEFt7X58aPgpIivs0ng75+Xkyiy2ChCQ5t/t51BdtO/XcepgFLmEC/E+YXHGWQK+TS8TwTPreRA38rN1ILkwzGBiqsCO7beoialQaT1pH9EoyegeR3eis3rGw+RweYzqjXy9CuKBPGSkR6tMpSFNkyfTp/Hs6K900hXO7FSgjpgc5NgefHOJkLPuwu+mZQCzI5GVHfKH4i02+ORa6ShtBbeoYb6HozAeusMSKwNnXduYMViHRc+NhUS0WXHTvvGYsiCYlLN/yEkWeycfD/fYWIOXrugG/XzB9lsnRdQBmuRvRuzDUfv/Wj4Ha1FCqQ73atjGcpHNjpbbm6pWtwUqsUSmT9A/e0g4MRAKk3PBVlpA4a+h1+MowosoMDX/MIu0bWHetSagGDGthPbQS4O+EivowauzwRpcJbAMFgY7AuEhFT0fI2sOwfEpkTMrCoGImN+pHvqj5V/Msi6B6S7ATEhUwEcOLz+1kG+gxf7oMxPw2R+hdZ8oAkUOQIvhjgySIO7in5Hc5FsnmdxzfFxwE/KohAcJhtAITZQv+4G1wOEHVqEiv/vu/Zb/lI4t5+r2XjPFylBQSFldfVTWlzVjaCQn6mfWpJQtIGV8AaZNyMxl3WsLZq0rY10pBJnCdb5YUUnnetbPNO8cVRX8QXaiOWEoZk8X0FCbaWHAsZF6PUIl51TYR/Odbfdc8a9zS2mOrbFctljGOjvC9+H+XxmPgvM9maUlmmgK05BojIhz6kJa4+depQ5f3q5ZeXMDoelPoWJyiLfDkad4k0X+YJQxFxmvPScYtojAhbp6/IlmiOGV4tLBNFQDSnCulg6d8iOtfogljs2xq/OJUJ1uZb3iVso0FivEz1qBdFKVNKzlet6J+X4AcPktCUCiVAlq7vnxUAXnSWS/rkn1rmTcdm5Zw7O2SET1o0vx1zD6Ah8D9CmppLLbgBtOFLDaIH5n26dPVoO30c4v0EF70eQnn7LJNoPS93N9U6sXEv6wWjn+2qC28oiaczER2PEd1XCsxMnVOYgN6pgo0HZpdaY1pHCC1rgouuXNEVTVGbJWmbA2AOuoBJqkIcXMszRQcAGWBLoq1/5krHILpaZrWjZ1QnKsTPPt+OGz60TK7zpUqBZxrs3syyPEkwLBzNg9vkBWvOrFckjlEqs4N9P03CeA5JmOe8aTdRk37eHGNLJ5Rmy8xCPN+2a95x/DrXYvU+YlT5iMPVV5St4OTQuwhvTChm29RNVcqPJux0TNJavaCoCl+2yb/nAwApTBAafQlPvj4YzHrMIjjT4teDKGvgMHIUJnnzaf7Y95xVSBRHMqO9w9UayUKSZ9dYLrRSdw4P0x57+XJQjbIcFGvyWaXvGPYWxNunTZIRyXQRdE71dWm0ifngkw7360tfkEQBRUe1j3lBKX0Gm1M04NwuVGakYCDr8IgeG0GndaFg+q/ByncVfpjQjAEWaXM4NPcjP2YtmzbUrWDkDYanVG/oMFxcIFGQFWp8/Qm6aPELf1hRlF58vbUyhuKJdu/QrPs+j4Xkg9Gdvy1nCr7qFdF+AHrzrPeXzL75NP68GhnVOD6zeCFeJ6xmKoDylxgs+RakYq4g+mn70uUMksEpOe1CuOihxIu0rRxtyGwYol0BVXcR3+yfYUAjsgP2VgyLWub9ZrxzM/GSfLE6EEvcZyPCiLMbaR1AcbE0x1/onOLLqGTahLxWufdlKaqrqLlxxZdqwU6viYH25LtwOgVAYIMfDgP1MeWzPHCX53uToW6EDQ78W25ePA9pM7kEfZFt4yIHnTBgGUgJ9CNA834krrNGFhVLVGWNA3hRxk9FpHbvpXgQ/IxiI14frqEQVuBHJFHwKgz3AVvaOBuB+ujdGb52IkoUV1QK6NwW95e1Qk+Y9CHiLwE59wilwsWepwhGkN87qL6GfS89ESkfmW0eZJ2IdTSkpptAA4T0jzs+mekAttBedIALWAZDV/56Y8yrtP22s/D4oZvAp1ZEU+wPVDgopoVYsLlgqYPhvU5jUg1PIKXEdG+Q0G+IZewPkU2JHIrggtkjRxslBNz5ZZq4qwjbf/0cHpHFGodjoj9THoGdZesteYFMZEnfzjpOuOGBZdnwHP3AxOTB5X2zDfGFOPlEE8mJ3v4i+v5CCATeBkuZJOz7mUjPsQdEYeVmXMLmLTb//vfphFoFKhhDYSCDsJnlRqW2ZVTUx18Wrta2v0tvx3pTwE0WqjQHH5CTe1J4rI0oHvR8luizwqJnbU/pmcLWiWxAKLnHYlKaYwZl0VeRuE+Tkd4ge4MggPiQEb3RvcV0wg2T+yjUDebtr6xK8lyWHDxPPFScKEtfkLpyEfBBxaZK1IwA2s3Q7O65EXWCBVqrnw3GDHfVhdE6SQ1stDujs6CCEbdYkZ5CTz3j/+HnNSWHIDGZtc7jYqWA/VjlMoWNroxn4H7LF6mjJhxcc78UTc4WWU+G0aQ27KlUOg58niDsg7ZhhD4HOOp64VkaJyzxy90P0ShoUTvc7/gwcKagVCxvjF20TOgQcjuHFbedCgWHsUqoVgVci4OK/hw5iFT+XuANaUQZLeS6lOEZSSxIaR7VVh2143+YSN+RMzw6yDNAvI+XUpoeLh93TtiUZ+Qx39V44T3UvB4R9ViQF8Q4uk7IfIyxFw/9i/kw1Qs/ge9bd9e7EHnHkYxamgdYm18hBVR2DSHNfM6HkZFfLP/OXYBTy/LsVfo1F+x2p1yzBox1QA0vLbaeIBdmhH8iIRK3OMs7sENEIcpDZP1UJ4+tKsISfyUhhHdi/j430/2CljbeFwp1hSoMefrT7zTP3JHtuZyM8stX3Px0x//NVpawp3quPmRbCsyW8rr9npWW3JhGKLFmHqOVztz//DCd6yXwiK3p1inAXAoV7mChIBHPer5nWnxNP1qi/fTVo2FqswgoJV7wGkP0OoY8UEq7FYKErv6GKqbY9tfy8On/q7uuCcSTNRYWlPssOfw20Dn6oPf/dh84gFw3JQUs1cbQ7tOsn6osS9BEsxO5N1ygXk4grlJpADsjnVB1WXEkXqpHFa7CpLSAyqx5d3wzrUwoLhcf2bH4jFUp0iGoedQq2JWfu/B2DwOf2Xpguu9OwnoTA2igxKY9g9Q4rqlNqKNs3B7SALh05D4r6MOW8Hq66FtozopRZAw+CuM3P8B7kW30zvpy3kUl1o3x6jDOpAiT2GDWnWBUnQooHM1uNyAR+fvFtPozJXVaQ3o0vzl/lmxqX/7F//NJ5YkFPPX/HccTmuLSiwrt1kIPyWpK/9MMBmVEttglo3EwCJmgA9i+nWWNYVuyXAJJe0r8jf/LrJUVKoif+OeOhV7chRjEyniRiVjcUH++6xKsl/9h/jOoN1Dx9u6a8yF1k5LZuNHhJI+E2hzkVBVwTDJCD8vCI04qIAVX0uAX+11Cgh4+puhs5C8bNg5OMX8AOX+PTIFtoYwItiEul8T/Ftl3BcWhpbPxYMibq1IQkdTfRP8+Gf8VeExB2wmogAmlFmQiDOgMQYKubf2rcOe255uGyIkCR+vhwZz1AO7yCuCnjqKqXoINyeI60eyeDSBgwQ3GdHbV6GxYvPtBBYxmXogbNLDRvcMhMEdGAFU3DTmhMC+HjFGI2Z4L+QPEBLYsGJC8fyuHZycTKQQ91a7f7NRBBUomGEzNSKjueGaRsYtHybCxJkh4qOvcsrVQEg2qAOFzcpDEVSC1cjwx9CeaDxLFYR0DWaK+rUV56UWOHGUyuLf210Bm8srpP/s/56xWhe+QeA9bb9715/ay4Vp4SDIglRb70h4X9HUhyAIkm5Dex69x7f9Q6MNUAcFum3pd5LnYMjrSkeIudqxYWyQjQTwSIe9jyqi9WABFIf4B9ir9lKRqeILpzvv0vnm4f3BnSAQjwByVQtam0jkdpTIUHy8OE3jm1jvGThc/4vexw4wgWVTpsTsH7ouvZwqNBf+ckkRAvl+PAYFEQrJjURWIYBfF5cZYHe14qL1olulIdHMu79535AeY3JHasJPxQ1laLg3Wg582eJj90co5PA1pnuybpMiTfPtraJtAAAAAAAAAAAAAAAAAAAABkrTVKg4fdu7q30QbNiiphJoGZRw0zsquP52V3PL2VBYszsgBmL8pTAzXadbgjWtrw6p27drx8lwVrxnfmxuLTVkRbeSI8vr9ErK4oJ5wDTLBmeJHUXZEk2JDZ+Sf8n4BVBHARKfS4l0p0wYb6oe05cfFC9vVAAAAZnFYsKeJjOjuux2shV3EMYEiTj3r+0a76lONYgVsoJC/z4f+nHgxtoWWASiv6NzkCQv15LC31KCi512RVNqZGuxu21768gbHOQAcc9dRBeQ6QoBOoPYq1Obxh0bAMKjdh97/p7R/W5BMjDTRD/NocJF4NytUeD8f/HvJvf2r2+Qfz2MQGlo6OmmbqhKLNIG1+7KIQ3GYvkygmbm0IqphDARn3/M8ONCAdxMvXCOpb5MNQD8tis6EgQiCUHrlRe90L+nkVs31/qwrtqfYD8ikbngA+r+fmCXPohahtohIP24pCjuYtEBtrG8y+iVTNiVMcUcbAYTIfX/vNpLV7x+GztTpxSGVEuzsSiC866MNbjpDwwJ2vNRvJQYDqMIvqGOU4MY3iJeR8VwsuNJSit8j7lg2ah3fgzNctOp2UssOVU2yxzgZc5y97mONFBASTz0QBWlTlvzTtVT7ROWqyL0f3FQnqpDYHoJbljT1+3icDsqdF+J/7mCt2SfmA8d1Cf/pHWXtgM5wCmt/29hPKdqc1noy9MfPGZ4/5k3le7OJfFpiMhDX9PbErdafONlHnrtXhAn2fckyLdbmi99hIyEkhKfreRftvKCmfVq0HaOYI85gSsw/LUpovbzz3TvzeDC/wbx9bEIhOmW7XsZzPJncdnCD69P2ZL/KPdf7UmidgpIrC0c6EBeuHq1+ptkvQuh7nnVi1vL9hSgD1yEE4kuwFPxjA7+ZEhfftixB1iaKnIawkATGXPNnO7bgVuFKh1vzYal21g96RNS5HxVi7jCf2JrFf1FEHEnzJKXG2JSB1T53ePwYWT5KOVbZjZIcxeluzmGWZDzRZdtCIbNZtkSNz7gu8KCVEgBt2ebh4kzQCXnRA2imvClvTlRhHdthccjSzQ4pfxk6UEsA3as1Dv77l/fiSaagaQOLKqDyBGGIslwcc5+1v+btEJnZtjQv0Fkdvyh0qvFkTRlhu7LCDVo+jw1qvUJjg9qcxs/aRcjsbfI2OmSMO4e9GN17FCZsPNd0kaCJcz6w2LK6coPdwbcvPOYqRr0GdMJ8IpGOC1HaFFB0oWG2m6GE0m+Wd6h600iMzyzWcwNs/pAyqMq8KVOkWdEMajFs/wGKiTUzSJKluP2Eu7HntuO0AF4ejlPQKhMBUCuAPVDPBNqRONOOO+RAo/trBIN7+5zxq7aL0JWctxjdZgHOpHhBC6rxsCGZn3HLL4Rhk+ovDPq239rb0NkJAhOqn80qMshymm6MsipS/en5dD7y8fnfwi1WW0b2xx9hbfmLY9zXsqsGzkG6imc7DcUmF6geCg4WNzLRwHaLfE8KQ+LVL7yGKyQ8OVX1Yid1kovFoJyVCWkgkNHrTkO/vVswJxOCvmag24Aj5fovn6hDzwaX4przt+j1KI3tRUqTboCKyk1EqwxsHqhMgsE92O1psRATUCLt5eCG52dQFvviCWvm7GhtLD6XsfpmbMr+GjvcBZfkXxSRJW24ACHmDP5io11qrnX4bI8LiAjwqW2/4A19uzeyzC987OZAX8TvG03QLLCOYH5CNSnTJtKRZakl5cNPumyBKTTnQtcc18wE6TMJ3taGJS+ivPRd1kAu6hHQmwH02FzozZUUXZrezYIq8wDKv9E7QSyqESgu2B1tSP12SUqp2nKE4gPr+0Fg2K2aQb+khsJmo/tBQRG1eJ6uaQKUldvHWcAMT3kepGjr55Vl6oBfSOJe6zKL/gx6AIsySJOpkVZK9e3+b44+cxMkh3h47f6JfHsNesHIhnbaTZ4GBWk4kyq17Z0gc0w/6CTQNMs0ovtE8X7hbANr/wd0b5TeInMax5lI0SUGq9oLDdstduO9fOuYQ3AFj//ZYSpTBfFv1QJ2VZPn5pp4zf5w0alADkeL7U1okar1pHcqZgwJgDMNVAPyiToOgzh7/DJ6Et+6kZXewggdKaZYDg4lu6lebCwFADS9Dfhtx3W539lojz9FNzoPKFwiWcMmRrzz2D4Kf9H3eZt39Q6PbDD9NSspX5RuqgSkt0JGc/VgYvMIwkAIkRH1p4ltb5/6AumgiebKMyQ/IfCIIRFIpABLTtO13dBgbPDoxfHPrgEc/3bVlcr9JeS4JUjHIE1v2plAFepAeIBPV+vIadCDZaP7ycXdoY1q8n9EtxCypk4JRoTRaey4KxU1mz2ObfWqKjV5yAJ2bN9l4Z5nsjLnm2RopC6bRONg4P5eLC9ZqsFg1TsMWUHuDHFza37zJauAIbzEotlPxutHa5wIOLNxR/V0d4rZEst9VnHH9a3oIZ9FhHo1KebjsY6T8LBAVtkTYGO2DO+uViQtzbM3WtHhhTnZfn2NZm4PVwd96pE3EWGt1N85T87tI2Ac/ILu1y/dr1jnM4zkB+ss+u12suMB73m++kVwMN5Bg2dn0UvUOASXNWHBXVSpdlnVQx/P0/oYQu91o3p6KNzpT4tfMw3+io+Ic5eCIk0dcNQTrq18OId04CahsQjwacLVB2u1DvRAPN0lUPTHP/N2OxxYgITnScNBkPhZMe5us1tvhvbjSfAc1sIFPs+VM/HPLv7bo811s2NwrInVSc2WWLDK33VOiNr5BEq9vtXyeDbOhLux6rym2NwXIIhwMqBPM0XwwmmwQoWBkfhnwp8ETdmrgq7lo/BVSYL+h1S1Xnhu5BDmLXW3NBfQ9194jKc3P9aX6yZrxGhuUFjJFILSiylcU1M+1/lEg8Ppf6X6YGJKoG/vsc9JxoE1rO+QoivHUHdal4ZWUNhXHD8nzUvEQCgiPP7/w8L+IaaD9QCGF5guS2BNFPOsSue/J0osoDGwiG0sXeFCrSo+yoh0/doldMMoXld1AnFw+rBxkXGDTFtgIDwvdM5ia9/MXEcxEhVJT3Kb4Qinoc0q9yaWMdHrSU7nyqDuXU2EgG4zLmVVcZhNAuNmEnaLYBDxvwN31nb+6peY81Iz6nmGeaDrl1cSIu+OLSyfcyqIDL9FJT8mfT+tVRvdFowNpI7m2eJh+rjE0kRQbl07wSgfHyFwYvH9f9D4Z1zL0CATqwt5aBnu9+iN4UmLS45i9jwbX8LpJyBOsyun3N7ZQqvLAEXolnyRjW+O3CLqTO7o+qkT6+mXX2qG4pwvgg+cjsjUpHPmMTULxTE9U+38dwmV2ReHJF5qYnUCwbJol6vVWfHuiJdEfvDYr2h4sS4GUECfCkod3VM8cOzBfJqUGsYWFol6/J/DH9s8W3vvvku/Slt7StsSRN/+ADxeEsacmy7u/1mnpgXBLKSiC2flc79OOoSuU6ZnSJIq+YPYb1EAAYPmcbRODJOUAXgXPKosb043/zx/KOdagh137cEQ+Uec3kDzF2qPzIdcPsoO6SLNVk8Es0Sqvi3IZzXJwAwZkjtOE01Lo3JJd9+65bNMNrHQNz6PFL2DFEujOx71eX62rocO243zyGn16fbH5ZSBSxn8TbRktLoA8pU7JQi0TaGW+RVygH0c0MQ8YhyyY1dU3lTQI/mQdsc9SFIddHu2nObK2DPaaCX/bfsBSHDkL/WM42t22j2zQxg8ReTpmAytBcnV6ckUR+zGMxB9GQMdvodcIZL3Htt1uqEDXsbEBGQC1ZP32y/UyfFzdvmtVvbnY4i1hDMBYigHA0ernAemWnjvjsKklNL3s8mXyC/l+oLvi6HccrtQAtSzZ0RpzYrWLOnERCFj7ZbBU4tCqNUO+alE7hRLjn/H/Cw+HF8NV9SRwgYRgZivwjKg4iWTwzdvlJwDTpAoIpGNccYaAIcErLT1hRpciazpB5Jz696T/fU9K5BP/EmfzJT7uE5lUfYtjxmO1QYocSbpkDuVkMDZAN8I77/AAsxP6EnzBQniR4GOlzZJjWeJjoSCi4R69jI+u8+uALhux3SH+yTztnMR/z3gO9kG9FARZ08/WI8Ku33YtsFKq6u8Fh3mPeWi11ET1aroH5U2tCjjbG2TTWNhnRIyWsquq1iGCpW/lVrXpWLIF5f3lFXfyLRLN5XhbjzNe5ouIDjZ6Hb4DlpMJ1SsWjWMzI2xV83vUqdU1uDUvSm+YlpsVUsCLyu8T24pwUQDxBYIJLI4m1oL6LihAkAtlc2FTuSqy2ABTjFClEQbp+I/AdWGFiF6YzlxZCstpgUdIkc7HdVfN30+qZNmTTqJg7YrQBRq4rjPwQLxPl0MdeINi+UGzi9J8ydTXT3T/z1UEcai6nCpnRUrgSOMtKTuO1EBK5sIXWkvR9ybnxUpEiggUdI43uavMrRUiqEadLkJeXVCTMVvzDD5lAeaS+64s7nVOJBa25/HZnDyfI8odvVCXjKTb+ik0+pxWlZ5V+iQ2AqsGjE924std2LQWZgDImRBJ/9NzF8vuHFE8E3ld2lS/ipd1250fiKqz8XWVAtQA8tgIBEgKQxOD3l6GwbvtgK/RLzFLyd/rv4gv4441WCBMnMTMZFMTivjgB919Gh7WBP8HYDAv353Lvy83A/7Rk6BHJ/fvhlFZW5R55Iof5SZHo+guGKDwYcE93Cbf+Oe+9EwhBcS14u/3y5DBKxTZrB45kNYCMyBvEvdQ3u25tXyJcpHm5/Eu5imweIf4AJGsqZue4yeba6a0BfWDOz1eWJO9RuOPIHIhHxMJQbEQVEDjxUepPEQG8bCsoaB0S2v9vFh3tPCl1vKJvYs1iy4/DYjUomu0Ev4bb+KzuM7Bd0mXmLlEGFHuU0+EZspDYcLnC8Szb+JeGQaiPPTbvImX4cT4HUIVX7EzcqUNzuxO995qPZsE0/mBsZ9g4g/ca/CNxBVAAr8+nk5dAdBAauepJQAAF4tV+qiB6urozC6mAWBFHBwULUuA2Q7VlHPWm6poeYfsmN4pL9RlzkbzmOTl8EYTZyQnWm9figB1g7RBa30ycgnSU6RnuWro5CpDozH5V21K7rafTHI/8RAsUUTpZYvfh4pWtsoBJLssjfxdsGA348rxaObA6csTq7+6kkKmAe8pXW5pubajDpr+Gl8RDAzABFfqqypAwPFFJFZRW+HTljsGOMDHEYoAAADUPtDlhHdwtXvTvur8/etX9y/EuhWS49Vdk56CexblP4MwTpYV15ADlrwcafooAMxCBftIoBvd/oZq0/7qBTDJPjjmDzlEsJeFC39YH+1IFYhX5oNbPj8MRmPLWacHt3rBf5fmUgBlmHH9AD25EIuF4gwkQKaVvfve0vZxZ98WkTGvfDmUIipCGIUplrXUsyd6ChupVZio13wywkqfhIdZVVf+piaFWLd9Zs2mHFPOabmtIUyQeHcK4WriMPwqOIVxXCiu0PJTe3zur79hzum1Wae9+uRsWYmlsCPev3Bywwg8rrsLodchbPUGah+bPFDftQmeeYoSxU4VecLrUXUTTD0ff0yB2f6N/Z/ZmY/m9OIV+7NcbsImFTtxok03KmThPxTl/kgiazUY44bV2ajbPhd5/Lnz11pbFlpRvR3VqURUko3hgBCDozP4i6huJLTEvIIwCev3drdJqOJ80koblycdsGnEXQIzQI/yYgqkiWlqv6taMmD0ett9C4+cIts+/cHZJUWoKbK6LCYVlHpnbrQHkARkUbl8pmdqQtQiiRnSVTPpNhKH3AQ6tZvcBp1eMhrNsiFEu9LlkrbI7EsOxgfTRB6UiZaTlIDEpxWBGx2URl+r38r1+mzwP5q/gtgMNwMm/SV3G8sAoRF93E/pVxBC2n5slC+L2EtFCErnT1udSfPIDUofiEJpq/wPX6CHe2zSE4Z4QtHPcFoMhSJgTH4XypiE7KJZM5/M145o5MB+Xtscyjq2uAg8XPijETZlcmKwndZyHZaYmK8AQmovVr/CVmA/jRv6U/NeuUvKcfYlhwKEt/+3ZXUjfFG8p0lnd79H/RDdbe+WEwoQRdgiU8joK2XeZj+WdUis5PQIaTq+rvItfXYGvWiRuhzpSND9qR/heo7BrVJfh5G3Zp2suGRwp8jNypEqclWUNtndA9C0Dt03SmilqsenycJAl47IzWJcF8zlDwaHBADp4de+6DobSNcXOT/FVOWTCUyJ35WG1zqqyEKzECbyeAx8UU7Ag/xC7WURVKT2jBeFb+JO9Mpdcbe0ZYe/GrPsd+vxFhilf8gPzA8nwU8EsGP6u2ZdyxcorYqf8DCoZvI3dJ0ZoU9IJ8fncPlyW6k+VBNtRuS9EZrMKGd5jq8/eYcH4Ub1TzqbCgrKJ4AfvH4HOtQrpQpJYbs/rlFbB4NmP9Qypxuz4PVXe7rJQvTTcL0WFePpqEN27PcEvZEbFE2VB3PZkcvrnaRpq8q3jxqWDsf+UFiNgcNVeF0/ylXgrxBH7q8ADtPxioZuj4xBEgUD3uYOf5QrsPVHjZ5c+Ytvq3SVN5XoFXHun4Sm3YtLOmYyHrk+o+TZefK3kto+dj40A3d3gn/J1WLZ6usrVSih89voqBPx3g6oZW1y+abLo7HMvXayWdudA/1ZFlnAMGh/saKm7g5Gj1+4GRkWBfOE0AmXcehq+ldMSUGn3uLk5ktJ9FPsCqBj0q2d2af+SbhYiL8EkcJoG2VtP3ntlTxwjzal6hfYQIIOTYWnZWtFoKVnnPlaBPEdceG9u4y172gGGYWAwwpt81Vk6ZGOOHrJx6NnBbbBIkVx3wC/J94qH/IjxBu1K9WDApns9IShmZ7Q5U8WD/NKkxfHQZQkCpv0fOzTnFOG9IVs4AbQlG3wCle5bpJpK8T4b7pZb0JEFBUY3FzBl9lLFMgLv30xPwsj9mz+FYuoKPNmdqPGituVCV5L9F0dvupDKsa/Vl2ygSmpn+3/I3Fok1ulF8DxD9Jor8qZ2lw82yC1WfW+yd3Mj9IrHFuaA8+3QMhwHmA6ekvzzFIDofeOgwST8jRkELVDGOVplk8IycUdixm16u1pDVYFdsKegE3JjVq26P2JHeEIj89fPNl1YMfC1hURhezDTUhbocmWacsGTU5wW0C+OctFmDczBy+BD0xOuYM9GhIlQuswx/czifrpSEYfIkyO42REcRpcAlFCGd2aqRuC/jIqi+JfRmC+P3ZNYoVXjpIGfe34dxvJcYcDo8B18wT9IKKTJwjoACZgIKdV+njBZ0PHLAp8V6ILi/yr8mIoP2K2RBAvgt6sduEWisc2Aq+4tM/9AgOtIBvMnJbsh4Onc0lhsd8snwyUMJx4CcuZPRdRxnv6GE4906cH10ia8mLVqA54jZDJQTXz5YsAXIOTcTMt3hw84G7wTpGAnlcP77y4BbVuf/Y4HHvuMEhCxV5ER18cgJsVI7kj5owBwC3+683LKUzHH1i4/a58GT61yMLz/gkZBJ0mi6MC0j0+6e8yb6WaCybz7hDn2L6mlLutd6une3YSfE+QiUVWwmNXwEcatX3U+krH8f3jpmxgfPDuTmR/JmM88/eZKuSl+flqmaykWTSKZKJSwM6Rw2WR0uE55WYFCMiyQGFAqQvczbT/y5j/Z57stzJSwQStYKE6wGmq4DGwWPHIfWE7Wjy5aU0tx9uiPnX2aFzzapkvwpkw68DpxisDdXaJ/FWSlgm6g/X7TaAB/MqXofR1mQ1JnIqSZ1SZfDDOd/mgH8ZCHpa87EGmsd/LjuJKSwyHVunp5iAFtnBBQqGli5Sn+tZEVwJaqzyWJ60WfU4vro4qEMvSkqJBY9EYc+72A4qlLUSvoGi5r/miH4E2+heLcQmFlDm1b0YfGcIRhRkm+0X6RLCEwK/TwTaCoGL3ox9e5QKsCXYPZPd+UDY9h+BAcJQ2WfD6ccpHfKwOab7ZICZSYbsWHSjZWLw8Wh+epEpLny5CvnHWwaOTNhBQkFO2xnjPRMYYFcP4GzjWqMLA1uVTQWGmp4KS/thsgpLM97YhEr4z04Rbhz10LdMyo3kNrz74lwhPeO7uYEYcOZvV2bNzwc8Ax/Cc4UNOmzS75lJeMXue+phiVmrXuaZTIVU/7OUyOW/TOtDWFsMERxM9LbvGvOutxmtG+aHWXXuIVR5KCN831tjCOKiBXlANdmOT7tvW6tLM5bR5sGOXeMR2hJM7kzE32NfHTHU/3uL+63MOAneqobtefsbXe6dSAjS2O0Vz0jSq5iS6lqOzTA8G6tf4N7x8A49kuY3wklyhBOjzF7y9a0PZhqM5JgMUXL4QDxsTgKN1cuN7Ms2g7wCMPsSh4D2rkKiAcQebaMoMBmk2IVnmeecKk2PK0ZXy0mXgJie2OZ8qqQ5s+bctS+oXYpfdSe/28m/r1On1UlbozwmQRciBPseJLnL+n3FCUgeAzzGxrq45OtFvpxkofCNtnV3h8emkbCtOOEY6+EWxxZxJeFavYudbEgAZNjdVENuEaRixd/0qbBX57VwzteJWhr5Llzhp/Y2xudWcirluKBayOKOsysPos1xZuTxCWc74Mtfw+hCiOonwJMBX7OycmYpUkNc0lX/rXQdj0EYAkA67A87MKI3peB4F89XyfCyUAqRp7YFFMbuT2JByEG/eYDio85zwY4o62bOy2xv/cxq4pRLDw6vOzeLfy6DJHdbKSdw53hHDNO0Lf04ru8xE1HLcXdqFcEqU8rrqnQOg7ibagHMxbZcusBL+lqLgsx2DCdZwRrmiKO8LJCBRwvDeq+Rq9WqDIt+oFZU2wU/IrBuz5GnuZkwRtRb5p6yn68W/MPvnkuWXnFbjekqBozL20g4gOiuJ2FBrzihwpAzdtG1MTsWGlMdkQ1h5z24quxRBPu/5H721vtjsc34WS8q74Fcoj66OavRzb0EHsuN109w1jzooOUP97+YtGdksWT+hAgteqGDmy4IUqAU4cd0JrUsZEctzduofD5x8BjKYpGKS3PUiaVSP5x9XHJW9tCl6lFHuGbjt04tET7w41CjeoZkywIC9sXrxU7lBgDsAWVlgz5WwV3OTj2wAFjbNAg80dVNNgMlqPYURhRpgAWpS7B7eA5A1moPo6jfdQU8t/JpD+AjipQ1u4wg84WZNTO/o6oYACAsLjrb+1CKbdbnkMQZ2JcL8JPvEga1FnL0rKnUd5j1iMomv0ZgsR7rYO6v81EyEh4PEytGMY2TpmKufF1k1n88lTWcMUS6U9dF4xV3edFXZ7BR/5KfpWJDJPMZfDA4YlodgTcHpkPMSB3jv584f86qSbiynhyKc6zVDQXR+/INNzcn+z1gB3ZIp0U4ewkw5sUzqw6boWtL8ZsoB7NdLU1N3/vEBBmsrz12pH7yWIuo4EYD1YRUKEbOAM/H5JkMivxpDwfQHudnHwWyVxHNPs7VNCzJGvMkBiUmWfqxH0zbYcGsQeTKG03Hd+XNtmudSE3wsMShOgom5M102SKUZnyqK/ecxy/HXIcB1WTdhN2ZP/fh2ZRwSu0WtSqZnodCVpnGpn3fKyc2cu7fAk0P71i9053CohYIfJeUDmGtTR6GdI3e3qJ6qa2lOoZDlFn72FDmQF1OzuKQunVfUTd/y8XS+WKdGz9IX9AILKa96idjPzqhNBP/NvxKyz+WJwODeNpwxIQreA10RxS32NGKcp9Zy0ueg0Oc8Gn7dk8kXjSLx7Fqm6KzeMpdkBjZILnUv4wBfk9itm13w7d3knodslUPxK6T2KCcnnR9T7JF4txoRWpZoIODK2kJwzNgaKR8AEP/W5PdUFxHyB56NOXhBLKzOu53aJtwmXyUHWaYgWWjTlHAzYIuhMgBaVSH0OV3Cpgnyff4D1X+1OHDA0e4RyWLRFRQIdX0WDoj58gRXrw5LPBa6hrnq6IKR/EQvWSKouY4xgqX1Jsir8Wnjs/uuhuiC8aTvZz+hpuYoK8YjZpMMa7+FtXVasFLZd4MkM1TPxFJiXx0JW7wPR0bW4Bd1Rp8g09a/Pxg+HwWWq97kUsNXtla1aGYaB+Sr8S/NsNyY2SBr5twA3Gyhn5HFSafHrXdW0g30pHsBwUD3XcRt5YhNmRIxtrrPKRvLxhvTq750/EHxcPXyYcuM6UsCZops+5IladikCSvWDgAWek6EU4YCvoJbW3+Ig8PoS1HHZjsNv9U9FXe3/7nBC0DolOsJOs3jFSwlRagXdkQz6347QwUmUbimhtd1fncJXKirZKNQCmEjn5yBp5BYK4K1HK4cYPHdujj37QMkqg9gksEV/peH9ZoF4XDqalF8DC9dwOQAc84AEaqqKkgHGI6QBPEPDCT73NRA0meFOhPCOxVa3pIl83nJcKlg0cRLNUSvsg1TSROVd84AQdkpT6moBVw38DjvP4OglmaA7ew1r3GSlGa8rUnYImj5bMOumYIMzj2P3qeeGRWjECFbFs+648XN6DAV4Hfc8XiWKYMXI2AfP9TJiZOsj/mE2mF15x6zzus4uwzA/AqI+kgid8kKPIMsJXZUIBvtFRHdLMVDNzNcLIkyEKUUNzmNYn7C28vjZJKZQM9K30kRLYU7pZiqTZparj0Ji7HAcKA0aU92EjNsufNIa2S/ePPxqSUx9q4fXWsk9OLh4xIpLmtN6oqFIasLahSq8S3K6Pux0t8D4x5G1f4232KQLhPzQqs1gSl4XmKC/ZCRuJ7DdlufCdxYQkKM0ILEWdmQrgLKASnKbcejgtKAAIyAAAAOKQF/En5d6D2z8ZlZ7DMxSzBBcy5Q9YnagsBIZzUJ45ML8iK2CvC7BAN9cQUO4gx4xfFJgAAAAAAAAAAAAAFZ0TkmBxvgPymcci70YzjSeN4UjTSwLhHpIvWe+m7oefkYE9YsUjyLPSH65+BDejzhOlJUOcdqc8fdTII2qDvyo0TrR8yiGaP0+Zfm1gYfz1w8rxn9nT/vUrUl2rkhx92Wk8WWbYTuuoyfbHVPJk2L8mOV9Fi1lXP735mj7r1c6DraeDjH2ttdi6gKy2nvzHetHswn+jaWMEp5bxawhaveuRGv1Wexe5D4SIu2yEF8LLuQv5XAYGgej2LVwiTyPdiavpW243h4V7pXQSzi3dFVcMxBjNg4fpH9aB/Y6AvMe4U8lUmG7HVhb1lYnbH+RaD6WwQlSu57mL/6KEFQMXlS98hC4TVrD0rZeutsZfjheCaZjGEn9BmHt7Y2cjIu3AB/tlTOPYQOn6k3LX/4YqdH92MJPv+WgVKJrJBe4JC7Tn3E64u8qDkMQ47WbnTa4jKxv0T7IsEMFW6REET1EHRbAGkGmbIfPKSxvgAAAGFdSOtUrOdC7y21HVO0VzYyWp1VsEkr7J/xo6g6C7VMw/OubaviUHMLJjtU4xRQUMPrsOkBGr5dczMf/yFJt4giEvrd0wzCzq/bhPI2eW5lgV62UwiEAVQGZoezOpKpzS73JiO2kgQhUEQk2oqL0y5erTHcozyVC2PWXZUV02+qaAIaBIdUOeDJHder2R861hq++LgR1TcXM/NV1s7sZ4/r55QQVeXZ/O7rvNwxC2PxLOmQui3wqjmBtV/BTYAl7uiVXPWagaWm06cEV683Txbr7YvHu3hXtjqd8luSNTKfJuYatxVP737hhFn6vfA9P1Ig59uSCcrul8kW/cA+NrZVDK8DGNh3wt0M/C+6lro+cAH8mw/d/tDBb6NBjQ2YP5QybUDCiWsSUYn2D8DYQ/f7+go/BZZVBreN8D4tC11dxruw+wAroWVFbvSRJ2zdaECQ13JDW5Mqv/nkgjlcR+Aayhkor1b8WPXIXRXWMTj9vO/NeWNeDWcT4wmx2GtzOaTzs07hNseS71xeBQBOWzZHl3ErOPK+tSHG4ZYaZk76FYsfF+pg9GXW24EvcbzUaJheDAC8lsKfUgvv1ezkzNbjQbGclLISNXS+oILQPkWMxjkfXGwacKrb7PDg9H8/WPFyeNaTakOKC4clK48XNN/0uXi9wZ1/mcfQ9KxOvRk5xK+0TifrUKZKWY9cSXPetwUdyQm9YibLVLtj2KBortGn4RuiMqQCMykJ02NcCOzg/lZQvVyJ5F0ZGVky7TF9ySafUPGTvuWF6ue2FrTupxSvO++8tGu3xvxkJdUiZxLd7y4mVbaZxPSfpAtSPv4BV7fEl5Qno4Hi0OYcB8npqrpNJRL3vBXW/HNJDtZ068n1InFM7ZCVSY675+CsO48H8EUmpBuFNx3T/pqM3cwy70rQKIG0t2Gd70RWCBLy7q2xt84Q+9xKeHo+j3/D3Bot0usQl6mS/NYq3PPFZ/u8a++COzCWEa9Wsr2qmzPGg/EHoE09pdU9s7jpwV1G2Mc/+jRFdv1xo96nsT4/CJVjtt6gSz/wKZEYLM9IkU01RH+PJlCmZe5icVAc8MAIMzA3k5q61pPXKrudgtsrmMf2ToMUVO7vGXnFBzJhgc9G2Pb8MQ5W+X/vhvgOncH/QrsdnTh/P3wa3ylVtTGlZ3YC4gxLozVatK2gVhTDSnDIGRtxZBIEb9DQtNcW9N9MzfJA/sBUY2++KY6d0fBtmF8mwkozhgagmxmTNNqZPGQCl7mjA04rEPtO0Onlw+EE6eB7VuKeSyaKYkB7A9V9F8fXQCU2hAOVOxFe221jBksjOn+DKMN3Icx/bzRoGVGQQKeb5ghMtWMstOgCHJsZvttCPbDZt0cM+j01n95ttCJ+Hh2ip3cdxFShLWSuwWxwIqE8peGaUaja+mWC5qk+kAIG+8z7uz0Pzn8dOesfEZ4r1+/YcOKVeMpzIhuEw+SZMCNMKD3kfjfQw45LPd/CrBinMs6GZ5ipJokzOUMdgTqhYTBhfNPhbFA5aPrCYAOlwDzwnFHeeO+8Mt6p8U614VE28fwXpqBj2nIMHSjRuryj//v8UYVGaO2VwTsHwlSnekofPflHSqmUT2rr/aBsTQq9uULgRE7EI1UBWeiZ90l9yPjcMM0YeNTzF5re49RduIAFwUAw6XvvLk57xoKB42YPoUoKa0E02QZCxnlGPlpToIQ0qsQaCkYGQ+u07NWkTTsDM5pZnw8Jm3i/nyJa4+3DJJjRWJ7HXViCnUkfX/MAH9PjKxYOuPM0l6BPvespNHYLZGed7o7P8NNqzlWXX98/1b9FWzkHqVQHvIL/RwyCdikeDxqa7qXdLJv1uso21xN93TIennmTgl8lxt+DEvyifVWEfEyraRHoE0AZJZtW888egLm2+3SdMQEhKemo1QMc9VGx9CWAYUFteYcMi4n80bhMDW+DxYqBQ3eMUPEuhtBE4YCKYOegcbHNX/al8HCbTts6qKPQNyMdgZDYn4zGxMfdD7PqpWxOT6myH96lkVR5CUDZuHhm3+KhiwdlQrTuYCpZK4QyTsHbhwmTSE5gwo9HNteUoKmk+E0O4AAAAABaQ8myd5YLK07bVRJliykgn+Frksq0tduJwGU3x9o5kz0lxjqS/thHwoEJDle52Tfrjg9L4Xq2bUn6s8Q5gHKXxhDAYA6YDjoioJgvS7qYInvmE6xjKFjvRQr1mIhm+PyqJZiNWFGx5pYMwVvhn1CIth4f6xGQlHdOHpD/3C2AvvgG4BdNd7j2QuxGT/5M4VmTOx9bSyMJMhStw61ruqCIkGcYxjDTdV4z7u9nzQsIxiU+iP8RwFz4Oql8Kw/LYFG6kPvoBZBM4EGU9rRJiZPFXliCJw3ugHZE1WQ3EL5W3kWH+OCUSKRQpn8LDAQv9ydVZfPj4mofVKXxClw2gcO0O3I37xUaE63+gAAAAAAAAAAAAtUPer7L6IAAAA==\r\n\r\n[img-10]:data:image/webp;base64,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\r\n\r\n[img-11]:data:image/webp;base64,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\r\n\r\n[img-12]:data:image/webp;base64,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\r\n\r\n[img-13]:data:image/webp;base64,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"
    },
    {
      "id": "/Chrome浏览器的拓展程序的安装位置",
      "metadata": {
        "permalink": "/blog/Chrome浏览器的拓展程序的安装位置",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Chrome浏览器的拓展程序的安装位置.md",
        "source": "@site/blog\\Chrome浏览器的拓展程序的安装位置.md",
        "title": "Chrome浏览器的拓展程序的安装位置",
        "description": "这篇博客讲的很清楚",
        "date": "2020-04-29T00:00:00.000Z",
        "formattedDate": "2020年4月29日",
        "tags": [
          {
            "label": "谷歌浏览器",
            "permalink": "/blog/tags/谷歌浏览器"
          }
        ],
        "readingTime": 0.105,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Chrome浏览器的拓展程序的安装位置",
          "date": "2020-04-29T00:00:00.000Z",
          "categories": "谷歌浏览器",
          "tags": [
            "谷歌浏览器"
          ]
        },
        "prevItem": {
          "title": "13 款内容收集整理利器，打造你专属的个人知识库标注利器总结",
          "permalink": "/blog/13 款内容收集整理利器，打造你专属的个人知识库标注利器总结"
        },
        "nextItem": {
          "title": "Linux之Vim命令行模式",
          "permalink": "/blog/Linux之Vim命令行模式"
        }
      },
      "content": "### 这篇博客讲的很清楚\r\n[拓展程序的安装位置](https://blog.csdn.net/qq_34764577/article/details/81184628)\r\n![](https://gitee.com/justin2/pic/raw/master/20200429171326.png)"
    },
    {
      "id": "/Linux之Vim命令行模式",
      "metadata": {
        "permalink": "/blog/Linux之Vim命令行模式",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Linux之Vim命令行模式.md",
        "source": "@site/blog\\Linux之Vim命令行模式.md",
        "title": "Linux之Vim命令行模式",
        "description": "如何进入vim命令行模式",
        "date": "2020-04-29T00:00:00.000Z",
        "formattedDate": "2020年4月29日",
        "tags": [
          {
            "label": "linux",
            "permalink": "/blog/tags/linux"
          }
        ],
        "readingTime": 0.64,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Linux之Vim命令行模式",
          "date": "2020-04-29T00:00:00.000Z",
          "categories": "linux",
          "tags": [
            "linux"
          ]
        },
        "prevItem": {
          "title": "Chrome浏览器的拓展程序的安装位置",
          "permalink": "/blog/Chrome浏览器的拓展程序的安装位置"
        },
        "nextItem": {
          "title": "浏览器中截长图的工具",
          "permalink": "/blog/浏览器中截长图的工具"
        }
      },
      "content": "### 如何进入vim命令行模式\r\nvim + 文件名\r\n下面我们举个例子 \r\n```\r\nvim 2.py\r\n```\r\n![](https://gitee.com/justin2/pic/raw/master/20200429145618.png)\r\n运行后是下面这样的（此时我们处在命令行的模式下）\r\n![](https://gitee.com/justin2/pic/raw/master/20200429145723.png)\r\n### 命令行模式下的操作快捷键\r\n|按键|功能|\r\n|---|---|\r\n|home|回到一行的起始位置|\r\n|end|回到一行的末尾|\r\n|gg|回到文件的开头位置|\r\n|G|回到文件的末尾|\r\n|ZZ|保存并退出|\r\n|u|撤销操作|\r\n|/+你要查找的内容|查找相关内容|"
    },
    {
      "id": "/浏览器中截长图的工具",
      "metadata": {
        "permalink": "/blog/浏览器中截长图的工具",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/浏览器中截长图的工具.md",
        "source": "@site/blog\\浏览器中截长图的工具.md",
        "title": "浏览器中截长图的工具",
        "description": "今天发现一个特别好用的截长图的工具，那就是Full page Screen,这个是Chrome浏览器里的一个插件，点一下插件的相机按钮即可",
        "date": "2020-04-29T00:00:00.000Z",
        "formattedDate": "2020年4月29日",
        "tags": [
          {
            "label": "谷歌浏览器",
            "permalink": "/blog/tags/谷歌浏览器"
          }
        ],
        "readingTime": 0.25,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "浏览器中截长图的工具",
          "date": "2020-04-29T00:00:00.000Z",
          "categories": "谷歌浏览器",
          "tags": [
            "谷歌浏览器"
          ]
        },
        "prevItem": {
          "title": "Linux之Vim命令行模式",
          "permalink": "/blog/Linux之Vim命令行模式"
        },
        "nextItem": {
          "title": "谷歌浏览器进入无痕模式的快捷键",
          "permalink": "/blog/谷歌浏览器进入无痕模式的快捷键"
        }
      },
      "content": "### 今天发现一个特别好用的截长图的工具，那就是Full page Screen,这个是Chrome浏览器里的一个插件，点一下插件的相机按钮即可\r\n![](https://gitee.com/justin2/pic/raw/master/20200429161815.png)"
    },
    {
      "id": "/谷歌浏览器进入无痕模式的快捷键",
      "metadata": {
        "permalink": "/blog/谷歌浏览器进入无痕模式的快捷键",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/谷歌浏览器进入无痕模式的快捷键.md",
        "source": "@site/blog\\谷歌浏览器进入无痕模式的快捷键.md",
        "title": "谷歌浏览器进入无痕模式的快捷键",
        "description": "使用下面的快捷键即可进入无痕浏览",
        "date": "2020-04-27T00:00:00.000Z",
        "formattedDate": "2020年4月27日",
        "tags": [
          {
            "label": "谷歌浏览器",
            "permalink": "/blog/tags/谷歌浏览器"
          }
        ],
        "readingTime": 0.115,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "谷歌浏览器进入无痕模式的快捷键",
          "date": "2020-04-27T00:00:00.000Z",
          "categories": "谷歌浏览器",
          "tags": [
            "谷歌浏览器"
          ]
        },
        "prevItem": {
          "title": "浏览器中截长图的工具",
          "permalink": "/blog/浏览器中截长图的工具"
        },
        "nextItem": {
          "title": "为什么PPT有的部分无法修改？",
          "permalink": "/blog/为什么PPT有的部分无法修改？"
        }
      },
      "content": "## 使用下面的快捷键即可进入无痕浏览\r\n```\r\nCtrl + Shift + N\r\n```"
    },
    {
      "id": "/为什么PPT有的部分无法修改？",
      "metadata": {
        "permalink": "/blog/为什么PPT有的部分无法修改？",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/为什么PPT有的部分无法修改？.md",
        "source": "@site/blog\\为什么PPT有的部分无法修改？.md",
        "title": "为什么PPT有的部分无法修改？",
        "description": "修改母版",
        "date": "2020-04-25T00:00:00.000Z",
        "formattedDate": "2020年4月25日",
        "tags": [
          {
            "label": "学术检索",
            "permalink": "/blog/tags/学术检索"
          }
        ],
        "readingTime": 0.525,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "为什么PPT有的部分无法修改？",
          "date": "2020-04-25T00:00:00.000Z",
          "categories": "学术检索",
          "tags": [
            "学术检索"
          ]
        },
        "prevItem": {
          "title": "谷歌浏览器进入无痕模式的快捷键",
          "permalink": "/blog/谷歌浏览器进入无痕模式的快捷键"
        },
        "nextItem": {
          "title": "给next主题添加搜索，一直转圈（loading）",
          "permalink": "/blog/给next主题添加搜索，一直转圈（loading）"
        }
      },
      "content": "## 修改母版\r\n>当我们看到非常好的ppt的时候，我们往往会下载下来，当做我们以后的ppt模板来使用，但是我发现一个问题，那就是这个优秀的ppt往往有的位置无法修改，后来经过查询资料，我发现，是因为母版的问题，我们只需要切换到母版样式即可进行修改"
    },
    {
      "id": "/给next主题添加搜索，一直转圈（loading）",
      "metadata": {
        "permalink": "/blog/给next主题添加搜索，一直转圈（loading）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/给next主题添加搜索，一直转圈（loading）.md",
        "source": "@site/blog\\给next主题添加搜索，一直转圈（loading）.md",
        "title": "给next主题添加搜索，一直转圈（loading）",
        "description": "结论：生成的search.xml的问题",
        "date": "2020-04-25T00:00:00.000Z",
        "formattedDate": "2020年4月25日",
        "tags": [
          {
            "label": "hexo",
            "permalink": "/blog/tags/hexo"
          }
        ],
        "readingTime": 0.63,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "给next主题添加搜索，一直转圈（loading）",
          "date": "2020-04-25T00:00:00.000Z",
          "categories": "hexo",
          "tags": [
            "hexo"
          ]
        },
        "prevItem": {
          "title": "为什么PPT有的部分无法修改？",
          "permalink": "/blog/为什么PPT有的部分无法修改？"
        },
        "nextItem": {
          "title": "Hexo博客的搭建流程",
          "permalink": "/blog/Hexo博客的搭建流程"
        }
      },
      "content": "## 结论：生成的search.xml的问题\r\n>在我给next主题添加搜索功能时，我发现搜索那个区域一直有个圈在转，后来经过我的反复排查，大约耗时一上午吧，调试的时候真的令人头疼，我终于找到问题所在了，那就是因为生成的search.xml文件的问题。\r\n## 解决方案：在[xml验证器](https://validator.aborla.net/?__cf_chl_jschl_tk__=b9482396112de743e3b68997352b4464da25a2a3-1587811681-0-ATINmZY8sGoeGP9szYrRxI7y3MSsDxnHw0ZixFC3nC-NG8rwVPDwStQYK3fRnMBmVnHctv2FQCx_uJrB2X6g4zNNDKX9fhqb8mtMh5QwPJzttxlHR2T_ZKpqKRL1sHq5qr30p6PItmr-qapRUmI0rbCzwPPQYV4T8FXiS3PWsN-2JqRLewjpnM1KsU3dXHLHiD7i3v8BfVG9R9luQS-kvFkDEfmHP6tmGSbdViF6MSmyVyr_BTXG6FTSNNBVfkEujQurh5xwRqKn2qwsrSRFidk)里将错误的文件生成正确的后，复制粘贴到原文件中即可。"
    },
    {
      "id": "/Hexo博客的搭建流程",
      "metadata": {
        "permalink": "/blog/Hexo博客的搭建流程",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Hexo博客的搭建流程.md",
        "source": "@site/blog\\Hexo博客的搭建流程.md",
        "title": "Hexo博客的搭建流程",
        "description": "黄浩大佬的Hexo博客搭建教程",
        "date": "2020-04-24T00:00:00.000Z",
        "formattedDate": "2020年4月24日",
        "tags": [
          {
            "label": "hexo",
            "permalink": "/blog/tags/hexo"
          }
        ],
        "readingTime": 0.075,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Hexo博客的搭建流程",
          "date": "2020-04-24T00:00:00.000Z",
          "categories": "hexo",
          "tags": [
            "hexo"
          ]
        },
        "prevItem": {
          "title": "给next主题添加搜索，一直转圈（loading）",
          "permalink": "/blog/给next主题添加搜索，一直转圈（loading）"
        },
        "nextItem": {
          "title": "linux基础指令（一）",
          "permalink": "/blog/linux基础指令（一）"
        }
      },
      "content": "## [黄浩大佬的Hexo博客搭建教程](https://mrhuanhao.cn/2020/03/23/hexobase/)"
    },
    {
      "id": "/linux基础指令（一）",
      "metadata": {
        "permalink": "/blog/linux基础指令（一）",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/linux基础指令（一）.md",
        "source": "@site/blog\\linux基础指令（一）.md",
        "title": "linux基础指令（一）",
        "description": "|操作命令|内容|",
        "date": "2020-04-24T00:00:00.000Z",
        "formattedDate": "2020年4月24日",
        "tags": [
          {
            "label": "linux",
            "permalink": "/blog/tags/linux"
          }
        ],
        "readingTime": 0.54,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "linux基础指令（一）",
          "date": "2020-04-24T00:00:00.000Z",
          "categories": "linux",
          "tags": [
            "linux"
          ]
        },
        "prevItem": {
          "title": "Hexo博客的搭建流程",
          "permalink": "/blog/Hexo博客的搭建流程"
        },
        "nextItem": {
          "title": "Openwall爬虫V1.0",
          "permalink": "/blog/Openwall爬虫V1.0"
        }
      },
      "content": "|操作命令|内容|\r\n|:--:|:--:|\r\n| 清屏 | ctrl + L|\r\n|帮助命令|man|\r\n|进入命令|cd|\r\n|文本到图形|init5|\r\n|图形到文本|init3|\r\n|显示当前目录内容|ls|\r\n|显示主机名|hostname|\r\n|显示当前路径|pwd|\r\n|删除|rm -rf + 名字|\r\n|改名|mv a b|\r\n|移动|mv a c|\r\n|拷贝|cp |\r\n|查看文件内容|cat|\r\n|终止|ctrl + c/z|\r\n|新建文件夹|mkdir|"
    },
    {
      "id": "/Openwall爬虫V1.0",
      "metadata": {
        "permalink": "/blog/Openwall爬虫V1.0",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/Openwall爬虫V1.0.md",
        "source": "@site/blog\\Openwall爬虫V1.0.md",
        "title": "Openwall爬虫V1.0",
        "description": "生成可以使用carbon",
        "date": "2020-04-24T00:00:00.000Z",
        "formattedDate": "2020年4月24日",
        "tags": [
          {
            "label": "爬虫",
            "permalink": "/blog/tags/爬虫"
          }
        ],
        "readingTime": 0.045,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "Openwall爬虫V1.0",
          "date": "2020-04-24T00:00:00.000Z",
          "categories": "爬虫",
          "tags": [
            "爬虫"
          ]
        },
        "prevItem": {
          "title": "linux基础指令（一）",
          "permalink": "/blog/linux基础指令（一）"
        },
        "nextItem": {
          "title": "SecurityTracker爬虫V1.0",
          "permalink": "/blog/SecurityTracker爬虫V1.0"
        }
      },
      "content": "![](https://gitee.com/justin2/pic/raw/master/20200420173156.png)\r\n>生成可以使用carbon"
    },
    {
      "id": "/SecurityTracker爬虫V1.0",
      "metadata": {
        "permalink": "/blog/SecurityTracker爬虫V1.0",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/SecurityTracker爬虫V1.0.md",
        "source": "@site/blog\\SecurityTracker爬虫V1.0.md",
        "title": "SecurityTracker爬虫V1.0",
        "description": "生成可以使用carbon",
        "date": "2020-04-24T00:00:00.000Z",
        "formattedDate": "2020年4月24日",
        "tags": [
          {
            "label": "爬虫",
            "permalink": "/blog/tags/爬虫"
          }
        ],
        "readingTime": 0.045,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "SecurityTracker爬虫V1.0",
          "date": "2020-04-24T00:00:00.000Z",
          "categories": "爬虫",
          "tags": [
            "爬虫"
          ]
        },
        "prevItem": {
          "title": "Openwall爬虫V1.0",
          "permalink": "/blog/Openwall爬虫V1.0"
        },
        "nextItem": {
          "title": "以json格式输出的时候防止中文乱码的办法",
          "permalink": "/blog/以json格式输出的时候防止中文乱码的办法"
        }
      },
      "content": "![](https://gitee.com/justin2/pic/raw/master/20200420171647.png)\r\n>生成可以使用carbon"
    },
    {
      "id": "/以json格式输出的时候防止中文乱码的办法",
      "metadata": {
        "permalink": "/blog/以json格式输出的时候防止中文乱码的办法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/以json格式输出的时候防止中文乱码的办法.md",
        "source": "@site/blog\\以json格式输出的时候防止中文乱码的办法.md",
        "title": "以json格式输出的时候防止中文乱码的办法",
        "description": "只用修改红色方框的两个点即可",
        "date": "2020-04-24T00:00:00.000Z",
        "formattedDate": "2020年4月24日",
        "tags": [
          {
            "label": "debug",
            "permalink": "/blog/tags/debug"
          }
        ],
        "readingTime": 0.08,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "以json格式输出的时候防止中文乱码的办法",
          "date": "2020-04-24T00:00:00.000Z",
          "categories": "debug",
          "tags": [
            "debug"
          ]
        },
        "prevItem": {
          "title": "SecurityTracker爬虫V1.0",
          "permalink": "/blog/SecurityTracker爬虫V1.0"
        },
        "nextItem": {
          "title": "在VSCode中设置python虚拟环境",
          "permalink": "/blog/在VSCode中设置python虚拟环境"
        }
      },
      "content": "## 只用修改红色方框的两个点即可\r\n![](https://gitee.com/justin2/pic/raw/master/20200419165737.png)"
    },
    {
      "id": "/在VSCode中设置python虚拟环境",
      "metadata": {
        "permalink": "/blog/在VSCode中设置python虚拟环境",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/在VSCode中设置python虚拟环境.md",
        "source": "@site/blog\\在VSCode中设置python虚拟环境.md",
        "title": "在VSCode中设置python虚拟环境",
        "description": "1:使用cmd调出我们的系统命令",
        "date": "2020-04-24T00:00:00.000Z",
        "formattedDate": "2020年4月24日",
        "tags": [
          {
            "label": "VSCode",
            "permalink": "/blog/tags/vs-code"
          }
        ],
        "readingTime": 0.585,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "在VSCode中设置python虚拟环境",
          "date": "2020-04-24T00:00:00.000Z",
          "categories": "VSCode",
          "tags": [
            "VSCode"
          ]
        },
        "prevItem": {
          "title": "以json格式输出的时候防止中文乱码的办法",
          "permalink": "/blog/以json格式输出的时候防止中文乱码的办法"
        },
        "nextItem": {
          "title": "快速检索文献并下载文献的方法",
          "permalink": "/blog/快速检索文献并下载文献的方法"
        }
      },
      "content": "### 1:使用cmd调出我们的系统命令\r\n### 2：建立我们的虚拟环境文件夹（注意这个文件夹的路径必须是全英文，否则会报错）\r\n### 3:在cmd中输入以下命令\r\n```\r\nvirtualenv mycode\r\nmycode\\Scripts\\activate\r\n``` \r\n### 4:打开我们的VSCode，选择我们上面操作好的文件夹\r\n### 5：在VSCode的左下角选择那个虚拟环境即可\r\n### 6：如果报错的话，采用下面的解决办法\r\n![](https://gitee.com/justin2/pic/raw/master/20200421110837.png)"
    },
    {
      "id": "/快速检索文献并下载文献的方法",
      "metadata": {
        "permalink": "/blog/快速检索文献并下载文献的方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/快速检索文献并下载文献的方法.md",
        "source": "@site/blog\\快速检索文献并下载文献的方法.md",
        "title": "快速检索文献并下载文献的方法",
        "description": "1:AnyPaper",
        "date": "2020-04-24T00:00:00.000Z",
        "formattedDate": "2020年4月24日",
        "tags": [
          {
            "label": "学术检索",
            "permalink": "/blog/tags/学术检索"
          }
        ],
        "readingTime": 0.735,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "快速检索文献并下载文献的方法",
          "date": "2020-04-24T00:00:00.000Z",
          "categories": "学术检索",
          "tags": [
            "学术检索"
          ]
        },
        "prevItem": {
          "title": "在VSCode中设置python虚拟环境",
          "permalink": "/blog/在VSCode中设置python虚拟环境"
        },
        "nextItem": {
          "title": "快速进行文献翻译",
          "permalink": "/blog/快速进行文献翻译"
        }
      },
      "content": "## 1:AnyPaper\r\n#### 我们可以通过[洛奇Town](https://ifish.fun/paper/search)，进行下载论文。\r\n![](https://gitee.com/justin2/pic/raw/master/20200423174843.png)\r\n>具体的使用方法是直接输入DOI号即可进行一键下载，在进行检索的时候下面还提供了最新的SCI-Hub的可用网址，并且给出了延迟检测，是一个很高效的网站，希望这个网站能做的久一点吧，感谢作者！\r\n>这个网站，还提供了很多的优质音乐哦！学习累了，可以听一听。\r\n## 2:学术屋\r\n#### [具体网址](http://sci.xueshuwu.cn/)\r\n![](https://gitee.com/justin2/pic/raw/master/20200423174559.png)\r\n## 3：思谷学术\r\n#### [具体网址](https://siguso.com/google/)\r\n![](https://gitee.com/justin2/pic/raw/master/20200423174756.png)"
    },
    {
      "id": "/快速进行文献翻译",
      "metadata": {
        "permalink": "/blog/快速进行文献翻译",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/快速进行文献翻译.md",
        "source": "@site/blog\\快速进行文献翻译.md",
        "title": "快速进行文献翻译",
        "description": "经过大量尝试，本人有了一些心得体会：",
        "date": "2020-04-24T00:00:00.000Z",
        "formattedDate": "2020年4月24日",
        "tags": [
          {
            "label": "学术检索",
            "permalink": "/blog/tags/学术检索"
          }
        ],
        "readingTime": 0.39,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "快速进行文献翻译",
          "date": "2020-04-24T00:00:00.000Z",
          "categories": "学术检索",
          "tags": [
            "学术检索"
          ]
        },
        "prevItem": {
          "title": "快速检索文献并下载文献的方法",
          "permalink": "/blog/快速检索文献并下载文献的方法"
        },
        "nextItem": {
          "title": "爬虫之bs4基础",
          "permalink": "/blog/爬虫之bs4基础"
        }
      },
      "content": "###### 经过大量尝试，本人有了一些心得体会：\r\n---\r\n## 1：使用Adobe acrobat pro DC 将PDF文档转换为word文档。\r\n## 2：将转换后的word文档，传到[deftpdf](https://deftpdf.com/translate#)。\r\n## 3：即可在线或者下载观看。\r\n<p align=\"right\">本文看似简单，却凝聚了作者的大量心血！</p>"
    },
    {
      "id": "/爬虫之bs4基础",
      "metadata": {
        "permalink": "/blog/爬虫之bs4基础",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/爬虫之bs4基础.md",
        "source": "@site/blog\\爬虫之bs4基础.md",
        "title": "爬虫之bs4基础",
        "description": "",
        "date": "2020-04-24T00:00:00.000Z",
        "formattedDate": "2020年4月24日",
        "tags": [
          {
            "label": "爬虫",
            "permalink": "/blog/tags/爬虫"
          }
        ],
        "readingTime": 0.02,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "爬虫之bs4基础",
          "date": "2020-04-24T00:00:00.000Z",
          "categories": "爬虫",
          "tags": [
            "爬虫"
          ]
        },
        "prevItem": {
          "title": "快速进行文献翻译",
          "permalink": "/blog/快速进行文献翻译"
        },
        "nextItem": {
          "title": "给Hexo添加自定义菜单menu的方法",
          "permalink": "/blog/给Hexo添加自定义菜单menu的方法"
        }
      },
      "content": "![](https://gitee.com/justin2/pic/raw/master/20200423203434.png)\r\n![](https://gitee.com/justin2/pic/raw/master/20200423203506.png)\r\n![](https://gitee.com/justin2/pic/raw/master/20200423203523.png)\r\n![](https://gitee.com/justin2/pic/raw/master/20200423203543.png)"
    },
    {
      "id": "/给Hexo添加自定义菜单menu的方法",
      "metadata": {
        "permalink": "/blog/给Hexo添加自定义菜单menu的方法",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/给Hexo添加自定义菜单menu的方法.md",
        "source": "@site/blog\\给Hexo添加自定义菜单menu的方法.md",
        "title": "给Hexo添加自定义菜单menu的方法",
        "description": "1：修改站点配置文件下的menu",
        "date": "2020-04-24T00:00:00.000Z",
        "formattedDate": "2020年4月24日",
        "tags": [
          {
            "label": "hexo",
            "permalink": "/blog/tags/hexo"
          }
        ],
        "readingTime": 0.955,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "给Hexo添加自定义菜单menu的方法",
          "date": "2020-04-24T00:00:00.000Z",
          "categories": "hexo",
          "tags": [
            "hexo"
          ]
        },
        "prevItem": {
          "title": "爬虫之bs4基础",
          "permalink": "/blog/爬虫之bs4基础"
        },
        "nextItem": {
          "title": "视频测试",
          "permalink": "/blog/视频测试"
        }
      },
      "content": "## 1：修改站点配置文件下的menu\r\n![](https://gitee.com/justin2/pic/raw/master/20200412091841.png)\r\n## 2:修改主题目录下的language目录下的zh-CN.yml\r\n![](https://gitee.com/justin2/pic/raw/master/20200412092209.png)\r\n## 3：设置图标\r\n![](https://gitee.com/justin2/pic/raw/master/20200412092311.png)\r\n##### 将红框里的改成[图标网站](https://fontawesome.com/icons)里的类型，这里注意选择的是下面的这个位置：\r\n![](https://gitee.com/justin2/pic/raw/master/20200412092551.png)\r\n## 4：创建菜单的文件夹\r\n##### 在blog目录下使用git bush 输入以下命令：\r\n```\r\nhexo new page 'name'\r\n```\r\n##### 注意这里的name填的是，上面提到的菜单类型，我在配置的时候，就是在这个位置出了问题，所以这个位置一定要小心！\r\n\r\n## 5：在 index.md 中增加 type 属性\r\n![](https://gitee.com/justin2/pic/raw/master/20200412093442.png)\r\n##### 注意：这里的类型，也是我们上文提到的菜单类型！\r\n\r\n## 6：在文章中加入相关属性"
    },
    {
      "id": "/视频测试",
      "metadata": {
        "permalink": "/blog/视频测试",
        "editUrl": "https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/视频测试.md",
        "source": "@site/blog\\视频测试.md",
        "title": "视频测试",
        "description": "方法1：通过哔哩哔哩的分享按钮里的嵌入地址可以实现",
        "date": "2020-04-24T00:00:00.000Z",
        "formattedDate": "2020年4月24日",
        "tags": [
          {
            "label": "hexo",
            "permalink": "/blog/tags/hexo"
          }
        ],
        "readingTime": 0.165,
        "hasTruncateMarker": false,
        "authors": [],
        "frontMatter": {
          "title": "视频测试",
          "date": "2020-04-24T00:00:00.000Z",
          "categories": "hexo",
          "tags": [
            "hexo"
          ]
        },
        "prevItem": {
          "title": "给Hexo添加自定义菜单menu的方法",
          "permalink": "/blog/给Hexo添加自定义菜单menu的方法"
        }
      },
      "content": "## 方法1：通过哔哩哔哩的分享按钮里的嵌入地址可以实现\r\n<iframe src=\"//player.bilibili.com/player.html?aid=2450500&bvid=BV1Bs411U73H&cid=3127478&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>"
    }
  ]
}