<!doctype html>
<html lang="zh-Hans" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.1.0">
<title data-rh="true">一篇文章，彻底搞懂浏览器的缓存机制 | 7Wate</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://qq1120637483.github.io//blog/一篇文章，彻底搞懂浏览器的缓存机制"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" name="keywords" content="7wate, wiki, blog, c, c++, java, python, linux"><meta data-rh="true" property="og:title" content="一篇文章，彻底搞懂浏览器的缓存机制 | 7Wate"><meta data-rh="true" name="description" content="无论在工作中还是平时的学习面试过程中，HTTP缓存几乎都是我们绕不开的话题，面对这些常见的知识点，我们不应该选择逃避，而是勇于面对，去搞懂它们。"><meta data-rh="true" property="og:description" content="无论在工作中还是平时的学习面试过程中，HTTP缓存几乎都是我们绕不开的话题，面对这些常见的知识点，我们不应该选择逃避，而是勇于面对，去搞懂它们。"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2021-10-06T00:00:00.000Z"><meta data-rh="true" property="article:tag" content="面试题"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://qq1120637483.github.io//blog/一篇文章，彻底搞懂浏览器的缓存机制"><link data-rh="true" rel="alternate" href="https://qq1120637483.github.io//blog/一篇文章，彻底搞懂浏览器的缓存机制" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://qq1120637483.github.io//blog/一篇文章，彻底搞懂浏览器的缓存机制" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="7Wate`s Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="7Wate`s Blog Atom Feed">
<link rel="alternate" type="application/json" href="/blog/feed.json" title="7Wate`s Blog JSON Feed">

<link rel="preconnect" href="https://www.google-analytics.com">
<script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","G-MHMEL0F832","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>
<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-MHMEL0F832"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-MHMEL0F832",{anonymize_ip:!0})</script><link rel="stylesheet" href="/assets/css/styles.a2a76c0f.css">
<link rel="preload" href="/assets/js/runtime~main.3f6835d1.js" as="script">
<link rel="preload" href="/assets/js/main.0d220686.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a href="#" class="skipToContent_fXgn">跳到主要内容</a></div><nav class="navbar navbar--fixed-top navbarHideable_m1mJ"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><b class="navbar__title text--truncate">🐋 Faith&amp;Passion&#x27;s Wiki</b></a></div><div class="navbar__items navbar__items--right"><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">🍁 博客</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">🦖 Wiki</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/structures-algorithms">数据结构与算法</a></li><li><a class="dropdown__link" href="/computer-network">计算机网络</a></li><li><a class="dropdown__link" href="/operating-system">操作系统</a></li><li><a class="dropdown__link" href="/database-system">数据库</a></li><li><a class="dropdown__link" href="/computer-security">网络安全</a></li><li><a class="dropdown__link" href="/software-engineering">软件工程</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">🪟 面经</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/roadmap">前端面经</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">⏰ LeetCode</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/org">开源社区</a></li></ul></div><a class="navbar__item navbar__link" href="/life">🏄‍♂️ 生活</a><a class="navbar__item navbar__link" href="/journal">📜 随笔日记</a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_pO2u margin-bottom--md">近期文章</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/查找字符串中最长的单词">查找字符串中最长的单词</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/JS模块化演变及其区别">JS模块化演变及其区别</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/你知道原型链？那你能实现一个new吗？">你知道原型链？那你能实现一个new吗？</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/Koa的洋葱模型到底是什么？">Koa的洋葱模型到底是什么？</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/OSI七层网络模型，你了解多少？">OSI七层网络模型，你了解多少？</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/Promise的异常捕获问题">Promise的异常捕获问题</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/Vue中的v-if和v-for为什么不能一起用？">Vue中的v-if和v-for为什么不能一起用？</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/for...in和for....of的区别是什么？">for...in和for....of的区别是什么？</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/这一次，彻底搞懂Vue中的keep-alive">这一次，彻底搞懂Vue中的keep-alive</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/LeetCode——简化路径（辅助栈）">LeetCode——简化路径（辅助栈）</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="title_f1Hy" itemprop="headline">一篇文章，彻底搞懂浏览器的缓存机制</h1><div class="container_mt6G margin-vert--md"><time datetime="2021-10-06T00:00:00.000Z" itemprop="datePublished">2021年10月6日</time> · <!-- -->阅读需 24 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><span itemprop="name">Justin</span></div></div></div></div></div></header><div id="post-content" class="markdown" itemprop="articleBody"><blockquote><p>无论在工作中还是平时的学习面试过程中，HTTP缓存几乎都是我们绕不开的话题，面对这些常见的知识点，我们不应该选择逃避，而是勇于面对，去搞懂它们。</p></blockquote><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="为什么需要缓存">为什么需要缓存？<a class="hash-link" href="#为什么需要缓存" title="标题的直接链接">​</a></h2><blockquote><p>在任何一个前端项目中，访问服务器获取数据都是很常见的事情，如果相同的数据被重复请求了不止一次，那么多余的请求必然会浪费网络带宽，以及延迟浏览器渲染所要处理的内容，从而影响用户的使用体验。如果用户使用的是按量计费的方式访问网络，多余的请求还会隐形的增加用户的网络流量资费。因此考虑使用缓存技术对已经获取的资源进行重用，是一种提升网站性能与用户体验的有效策略。</p></blockquote><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="缓存的原理">缓存的原理<a class="hash-link" href="#缓存的原理" title="标题的直接链接">​</a></h2><blockquote><p>缓存的原理是在首次请求后保存一份请求资源的响应副本，当用户再次发起相同请求后，如果判断缓存命中则拦截请求，将之前存储的响应副本返回给用户，从而避免了重新向服务器发起资源请求。</p></blockquote><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="http缓存">HTTP缓存<a class="hash-link" href="#http缓存" title="标题的直接链接">​</a></h2><blockquote><p>HTTP缓存应该算是前端开发中最常接触的缓存之一，它又可以细分为强制缓存和协商缓存，二者最大的区别在于判断缓存命中时，浏览器是否需要向服务器端进行询问以协商缓存的相关信息，进而判断是否需要就响应内容进行重新请求，下面让我们来看看HTTP缓存的具体机制及缓存的决策策略。</p></blockquote><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="强制缓存">强制缓存<a class="hash-link" href="#强制缓存" title="标题的直接链接">​</a></h3><blockquote><p>对于强制缓存而言，如果浏览器判断所请求的目标资源有效命中，则直接从强制缓存中返回请求响应，无须与服务器进行任何通信。</p></blockquote><blockquote><p>其中与强制缓存相关的两个字段是expires和cache-control，expires是在HTTP1.0协议中声明的用来控制缓存失效日期时间戳的字段，它由服务器端指定后通过响应头告知浏览器，浏览器在接收到带有该字段的响应体后进行缓存。</p></blockquote><blockquote><p>若之后浏览器再次发起相同的资源请求，便会对比expires与本地当前的时间戳，如果当前请求的本地时间戳小于expires的值，则说明浏览器缓存的响应还未过期，可以直接使用而无须向服务器端再次发起请求。只有当本地时间戳大于expires值，发生缓存过期时，才允许重新向服务器发起请求。</p></blockquote><blockquote><p>从上述强制缓存的是否过期的判断机制中不难看出，这个方式存在一个很大的漏洞，即对本地时间戳过分依赖，如果客户端本地的时间与服务器端的时间不同步，或者对客户端的时间进行主动修改，那么对于缓存过期的判断可能就无法和预期相符。</p></blockquote><blockquote><p>为了解决expires判断的局限性，从HTTP1.1协议开始新增了cache-control字段来对expires的功能进行拓展和完善。从上述代码中可见cache-control设置了maxage=31536000的属性值来控制响应资源的有效期，它是一个以秒为单位的时间长度，表示该资源在被请求到后的31536000秒内有效，如此便可避免服务器端和客户端时间戳不同步而造成的问题。</p></blockquote><blockquote><p>注意：如果Cache-Control的max-age和expires同时存在，则以max-age为准。</p></blockquote><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="cache-control的其他参数">Cache-Control的其他参数<a class="hash-link" href="#cache-control的其他参数" title="标题的直接链接">​</a></h3><ul><li>no-cache</li></ul><blockquote><p>设置no-cache并非不适用缓存，而是表示强制进行协商缓存，即对于每次发起的请求都不会再去判断强制缓存是否过期，而是直接与服务器写撒谎给你来验证缓存的有效性，若缓存未过期，则会使用本地缓存。</p></blockquote><ul><li>no-store</li></ul><blockquote><p>设置no-store则表示禁止使用任何缓存，客户端的每次请求都需要服务器端给予全新的响应。no-cache与no-store是两个互斥的属性值，不能同时设置。</p></blockquote><ul><li>public</li></ul><blockquote><p>若资源响应头中的cache-control字段设置了public属性值，则表示响应资源既可以被浏览器缓存，又可以被代理服务器缓存。</p></blockquote><ul><li>private </li></ul><blockquote><p>private则限制了响应资源只能被浏览器缓存，如果没有显示指定则默认值是private。</p></blockquote><ul><li>max-age</li></ul><blockquote><p>表示服务器端告知客户端浏览器响应资源的过期时长。</p></blockquote><ul><li>s-maxage</li></ul><blockquote><p>对于大型架构的项目通常会涉及使用各种代理服务器的情况，这就需要考虑缓存在代理服务器上的有效性问题，这边是s-maxage存在的意义，它表示缓存在代理服务器中的过期时长，且仅当设置了public属性值时才是有效的。</p></blockquote><blockquote><p>由此可见，cache-control能够作为expires的完全替代方案，并且拥有其所不具备的一些缓存控制特性，在项目实践中使用它就足够了，目前expires还存在的唯一理由就是向下兼容。</p></blockquote><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="协商缓存">协商缓存<a class="hash-link" href="#协商缓存" title="标题的直接链接">​</a></h3><blockquote><p>顾名思义，协商缓存就是在使用本地缓存之前，需要向服务器发起一次GET请求，与之协商当前浏览器保存的本地缓存是否已经过期。通常是采用所请求资源的最近一次的修改时间戳来判断的。</p></blockquote><ul><li>实例</li></ul><blockquote><p>假设客户端需要向服务器请求一个manifest.js的JS文件，为了让该资源被再次请求时能够通过协商缓存的机制使用本地缓存，那么首次返回该图片资源的响应头中应包含一个名为last-modified的字段，该字段的属性值为该JS文件最近一次修改的时间戳。</p></blockquote><blockquote><p>当我们刷新网页时，由于该JS文件使用的是协商缓存，客户端浏览器无法确定本地缓存是否过期，所以需要向服务器发送一次GET请求，进行缓存有效性的协商，此次GET请求的请求头中需要包含一个ifmodified-since字段，其值正是上次响应头中last-modified的字段值。</p></blockquote><blockquote><p>当服务器收到该请求后便会对比请求资源当前的修改时间戳与if-modified-since字段的值，如果二者相同则说明缓存未过期，可继续使用本地缓存，否则服务器重新返回全新的文件资源。</p></blockquote><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="基于last-modified的协商缓存服务器端代码">基于Last-Modified的协商缓存（服务器端代码）<a class="hash-link" href="#基于last-modified的协商缓存服务器端代码" title="标题的直接链接">​</a></h4><div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> </span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> data </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> fs</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">readFileSync</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&#x27;./imgs/CSS.png&#x27;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> mtime </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> fs</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">statSync</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&#x27;./imgs/CSS.png&#x27;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> ifModifiedSince </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> req</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">headers</span><span class="token punctuation" style="color:#393A34">[</span><span class="token string" style="color:#e3116c">&#x27;if-modified-since&#x27;</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><span class="token keyword control-flow" style="color:#00009f">if</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">ifModifiedSince </span><span class="token operator" style="color:#393A34">===</span><span class="token plain"> mtime</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">toUTCString</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    res</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">statusCode</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">304</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    res</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">end</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword control-flow" style="color:#00009f">return</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> res</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">setHeader</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&#x27;last-modified&#x27;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain">mtime</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">toUTCString</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> res</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">setHeader</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&#x27;Cache-Control&#x27;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token string" style="color:#e3116c">&#x27;no-cache&#x27;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> res</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">end</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">data</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="last-modified协商缓存流程">Last-Modified协商缓存流程<a class="hash-link" href="#last-modified协商缓存流程" title="标题的直接链接">​</a></h4><blockquote><p>客户端第一次请求目标资源的时，服务器返回的响应标头包含last-modified和该资源的最后一次修改的时间戳，以及cache-control：no-cache，当客户端再次请求该资源的时候，会携带一个ifmodifiedsince字段，如果这个字段对应的时间与目标资源的时间戳进行对比，如果没有变化则返回一个304状态码。</p></blockquote><blockquote><p>需要注意的是：协商缓存判断缓存有效的响应状态码是304，但是如果是强制缓存判断有效的话，响应状态码是200。</p></blockquote><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="last-modified的不足">last-modified的不足<a class="hash-link" href="#last-modified的不足" title="标题的直接链接">​</a></h4><ol><li>last-modified是根据请求资源的最后修改时间戳进行判断的，虽然请求的文件资源进行了编辑，但是内容并没有发生任何变化，时间戳也会更新，从而导致协商缓存时关于有效性的判断验证为失效，需要重新进行完整的资源请求。这无疑会造成网络带宽资源的浪费，以及延长用户获取到目标资源的时间。</li><li>标识文件资源修改的时间戳单位是秒，如果文件修改的速度非常快，假设在几百毫秒内完成，那么通过时间戳的方式来验证缓存的有效性，是无法识别出该次文件资源的更新的。</li></ol><blockquote><p>其实造成上述两种缺陷的原因相同，就是服务器无法根据资源修改的时间戳识别出真正的更新，进而导致重新发起了请求，该重新请求却使用了缓存的Bug场景。</p></blockquote><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="基于etag的协商缓存服务端代码">基于Etag的协商缓存（服务端代码）<a class="hash-link" href="#基于etag的协商缓存服务端代码" title="标题的直接链接">​</a></h4><p><img loading="lazy" src="https://img-blog.csdnimg.cn/img_convert/03ccddbca7c68a55afdae8519ddd665d.png" class="img_ev3q"></p><blockquote><p>为了弥补通过时间戳判断的不足，从HTTP1.1规范开始新增了一个Etag的头信息，即实体标签。
其内容主要是服务器为不同的资源进行哈希计算所生成的一个字符串，该字符串类似于文件指纹，只要文件内容编码存在差异，对应的Etag对文件资源进行更精准的变化感知。</p></blockquote><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="etag协商缓存的流程">Etag协商缓存的流程<a class="hash-link" href="#etag协商缓存的流程" title="标题的直接链接">​</a></h4><ol><li>首先，服务端将要返回给客户端的数据通过etag模块进行哈希计算生成一个字符串，这个字符串类似于文件指纹。</li><li>检测客户端的请求标头中的ifNoneMatch字段的值和第一步计算的值是否一致，一致则返回304。</li><li>如果不一致则返回etag标头和Cache-Control：no-cache。</li></ol><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="etag的不足">Etag的不足<a class="hash-link" href="#etag的不足" title="标题的直接链接">​</a></h4><blockquote><p>不像强制缓存中cache-control可以完全替代expires的功能，在协商缓存中，Etag并非last-modified的替代方案而是一种补充方案，因为依旧存在一些弊端。</p></blockquote><ol><li>服务器对于生成文件资源的Etag需要付出额外的计算开销，如果资源的尺寸比较大，数量较多且修改频繁，那么生成的Etag的过程就会影响服务器的性能。</li><li>Etag字段值的生成分为强验证和弱验证，强验证根据资源内容进行生成，能够保证每个字节都相同，弱验证则根据资源的部分属性来生成，生成速度快但无法确保每个字节都相同，并且在服务器集群场景下，也会因为准确不够而降低协商缓存有效性的成功率，所以恰当的方式是根据具体的资源使用场景选择恰当的缓存校验方式。</li></ol><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="缓存决策及其注意事项">缓存决策及其注意事项<a class="hash-link" href="#缓存决策及其注意事项" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="缓存决策">缓存决策<a class="hash-link" href="#缓存决策" title="标题的直接链接">​</a></h3><blockquote><p>假设在不考虑客户端缓存容量与服务器算力的理想情况下，我们当然希望客户端浏览器上的缓存触发率尽可能高，留存时间尽可能长，同时还要Etag实现当资源更新时进行高效的重新验证。但实际情况往往是容量与算力都有限，因此就需要制定合适的缓存策略，来利用有限的资源达到最优的性能效果，明确能力的边界，力求在边界内做到最好。</p></blockquote><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="缓存决策树">缓存决策树<a class="hash-link" href="#缓存决策树" title="标题的直接链接">​</a></h3><blockquote><p>在面对一个具体的缓存需求时，我们可以参照如下的缓存决策树来逐步确定对一个资源具体的缓存策略。</p></blockquote><ul><li>是否使用缓存<ul><li>否：no-store</li><li>是：<ul><li>是否进行协商缓存<ul><li>是：no-cache</li><li>否<ul><li>是否会被代理服务器缓存<ul><li>是：public</li><li>否：private<ul><li>配置强制缓存过期时间<ul><li>配置协商缓存的Etag或last-modified。</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="cdn缓存">CDN缓存<a class="hash-link" href="#cdn缓存" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="什么是cdn">什么是CDN？<a class="hash-link" href="#什么是cdn" title="标题的直接链接">​</a></h3><blockquote><p>CDN全称是内容分发网络，它是构建在现有网络基础上的虚拟智能网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、调度及内容分发等功能模块，使用户在请求所需访问的内容时能够就近获取，以此来降低网络拥塞，提高资源对用户的响应速度。</p></blockquote><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="不使用cdn的通信流程">不使用CDN的通信流程<a class="hash-link" href="#不使用cdn的通信流程" title="标题的直接链接">​</a></h3><ol><li>向传统的DNS服务器请求域名解析。</li><li>DNS服务器返回域名对应的服务器IP。</li><li>根据服务器IP请求服务器内容。</li><li>服务器返回响应资源。</li></ol><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="使用cdn的通信流程">使用CDN的通信流程<a class="hash-link" href="#使用cdn的通信流程" title="标题的直接链接">​</a></h3><ol><li>客户端向传统的DNS服务器请求域名解析。</li><li>传统的DNS服务器将域名解析权交给了CNAME指向的专用DNS服务器，所以对用户输入域名的解析最终是在CDN专用的DNS服务器上完成的。</li><li>CDN专用的DNS服务器将CDN负载均衡器的IP发给客户端。</li><li>浏览器会重新向CDN负载均衡器发起请求，经过对用户IP地址的距离、所请求资源内容的位置等的综合计算，返回给用户确定的缓存服务器IP地址。</li><li>浏览器最后对缓存服务器进行请求资源。</li></ol><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="静态资源适合使用cdn">静态资源适合使用CDN<a class="hash-link" href="#静态资源适合使用cdn" title="标题的直接链接">​</a></h3><blockquote><p>静态资源指的是不需要网站业务服务器参与计算即可得到的资源，包括第三方库的JavaScript脚本文件、样式表文件以及图片等，这些文件的特点是访问频率高、承载流量大、但更新频次低，且不与业务有太多耦合。</p></blockquote><blockquote><p>如果是动态资源文件，比如依赖服务器端渲染得到的HTML页面，它需要借助服务器端的数据进行计算才能得到，所以这样的资源不适合存放在CDN缓存服务器上。</p></blockquote><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="cdn的性能优化">CDN的性能优化<a class="hash-link" href="#cdn的性能优化" title="标题的直接链接">​</a></h3><blockquote><p>下面仅介绍一个CDN优化点：域名设置。</p></blockquote><blockquote><p>在淘宝的主页上，主站请求的域名为 <a href="http://www.taobao.com" target="_blank" rel="noopener noreferrer">www.taobao.com</a> ，而静态资源请求CDN服务器的域名有g.alicdn.com和img.alicdn.com两种，这样做的原因有以下两点：</p></blockquote><ol><li>避免对静态资源的请求携带不必要的cookie信息。</li><li>考虑浏览器对同一域名下并发请求的限制。</li></ol><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="面试常见问题">面试常见问题<a class="hash-link" href="#面试常见问题" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="问题1强缓存涉及到哪些请求头">问题1：强缓存涉及到哪些请求头？<a class="hash-link" href="#问题1强缓存涉及到哪些请求头" title="标题的直接链接">​</a></h3><blockquote><p>答：涉及到expires和cache-control两个字段，expires是HTTP1.0协议中的，cache-control是HTTP/1.1协议的。</p></blockquote><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="问题2为什么现在不用expries用cache-control">问题2：为什么现在不用expries用cache control？<a class="hash-link" href="#问题2为什么现在不用expries用cache-control" title="标题的直接链接">​</a></h3><blockquote><p>答：因为基于expires的强制缓存对本地时间戳过于依赖，如果客户端本地的时间与服务器端的时间不同步，那么对缓存过期的判断可能就会出错。cache-control通过maxage=xxx秒的形式来控制响应资源的有效期，如此可以避免服务器端和客户端时间戳不同步的问题。</p></blockquote><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="问题3强缓存public-private-no-store-no-catch区别cache-control有哪些属性分别表示什么意思">问题3：强缓存public private no-store no-catch区别？（Cache-Control有哪些属性?分别表示什么意思？）<a class="hash-link" href="#问题3强缓存public-private-no-store-no-catch区别cache-control有哪些属性分别表示什么意思" title="标题的直接链接">​</a></h3><blockquote><p>public：表示响应资源既可以被客户端缓存也可以被代理服务器缓存。
private：表示响应资源只能被浏览器缓存，如果没有显式指定则默认是private
no-store：表示禁止使用任何缓存，每次请求都需要服务器给与全新的响应。
no-cache：表示使用协商缓存。每次请求不再去判断强制缓存是否过期，而是直接向服务器发送请求来验证缓存的有效性。
max-age：表示服务器端告知客户端浏览器响应资源的过期时长。
s-maxage：表示缓存在代理服务器中的过期时长，且仅当设置了public属性值时才是有效的。</p></blockquote><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="问题4协商缓存的校验是在客户端还是服务器端协商缓存怎么验证是否命中">问题4：协商缓存的校验是在客户端还是服务器端？协商缓存怎么验证是否命中？<a class="hash-link" href="#问题4协商缓存的校验是在客户端还是服务器端协商缓存怎么验证是否命中" title="标题的直接链接">​</a></h3><blockquote><p>答：服务器端，服务器端会对比文件最后的修改时间和客户端请求携带的时间是否一致，一致则判断命中缓存。协商缓存存在两种形式，一种是基于last-modified，客户端第一次请求目标资源的时候，服务器返回的响应标头中包含last-modified和该资源的最后一次修改的时间戳，以及cache-control：no-cache，当客户端再次请求该资源的时候，会携带一个ifmodifiedsince字段，如果这个字段对应的时间和目标资源的时间戳进行对比，没有变化则返回304状态码。另一种是基于Etag的协商缓存，手下服务端将要返回给客户端的数据通过etag模块进行哈希计算生成一个字符串，这个字符串类似于文件指纹，检测客户端的请求标头中的ifNoneMatch字段的值和第一步计算的值是否一致，一致则返回304，不一致则返回最新的数据以及etag标头和Cache-Control：no-cache。</p></blockquote><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="问题5协商缓存出于什么原因有last-modifiedetag">问题5：协商缓存出于什么原因有Last-Modified,Etag?<a class="hash-link" href="#问题5协商缓存出于什么原因有last-modifiedetag" title="标题的直接链接">​</a></h3><blockquote><p>答：之所以有last-modified还有etag，是因为这二者均有自己的不足，last-modified是根据请求资源的最后修改时间戳来进行判断的，有可能只是对文件名进行了编辑，但是文件内容并未修改，这样时间戳也会更新，从而导致协商缓存判断失效，请求了已经存在的完整资源，这对网络带宽是一种浪费，也有可能是文件修改的速度是毫秒级别的，但是last-modified的单位是秒，可能无法识别出资源的修改。etag并非last-modified的完全替代方案，只能是一种补充方案，etag存在的问题是，服务器需要对文件资源进行etag计算，需要付出额外的计算开销，如果资源的尺寸比较大，生成Etag的过程可能会影响服务器的性能，所以这也就是为什么协商缓存既有last-modified又有etag的原因了。</p></blockquote><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="问题6协商缓存和强缓存的区别">问题6：协商缓存和强缓存的区别？<a class="hash-link" href="#问题6协商缓存和强缓存的区别" title="标题的直接链接">​</a></h3><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="相同点">相同点<a class="hash-link" href="#相同点" title="标题的直接链接">​</a></h4><blockquote><p>都是从客户端缓存中读取资源。</p></blockquote><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="不同点">不同点<a class="hash-link" href="#不同点" title="标题的直接链接">​</a></h4><ol><li>如果浏览器命中的是强缓存，则不需要给服务器发请求，而协商缓存最终由服务器来决定是否使用缓存，即客户端与服务器之间存在一次通信。</li><li>在chrome中命中缓存，返回的状态码是200，而如果是协商缓存，返回的是状态码304。</li></ol><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="问题7expires-和-cache-control-哪个优先级高-不缓存怎么设置">问题7：expires 和 cache-control 哪个优先级高? 不缓存怎么设置？<a class="hash-link" href="#问题7expires-和-cache-control-哪个优先级高-不缓存怎么设置" title="标题的直接链接">​</a></h3><blockquote><p>答：expires是HTTP/1.0的产物，Cache-Control则是HTTP/1.1的产物，二者如果同时存在的话，Cache-Control优先级比Expires高。不缓存则是通过Cache-Control：no-store设置。</p></blockquote><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="问题8lastmodified-对应有个请求头是什么">问题8：LastModified 对应有个请求头是什么？<a class="hash-link" href="#问题8lastmodified-对应有个请求头是什么" title="标题的直接链接">​</a></h3><blockquote><p>last-modified-since.</p></blockquote><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="问题9缓存的优先级顺序">问题9：缓存的优先级顺序？<a class="hash-link" href="#问题9缓存的优先级顺序" title="标题的直接链接">​</a></h3><blockquote><p>答：Cache-Control &gt; Expires &gt; Etag &gt; Last-Modified。</p></blockquote></div><footer class="row docusaurus-mt-lg blogPostFooterDetailsFull_mRVl"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/面试题">面试题</a></li></ul></div><div class="col margin-top--sm"><a href="https://git.7wate.com/zhouzhongping/wiki/src/branch/master/blog/一篇文章，彻底搞懂浏览器的缓存机制.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="博文分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/面试官让你使用CSS画一个圆，你会吗？"><div class="pagination-nav__sublabel">较新一篇</div><div class="pagination-nav__label">面试官让你使用CSS画一个圆，你会吗？</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/一道考查面试者CSS功底的面试题—实现CSS九宫格"><div class="pagination-nav__sublabel">较旧一篇</div><div class="pagination-nav__label">一道考查面试者CSS功底的面试题—实现CSS九宫格</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#为什么需要缓存" class="table-of-contents__link toc-highlight">为什么需要缓存？</a></li><li><a href="#缓存的原理" class="table-of-contents__link toc-highlight">缓存的原理</a></li><li><a href="#http缓存" class="table-of-contents__link toc-highlight">HTTP缓存</a><ul><li><a href="#强制缓存" class="table-of-contents__link toc-highlight">强制缓存</a></li><li><a href="#cache-control的其他参数" class="table-of-contents__link toc-highlight">Cache-Control的其他参数</a></li><li><a href="#协商缓存" class="table-of-contents__link toc-highlight">协商缓存</a></li></ul></li><li><a href="#缓存决策及其注意事项" class="table-of-contents__link toc-highlight">缓存决策及其注意事项</a><ul><li><a href="#缓存决策" class="table-of-contents__link toc-highlight">缓存决策</a></li><li><a href="#缓存决策树" class="table-of-contents__link toc-highlight">缓存决策树</a></li></ul></li><li><a href="#cdn缓存" class="table-of-contents__link toc-highlight">CDN缓存</a><ul><li><a href="#什么是cdn" class="table-of-contents__link toc-highlight">什么是CDN？</a></li><li><a href="#不使用cdn的通信流程" class="table-of-contents__link toc-highlight">不使用CDN的通信流程</a></li><li><a href="#使用cdn的通信流程" class="table-of-contents__link toc-highlight">使用CDN的通信流程</a></li><li><a href="#静态资源适合使用cdn" class="table-of-contents__link toc-highlight">静态资源适合使用CDN</a></li><li><a href="#cdn的性能优化" class="table-of-contents__link toc-highlight">CDN的性能优化</a></li></ul></li><li><a href="#面试常见问题" class="table-of-contents__link toc-highlight">面试常见问题</a><ul><li><a href="#问题1强缓存涉及到哪些请求头" class="table-of-contents__link toc-highlight">问题1：强缓存涉及到哪些请求头？</a></li><li><a href="#问题2为什么现在不用expries用cache-control" class="table-of-contents__link toc-highlight">问题2：为什么现在不用expries用cache control？</a></li><li><a href="#问题3强缓存public-private-no-store-no-catch区别cache-control有哪些属性分别表示什么意思" class="table-of-contents__link toc-highlight">问题3：强缓存public private no-store no-catch区别？（Cache-Control有哪些属性?分别表示什么意思？）</a></li><li><a href="#问题4协商缓存的校验是在客户端还是服务器端协商缓存怎么验证是否命中" class="table-of-contents__link toc-highlight">问题4：协商缓存的校验是在客户端还是服务器端？协商缓存怎么验证是否命中？</a></li><li><a href="#问题5协商缓存出于什么原因有last-modifiedetag" class="table-of-contents__link toc-highlight">问题5：协商缓存出于什么原因有Last-Modified,Etag?</a></li><li><a href="#问题6协商缓存和强缓存的区别" class="table-of-contents__link toc-highlight">问题6：协商缓存和强缓存的区别？</a></li><li><a href="#问题7expires-和-cache-control-哪个优先级高-不缓存怎么设置" class="table-of-contents__link toc-highlight">问题7：expires 和 cache-control 哪个优先级高? 不缓存怎么设置？</a></li><li><a href="#问题8lastmodified-对应有个请求头是什么" class="table-of-contents__link toc-highlight">问题8：LastModified 对应有个请求头是什么？</a></li><li><a href="#问题9缓存的优先级顺序" class="table-of-contents__link toc-highlight">问题9：缓存的优先级顺序？</a></li></ul></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 7Wate, Inc. Built with <a href="https://www.docusaurus.cn/" target="_blank" rel="noopener noreferrer">Docusaurus</a>.<br>Powered by <a href="https://webify.cloudbase.net/" target="_blank" rel="noopener noreferrer">CloudBase Webify</a></div></div></div></footer></div>
<script src="/assets/js/runtime~main.3f6835d1.js"></script>
<script src="/assets/js/main.0d220686.js"></script>
</body>
</html>