<!doctype html>
<html lang="zh-Hans" dir="ltr" class="blog-wrapper blog-tags-post-list-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.1">
<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-S4SD5NXWXF"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-S4SD5NXWXF",{anonymize_ip:!0})</script>


<link rel="search" type="application/opensearchdescription+xml" title="Faith&amp;Passion的小站" href="/opensearch.xml">
<link rel="preconnect" href="https://matomo.kuizuo.cn/">
<script>var _paq=window._paq=window._paq||[];_paq.push(["setRequestMethod","POST"]),_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),_paq.push(["enableHeartBeatTimer"]),function(){var e="https://matomo.kuizuo.cn/";_paq.push(["setRequestMethod","POST"]),_paq.push(["setTrackerUrl",e+"matomo.php"]),_paq.push(["setSiteId","1"]);var a=document,t=a.createElement("script"),p=a.getElementsByTagName("script")[0];t.type="text/javascript",t.async=!0,t.src=e+"matomo.js",p.parentNode.insertBefore(t,p)}()</script>


<script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?c9a3849aa75f9c4a4e65f846cd1a5155",e.defer=!0;var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script>
<meta name="baidu-site-verification" content="code-rqLUw5reVS">
<script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js",t.defer=!0;var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script>
<link rel="alternate" type="application/rss+xml" href="/rss.xml" title="Faith&amp;Passion RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Faith&amp;Passion Atom Feed">
<link rel="alternate" type="application/json" href="/feed.json" title="Faith&amp;Passion JSON Feed">

<link rel="icon" href="/img/logo.png">
<link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="rgb(51 139 255)"><title data-rh="true">5 篇博文 含有标签「HTTP」 - Faith&amp;Passion的小站</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://qq1120637483.github.io//img/logo.png"><meta data-rh="true" name="twitter:image" content="https://qq1120637483.github.io//img/logo.png"><meta data-rh="true" property="og:url" content="https://qq1120637483.github.io//tags/http"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="keywords" content="Faith&amp;Passion"><meta data-rh="true" name="keywords" content="blog, javascript, typescript, node, react, vue, web, 前端, 后端"><meta data-rh="true" property="og:title" content="5 篇博文 含有标签「HTTP」 - Faith&amp;Passion的小站"><meta data-rh="true" name="docusaurus_tag" content="blog_tags_posts"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_tags_posts"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://qq1120637483.github.io//tags/http"><link data-rh="true" rel="alternate" href="https://qq1120637483.github.io//tags/http" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://qq1120637483.github.io//tags/http" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://GV6YN1ODMO-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.40b05b18.css">
<link rel="preload" href="/assets/js/runtime~main.2be16868.js" as="script">
<link rel="preload" href="/assets/js/main.82cffc67.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.webp" alt="Passion" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.webp" alt="Passion" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Passion</b></a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">学习</a><ul class="dropdown__menu"><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/tags">标签</a></li><li><a class="dropdown__link" href="/archive">归档</a></li><li><a class="dropdown__link" href="/docs/skill/">笔记</a></li><li><a class="dropdown__link" href="/docs/tools/">工具推荐</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">工具</a><ul class="dropdown__menu"><li><a href="https://api.kuizuo.cn" target="_blank" rel="noopener noreferrer" class="dropdown__link">API服务</a></li></ul></div><a class="navbar__item navbar__link" href="/project">项目</a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_brwN thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_r4Q1 margin-bottom--md">Recent posts</div><ul class="sidebarItemList_QwSx clean-list"><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/查找字符串中最长的单词">查找字符串中最长的单词</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/JS模块化演变及其区别">JS模块化演变及其区别</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/你知道原型链？那你能实现一个new吗？">你知道原型链？那你能实现一个new吗？</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/Koa的洋葱模型到底是什么？">Koa的洋葱模型到底是什么？</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/OSI七层网络模型，你了解多少？">OSI七层网络模型，你了解多少？</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/Promise的异常捕获问题">Promise的异常捕获问题</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/Vue中的v-if和v-for为什么不能一起用？">Vue中的v-if和v-for为什么不能一起用？</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/for...in和for....of的区别是什么？">for...in和for....of的区别是什么？</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/这一次，彻底搞懂Vue中的keep-alive">这一次，彻底搞懂Vue中的keep-alive</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/LeetCode——简化路径（辅助栈）">LeetCode——简化路径（辅助栈）</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><header class="margin-bottom--xl"><h1>5 篇博文 含有标签「HTTP」</h1><a href="/tags">查看所有标签</a></header><article class="blogPost-container margin-bottom--lg" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 itemprop="headline"><a itemprop="url" class="titleLink_BX2g" href="/（最系统、最全面）这一次，彻底搞懂HTTP面试">（最系统、最全面）这一次，彻底搞懂HTTP面试</a></h2></header><div class="markdown" itemprop="articleBody"><blockquote><p>无论是大厂面试还是小厂面试，无论是社招还是校招，博主做了大量的统计分析，计算机网络中的HTTP协议相关的考点，几乎是必考的，让我们一起来学习这个知识吧。</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="一http2新特性">一、HTTP2新特性<a class="hash-link" href="#一http2新特性" title="标题的直接链接">​</a></h2><blockquote><p>首先，我们要明确HTTP2到底有哪些新特性。博主总结了多篇文章，HTTP2新特性主要围绕着下面六个方面。</p></blockquote><ol><li>二进制分帧</li><li>首部压缩</li><li>流量控制</li><li>多路复用</li><li>请求优先级</li><li>服务器推送</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="二进制分帧">二进制分帧<a class="hash-link" href="#二进制分帧" title="标题的直接链接">​</a></h3><blockquote><p>在介绍二进制分帧之前，首先介绍下什么是帧，但是介绍帧的时候，又不可避免的要介绍到消息和数据流的概念，为了便于大家的理解，博主还是决定对这些内容分别进行系统的介绍。</p></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="帧消息和数据流的关系">帧、消息和数据流的关系<a class="hash-link" href="#帧消息和数据流的关系" title="标题的直接链接">​</a></h4><ul><li>帧(frame)：可以理解为一个连续的消息流中的一个片段，是最小单位。</li><li>消息(message)：对应于HTTP1中的请求或者响应，包含一条或者多条message。</li><li>数据流(stream)：包含1条或者多条message。</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="http2突破http11协议性能限制的核心">HTTP2突破HTTP1.1协议性能限制的核心<a class="hash-link" href="#http2突破http11协议性能限制的核心" title="标题的直接链接">​</a></h4><blockquote><p>HTTP2所有性能增强的核心就在于应用层和传输层之间增加了一个二进制分帧层。</p></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="二进制分帧层原理">二进制分帧层原理<a class="hash-link" href="#二进制分帧层原理" title="标题的直接链接">​</a></h4><blockquote><p>二进制分帧层通过将所有传输的信息分割为更小的消息和帧，并采用二进制格式进行编码，其中，HTTP1.1中的首部信息header封装到Headers帧中，而request body则封装到Data帧中。HTTP2的通信都在一个TCP连接上完成，这个连接可以承载任意数量的双向数据流，相应的每个数据流以消息的形式发送，而消息由一个或多个帧组成，这些帧可以乱序发送，然后根据每个帧的首部流标识符重新组装。二进制分帧为HTTP2的其他特性提供了基础。</p></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="二进制帧的结构">二进制帧的结构<a class="hash-link" href="#二进制帧的结构" title="标题的直接链接">​</a></h4><blockquote><p>下图是二进制帧的结构图</p></blockquote><p><img loading="lazy" src="https://img-blog.csdnimg.cn/img_convert/6e0165e39fe7ab0b763dac676af2a3d8.png" alt="image.png" class="img_ev3q"></p><blockquote><p>HTTP2的二进制帧主要包括头部帧和数据帧，其中头部帧包括3个字节的帧长度，1字节的帧类型和1字节的标志位以及31bit的流标识符，接下来将详细介绍每一部分的作用。</p></blockquote><ul><li>帧长度：表示的是数据帧的长度。</li><li>帧类型：表示这个帧是数据帧还是控制帧。</li><li>标志位：用于携带简单的控制信息，例如通过标志位来表示流的优先级。</li><li>流标识符：用来表示这个帧属于哪个流的，接收方可以根据这个信息从乱序的帧里面找到相同流id的帧，从而有序的组装信息。</li><li>数据帧：存放的时经过HPACK算法压缩后的HTTP头部和数据体。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="首部压缩">首部压缩<a class="hash-link" href="#首部压缩" title="标题的直接链接">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="首部压缩的原理">首部压缩的原理<a class="hash-link" href="#首部压缩的原理" title="标题的直接链接">​</a></h4><blockquote><p>HTTP2使用HPACK算法压缩请求和响应标头的元数据，这种格式支持通过静态霍夫曼编码对传输的头部字段进行编码，从而减小了传输的大小，同时这种压缩算法要求客户端和服务器同时维护和更新一个首部表，这个首部表能够跟踪和存储之前发送过的键值对，对于相同的数据不再通过每次请求和响应进行发送，假如第一个请求发送了所有的头部字段，第二个请求则只需发送有差异的字段，这样可以减少冗余的数据，降低开销。HPACK主要包含两个压缩模块，索引表和静态霍夫曼编码，其中索引表又包含静态表和动态表。静态表包含61个预定义Header的Key value，传输的时候使用对应的索引Index替换。动态表是一个先进先出的队列，初始的时候是空的，解压header的时候按需添加，每次添加的时候放在队首，移除的时候从队尾开始，动态表的大小不是无限制的。</p></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="hpack算法">HPACK算法<a class="hash-link" href="#hpack算法" title="标题的直接链接">​</a></h4><blockquote><p>HPACK算法主要包括三个组成部分。</p></blockquote><ul><li>静态表</li><li>动态表</li><li>Huffman压缩算法</li></ul><blockquote><p>客户端和服务端都会建立和维护一张字典，主要目的时使用长度较小的索引号表示重复的头部字符串，再用Huffman编码压缩数据，可以达到较高的压缩率。</p></blockquote><blockquote><p>静态表：HTTP2为出现在头部的字符串和字段建立了一张静态表，它是写入到HTTP2客户端和服务器的代码中的，静态表里共有61组，例如，在静态表中GET方法的索引号是2，POST方法的索引号是3。静态表的索引表示的是头部名，value表示的是头部名对应的内容。</p></blockquote><blockquote><p>动态表：因为静态表只包含了61中高频出现在头部的字符串，不在静态表范围的头部字符串就需要我们自行构建动态表，这个动态表的索引从62起步，比如第一次发送user-agent，会将这个字符串对应的索引号，字符串和对应的数据经过霍夫曼编码后的二进制值发送给服务端，在第二次发送的时候，就不用重复发送这个字段的数据了，只用发送一个字节的索引号即可，因为双方都可以根据自己的动态表获取到该字段的值。这样避免了大量的冗余数据的传输，节约了带宽。</p></blockquote><blockquote><p>动态表会无限制扩大吗？答案是否定的，因为动态表越大占用的内存也就越大，是会影响服务器性能的，所以web服务器会提供相应的配置，避免动态表无限增大，达到上限后便会关闭HTTP2连接释放内存。</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="流量控制">流量控制<a class="hash-link" href="#流量控制" title="标题的直接链接">​</a></h3><blockquote><p>在HTTP2协议中，我们可以在同一个TCP连接中，建立多个数据流，这些数据流之间也是存在相互竞争的，因此也需要对流中的帧进行流量控制，但是只有流量帧受流量控制，而其他类型的帧不受流量控制，HTTP2通过使用WINDOW_UPDATE帧来提供流量控制。</p></blockquote><blockquote><p>HTTP2协议中的流量控制有以下几个特征：</p></blockquote><ul><li>流量控制基于HTTP连接的每一跳进行的，而非端到端的控制。（这里的每一跳指的是HTTP连接中间可能的代理服务器）</li><li>接收方公布自己打算在每个流以及整个连接上分别接收多少字节，这是一个以信用为基础的方案。</li><li>流量控制是有方向的，由接收者全面控制，接收方可以为每个流和整个连接设置任意的窗口大小，发送方必须尊重接收方设置的流量控制限制。</li><li>无论是新流还是整个连接，流量控制窗口的初始值是65535字节。</li><li>HTTP2只定义了WINDOW_UPDATE帧的格式和语义，并没有对通信双方如何实现进行约束。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="多路复用">多路复用<a class="hash-link" href="#多路复用" title="标题的直接链接">​</a></h3><blockquote><p>在HTTP1.1中，如果客户端想发送多个并行的请求，必须使用多个TCP连接，而HTTP2的二进制分帧层突破了这一限制，所有的请求和响应都在同一个TCP连接上完成，单个连接可以承载任意数量的双向数据流，数据流以消息的形式发送，消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为可以根据帧首部的流标识符进行重新组装。</p></blockquote><blockquote><p>上面的特性使得性能有了极大的性能提升，原因如下：</p></blockquote><ul><li>因为同一个域名只需要占用一个TCP连接，使用这个连接并行发送多个请求和响应，这样使得整个页面的资源的下载过程只需要一次慢启动，同时也避免了多个TCP连接带来的竞争问题。</li><li>可以并行交错的发送多个请求或响应，这些请求或响应之间互不影响。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="请求优先级">请求优先级<a class="hash-link" href="#请求优先级" title="标题的直接链接">​</a></h3><blockquote><p>HTTP2中每个流都可以带有一个31bit的优先值，0表示做高优先级，数值越大优先级越低，在一个TCP连接上，可以发送多个请求，并不等于说这些请求对于服务器来说都是一视同仁的，因为客户端对资源的需求不同，比如客户端对css和js的需求远大于对文档内图片的需求，所以每一个流的headers帧中可以带有一个优先级，服务端可以因此适当分配资源，优先发送优先级高的帧。服务端在使用请求优先级的时候要避免带来队头阻塞的问题。</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="服务器推送">服务器推送<a class="hash-link" href="#服务器推送" title="标题的直接链接">​</a></h3><blockquote><p>HTTP2改变了传统的请求应答模式，服务器不再完全被动地响应请求，也可以新建流主动向客户端发送消息，比如，浏览器刚请求HTML页面的时候，服务器可能会将主页内容，logo以及样式表都响应到客户端的缓存，当客户端需要这些资源的时候，这些资源已经在缓存中了，这样可以减少等待的延迟，不过只有建立连接后，服务器才可以推送资源，这种机制就是服务器推送。</p></blockquote><blockquote><p>服务器推送的特点：</p></blockquote><ul><li>针对每一个希望发送的资源，服务器会发送一个PUSH_PROMISE帧，当然客户端有权选择拒绝这个资源，通过RST_STREAM帧，这一步的操作先于父响应(index.html)，客户端了解到服务器端打算推送哪些资源，就不会为这些资源创建重复的请求，当客户端收到index.html的响应时，script.js和style.css已经存在于缓存中了。</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="二http2有什么缺点">二、HTTP2有什么缺点？<a class="hash-link" href="#二http2有什么缺点" title="标题的直接链接">​</a></h2><ol><li>TCP以及TCP+TLS建立连接的延时，HTTP2使用TCP协议来传输，而如果使用HTTPS还需要使用TLS协议进行安全传输，而使用TLS也需要一个握手的过程，这也会带来一些延时。</li><li>TCP的队头阻塞并没有彻底解决，在HTTP2中，多个请求是在一个TCP管道中的，当HTTP2出现丢包的时候，整个TCP都要开始等待重传，此时会阻塞该TCP连接中的所有请求。此时可能还不如HTTP1.1中的多个TCP连接效率高。队头阻塞分为TCP队头阻塞和HTTP队头阻塞，HTTP2解决的是HTTP队头阻塞，但是TCP的队头阻塞并未解决。因为HTTP是应用层协议，TCP是传输层协议。</li><li>多路复用导致服务器压力上升，多路复用由于没有限制同时请求数量，有可能出现短时间内请求数爆发的情况，会导致服务器压力上升。</li><li>多路复用容易超时，大批量的请求同时发送，但是网络的带宽和服务器的资源是有限的，此时可能会出现请求超时的情况。</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="http20多路复用在什么情况下效率不如11">HTTP2.0多路复用在什么情况下效率不如1.1？<a class="hash-link" href="#http20多路复用在什么情况下效率不如11" title="标题的直接链接">​</a></h3><blockquote><p>HTTP2.0在丢包的时候效率可能不如1.1，因为在出现丢包的情况下，整个TCP都要开始等待重传，也就导致后面的所有数据都被阻塞了，但是对于HTTP1.1来说，可以开启多个TCP连接，出现这种情况只会影响到其中一个连接，剩余的TCP连接还可以正常传输数据。</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="二进制分帧的根本目的是什么只是为了读取速度快吗">二进制分帧的根本目的是什么，只是为了读取速度快吗？<a class="hash-link" href="#二进制分帧的根本目的是什么只是为了读取速度快吗" title="标题的直接链接">​</a></h3><blockquote><p>二进制分帧的根本目的是为了更有效的利用底层TCP协议，同时也是HTTP2协议中的其他功能和性能优化的基础。</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="http2中的长连接相比于http1中手动指定keep-alive的优势原理">HTTP2中的长连接相比于http1中手动指定keep-alive的优势、原理<a class="hash-link" href="#http2中的长连接相比于http1中手动指定keep-alive的优势原理" title="标题的直接链接">​</a></h3><ol><li>HTTP1.X中的keep-alive必须按照请求发送的顺序返回响应，但是HTTP2多路复用可以不按顺序进行响应。</li><li>HTTP1.X中的keep-alive单个TCP连接在同一时刻只能处理一个请求，HTTP2单个TCP在同一时刻可以发送多个请求和响应。</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="三http30">三、HTTP3.0<a class="hash-link" href="#三http30" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么要有http30">为什么要有HTTP3.0？<a class="hash-link" href="#为什么要有http30" title="标题的直接链接">​</a></h3><blockquote><p>之所以要有HTTP3主要原因还在于上文提到的HTTP2存在的问题，这些问题的根源是底层支撑的TCP协议造成的。Google意识到这些问题之后，于是就提出了基于UDP协议的QUIC协议，让HTTP跑在QUIC上，而不是TCP上，这就是HTTP3，HTTP3解决了HTTP2存在的队头阻塞问题。</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="http3为什么选择udp">HTTP3为什么选择UDP？<a class="hash-link" href="#http3为什么选择udp" title="标题的直接链接">​</a></h3><blockquote><p>HTTP3选择UDP主要有以下一些原因：</p></blockquote><ul><li>基于TCP开发的设备和协议非常多，兼容起来困难。</li><li>TCP协议栈是Linux内部的重要部分，修改和升级成本很大。</li><li>UDP本身是无连接的、没有建链和拆链成本。</li><li>UDP的数据包无队头阻塞问题。</li><li>UDP改造成本小。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="http3新特性">HTTP3新特性<a class="hash-link" href="#http3新特性" title="标题的直接链接">​</a></h3><ol><li>多路复用，解决了TCP队头阻塞问题。</li></ol><blockquote><p>HTTP2.0协议的多路复用机制解决了HTTP层的队头阻塞问题，但是在TCP层仍然存在队头阻塞问题，如果基于TCP协议，会出现某个数据包丢失导致整个连接数据被阻塞。QUIC协议是基于UDP协议实现的，在一条链上可以有多个流，流与流之间是互不影响的，一个流的包发生丢包只需这个流的包进行重传，其他流的包不受影响，这样就解决了TCP存在的队头阻塞问题，同时QUIC协议在移动端的表现也比TCP好，因为TCP是基于IP和端口号去识别连接的，这种变化在多变的移动端网络环境下是很脆弱的，QUIC通过Id的方式去识别连接，不管网络环境如何变化，只要ID不变，就能迅速连上。</p></blockquote><ol start="2"><li>0RTT建链</li></ol><blockquote><p>RTT指的是数据包在网络中一来一回的时间消耗。RTT包括三部分：往返传播时延、网络设备内排队时延、应用程序数据处理时延。</p></blockquote><blockquote><p>一般来说HTTPS协议建立完整的链接需要TCP握手和TLS我受不，总计至少需要2-3个RTT，普通的HTTP协议也需要至少一个RTT才可以完成握手，然而QUIC协议可以实现在第一个包就包含有效的应用数据，从而实现0RTT，但是这是有前提条件的，对于第一次交互的客户端和服务端0RTT也是做不到的，因为双方需要进行1RTT的密钥交换，首次连接客户端对密钥信息进行了缓存，在缓存有效时间内，再次连接可以跳过这个1RTT，实现0RTT的数据交互。</p></blockquote><ol start="3"><li>前向纠错机制</li></ol><blockquote><p>QUIC协议的的每个数据包除了它本身的内容之外，还包括了部分其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传，向前纠错牺牲了每个数据包可以发送数据的上限，但是减少了因为丢包导致的数据重传，因为数据重传将会消耗更多的时间，假如要发送三个包，协议会计算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包，当非校验包丢失的时候，可以通过另外三个包计算出丢失的数据包的内容，当然这种技术只能使用在丢失一个包的情况，如果出现丢失多个包的情况，就只能使用重传机制了。</p></blockquote><ol start="4"><li>连接迁移</li></ol><blockquote><p>网络切换几乎无时无刻都在发生。TCP协议使用五元组来表示一条唯一的连接，当我们从4G环境切换到WiFi环境的时候，手机的IP地址会发生变化，此时就必须创建新的TCP连接才能继续传输数据。QUIC协议摒弃了五元组的概念，使用64位随机数作为连接的ID，并使用该ID表示连接，基于QUIC协议，在切换流量和WiFi的时候，不会出现重连的情况，提高了效率。</p></blockquote><ol start="5"><li>加密认证的报文</li></ol><blockquote><p>TCP协议头部没有经过任何加密和认证，所以在传输过程中很容易被中间网络设备篡改，注入和窃听，但是QUIC除了个别报文外，所有报文头部都是经过加密认证的。</p></blockquote><ol start="6"><li>实现了类似TCP的流量控制，传输可靠性的功能。</li></ol><blockquote><p>虽然UDP不提供可靠性的传输，但QUIC在UDP的基础上增加了一层来保证数据可靠性的可靠性传输，它提供了数据包重传，拥塞控制以及其他一些TCP中存在的特性。</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="四http0-http11-http20的区别">四、HTTP.0 HTTP1.1 HTTP2.0的区别<a class="hash-link" href="#四http0-http11-http20的区别" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="http10和http11之间的区别">HTTP1.0和HTTP1.1之间的区别<a class="hash-link" href="#http10和http11之间的区别" title="标题的直接链接">​</a></h3><ol><li>缓存处理</li></ol><blockquote><p>在HTTP1.0中主要是用header里面的If-Modified-Since，Expires作为缓存判断的标准，而HTTP1.1则引入了更多的缓存控制策略，例如Etag,If-Unmodified-Since,If-Match,If-None-Match等更多可供选择的缓存头来控制缓存策略。</p></blockquote><ol start="2"><li>带宽优化及网络连接的使用</li></ol><blockquote><p>在HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的某一部分，而服务器却将整个对象传送过来了，并且不支持断点续传功能。HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p></blockquote><ol start="3"><li>错误通知的管理</li></ol><blockquote><p>在HTTP1.1中新增了24个错误状态响应码，如409（Conflit）表示请求的资源和资源的当前状态发生冲突，410(Gone)表示服务器上的某个资源被永久的删除。</p></blockquote><ol start="4"><li>Host头处理</li></ol><blockquote><p>在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此请求消息中的URL并没有传递主机名Hostname,但是随着虚拟主机的发展，在一台物理服务器上可以存在多个虚拟主机，并且共享一个IP地址，HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误400 Bad Request。</p></blockquote><ol start="5"><li>长连接</li></ol><blockquote><p>HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection: keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="http20和http11之间的区别">HTTP2.0和HTTP1.1之间的区别<a class="hash-link" href="#http20和http11之间的区别" title="标题的直接链接">​</a></h3><ol><li>新的二进制格式</li></ol><blockquote><p>HTTP1.1的解析是基于文本的，基于文本协议的格式解析存在天然缺陷，二进制则不同，只有0和1的组合，基于这种考虑HTTP2.0的协议解析采用二进制格式，实现方便且健壮。</p></blockquote><ol start="2"><li>多路复用</li></ol><blockquote><p>关于这部分的介绍请看HTTP2.0新特性关于多路复用的介绍。</p></blockquote><ol start="3"><li>首部压缩</li></ol><blockquote><p>关于这部分的介绍请看HTTP2.0新特性关于首部压缩的介绍。</p></blockquote><ol start="4"><li>服务器推送</li></ol><blockquote><p>关于这部分的介绍请看HTTP2.0新特性关于服务器推送的介绍。</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="五keep-alive机制">五、Keep-Alive机制<a class="hash-link" href="#五keep-alive机制" title="标题的直接链接">​</a></h2><blockquote><p>说起keep-alive，我们首先要明确的是，有两种keepalive，一种是TCP的keepalive，另一种是HTTP的keep-alive。</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="tcp的keepalive">TCP的keepalive<a class="hash-link" href="#tcp的keepalive" title="标题的直接链接">​</a></h3><blockquote><p>TCP的keepalive存在的主要意义是保持客户端和服务端的连接，一方会不定期的发送心跳包给另一方，如果间隔发送几次，对方返回的都是RST，而不是ACK，那么就释放当前的连接，如果TCP层没有keepalive的机制，一旦一方断开连接却没有发送FIN给另外一方，那么另外一方会一直以为这个连接还存在，长时间的话，这对服务器的资源的影响是很大的。</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="http的keep-alive">HTTP的keep-alive<a class="hash-link" href="#http的keep-alive" title="标题的直接链接">​</a></h3><blockquote><p>HTTP层的keep-alive主要是为了复用TCP连接，HTTP服务的发起方一般都是浏览器，一般先执行完逻辑并传输完数据的一定是服务端，假如没有keep-alive机制的存在，服务端在传输完数据之后会首先断开连接，由于TCP的四次挥手的机制，先发起断开连接的一方会进入TIME_WAIT状态并等待2MSL的时间，客户端的每一次请求服务端都要消耗这个时间，但是服务器的资源是非常有限的，这对服务器端的消耗是巨大的，所以HTTP层的keep-alive是非常重要的。</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="二者区别">二者区别<a class="hash-link" href="#二者区别" title="标题的直接链接">​</a></h3><blockquote><p>TCP的keepalive是在ESTABLISHED状态，主要是用于检测连接的可用性，而TCP的keep-alive主要是为了进行TCP连接的复用，避免频繁的TCP三次握手和四次挥手的环节。</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="六http基本结构">六、HTTP基本结构<a class="hash-link" href="#六http基本结构" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="http协议在哪一层下面那一层是什么协议">HTTP协议在哪一层？下面那一层是什么协议？<a class="hash-link" href="#http协议在哪一层下面那一层是什么协议" title="标题的直接链接">​</a></h3><blockquote><p>HTTP协议在应用层，如果是TCP/IP四层网络模型的话，下一层是传输层，这一层一般是TCP/UDP协议。</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="http有哪些请求方法">HTTP有哪些请求方法？<a class="hash-link" href="#http有哪些请求方法" title="标题的直接链接">​</a></h3><blockquote><p>HTTP1.0定义了三种请求方法：GET、HEAD、POST方法。
HTTP1.1新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE和CONNECT方法。</p></blockquote><ul><li>GET：请求指定的页面信息，并返回实体主体。</li><li>HEAD：类似GET请求，只不过返回的响应中没有具体的内容，用于获取报头。</li><li>POST：向指定资源提交数据，例如提交表单。</li><li>PUT：通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定资源的内容。</li><li>DELETE：请求服务器删除指定的资源。</li><li>CONNECT：当浏览器配置为使用代理服务器时才会用到CONNECT方法。</li><li>OPTIONS：用于描述目标资源的通信选项，查看服务器支持哪些请求方法。</li><li>TRACE：沿着到目标资源的路径执行一个消息环回测试，可用于debug测试。</li><li>PATCH：对已知资源进行局部更新。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="http有哪些常见的请求头">HTTP有哪些常见的请求头？<a class="hash-link" href="#http有哪些常见的请求头" title="标题的直接链接">​</a></h3><blockquote><p>下面介绍一些常用的请求头。</p></blockquote><ul><li><p>Accept: 浏览器可以接受服务器返回的类型。</p></li><li><p>Accept-Encoding：浏览器申明自己能够处理的压缩或编码方法。</p></li><li><p>Accept-Language：用于浏览器声明自己接收的语言。</p></li><li><p>Connection</p><ul><li>Connection: keep-alive 当一个网页打开完成之后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。即TCP连接的复用。</li><li>Connection：close 代表一个Request完成之后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭，当客户端再次发送请求的时候，需要重新建立TCP连接。</li></ul></li><li><p>Host: 发送请求时，该报头域是必需的，主要用于指定被请求资源的主机和端口号。</p></li><li><p>Referer：这个字段主要是告诉服务器，该请求是从哪个页面链接过来的。</p></li><li><p>User-Agent：告诉服务器，客户端使用的操作系统和浏览器的名称和版本。</p></li><li><p>Cache-Control:</p><ul><li>private：告诉服务器响应只能作为私有缓存，不能再用户间共享。</li><li>public：响应可以被缓存并再多用户间共享</li><li>no-cache：使用协商缓存。</li><li>no-store：不缓存。</li></ul></li><li><p>cookie：用于存储一些用户信息以便让服务器辨别用户身份，例如cookie中可能会存储用户的id和密码，当用户登录后就会再客户端产生一个cookie来存储相关信息，这样浏览器通过读取cookie信息去服务器上验证并通过后可以认定是否是合法用户。</p></li><li><p>Range：用于断点续传，告知服务器自己想要获取对象的哪一部分。</p></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="http请求体的内容">HTTP请求体的内容<a class="hash-link" href="#http请求体的内容" title="标题的直接链接">​</a></h3><blockquote><p>HTTP的请求体一般有三种形式，例如：</p></blockquote><ul><li>application/json</li><li>text/xml</li><li>application/x-www-form-urlencoded</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="http的报文结构">HTTP的报文结构<a class="hash-link" href="#http的报文结构" title="标题的直接链接">​</a></h3><blockquote><p>HTTP的报文结构包括请求报文的报文结构和响应报文的报文结构。</p></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="请求报文的报文结构">请求报文的报文结构<a class="hash-link" href="#请求报文的报文结构" title="标题的直接链接">​</a></h4><ul><li>请求行：请求方法 + 请求URL + HTTP版本</li><li>请求头：字段名和对应的值</li><li>空行：请求头之后是一个空行，主要是告知服务器下面不在有请求头。</li><li>请求体：由用户自定义添加，例如post方法的body部分。</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="响应报文的报文结构">响应报文的报文结构<a class="hash-link" href="#响应报文的报文结构" title="标题的直接链接">​</a></h4><ul><li>状态行： HTTP版本 + 状态码 + 状态描述符（OK）</li><li>响应头：字段名 + 对应的值</li><li>空行</li><li>响应体</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是http劫持">什么是HTTP劫持？<a class="hash-link" href="#什么是http劫持" title="标题的直接链接">​</a></h3><blockquote><p>当用户的浏览器和目标服务器建立连接通道后，当浏览器发起HTTP请求后，运营商的路由器会首先收到这次HTTP请求，之后运营商路由器的旁路设备会将此TCP连接为HTTP协议，然后抢在网站服务器返回数据之前发送HTTP协议的302状态码进行劫持，浏览器以为是临时重定向，便跳转到目标URL上，旁路设备完成标记后会返回修改后的HTML代码，导致浏览器中被插入了运营商的广告，随后网站服务器的真正数据会被丢弃。</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="七http10存在的问题">七、HTTP1.0存在的问题<a class="hash-link" href="#七http10存在的问题" title="标题的直接链接">​</a></h2><blockquote><p>HTTP1.0主要存在以下几个问题：</p></blockquote><ol><li>无法复用连接，每次发送请求都需要进行一次TCP连接，而TCP的连接释放过程又是比较增加延时的，这样会使得网络带宽的利用率比较低。</li><li>存在队头阻塞的问题，一个请求必须在前一个请求响应到达之后才能发送。</li><li>不支持断点续传，也就是说每次都会传送全部的页面和数据。</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="八https加密原理">八、HTTPS加密原理<a class="hash-link" href="#八https加密原理" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么要有https">为什么要有HTTPS？<a class="hash-link" href="#为什么要有https" title="标题的直接链接">​</a></h3><blockquote><p>之所以要有HTTPS，是因为HTTP协议是一种不安全的传输协议，HTTP在传输数据的过程中，所有的数据都是明文传输，即使在前端通过一些加密算法进行加密后，服务端也是无法直接进行解密的。</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="对称加密和非对称加密">对称加密和非对称加密<a class="hash-link" href="#对称加密和非对称加密" title="标题的直接链接">​</a></h3><blockquote><p>HTTPS解决数据传输安全问题的方案就是使用加密算法，具体来说是对称加密和非对称加密的混合使用，下面我们先介绍下这两种加密算法的特点。</p></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="对称加密">对称加密<a class="hash-link" href="#对称加密" title="标题的直接链接">​</a></h4><blockquote><p>对称加密指的是加密和解密都用的同一个密钥，常用的对称加密算法有DES，AES等。</p></blockquote><ul><li>优点：算法公开，计算量小、加密速度快、加密效率高、适合对比较大的数据进行加密。</li><li>缺点：由于交易双方使用的是相同的密钥，所以无法避免密钥的传输，密钥在传输的过程中可能会被截获，用户每次使用对称加密算法，都需要使用其他人不知道的唯一密钥，这会使得双方所拥有的的钥匙数量急剧增长，密钥管理更加困难。</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="非对称加密">非对称加密<a class="hash-link" href="#非对称加密" title="标题的直接链接">​</a></h4><blockquote><p>非对称加密就是加密和解密使用两个不同的密钥：公钥和私钥。其中公钥和私钥是一堆，如果使用公钥对数据进行加密，只有用对应的私钥才能进行解密。如果使用私钥对数据进行加密，那么只有使用对应的公钥才能进行解密。非对称加密算法实现信息交换的基本过程是：客户端拿到服务器的公钥后，会生成一个随机KEY，然后使用公钥把这个KEY进行加密然后发送给服务器，服务器使用私钥将其解密，这样双方都拥有了同一个密钥KEY，然后就可以使用这个KEY进行对称加密交互数据，同时避免了KEY传输被拦截的情况，也就保证了加密数据的安全。</p></blockquote><ul><li>优点：算法公开，加密和解密使用的是不同的钥匙，私钥不需要通过网络进行传输，安全性很高。</li><li>缺点：计算量比较大，加密和解密速度相比对称机密慢很多。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="http和https之间的关系">HTTP和HTTPS之间的关系<a class="hash-link" href="#http和https之间的关系" title="标题的直接链接">​</a></h3><ul><li>HTTPS = HTTP + SSL/TLS</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="https的加密流程">HTTPS的加密流程<a class="hash-link" href="#https的加密流程" title="标题的直接链接">​</a></h3><blockquote><p>HTTPS的整个通信过程可以分为两大阶段，一是证书验证阶段，二是数据传输阶段，其中数据传输阶段又可以分为非对称加密和对称加密两个阶段。</p></blockquote><ol><li>客户端请求HTTPS的网址，然后连接到服务器的443端口。（HTTPS默认的端口是443，HTTP默认的端口是80）。</li><li>采用HTTPS协议的服务器必须要有一套由数字证书认证机构颁发的CA证书，颁发证书的同时会产生一个私钥和公钥，私钥是由服务端保存的，不可泄露，公钥则是附带在证书的信息中，可以公开的。证书本身也带有一个证书电子签名，这个签名是用来验证证书的完整性和真实性，可以防止证书被篡改。</li><li>服务器响应客户端请求，将证书传递给客户端，证书中包含公钥和大量其他信息，比如证书颁发机构信息、公司信息和证书有效期等，通过chrome浏览器点击地址栏的锁标志可以查看证书的详细信息。</li><li>客户端解析证书并对其进行验证，如果证书不是可信机构颁发的，或者证书中的域名和实际域名不一致，或者证书过期，就会对访问者显示警告信息，如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥A，然后客户端还会生成一个随机码KEY，并使用公钥A将其加密。</li><li>客户端把加密后的随机码KEY发送给服务器，作为后面对称加密的密钥。</li><li>服务器在收到密文后，会通过私钥解析出随机码KEY。</li><li>服务器使用上述步骤获取到的KEY，对数据进行对称加密并发送给客户端，客户端使用相同的KEY对数据进行解密。</li><li>然后双方使用对称加密传输完所有数据。</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="http和https的区别">HTTP和HTTPS的区别<a class="hash-link" href="#http和https的区别" title="标题的直接链接">​</a></h3><ol><li>安全性不同。HTTP明文传输，不对数据进行加密安全性较差，HTTPS的数据传输过程是加密的，安全性较好。</li><li>是否需要申请CA证书。HTTPS协议需要申请证书，HTTP协议不需要。</li><li>页面响应速度不同。HTTP页面响应速度比HTTPS快，因为HTTPS多了一层加密层，所以会影响速度。HTTP协议使用TCP三次握手建立连接，客户端和服务器交换需要三个包，而HTTPS除了TCP的三个包之外，还要加上ssl的九个包。</li><li>端口不同。HTTP默认的是80端口，HTTPS默认的是443端口。</li><li>消耗服务器资源不同。HTTPS是构建在SSL/TLS之上的HTTP协议，所以更加消耗服务器的资源。</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="https的缺点">HTTPS的缺点<a class="hash-link" href="#https的缺点" title="标题的直接链接">​</a></h3><ol><li>HTTPS协议握手阶段比较费时，会使页面的加载时间延长50%，增加10%到20%的耗电。</li><li>SSL证书需要一定的费用，功能越强大的证书费用较高。</li><li>HTTPS需要较高的服务器资源，会导致成本上升。</li><li>HTTPS协议的加密范围比较有限，某些国家如果能够控制CA根证书的情况下，中间人攻击也是可行的。</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="tls工作原理及详细握手过程">TLS工作原理及详细握手过程<a class="hash-link" href="#tls工作原理及详细握手过程" title="标题的直接链接">​</a></h3><blockquote><p>HTTPS相比于HTTP最大的不同就是多了一层SSL或TLS，SSL和TLS协议可以为通信双方提供识别和认证通道，从而保证了通信的机密性和数据完整性，不过目前SSL逐渐被TLS协议取代，因此下文主要对TLS进行介绍。TLS握手是启动HTTPS通信的过程，类似于TCP建立连接时的三次握手，在TLS握手的过程中，通信双方交换消息以相互验证，相互确认，并确立它们所使用的加密算法以及用于对称加密的密钥，所以TLS握手时HTTPS通信的基础部分。</p></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="tls握手的主要目的">TLS握手的主要目的<a class="hash-link" href="#tls握手的主要目的" title="标题的直接链接">​</a></h4><ol><li>协商双方通信所使用的TLS版本（例如TLS1.0还是1.2）。</li><li>确定双方要使用的密码组合。</li><li>客户端通过服务器的公钥和数字证书上的数字签名验证服务端的身份。</li><li>生成会话密钥，该密钥将用于握手结束后的对称加密。</li></ol><h4 class="anchor anchorWithStickyNavbar_LWe7" id="tls握手的详细过程重看-rsa-12-13">TLS握手的详细过程(重看 RSA 1.2 1.3)<a class="hash-link" href="#tls握手的详细过程重看-rsa-12-13" title="标题的直接链接">​</a></h4><blockquote><p>不同的密钥交换算法，TLS的握手过程有一些区别，当前TLS握手有三个版本，分别是RSA版本、TLS1.2和TLS1.3。</p></blockquote><blockquote><p>下面详细介绍下RSA版的TLS握手。传统的TLS握手基本都是使用RSA算法来实现密钥交换的。，接下来，我们对RSA版的TLS的每一次握手进行介绍。</p></blockquote><ul><li><p>第一次握手：客户端首先会发送一个Client Hello消息，这个消息中包含了客户端使用TLS版本号，支持的密码套件列表，以及客户端生成的随机数，这个随机数会被服务器端保留，是生成对称加密密钥的参数之一。</p></li><li><p>第二次握手：服务端收到客户端的Client Hello消息后，会确认TLS版本号是否支持，然后从客户端支持的密码套件列表中选择一个密码套件，然后生成服务端随机数，然后返回Server Hello消息，消息里面包含了服务器选择的TLS版本号，和服务端随机数，和服务端选择的密码套件，同时服务端还会将自己的数字证书发送给客户端。（客户端和服务端都会各自生成一个随机数，并且会把随机数传递给对方，这两个随机数是作为后续生成会话密钥的条件）</p></li><li><p>第三次握手：客户端验证完服务端的证书后，如果该证书是可信证书的话，客户端会生成一个随机数pre-master（预主密钥）,然后用服务器的RSA公钥加密该随机数（RSA公钥是从服务端发过来的数字证书中提取的），然后传递给服务端。服务端收到后，会用RSA私钥进行解密，得到客户端发过来的随机数pre-master，至此，客户端和服务端均拥有了三个随机数，分别是Client Random、Server Random、pre-master，双方会根据这三个随机数，生成会话密钥，它是对称密钥，用于对后续的HTTP请求和响应数据的加密和解密，生成完会话密钥之后，客户端会发送一个密码策略已经改变的报文给服务端，告诉服务端开始使用加密方式发送消息，然后客户端还会发送一个消息把之前所有发送的数据做一个摘要，然后使用会话密钥加密一下，让服务器做个验证，以验证之前的握手信息有没有被中途篡改过。</p></li><li><p>第四次握手：服务器也会进行同样的操作，发送一个密码策略已经改变的报文，然后也会把之前所有发送的数据做一个摘要，然后使用会话密钥加密之后，让客户端做一个验证，如果双方都验证加密和解密没有问题，那么握手正式完成，之后就会使用会话密钥来加解密HTTP请求和响应了。</p></li></ul><blockquote><p>RSA算法的缺陷</p></blockquote><blockquote><p>使用RSA密钥协商算法的最大问题是不支持前向保密，一旦服务端的私钥泄露了，过去第三方截获的所有TLS通讯密文都会被破解，于是有了基于ECDHE算法的TLS1.2,下面简要介绍下TLS1.2的握手过程。</p></blockquote><ul><li>第一次握手：客户端向服务端发送Client Hello，这个消息包含了客户端支持的TLS版本号，支持的密码套件列表以及客户端生成的随机数。</li><li>第二次握手：服务端收到后，会立即返回一个服务端随机数，与服务端选择的密码套件和包含公钥的数字证书，然后服务器将利用私钥将客户端随机数、服务端随机数、和服务端DH参数进行签名，生成服务器签名然后发送给客户端，同时发送这个服务端DH参数。</li><li>第三次握手：浏览器会先验证数字证书和服务器签名，通过后将客户端的DH参数传递给服务器。接着客户端通过ECDHE算法，利用客户端DH参数和服务端DH参数计算出预主密钥，有了预主密钥、客户端随机数和服务端随机数，客户端利用这三个计算出对称加密的主密钥。</li><li>第四次握手：服务端也使用ECDHE算法生成预主密钥，然后用相同的方法生成主密钥。当双方都验证通过之后，握手正式结束，后面开始正常收发加密的HTTP请求和响应了。</li></ul><blockquote><p>RSA和ECDHE握手过程的区别</p></blockquote><ul><li>RSA密钥协商算法不支持前向保密，ECDHE密钥协商算法不支持前向保密。</li><li>使用了RSA密钥协商的算法，TLS完成四次握手之后，才能进行应用数据的传输，而对于ECDHE算法，客户端可以不用等服务端的最后一次TLS握手，就可以提前发出加密的HTTP数据，节省了一个消息的往返时间。</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="八综合性面试题">八、综合性面试题<a class="hash-link" href="#八综合性面试题" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="https为什么既有对称加密也有非对称加密">HTTPS为什么既有对称加密也有非对称加密？<a class="hash-link" href="#https为什么既有对称加密也有非对称加密" title="标题的直接链接">​</a></h3><blockquote><p>对称加密的加解密使用的是用一个密钥，由于交易双方使用的是相同的密钥，无法避免密钥的传输，密钥在传输的过程中可能会被截获，但是对称加密的计算量较小，加密速度快，加密效率高。非对称加密采用的是公私钥的方式，私钥不在网络中传输，但是计算量比较大，效率不高。所以HTTPS利用这两者的优势，将两种方式结合起来，在交换密钥阶段使用非对称加密的方式，之后建立通信后，使用对称加密的方式。</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="客户端如何验证证书的有效性">客户端如何验证证书的有效性？<a class="hash-link" href="#客户端如何验证证书的有效性" title="标题的直接链接">​</a></h3><blockquote><p>一个数字证书通常包含了公钥、持有者信息、证书认证机构CA的信息、CA对这份文件的数字签名和使用的算法以及证书的有效期。数字证书的作用就是用来认证公钥持有者的身份，以防止第三方进行冒充，这个则行数是由CA证书认证机构签名的，这个CA证书认证机构是网络世界的认证中心，具有极高的可信度，所以由他签发的证书是可靠的。之所以要签名是为例防止中间人对证书进行篡改。</p></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="ca签发证书的过程">CA签发证书的过程<a class="hash-link" href="#ca签发证书的过程" title="标题的直接链接">​</a></h4><ul><li>首先CA会把持有者的公钥、用途、颁发者、有效时间等进行一个打包，然后进行Hash计算，得到一个Hash值。</li><li>然后CA会使用自己的私钥将该Hash值进行加密，生成一个证书签名。</li><li>将证书签名添加到文件证书上，形成数字证书。</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="客户端验证服务端数字证书的过程">客户端验证服务端数字证书的过程<a class="hash-link" href="#客户端验证服务端数字证书的过程" title="标题的直接链接">​</a></h4><ul><li>客户端使用相同的哈希算法获取该证书的哈希值。</li><li>一般情况下，用户的浏览器和操作系统中集成了CA的公钥信息，浏览器收到证书之后可以使用CA的公钥解密数字签名得到另一个哈希值。</li><li>浏览器比较两个哈希值，如果值相同，则认为这个证书是可信的，反之认定证书不可信。</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="https如何防止中间人攻击">HTTPS如何防止中间人攻击？<a class="hash-link" href="#https如何防止中间人攻击" title="标题的直接链接">​</a></h4><blockquote><p>关于HTTPS防止中间人攻击的方法，我们只需要从上文中的客户端如何验证证书的有效性来回答即可。</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="参考文献">参考文献<a class="hash-link" href="#参考文献" title="标题的直接链接">​</a></h2><blockquote><p>特别感谢以下博主的文章支持！</p></blockquote><ul><li><p><a href="https://segmentfault.com/a/1190000021494676" target="_blank" rel="noopener noreferrer">HTTPS 详解一：附带最精美详尽的 HTTPS 原理图</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/344086342" target="_blank" rel="noopener noreferrer">图解 HTTPS：RSA 握手过程</a></p></li><li><p><a href="https://www.cnblogs.com/xiaolincoding/p/14318338.html" target="_blank" rel="noopener noreferrer">图解 ECDHE 密钥交换算法</a></p></li></ul></div><hr class="divider_nSib"><div class="blogPostInfo_k7sy"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="user" class="svg-inline--fa fa-user blog__author" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" color="#c4d3e0" width="16" height="16"><path fill="currentColor" d="M224 256c70.7 0 128-57.3 128-128S294.7 0 224 0 96 57.3 96 128s57.3 128 128 128zm89.6 32h-16.7c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16h-16.7C60.2 288 0 348.2 0 422.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-41.6c0-74.2-60.2-134.4-134.4-134.4z"></path></svg><span class="blog__author"><a class="blogPostAuthor_OLeU">Justin</a></span><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="calendar" class="svg-inline--fa fa-calendar" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" color="#c4d3e0" width="16" height="16"><path fill="currentColor" d="M12 192h424c6.6 0 12 5.4 12 12v260c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V204c0-6.6 5.4-12 12-12zm436-44v-36c0-26.5-21.5-48-48-48h-48V12c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v52H160V12c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v52H48C21.5 64 0 85.5 0 112v36c0 6.6 5.4 12 12 12h424c6.6 0 12-5.4 12-12z"></path></svg><time datetime="2021-10-31T00:00:00.000Z" class="blogPostDate_Z606" itemprop="datePublished">2021年10月31日</time><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="tags" class="svg-inline--fa fa-tags" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512" color="#c4d3e0" width="16" height="16"><path fill="currentColor" d="M497.941 225.941L286.059 14.059A48 48 0 0 0 252.118 0H48C21.49 0 0 21.49 0 48v204.118a48 48 0 0 0 14.059 33.941l211.882 211.882c18.744 18.745 49.136 18.746 67.882 0l204.118-204.118c18.745-18.745 18.745-49.137 0-67.882zM112 160c-26.51 0-48-21.49-48-48s21.49-48 48-48 48 21.49 48 48-21.49 48-48 48zm513.941 133.823L421.823 497.941c-18.745 18.745-49.137 18.745-67.882 0l-.36-.36L527.64 323.522c16.999-16.999 26.36-39.6 26.36-63.64s-9.362-46.641-26.36-63.64L331.397 0h48.721a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882z"></path></svg><span class="blogPostInfoTags_W9UY"><a class="tag_zVej tagRegular_sFm0" href="/tags/http">HTTP</a></span><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="clock" class="svg-inline--fa fa-clock blog__readingTime" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" color="#c4d3e0" width="16" height="16"><path fill="currentColor" d="M256,8C119,8,8,119,8,256S119,504,256,504,504,393,504,256,393,8,256,8Zm92.49,313h0l-20,25a16,16,0,0,1-22.49,2.5h0l-67-49.72a40,40,0,0,1-15-31.23V112a16,16,0,0,1,16-16h32a16,16,0,0,1,16,16V256l58,42.5A16,16,0,0,1,348.49,321Z"></path></svg><span class="blogPostReadTime_AZ1H blog__readingTime">阅读需 35 分钟</span></div></article><article class="blogPost-container margin-bottom--lg" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 itemprop="headline"><a itemprop="url" class="titleLink_BX2g" href="/压缩HTTP请求和响应数据的方法">压缩HTTP请求和响应数据的方法</a></h2></header><div class="markdown" itemprop="articleBody"><blockquote><p>在客户端和浏览器进行信息交互的时候，如果直接传输文件，可能会消耗太多的流量，通过压缩技术可以为我们节省很多流量，下面来介绍下HTTP响应数据是如何进行压缩的。</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="http响应数据压缩">HTTP响应数据压缩<a class="hash-link" href="#http响应数据压缩" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="使用gzip压缩文本">使用Gzip压缩文本<a class="hash-link" href="#使用gzip压缩文本" title="标题的直接链接">​</a></h3><blockquote><p>浏览器和服务器之间会使用主动协商机制，浏览器向服务器发送请求的时候，其请求标头中会含有Accept-Encoding字段，其中包含了客户端支持的压缩算法，以及各自的优先级，服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送Content-Encoding首部来告知浏览器它选择了哪一种压缩算法。</p></blockquote><ul><li>客户端请求标头实例</li></ul><p><img loading="lazy" src="https://img-blog.csdnimg.cn/img_convert/170f3bab09835a36465cccc4a2089783.png" class="img_ev3q"></p><ul><li>服务器端响应标头实例</li></ul><p><img loading="lazy" src="https://img-blog.csdnimg.cn/img_convert/8a8f9edf06e23314e9486b64dd89d342.png" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="http请求数据的压缩">HTTP请求数据的压缩<a class="hash-link" href="#http请求数据的压缩" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="头部数据压缩">头部数据压缩<a class="hash-link" href="#头部数据压缩" title="标题的直接链接">​</a></h3><blockquote><p>HTTP协议是不支持头信息压缩的，但是HTTP2引入了头信息压缩机制，一方面，头信息可以使用gzip或compress压缩后再发送，另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号。</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="请求体数据压缩">请求体数据压缩<a class="hash-link" href="#请求体数据压缩" title="标题的直接链接">​</a></h3><blockquote><p>上文中，我们提到了HTTP协议中的Accept-Encoding/Content-Encoding机制，这套机制可以很好地用于文本类响应正文地压缩，可以大幅度地减少网络传输，从而一直被广泛使用，但HTTP请求地发起方，无法事先知晓要访问地服务端是否支持解压，所以现阶段地浏览器没有压缩请求正文。</p></blockquote><blockquote><p>有一些通讯协议基于HTTP做了拓展，他们地客户端和服务端是专用地，可以放心大胆地压缩请求正文，例如WebDAV客户端就是这样地。</p></blockquote><blockquote><p>实际地Web项目中，会存在请求正文非常大的场景，例如发表长篇博客，上报用于调试的网络数据等待，这些数据如果能在本地压缩后再提交，就可以节省网络流量、减少传输时间。下面将介绍如何对HTTP请求正文进行压缩，包含如何再服务端解压、如何在客户端压缩两部分。</p></blockquote><blockquote><p>下面是三种常见的文本压缩方式</p></blockquote><ol><li>DEFLATE</li><li>ZLIB</li><li>GZIP</li></ol></div><hr class="divider_nSib"><div class="blogPostInfo_k7sy"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="user" class="svg-inline--fa fa-user blog__author" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" color="#c4d3e0" width="16" height="16"><path fill="currentColor" d="M224 256c70.7 0 128-57.3 128-128S294.7 0 224 0 96 57.3 96 128s57.3 128 128 128zm89.6 32h-16.7c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16h-16.7C60.2 288 0 348.2 0 422.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-41.6c0-74.2-60.2-134.4-134.4-134.4z"></path></svg><span class="blog__author"><a class="blogPostAuthor_OLeU">Justin</a></span><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="calendar" class="svg-inline--fa fa-calendar" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" color="#c4d3e0" width="16" height="16"><path fill="currentColor" d="M12 192h424c6.6 0 12 5.4 12 12v260c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V204c0-6.6 5.4-12 12-12zm436-44v-36c0-26.5-21.5-48-48-48h-48V12c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v52H160V12c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v52H48C21.5 64 0 85.5 0 112v36c0 6.6 5.4 12 12 12h424c6.6 0 12-5.4 12-12z"></path></svg><time datetime="2021-10-03T00:00:00.000Z" class="blogPostDate_Z606" itemprop="datePublished">2021年10月3日</time><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="tags" class="svg-inline--fa fa-tags" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512" color="#c4d3e0" width="16" height="16"><path fill="currentColor" d="M497.941 225.941L286.059 14.059A48 48 0 0 0 252.118 0H48C21.49 0 0 21.49 0 48v204.118a48 48 0 0 0 14.059 33.941l211.882 211.882c18.744 18.745 49.136 18.746 67.882 0l204.118-204.118c18.745-18.745 18.745-49.137 0-67.882zM112 160c-26.51 0-48-21.49-48-48s21.49-48 48-48 48 21.49 48 48-21.49 48-48 48zm513.941 133.823L421.823 497.941c-18.745 18.745-49.137 18.745-67.882 0l-.36-.36L527.64 323.522c16.999-16.999 26.36-39.6 26.36-63.64s-9.362-46.641-26.36-63.64L331.397 0h48.721a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882z"></path></svg><span class="blogPostInfoTags_W9UY"><a class="tag_zVej tagRegular_sFm0" href="/tags/http">HTTP</a></span><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="clock" class="svg-inline--fa fa-clock blog__readingTime" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" color="#c4d3e0" width="16" height="16"><path fill="currentColor" d="M256,8C119,8,8,119,8,256S119,504,256,504,504,393,504,256,393,8,256,8Zm92.49,313h0l-20,25a16,16,0,0,1-22.49,2.5h0l-67-49.72a40,40,0,0,1-15-31.23V112a16,16,0,0,1,16-16h32a16,16,0,0,1,16,16V256l58,42.5A16,16,0,0,1,348.49,321Z"></path></svg><span class="blogPostReadTime_AZ1H blog__readingTime">阅读需 3 分钟</span></div></article><article class="blogPost-container margin-bottom--lg" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 itemprop="headline"><a itemprop="url" class="titleLink_BX2g" href="/你了解HTTP长连接吗？">你了解HTTP长连接吗？</a></h2></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithStickyNavbar_LWe7" id="长连接出现的前夜">长连接出现的前夜<a class="hash-link" href="#长连接出现的前夜" title="标题的直接链接">​</a></h2><blockquote><p>在了解长连接之前，我们先看看与之对应的短连接是什么？在HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。</p></blockquote><blockquote><p>早前的通信情况来看，因为都是些容量很小的文本传输，所以没有太大的问题，但是随着HTTP传输文档中包含大量的富文本，比如使用浏览器浏览一个包含多张图片的HTML页面的时候，在发送请求访问HTML页面资源的同时，也会请求该HTML页面包含的其他资源，因此，每次的请求都会造成无谓的TCP连接的建立和断开，增大了开销。</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="keep-alive字段">keep-alive字段<a class="hash-link" href="#keep-alive字段" title="标题的直接链接">​</a></h2><blockquote><p>为了解决上面的问题，有些浏览器在请求的时候，使用了一个非标准的Connection字段。</p></blockquote><div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#000000;--prism-background-color:#ffffff"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#000000"><span class="token plain">Connection: keep-alive</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><blockquote><p>上面的字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。</p></blockquote><div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#000000;--prism-background-color:#ffffff"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#000000"><span class="token plain">Connection: keep-alive</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><blockquote><p>这样一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接，但是这不是标准的字段，不同实现的行为可能不一致，因此不是根本的解决办法。</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="长连接出现了">长连接出现了<a class="hash-link" href="#长连接出现了" title="标题的直接链接">​</a></h2><blockquote><p>1997年1月，HTTP/1.1版本发布了，它进一步完善了HTTP协议，直到现在还是最流行的版本。</p></blockquote><blockquote><p>HTTP/1.1版的最大变化就是引入了持久连接（HTTP Persistent Connections），即TCP默认连接不关闭，可以被多个请求复用，不用声明keep-alive字段。</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="持久连接的好处">持久连接的好处<a class="hash-link" href="#持久连接的好处" title="标题的直接链接">​</a></h3><ul><li>减少了TCP连接的重复建立和断开造成的额外开销，减轻了服务器端的负载。</li><li>使得HTTP请求和响应能够更早的结束，这样web页面的显示速度也就对应的提高了。</li></ul><blockquote><p>客户端和服务器端发现对方一段时间内没有活动，就可以主动关闭连接。不过规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。</p></blockquote><div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#000000;--prism-background-color:#ffffff"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#000000"><span class="token plain">Connection: close</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><blockquote><p>目前，对同一个域名，大多数浏览器允许同时建立6个持久连接。</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="管道机制">管道机制<a class="hash-link" href="#管道机制" title="标题的直接链接">​</a></h2><blockquote><p>注意：管道机制是基于持久连接的</p></blockquote><blockquote><p>HTTP/1.1版还引入了管道机制，即在同一个TCP连接里面，客户端可以同时发送多个请求，这样就进一步改进了HTTP协议的效率，以前发送请求后需要等待并接收响应，才能发送下一个请求。管线化技术出现后，不用等待响应即可直接发送下一个请求，这样就能够做到同时并行发送多个请求，而不需要一个接一个的等待响应了，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术则比持久连接要快的多，请求数越多，时间差就越明显。</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="案例">案例<a class="hash-link" href="#案例" title="标题的直接链接">​</a></h3><blockquote><p>假如一个客户端需要请求两个资源，以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出相应，收到后再发出B请求，管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求再回应B请求。</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="content-length字段">Content-Length字段<a class="hash-link" href="#content-length字段" title="标题的直接链接">​</a></h2><blockquote><p>一个TCP连接可以传回多个响应，势必就要有一种机制，区分数据包是属于哪一个响应的，这就是Content-Length字段的作用，声明本次回应的数据长度。</p></blockquote><div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#000000;--prism-background-color:#ffffff"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#000000"><span class="token plain">Content-Length: </span><span class="token number" style="color:rgb(9, 134, 88)">3495</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><blockquote><p>上面的代码告诉浏览器，本次响应的长度是3495个字节，后面的字节就属于下一个回应了。在1.0版本中,Content-Length字段不是必须的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="分块传输编码">分块传输编码<a class="hash-link" href="#分块传输编码" title="标题的直接链接">​</a></h2><blockquote><p>使用Content-Length字段的前提条件是，服务器发送响应之前，必须知道响应的数据长度，对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，这样的效率不行，更好的处理方法是，产生一块数据，就发送一块，采用流模式代替缓存模式。</p></blockquote><blockquote><p>因此，1.1版本规定可以不使用Content-Length字段，而是使用分块传输编码，只要请求或响应的头信息中有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。</p></blockquote><div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#000000;--prism-background-color:#ffffff"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#000000"><span class="token plain">Transfer-Encoding: chunked</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><blockquote><p>每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度，最后是一个大小为0的块，就表示本次回应的数据发送完了。</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="长连接带来的问题">长连接带来的问题<a class="hash-link" href="#长连接带来的问题" title="标题的直接链接">​</a></h2><blockquote><p>虽然HTTP1.1版本允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按照次序进行的，所以服务器只有处理完一个响应，才会进行下一个响应，如果前面的响应特别慢，后面就会有许多请求排队等待着，这就称之为队头阻塞。</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何避免">如何避免？<a class="hash-link" href="#如何避免" title="标题的直接链接">​</a></h3><ol><li>减少请求数。</li><li>同时多开持久连接。</li></ol></div><hr class="divider_nSib"><div class="blogPostInfo_k7sy"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="user" class="svg-inline--fa fa-user blog__author" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" color="#c4d3e0" width="16" height="16"><path fill="currentColor" d="M224 256c70.7 0 128-57.3 128-128S294.7 0 224 0 96 57.3 96 128s57.3 128 128 128zm89.6 32h-16.7c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16h-16.7C60.2 288 0 348.2 0 422.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-41.6c0-74.2-60.2-134.4-134.4-134.4z"></path></svg><span class="blog__author"><a class="blogPostAuthor_OLeU">Justin</a></span><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="calendar" class="svg-inline--fa fa-calendar" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" color="#c4d3e0" width="16" height="16"><path fill="currentColor" d="M12 192h424c6.6 0 12 5.4 12 12v260c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V204c0-6.6 5.4-12 12-12zm436-44v-36c0-26.5-21.5-48-48-48h-48V12c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v52H160V12c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v52H48C21.5 64 0 85.5 0 112v36c0 6.6 5.4 12 12 12h424c6.6 0 12-5.4 12-12z"></path></svg><time datetime="2021-09-28T00:00:00.000Z" class="blogPostDate_Z606" itemprop="datePublished">2021年9月28日</time><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="tags" class="svg-inline--fa fa-tags" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512" color="#c4d3e0" width="16" height="16"><path fill="currentColor" d="M497.941 225.941L286.059 14.059A48 48 0 0 0 252.118 0H48C21.49 0 0 21.49 0 48v204.118a48 48 0 0 0 14.059 33.941l211.882 211.882c18.744 18.745 49.136 18.746 67.882 0l204.118-204.118c18.745-18.745 18.745-49.137 0-67.882zM112 160c-26.51 0-48-21.49-48-48s21.49-48 48-48 48 21.49 48 48-21.49 48-48 48zm513.941 133.823L421.823 497.941c-18.745 18.745-49.137 18.745-67.882 0l-.36-.36L527.64 323.522c16.999-16.999 26.36-39.6 26.36-63.64s-9.362-46.641-26.36-63.64L331.397 0h48.721a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882z"></path></svg><span class="blogPostInfoTags_W9UY"><a class="tag_zVej tagRegular_sFm0" href="/tags/http">HTTP</a></span><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="clock" class="svg-inline--fa fa-clock blog__readingTime" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" color="#c4d3e0" width="16" height="16"><path fill="currentColor" d="M256,8C119,8,8,119,8,256S119,504,256,504,504,393,504,256,393,8,256,8Zm92.49,313h0l-20,25a16,16,0,0,1-22.49,2.5h0l-67-49.72a40,40,0,0,1-15-31.23V112a16,16,0,0,1,16-16h32a16,16,0,0,1,16,16V256l58,42.5A16,16,0,0,1,348.49,321Z"></path></svg><span class="blogPostReadTime_AZ1H blog__readingTime">阅读需 5 分钟</span></div></article><article class="blogPost-container margin-bottom--lg" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 itemprop="headline"><a itemprop="url" class="titleLink_BX2g" href="/优化HTTP请求和响应的方法">优化HTTP请求和响应的方法</a></h2></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithStickyNavbar_LWe7" id="为什么要进行请求和响应的优化">为什么要进行请求和响应的优化？<a class="hash-link" href="#为什么要进行请求和响应的优化" title="标题的直接链接">​</a></h2><blockquote><p>核心目的：更快的获取到内容。</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="核心思路">核心思路<a class="hash-link" href="#核心思路" title="标题的直接链接">​</a></h2><ol><li>更好的连接传输效率。</li><li>更少的请求数量。</li><li>更小的资源大小。</li><li>合适的缓存策略。</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="最佳实践">最佳实践<a class="hash-link" href="#最佳实践" title="标题的直接链接">​</a></h2><ol><li><strong>减少DNS查找</strong>：每次主机名的解析都需要一次网络往返，从而增加了请求的延迟时间，同时还会阻塞后续的请求。</li><li><strong>重用TCP连接</strong>：尽可能的使用持久连接，以消除因TCP握手和慢启动导致的延迟。</li><li><strong>减少HTTP重定向</strong>：HTTP重定向需要额外的DNS查询，TCP握手等非常耗时，最佳的重定向次数为0。</li><li><strong>压缩传输的资源</strong>：比如Gzip、图片缓存。</li><li><strong>使用缓存</strong>：比如HTTP缓存、CDN缓存、Service Worker缓存。</li><li><strong>使用CDN内容分发网络</strong>：把数据放在里用户地理位置更近的地方，可以明显减少每次TCP连接的网络延迟，增大吞吐量。</li><li><strong>删除没有必要请求的资源</strong>。</li><li><strong>在客户端缓存资源</strong>：缓存必要的应用资源，避免每次都重复请求相同的内容，例如多图片下载可以考虑使用缓存。</li><li><strong>内容在传输前先压缩</strong>：传输数据之前应该先压缩应用资源，把要传输的字节减少到最小，在压缩的时候确保对每种不同的资源采用最好的压缩手段。</li><li><strong>消除不必要的请求开销</strong>：减少请求的HTTP首部数据（比如HTTP Cooki）</li><li><strong>并行处理请求和响应</strong>：请求和响应的排队都会导致延迟，可以尝试并行的处理请求和响应（利用多个HTTP1.1连接实现并行下载，在可能的情况下使用HTTP管道计数）。</li><li><strong>针对协议版本采取优化措施</strong>：例如升级到HTTP2.0。</li><li><strong>根据需要采用服务端渲染方式</strong>：这种方式可以解决SPA应用首屏渲染慢的问题。</li><li><strong>采用预渲染的方式加速静态页面</strong>：页面渲染的极致性能，比较适合静态页面。</li></ol></div><hr class="divider_nSib"><div class="blogPostInfo_k7sy"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="user" class="svg-inline--fa fa-user blog__author" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" color="#c4d3e0" width="16" height="16"><path fill="currentColor" d="M224 256c70.7 0 128-57.3 128-128S294.7 0 224 0 96 57.3 96 128s57.3 128 128 128zm89.6 32h-16.7c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16h-16.7C60.2 288 0 348.2 0 422.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-41.6c0-74.2-60.2-134.4-134.4-134.4z"></path></svg><span class="blog__author"><a class="blogPostAuthor_OLeU">Justin</a></span><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="calendar" class="svg-inline--fa fa-calendar" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" color="#c4d3e0" width="16" height="16"><path fill="currentColor" d="M12 192h424c6.6 0 12 5.4 12 12v260c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V204c0-6.6 5.4-12 12-12zm436-44v-36c0-26.5-21.5-48-48-48h-48V12c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v52H160V12c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v52H48C21.5 64 0 85.5 0 112v36c0 6.6 5.4 12 12 12h424c6.6 0 12-5.4 12-12z"></path></svg><time datetime="2021-09-22T00:00:00.000Z" class="blogPostDate_Z606" itemprop="datePublished">2021年9月22日</time><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="tags" class="svg-inline--fa fa-tags" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512" color="#c4d3e0" width="16" height="16"><path fill="currentColor" d="M497.941 225.941L286.059 14.059A48 48 0 0 0 252.118 0H48C21.49 0 0 21.49 0 48v204.118a48 48 0 0 0 14.059 33.941l211.882 211.882c18.744 18.745 49.136 18.746 67.882 0l204.118-204.118c18.745-18.745 18.745-49.137 0-67.882zM112 160c-26.51 0-48-21.49-48-48s21.49-48 48-48 48 21.49 48 48-21.49 48-48 48zm513.941 133.823L421.823 497.941c-18.745 18.745-49.137 18.745-67.882 0l-.36-.36L527.64 323.522c16.999-16.999 26.36-39.6 26.36-63.64s-9.362-46.641-26.36-63.64L331.397 0h48.721a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882z"></path></svg><span class="blogPostInfoTags_W9UY"><a class="tag_zVej tagRegular_sFm0" href="/tags/http">HTTP</a></span><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="clock" class="svg-inline--fa fa-clock blog__readingTime" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" color="#c4d3e0" width="16" height="16"><path fill="currentColor" d="M256,8C119,8,8,119,8,256S119,504,256,504,504,393,504,256,393,8,256,8Zm92.49,313h0l-20,25a16,16,0,0,1-22.49,2.5h0l-67-49.72a40,40,0,0,1-15-31.23V112a16,16,0,0,1,16-16h32a16,16,0,0,1,16,16V256l58,42.5A16,16,0,0,1,348.49,321Z"></path></svg><span class="blogPostReadTime_AZ1H blog__readingTime">阅读需 2 分钟</span></div></article><article class="blogPost-container margin-bottom--lg" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 itemprop="headline"><a itemprop="url" class="titleLink_BX2g" href="/HTTP协议中的常用状态码">HTTP协议中的常用状态码</a></h2></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithStickyNavbar_LWe7" id="一设置状态码的意义">一、设置状态码的意义<a class="hash-link" href="#一设置状态码的意义" title="标题的直接链接">​</a></h2><blockquote><p>HTTP协议是在web浏览器和服务器之间进行传递信息的协议，HTTP协议中设置状态码的意义在于，服务器端通过状态码来高速浏览器端，当前的网页请求发生了什么以及当前WEB服务器的相应状态，HTTP状态码可以用来判断当前服务器端的的运行状况以及浏览器端网页的请求情况。</p></blockquote><hr><h2 class="anchor anchorWithStickyNavbar_LWe7" id="二常用的http状态码分类">二、常用的HTTP状态码分类<a class="hash-link" href="#二常用的http状态码分类" title="标题的直接链接">​</a></h2><ol><li><strong>1XX (服务器端接收请求，正在处理)</strong></li></ol><ul><li>场景介绍：假如浏览器端想给服务器发送一个较大的文件，如果服务器端给浏览器端返回的是1XX的状态码，则表示服务器端已经接收到了请求，正在处理。</li></ul><ol start="2"><li><strong>2XX（请求成功）</strong></li></ol><ul><li>场景介绍：服务器端接收到了请求，并进行了处理。</li></ul><ol start="3"><li><strong>3XX（重定向状态码）</strong></li></ol><ul><li>场景介绍：这个状态码表示服务器端认为浏览器端需要采取进一步的操作才能完成请求，重定向的目标在本次响应的Location域中。</li></ul><ol start="4"><li><strong>4XX（浏览器端/客户端错误）</strong></li></ol><ul><li>场景介绍：这类状态码代表着浏览器端可能发生了错误，妨碍了服务器的处理。</li></ul><ol start="5"><li><strong>5XX（服务器端错误）</strong></li></ol><ul><li>场景介绍：这类状态码表示服务器在处理请求的时候出现了错误，或者异常。</li></ul><hr><h2 class="anchor anchorWithStickyNavbar_LWe7" id="三常见状态码含义">三、常见状态码含义<a class="hash-link" href="#三常见状态码含义" title="标题的直接链接">​</a></h2><ul><li><strong>100</strong>：这是一个临时响应，表示服务器端已经接受部分请求，客户端应该继续发送请求的剩余部分。</li><li><strong>200</strong>：服务器端已经成功收到并处理了请求。</li><li><strong>204</strong>：服务器端成功处理，但是并未返回内容</li><li><strong>301</strong>：永久重定向，请求的资源已经被永久的移动到了新的URL，返回的信息会包括新的URL，浏览器会自动定向到新的URL。</li><li><strong>302</strong>：临时重定向，请求的资源临时的被移动到了新的URL，客户端应继续使用原有的URL。</li><li><strong>304</strong>：这是客户端有缓存情况下服务端的一种响应，客户端在请求一个文件的时候发现有缓存，那么请求中就会包含这个缓存文件的时间，服务器端收到请求之后会和本地文件进行对比，没有更新的话就返回状态码304，客户端收到响应后就会从本地缓存中加载这个资源。</li><li><strong>400</strong>：客户端的错误，服务器不理解请求的语法。</li><li><strong>403</strong>：服务器端拒绝执行客户端的请求。</li><li><strong>404</strong>：客户端请求的资源不存在。</li><li><strong>500</strong>：服务器内部的错误，使得服务器无法完成请求。</li><li><strong>502</strong>：服务器作为网关或代理，从上游服务器收到无效响应。</li></ul><hr><h2 class="anchor anchorWithStickyNavbar_LWe7" id="参考文献">参考文献<a class="hash-link" href="#参考文献" title="标题的直接链接">​</a></h2><p><a href="https://blog.csdn.net/lijie45655/article/details/91359707" target="_blank" rel="noopener noreferrer">http与https，http状态码详细列表</a></p><p><a href="https://juejin.cn/post/6844904080838492174#heading-6" target="_blank" rel="noopener noreferrer">HTTP面试-常用状态码（status code）的那些事</a></p><p><a href="https://juejin.cn/post/6844904202863394830" target="_blank" rel="noopener noreferrer">HTTP 中常用的状态码（14种）</a></p></div><hr class="divider_nSib"><div class="blogPostInfo_k7sy"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="calendar" class="svg-inline--fa fa-calendar" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" color="#c4d3e0" width="16" height="16"><path fill="currentColor" d="M12 192h424c6.6 0 12 5.4 12 12v260c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V204c0-6.6 5.4-12 12-12zm436-44v-36c0-26.5-21.5-48-48-48h-48V12c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v52H160V12c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v52H48C21.5 64 0 85.5 0 112v36c0 6.6 5.4 12 12 12h424c6.6 0 12-5.4 12-12z"></path></svg><time datetime="2021-05-17T00:00:00.000Z" class="blogPostDate_Z606" itemprop="datePublished">2021年5月17日</time><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="tags" class="svg-inline--fa fa-tags" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512" color="#c4d3e0" width="16" height="16"><path fill="currentColor" d="M497.941 225.941L286.059 14.059A48 48 0 0 0 252.118 0H48C21.49 0 0 21.49 0 48v204.118a48 48 0 0 0 14.059 33.941l211.882 211.882c18.744 18.745 49.136 18.746 67.882 0l204.118-204.118c18.745-18.745 18.745-49.137 0-67.882zM112 160c-26.51 0-48-21.49-48-48s21.49-48 48-48 48 21.49 48 48-21.49 48-48 48zm513.941 133.823L421.823 497.941c-18.745 18.745-49.137 18.745-67.882 0l-.36-.36L527.64 323.522c16.999-16.999 26.36-39.6 26.36-63.64s-9.362-46.641-26.36-63.64L331.397 0h48.721a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882z"></path></svg><span class="blogPostInfoTags_W9UY"><a class="tag_zVej tagRegular_sFm0" href="/tags/http">HTTP</a></span><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="clock" class="svg-inline--fa fa-clock blog__readingTime" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" color="#c4d3e0" width="16" height="16"><path fill="currentColor" d="M256,8C119,8,8,119,8,256S119,504,256,504,504,393,504,256,393,8,256,8Zm92.49,313h0l-20,25a16,16,0,0,1-22.49,2.5h0l-67-49.72a40,40,0,0,1-15-31.23V112a16,16,0,0,1,16-16h32a16,16,0,0,1,16,16V256l58,42.5A16,16,0,0,1,348.49,321Z"></path></svg><span class="blogPostReadTime_AZ1H blog__readingTime">阅读需 3 分钟</span></div></article><nav class="pagination-nav" aria-label="博文列表分页导航"></nav></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">学习</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/tags">标签</a></li><li class="footer__item"><a class="footer__link-item" href="/archive">归档</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/skill">技术笔记</a></li><li class="footer__item"><a class="footer__link-item" href="/project">实战项目</a></li></ul></div><div class="col footer__col"><div class="footer__title">社交媒体</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/about">关于我</a></li><li class="footer__item"><a href="https://github.com/qq1120637483" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://juejin.cn/user/2559318802828711/posts" target="_blank" rel="noopener noreferrer" class="footer__link-item">掘金<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">更多</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://docusaurus.io/zh-CN/" target="_blank"><img style="height:50px;margin-top:0.5rem" src="/img/buildwith.png"><a></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright"><p><a href="http://beian.miit.gov.cn/"></a></p><p>Copyright © 2022 - PRESENT Faith&Passion Built with Docusaurus.</p></div></div></div></footer></div>
<script src="/assets/js/runtime~main.2be16868.js"></script>
<script src="/assets/js/main.82cffc67.js"></script>
</body>
</html>